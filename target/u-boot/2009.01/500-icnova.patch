diff -Naur u-boot-2009.01/blackfin_config.mk u-boot/blackfin_config.mk
--- u-boot-2009.01/blackfin_config.mk	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/blackfin_config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -24,16 +24,23 @@
 CONFIG_BFIN_CPU := $(strip $(subst ",,$(CONFIG_BFIN_CPU)))
 CONFIG_BFIN_BOOT_MODE := $(strip $(subst ",,$(CONFIG_BFIN_BOOT_MODE)))
 
-PLATFORM_RELFLAGS += -ffixed-P5 -fomit-frame-pointer
+PLATFORM_RELFLAGS += -ffixed-P5 -fomit-frame-pointer -mno-fdpic
 PLATFORM_CPPFLAGS += -DCONFIG_BLACKFIN
 
+LDFLAGS += --gc-sections
+PLATFORM_RELFLAGS += -ffunction-sections -fdata-sections
+
 ifneq (,$(CONFIG_BFIN_CPU))
 PLATFORM_RELFLAGS += -mcpu=$(CONFIG_BFIN_CPU)
 endif
 
 SYM_PREFIX = _
 
+LDR_FLAGS += --bmode $(subst BFIN_BOOT_,,$(CONFIG_BFIN_BOOT_MODE))
 LDR_FLAGS += --use-vmas
+ifneq ($(CONFIG_BFIN_BOOT_MODE),BFIN_BOOT_BYPASS)
+LDR_FLAGS += --initcode $(obj)cpu/$(CPU)/initcode.o
+endif
 ifneq (,$(findstring s,$(MAKEFLAGS)))
 LDR_FLAGS += --quiet
 endif
diff -Naur u-boot-2009.01/board/ads5121/ads5121.c u-boot/board/ads5121/ads5121.c
--- u-boot-2009.01/board/ads5121/ads5121.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/ads5121/ads5121.c	2009-02-26 14:03:58.000000000 +0100
@@ -31,6 +31,8 @@
 #include <i2c.h>
 #endif
 
+DECLARE_GLOBAL_DATA_PTR;
+
 /* Clocks in use */
 #define SCCR1_CLOCKS_EN	(CLOCK_SCCR1_CFG_EN |				\
 			 CLOCK_SCCR1_LPC_EN |				\
@@ -38,6 +40,7 @@
 			 CLOCK_SCCR1_PSCFIFO_EN |			\
 			 CLOCK_SCCR1_DDR_EN |				\
 			 CLOCK_SCCR1_FEC_EN |				\
+			 CLOCK_SCCR1_PATA_EN |				\
 			 CLOCK_SCCR1_PCI_EN |				\
 			 CLOCK_SCCR1_TPR_EN)
 
@@ -101,6 +104,9 @@
 	 */
 	im->clk.sccr[0] = SCCR1_CLOCKS_EN;
 	im->clk.sccr[1] = SCCR2_CLOCKS_EN;
+#if defined(CONFIG_IIM) || defined(CONFIG_CMD_FUSE)
+	im->clk.sccr[1] |= CLOCK_SCCR2_IIM_EN;
+#endif
 
 	return 0;
 }
@@ -290,17 +296,28 @@
 	}
 };
 
+static  iopin_t rev2_silicon_pci_ioregs_init[] = {
+	/* FUNC0=PCI Sets next 54 to PCI pads */
+	{
+		IOCTL_PCI_AD31, 54, 0,
+		IO_PIN_FMUX(0) | IO_PIN_HOLD(0) | IO_PIN_DS(0)
+	}
+};
+
 int checkboard (void)
 {
 	ushort brd_rev = *(vu_short *) (CONFIG_SYS_CPLD_BASE + 0x00);
 	uchar cpld_rev = *(vu_char *) (CONFIG_SYS_CPLD_BASE + 0x02);
+	volatile immap_t *im = (immap_t *) CONFIG_SYS_IMMR;
 
 	printf ("Board: ADS5121 rev. 0x%04x (CPLD rev. 0x%02x)\n",
 		brd_rev, cpld_rev);
 	/* initialize function mux & slew rate IO inter alia on IO Pins  */
 
-
 	iopin_initialize(ioregs_init, sizeof(ioregs_init) / sizeof(ioregs_init[0]));
+	if (SVR_MJREV (im->sysconf.spridr) >= 2) {
+		iopin_initialize(rev2_silicon_pci_ioregs_init, 1);
+	}
 
 	return 0;
 }
@@ -312,3 +329,104 @@
 	fdt_fixup_memory(blob, (u64)bd->bi_memstart, (u64)bd->bi_memsize);
 }
 #endif /* defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP) */
+
+#if defined(CONFIG_CMD_IDE) && defined(CONFIG_IDE_RESET)
+
+void init_ide_reset (void)
+{
+	volatile immap_t *immr = (immap_t *) CONFIG_SYS_IMMR;
+	debug ("init_ide_reset\n");
+
+	/*
+	 * Clear the reset bit to reset the interface
+	 * cf. RefMan MPC5121EE: 28.4.1 Resetting the ATA Bus
+	 */
+	immr->pata.pata_ata_control = 0;
+	udelay(100);
+	/* Assert the reset bit to enable the interface */
+	immr->pata.pata_ata_control = FSL_ATA_CTRL_ATA_RST_B;
+	udelay(100);
+
+}
+
+void ide_set_reset (int idereset)
+{
+	volatile immap_t *immr = (immap_t *) CONFIG_SYS_IMMR;
+	debug ("ide_set_reset(%d)\n", idereset);
+
+	if (idereset) {
+		immr->pata.pata_ata_control = 0;
+		udelay(100);
+	} else {
+		immr->pata.pata_ata_control = FSL_ATA_CTRL_ATA_RST_B;
+		udelay(100);
+	}
+}
+
+#define CALC_TIMING(t) (t + period - 1) / period
+
+int ide_preinit (void)
+{
+	volatile immap_t *immr = (immap_t *) CONFIG_SYS_IMMR;
+	long t;
+	const struct {
+		short t0;
+		short t1;
+		short t2_8;
+		short t2_16;
+		short t2i;
+		short t4;
+		short t9;
+		short tA;
+	} pio_specs = {
+		.t0    = 600,
+		.t1    =  70,
+		.t2_8  = 290,
+		.t2_16 = 165,
+		.t2i   =   0,
+		.t4    =  30,
+		.t9    =  20,
+		.tA    =  50,
+	};
+	union {
+		u32 config;
+		struct {
+			u8 field1;
+			u8 field2;
+			u8 field3;
+			u8 field4;
+		}bytes;
+	}cfg;
+
+	debug ("IDE preinit using PATA peripheral at IMMR-ADDR %08x\n",
+		(u32)&immr->pata);
+
+	/* Set the reset bit to 1 to enable the interface */
+	immr->pata.pata_ata_control = FSL_ATA_CTRL_ATA_RST_B;
+
+	/* Init timings : we use PIO mode 0 timings */
+	t = 1000000000 / gd->ips_clk;	/* period in ns */
+	cfg.bytes.field1 = 3;
+	cfg.bytes.field2 = 3;
+	cfg.bytes.field3 = (pio_specs.t1 + t) / t;
+	cfg.bytes.field4 = (pio_specs.t2_8 + t) / t;
+
+	immr->pata.pata_time1 = cfg.config;
+
+	cfg.bytes.field1 = (pio_specs.t2_8 + t) / t;
+	cfg.bytes.field2 = (pio_specs.tA + t) / t + 2;
+	cfg.bytes.field3 = 1;
+	cfg.bytes.field4 = (pio_specs.t4 + t) / t;
+
+	immr->pata.pata_time2 = cfg.config;
+
+	cfg.config = immr->pata.pata_time3;
+	cfg.bytes.field1 = (pio_specs.t9 + t) / t;
+
+	immr->pata.pata_time3 = cfg.config;
+	debug ("PATA preinit complete.\n");
+
+	return 0;
+}
+
+#endif /* defined(CONFIG_CMD_IDE) && defined(CONFIG_IDE_RESET) */
diff -Naur u-boot-2009.01/board/ads5121/ads5121_diu.c u-boot/board/ads5121/ads5121_diu.c
--- u-boot-2009.01/board/ads5121/ads5121_diu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/ads5121/ads5121_diu.c	2009-02-26 14:03:58.000000000 +0100
@@ -37,7 +37,11 @@
 #include <video_fb.h>
 #endif
 
+#ifdef CONFIG_FSL_DIU_LOGO_BMP
 extern unsigned int FSL_Logo_BMP[];
+#else
+#define FSL_Logo_BMP NULL
+#endif
 
 static int xres, yres;
 
@@ -61,16 +65,40 @@
 	debug("DIU: Modified value of CLKDVDR = 0x%08x\n", *clkdvdr);
 }
 
+char *valid_bmp(char *addr)
+{
+	unsigned long h_addr;
+
+	h_addr = simple_strtoul(addr, NULL, 16);
+	if (h_addr < CONFIG_SYS_FLASH_BASE ||
+			h_addr >= (CONFIG_SYS_FLASH_BASE + CONFIG_SYS_FLASH_SIZE - 1)) {
+		printf("bmp addr %lx is not a valid flash address\n", h_addr);
+		return 0;
+	} else if ((*(char *)(h_addr) != 'B') || (*(char *)(h_addr+1) != 'M')) {
+		printf("bmp addr is not a bmp\n");
+		return 0;
+	} else
+		return (char *)h_addr;
+}
+
 int ads5121_diu_init(void)
 {
 	unsigned int pixel_format;
+	char *bmp = NULL;
+	char *bmp_env;
 
 	xres = 1024;
 	yres = 768;
 	pixel_format = 0x88883316;
 
-	return fsl_diu_init(xres, pixel_format, 0,
-		     (unsigned char *)FSL_Logo_BMP);
+	debug("ads5121_diu_init\n");
+	bmp_env = getenv("diu_bmp_addr");
+	if (bmp_env) {
+		bmp = valid_bmp(bmp_env);
+	}
+	if (!bmp)
+		bmp = FSL_Logo_BMP;
+	return fsl_diu_init(xres, pixel_format, 0, (unsigned char *)bmp);
 }
 
 int ads5121diu_init_show_bmp(cmd_tbl_t *cmdtp,
@@ -79,7 +107,7 @@
 	unsigned int addr;
 
 	if (argc < 2) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -101,7 +129,7 @@
 
 U_BOOT_CMD(
 	diufb, CONFIG_SYS_MAXARGS, 1, ads5121diu_init_show_bmp,
-	"diufb init | addr - Init or Display BMP file\n",
+	"Init or Display BMP file",
 	"init\n    - initialize DIU\n"
 	"addr\n    - display bmp at address 'addr'\n"
 	);
diff -Naur u-boot-2009.01/board/ads5121/pci.c u-boot/board/ads5121/pci.c
--- u-boot-2009.01/board/ads5121/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/ads5121/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -153,7 +153,7 @@
 		       CONFIG_PCI_SYS_MEM_BUS,
 		       CONFIG_PCI_SYS_MEM_PHYS,
 		       gd->ram_size,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose->region_count = 4;
 
diff -Naur u-boot-2009.01/board/alaska/alaska.c u-boot/board/alaska/alaska.c
--- u-boot-2009.01/board/alaska/alaska.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/alaska/alaska.c	2009-02-26 14:03:58.000000000 +0100
@@ -33,9 +33,9 @@
 
 	/* Flash 0 */
 #if defined (CONFIG_SYS_AMD_BOOT)
-	batu = CONFIG_SYS_FLASH0_BASE | (BL_512K << 2) | BPP_RW | BPP_RX;
+	batu = CONFIG_SYS_FLASH0_BASE | BATU_BL_512K | BPP_RW | BPP_RX;
 #else
-	batu = CONFIG_SYS_FLASH0_BASE | (BL_16M << 2) | BPP_RW | BPP_RX;
+	batu = CONFIG_SYS_FLASH0_BASE | BATU_BL_16M | BPP_RW | BPP_RX;
 #endif
 	batl = CONFIG_SYS_FLASH0_BASE | 0x22;
 	write_bat (IBAT0, batu, batl);
@@ -43,22 +43,22 @@
 
 	/* Flash 1 */
 #if defined (CONFIG_SYS_AMD_BOOT)
-	batu = CONFIG_SYS_FLASH1_BASE | (BL_16M << 2) | BPP_RW | BPP_RX;
+	batu = CONFIG_SYS_FLASH1_BASE | BATU_BL_16M | BPP_RW | BPP_RX;
 #else
-	batu = CONFIG_SYS_FLASH1_BASE | (BL_512K << 2) | BPP_RW | BPP_RX;
+	batu = CONFIG_SYS_FLASH1_BASE | BATU_BL_512K | BPP_RW | BPP_RX;
 #endif
 	batl = CONFIG_SYS_FLASH1_BASE | 0x22;
 	write_bat (IBAT1, batu, batl);
 	write_bat (DBAT1, batu, batl);
 
 	/* CPLD */
-	batu = CONFIG_SYS_CPLD_BASE | (BL_512K << 2) | BPP_RW | BPP_RX;
+	batu = CONFIG_SYS_CPLD_BASE | BATU_BL_512K | BPP_RW | BPP_RX;
 	batl = CONFIG_SYS_CPLD_BASE | 0x22;
 	write_bat (IBAT2, 0, 0);
 	write_bat (DBAT2, batu, batl);
 
 	/* FPGA */
-	batu = CONFIG_SYS_FPGA_BASE | (BL_512K << 2) | BPP_RW | BPP_RX;
+	batu = CONFIG_SYS_FPGA_BASE | BATU_BL_512K | BPP_RW | BPP_RX;
 	batl = CONFIG_SYS_FPGA_BASE | 0x22;
 	write_bat (IBAT3, 0, 0);
 	write_bat (DBAT3, batu, batl);
@@ -80,17 +80,17 @@
 	mtspr (DBAT5U, batu);
 
 	if (size <= 0x800000)	/* 8MB */
-		blocksize = BL_8M << 2;
+		blocksize = BATU_BL_8M;
 	else if (size <= 0x1000000)	/* 16MB */
-		blocksize = BL_16M << 2;
+		blocksize = BATU_BL_16M;
 	else if (size <= 0x2000000)	/* 32MB */
-		blocksize = BL_32M << 2;
+		blocksize = BATU_BL_32M;
 	else if (size <= 0x4000000)	/* 64MB */
-		blocksize = BL_64M << 2;
+		blocksize = BATU_BL_64M;
 	else if (size <= 0x8000000)	/* 128MB */
-		blocksize = BL_128M << 2;
+		blocksize = BATU_BL_128M;
 	else if (size <= 0x10000000)	/* 256MB */
-		blocksize = BL_256M << 2;
+		blocksize = BATU_BL_256M;
 
 	/* Memory */
 	batu = CONFIG_SYS_SDRAM_BASE | blocksize | BPP_RW | BPP_RX;
@@ -108,17 +108,17 @@
 	} else {
 		size -= 0x10000000;
 		if (size <= 0x800000)	/* 8MB */
-			blocksize = BL_8M << 2;
+			blocksize = BATU_BL_8M;
 		else if (size <= 0x1000000)	/* 16MB */
-			blocksize = BL_16M << 2;
+			blocksize = BATU_BL_16M;
 		else if (size <= 0x2000000)	/* 32MB */
-			blocksize = BL_32M << 2;
+			blocksize = BATU_BL_32M;
 		else if (size <= 0x4000000)	/* 64MB */
-			blocksize = BL_64M << 2;
+			blocksize = BATU_BL_64M;
 		else if (size <= 0x8000000)	/* 128MB */
-			blocksize = BL_128M << 2;
+			blocksize = BATU_BL_128M;
 		else if (size <= 0x10000000)	/* 256MB */
-			blocksize = BL_256M << 2;
+			blocksize = BATU_BL_256M;
 
 		batu = (CONFIG_SYS_SDRAM_BASE +
 			0x10000000) | blocksize | BPP_RW | BPP_RX;
diff -Naur u-boot-2009.01/board/amcc/acadia/cmd_acadia.c u-boot/board/amcc/acadia/cmd_acadia.c
--- u-boot-2009.01/board/amcc/acadia/cmd_acadia.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/acadia/cmd_acadia.c	2009-02-26 14:03:58.000000000 +0100
@@ -45,7 +45,7 @@
 	int cpu_freq;
 
 	if (argc < 3) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -96,6 +96,6 @@
 
 U_BOOT_CMD(
 	bootstrap,	3,	0,	do_bootstrap,
-	"bootstrap - program the I2C bootstrap EEPROM\n",
+	"program the I2C bootstrap EEPROM",
 	"<cpu-freq> <nor|nand> - program the I2C bootstrap EEPROM\n"
 	);
diff -Naur u-boot-2009.01/board/amcc/canyonlands/bootstrap.c u-boot/board/amcc/canyonlands/bootstrap.c
--- u-boot-2009.01/board/amcc/canyonlands/bootstrap.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/canyonlands/bootstrap.c	2009-02-26 14:03:58.000000000 +0100
@@ -99,7 +99,7 @@
 	extern char console_buffer[];
 
 	if (argc < 2) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -190,6 +190,6 @@
 
 U_BOOT_CMD(
 	bootstrap,	2,	0,	do_bootstrap,
-	"bootstrap - program the I2C bootstrap EEPROM\n",
+	"program the I2C bootstrap EEPROM",
 	"<nand|nor> - strap to boot from NAND or NOR flash\n"
 	);
diff -Naur u-boot-2009.01/board/amcc/katmai/cmd_katmai.c u-boot/board/amcc/katmai/cmd_katmai.c
--- u-boot-2009.01/board/amcc/katmai/cmd_katmai.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/katmai/cmd_katmai.c	2009-02-26 14:03:58.000000000 +0100
@@ -43,7 +43,7 @@
 	char pcixClock[4];
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -213,6 +213,6 @@
 
 U_BOOT_CMD(
 	bootstrap,	3,	1,	do_bootstrap,
-	"bootstrap - program the serial device strap\n",
+	"program the serial device strap",
 	"wrclk [prom0|prom1] - program the serial device strap\n"
 	);
diff -Naur u-boot-2009.01/board/amcc/katmai/katmai.c u-boot/board/amcc/katmai/katmai.c
--- u-boot-2009.01/board/amcc/katmai/katmai.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/katmai/katmai.c	2009-02-26 14:03:58.000000000 +0100
@@ -451,5 +451,6 @@
 
 int board_eth_init(bd_t *bis)
 {
+	cpu_eth_init(bis);
 	return pci_eth_init(bis);
 }
diff -Naur u-boot-2009.01/board/amcc/kilauea/cmd_pll.c u-boot/board/amcc/kilauea/cmd_pll.c
--- u-boot-2009.01/board/amcc/kilauea/cmd_pll.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/kilauea/cmd_pll.c	2009-02-26 14:03:58.000000000 +0100
@@ -183,7 +183,7 @@
 	char c = '\0';
 	pll_freq_t pll_freq;
 	if (argc < 2) {
-		printf("Usage: \n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		goto ret;
 	}
 
@@ -222,8 +222,8 @@
 		goto ret;
 
 	default:
-		printf("Invalid options"
-		       "\n\nUsage: \n%s\n", cmdtp->usage);
+		printf("Invalid options\n\n");
+		cmd_usage(cmdtp);
 		goto ret;
 	}
 
@@ -237,7 +237,7 @@
 
 U_BOOT_CMD(
 	pllalter, CONFIG_SYS_MAXARGS, 1,        do_pll_alter,
-	"pllalter- change pll frequence \n",
+	"change pll frequence",
 	"pllalter <selection>      - change pll frequence \n\n\
 	** New freq take effect after reset. ** \n\
 	----------------------------------------------\n\
diff -Naur u-boot-2009.01/board/amcc/luan/luan.c u-boot/board/amcc/luan/luan.c
--- u-boot-2009.01/board/amcc/luan/luan.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/luan/luan.c	2009-02-26 14:03:58.000000000 +0100
@@ -319,7 +319,7 @@
 			l2cache_status() ? "ON" : "OFF");
 		return 0;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -329,7 +329,7 @@
 
 U_BOOT_CMD(
 	l2cache,   2,   1,     do_l2cache,
-	"l2cache  - enable or disable L2 cache\n",
+	"enable or disable L2 cache",
 	"[on, off]\n"
 	"    - enable or disable L2 cache\n"
 	);
diff -Naur u-boot-2009.01/board/amcc/makalu/cmd_pll.c u-boot/board/amcc/makalu/cmd_pll.c
--- u-boot-2009.01/board/amcc/makalu/cmd_pll.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/makalu/cmd_pll.c	2009-02-26 14:03:58.000000000 +0100
@@ -183,7 +183,7 @@
 	char c = '\0';
 	pll_freq_t pll_freq;
 	if (argc < 2) {
-		printf("Usage: \n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		goto ret;
 	}
 
@@ -222,8 +222,8 @@
 		goto ret;
 
 	default:
-		printf("Invalid options"
-		       "\n\nUsage: \n%s\n", cmdtp->usage);
+		printf("Invalid options\n\n");
+		cmd_usage(cmdtp);
 		goto ret;
 	}
 
@@ -237,7 +237,7 @@
 
 U_BOOT_CMD(
 	pllalter, CONFIG_SYS_MAXARGS, 1,        do_pll_alter,
-	"pllalter- change pll frequence \n",
+	"change pll frequence",
 	"pllalter <selection>      - change pll frequence \n\n\
 	** New freq take effect after reset. ** \n\
 	----------------------------------------------\n\
diff -Naur u-boot-2009.01/board/amcc/sequoia/cmd_sequoia.c u-boot/board/amcc/sequoia/cmd_sequoia.c
--- u-boot-2009.01/board/amcc/sequoia/cmd_sequoia.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/sequoia/cmd_sequoia.c	2009-02-26 14:03:58.000000000 +0100
@@ -128,7 +128,7 @@
 	extern char console_buffer[];
 
 	if (argc < 2) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -226,6 +226,6 @@
 
 U_BOOT_CMD(
 	bootstrap,	2,	0,	do_bootstrap,
-	"bootstrap - program the I2C bootstrap EEPROM\n",
+	"program the I2C bootstrap EEPROM",
 	"<nand|nor> - strap to boot from NAND or NOR flash\n"
 	);
diff -Naur u-boot-2009.01/board/amcc/taihu/lcd.c u-boot/board/amcc/taihu/lcd.c
--- u-boot-2009.01/board/amcc/taihu/lcd.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/taihu/lcd.c	2009-02-26 14:03:58.000000000 +0100
@@ -140,7 +140,7 @@
 static int do_lcd_puts (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc < 2) {
-		printf("%s", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	lcd_puts(argv[1]);
@@ -151,7 +151,7 @@
 static int do_lcd_putc (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc < 2) {
-		printf("%s", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	lcd_putc((char)argv[1][0]);
@@ -166,7 +166,7 @@
 	char cur_addr;
 
 	if (argc < 3) {
-		printf("%s", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -232,25 +232,25 @@
 
 U_BOOT_CMD(
 	lcd_cls, 1, 1, do_lcd_clear,
-	"lcd_cls - lcd clear display\n",
+	"lcd clear display",
 	NULL
 	);
 
 U_BOOT_CMD(
 	lcd_puts, 2, 1, do_lcd_puts,
-	"lcd_puts - display string on lcd\n",
+	"display string on lcd",
 	"<string> - <string> to be displayed\n"
 	);
 
 U_BOOT_CMD(
 	lcd_putc, 2, 1, do_lcd_putc,
-	"lcd_putc - display char on lcd\n",
+	"display char on lcd",
 	"<char> - <char> to be displayed\n"
 	);
 
 U_BOOT_CMD(
 	lcd_cur, 3, 1, do_lcd_cur,
-	"lcd_cur - shift cursor on lcd\n",
+	"shift cursor on lcd",
 	"<count> <dir> - shift cursor on lcd <count> times, direction is <dir> \n"
 	" <count> - 0..31\n"
 	" <dir>   - 0=backward 1=forward\n"
diff -Naur u-boot-2009.01/board/amcc/taihu/taihu.c u-boot/board/amcc/taihu/taihu.c
--- u-boot-2009.01/board/amcc/taihu/taihu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/taihu/taihu.c	2009-02-26 14:03:58.000000000 +0100
@@ -93,7 +93,7 @@
 
 U_BOOT_CMD (
 	sw2_stat, 1, 1, do_sw_stat,
-	"sw2_stat - show status of switch 2\n",
+	"show status of switch 2",
 	NULL
 	);
 
@@ -102,13 +102,13 @@
 	int led_no;
 
 	if (argc != 3) {
-		printf("%s", cmd_tp->usage);
+		cmd_usage(cmd_tp);
 		return -1;
 	}
 
 	led_no = simple_strtoul(argv[1], NULL, 16);
 	if (led_no != 1 && led_no != 2) {
-		printf("%s", cmd_tp->usage);
+		cmd_usage(cmd_tp);
 		return -1;
 	}
 
@@ -123,7 +123,7 @@
 		else
 			gpio_write_bit(31, 0);
 	} else {
-		printf("%s", cmd_tp->usage);
+		cmd_usage(cmd_tp);
 		return -1;
 	}
 
@@ -132,7 +132,7 @@
 
 U_BOOT_CMD (
 	led_ctl, 3, 1, do_led_ctl,
-	"led_ctl	- make led 1 or 2  on or off\n",
+	"make led 1 or 2  on or off",
 	"<led_no> <on/off>	-  make led <led_no> on/off,\n"
 	"\tled_no is 1 or 2\t"
 	);
@@ -195,5 +195,6 @@
 
 int board_eth_init(bd_t *bis)
 {
+	cpu_eth_init(bis);
 	return pci_eth_init(bis);
 }
diff -Naur u-boot-2009.01/board/amcc/taihu/update.c u-boot/board/amcc/taihu/update.c
--- u-boot-2009.01/board/amcc/taihu/update.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/taihu/update.c	2009-02-26 14:03:58.000000000 +0100
@@ -127,6 +127,6 @@
 
 U_BOOT_CMD (
 	update_boot_eeprom, 1, 1, update_boot_eeprom,
-	"update_boot_eeprom  - update boot eeprom content\n",
+	"update boot eeprom content",
 	NULL
 	);
diff -Naur u-boot-2009.01/board/amcc/taishan/lcd.c u-boot/board/amcc/taishan/lcd.c
--- u-boot-2009.01/board/amcc/taishan/lcd.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/taishan/lcd.c	2009-02-26 14:03:58.000000000 +0100
@@ -167,7 +167,7 @@
 static int do_lcd_puts(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc < 2) {
-		printf("%s", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	lcd_puts(argv[1]);
@@ -176,7 +176,7 @@
 static int do_lcd_putc(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc < 2) {
-		printf("%s", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	lcd_putc((char)argv[1][0]);
@@ -189,7 +189,7 @@
 	char cur_addr;
 
 	if (argc < 3) {
-		printf("%s", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -254,16 +254,16 @@
 	return 0;
 }
 
-U_BOOT_CMD(lcd_test, 1, 1, do_lcd_test, "lcd_test - lcd test display\n", NULL);
-U_BOOT_CMD(lcd_cls, 1, 1, do_lcd_clear, "lcd_cls - lcd clear display\n", NULL);
+U_BOOT_CMD(lcd_test, 1, 1, do_lcd_test, "lcd test display", NULL);
+U_BOOT_CMD(lcd_cls, 1, 1, do_lcd_clear, "lcd clear display", NULL);
 U_BOOT_CMD(lcd_puts, 2, 1, do_lcd_puts,
-	   "lcd_puts - display string on lcd\n",
+	   "display string on lcd",
 	   "<string> - <string> to be displayed\n");
 U_BOOT_CMD(lcd_putc, 2, 1, do_lcd_putc,
-	   "lcd_putc - display char on lcd\n",
+	   "display char on lcd",
 	   "<char> - <char> to be displayed\n");
 U_BOOT_CMD(lcd_cur, 3, 1, do_lcd_cur,
-	   "lcd_cur - shift cursor on lcd\n",
+	   "shift cursor on lcd",
 	   "<count> <dir>- shift cursor on lcd <count> times, direction is <dir> \n"
 	   " <count> - 0~31\n" " <dir> - 0,backward; 1, forward\n");
 
@@ -373,8 +373,8 @@
 }
 
 U_BOOT_CMD(ledon, 1, 1, do_led_test_on,
-	   "ledon - led test light on\n", NULL);
+	   "led test light on", NULL);
 
 U_BOOT_CMD(ledoff, 1, 1, do_led_test_off,
-	   "ledoff - led test light off\n", NULL);
+	   "led test light off", NULL);
 #endif
diff -Naur u-boot-2009.01/board/amcc/taishan/showinfo.c u-boot/board/amcc/taishan/showinfo.c
--- u-boot-2009.01/board/amcc/taishan/showinfo.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/taishan/showinfo.c	2009-02-26 14:03:58.000000000 +0100
@@ -168,7 +168,7 @@
 }
 
 U_BOOT_CMD(xbriinfo, 1, 1, do_show_xbridge_info,
-	   "xbriinfo  - Show PCIX bridge info\n", NULL);
+	   "Show PCIX bridge info", NULL);
 
 #define TAISHAN_PCI_DEV_ID0 0x800
 #define TAISHAN_PCI_DEV_ID1 0x1000
@@ -222,7 +222,7 @@
 }
 
 U_BOOT_CMD(xdevinfo, 1, 1, do_show_pcix_device_info,
-	   "xdevinfo  - Show PCIX Device info\n", NULL);
+	   "Show PCIX Device info", NULL);
 
 extern void show_reset_reg(void);
 
@@ -233,4 +233,4 @@
 }
 
 U_BOOT_CMD(resetinfo, 1, 1, do_show_reset_reg_info,
-	   "resetinfo  - Show Reset REG info\n", NULL);
+	   "Show Reset REG info", NULL);
diff -Naur u-boot-2009.01/board/amcc/taishan/taishan.c u-boot/board/amcc/taishan/taishan.c
--- u-boot-2009.01/board/amcc/taishan/taishan.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/taishan/taishan.c	2009-02-26 14:03:58.000000000 +0100
@@ -315,5 +315,6 @@
 
 int board_eth_init(bd_t *bis)
 {
+	cpu_eth_init(bis);
 	return pci_eth_init(bis);
 }
diff -Naur u-boot-2009.01/board/amcc/taishan/update.c u-boot/board/amcc/taishan/update.c
--- u-boot-2009.01/board/amcc/taishan/update.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/taishan/update.c	2009-02-26 14:03:58.000000000 +0100
@@ -74,5 +74,5 @@
 }
 
 U_BOOT_CMD(update_boot_eeprom, 1, 1, do_update_boot_eeprom,
-	   "update_boot_eeprom  - update bootstrap eeprom content\n", NULL);
+	   "update bootstrap eeprom content", NULL);
 #endif
diff -Naur u-boot-2009.01/board/amcc/yucca/cmd_yucca.c u-boot/board/amcc/yucca/cmd_yucca.c
--- u-boot-2009.01/board/amcc/yucca/cmd_yucca.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/yucca/cmd_yucca.c	2009-02-26 14:03:58.000000000 +0100
@@ -59,7 +59,7 @@
 	char pcixClock[4];
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -281,6 +281,6 @@
 
 U_BOOT_CMD(
 	evb440spe,	3,	1,	do_evb440spe,
-	"evb440spe - program the serial device strap\n",
+	"program the serial device strap",
 	"wrclk [prom0|prom1] - program the serial device strap\n"
 );
diff -Naur u-boot-2009.01/board/amcc/yucca/yucca.c u-boot/board/amcc/yucca/yucca.c
--- u-boot-2009.01/board/amcc/yucca/yucca.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amcc/yucca/yucca.c	2009-02-26 14:03:58.000000000 +0100
@@ -956,5 +956,6 @@
 
 int board_eth_init(bd_t *bis)
 {
+	cpu_eth_init(bis);
 	return pci_eth_init(bis);
 }
diff -Naur u-boot-2009.01/board/amirix/ap1000/ap1000.c u-boot/board/amirix/ap1000/ap1000.c
--- u-boot-2009.01/board/amirix/ap1000/ap1000.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amirix/ap1000/ap1000.c	2009-02-26 14:03:58.000000000 +0100
@@ -659,7 +659,7 @@
 }
 
 U_BOOT_CMD (temp, 6, 0, do_temp_sensor,
-	    "temp    - interact with the temperature sensor\n",
+	    "interact with the temperature sensor",
 	    "temp [s]\n"
 	    "        - Show status.\n"
 	    "temp l LOW [HIGH] [THERM]\n"
@@ -674,28 +674,28 @@
 
 #if 0
 U_BOOT_CMD (loadace, 2, 0, do_loadace,
-	    "loadace - load fpga configuration from System ACE compact flash\n",
+	    "load fpga configuration from System ACE compact flash",
 	    "N\n"
 	    "    - Load configuration N (0-7) from System ACE compact flash\n"
 	    "loadace\n" "    - loads default configuration\n");
 #endif
 
 U_BOOT_CMD (swconfig, 2, 0, do_swconfigbyte,
-	    "swconfig- display or modify the software configuration byte\n",
+	    "display or modify the software configuration byte",
 	    "N [ADDRESS]\n"
 	    "    - set software configuration byte to N, optionally use ADDRESS as\n"
 	    "      location of buffer for flash copy\n"
 	    "swconfig\n" "    - display software configuration byte\n");
 
 U_BOOT_CMD (pause, 2, 0, do_pause,
-	    "pause   - sleep processor until any key is pressed with poll time of N seconds\n",
+	    "sleep processor until any key is pressed with poll time of N seconds",
 	    "N\n"
 	    "    - sleep processor until any key is pressed with poll time of N seconds\n"
 	    "pause\n"
 	    "    - sleep processor until any key is pressed with poll time of 1 second\n");
 
 U_BOOT_CMD (swrecon, 1, 0, do_swreconfig,
-	    "swrecon - trigger a board reconfigure to the software selected configuration\n",
+	    "trigger a board reconfigure to the software selected configuration",
 	    "\n"
 	    "    - trigger a board reconfigure to the software selected configuration\n");
 
diff -Naur u-boot-2009.01/board/amirix/ap1000/pci.c u-boot/board/amirix/ap1000/pci.c
--- u-boot-2009.01/board/amirix/ap1000/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amirix/ap1000/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -294,7 +294,7 @@
 	pci_set_region (hose->regions + 0,
 			AP1000_SYS_MEM_START, AP1000_SYS_MEM_START,
 			AP1000_SYS_MEM_SIZE,
-			PCI_REGION_MEM | PCI_REGION_MEMORY);
+			PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	/* PCI Memory space */
 	pci_set_region (hose->regions + 1,
diff -Naur u-boot-2009.01/board/amirix/ap1000/powerspan.c u-boot/board/amirix/ap1000/powerspan.c
--- u-boot-2009.01/board/amirix/ap1000/powerspan.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/amirix/ap1000/powerspan.c	2009-02-26 14:03:58.000000000 +0100
@@ -478,7 +478,7 @@
 }
 
 U_BOOT_CMD (eeprom, 4, 0, do_eeprom,
-	    "eeprom  - read/write/copy to/from the PowerSpan II eeprom\n",
+	    "read/write/copy to/from the PowerSpan II eeprom",
 	    "eeprom r OFF [NUM]\n"
 	    "    - read NUM words starting at OFF\n"
 	    "eeprom w OFF VAL\n"
diff -Naur u-boot-2009.01/board/armltd/.gitignore u-boot/board/armltd/.gitignore
--- u-boot-2009.01/board/armltd/.gitignore	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/.gitignore	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,2 @@
+/integratorap/u-boot.lds
+/integratorcp/u-boot.lds
diff -Naur u-boot-2009.01/board/armltd/integratorap/config.mk u-boot/board/armltd/integratorap/config.mk
--- u-boot-2009.01/board/armltd/integratorap/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorap/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,11 @@
+#
+# image should be loaded at 0x01000000
+#
+
+TEXT_BASE = 0x01000000
+
+ifneq ($(OBJTREE),$(SRCTREE))
+# We are building u-boot in a separate directory, use generated
+# .lds script from OBJTREE directory.
+LDSCRIPT := $(OBJTREE)/board/$(BOARDDIR)/u-boot.lds
+endif
diff -Naur u-boot-2009.01/board/armltd/integratorap/flash.c u-boot/board/armltd/integratorap/flash.c
--- u-boot-2009.01/board/armltd/integratorap/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorap/flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,473 @@
+/*
+ * (C) Copyright 2001
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * (C) Copyright 2001-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+
+#define PHYS_FLASH_SECT_SIZE	0x00020000	/* 256 KB sectors (x2) */
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];	/* info for FLASH chips    */
+
+/* Board support for 1 or 2 flash devices */
+#undef FLASH_PORT_WIDTH32
+#define FLASH_PORT_WIDTH16
+
+#ifdef FLASH_PORT_WIDTH16
+#define FLASH_PORT_WIDTH		ushort
+#define FLASH_PORT_WIDTHV		vu_short
+#define SWAP(x)			__swab16(x)
+#else
+#define FLASH_PORT_WIDTH		ulong
+#define FLASH_PORT_WIDTHV		vu_long
+#define SWAP(x)			__swab32(x)
+#endif
+
+#define FPW	FLASH_PORT_WIDTH
+#define FPWV	FLASH_PORT_WIDTHV
+
+#define mb() __asm__ __volatile__ ("" : : : "memory")
+
+
+/* Flash Organization Structure */
+typedef struct OrgDef {
+	unsigned int sector_number;
+	unsigned int sector_size;
+} OrgDef;
+
+
+/* Flash Organizations */
+OrgDef OrgIntel_28F256L18T[] = {
+	{4, 32 * 1024},				/* 4 * 32kBytes sectors */
+	{255, 128 * 1024},			/* 255 * 128kBytes sectors */
+};
+
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+unsigned long flash_init (void);
+static ulong flash_get_size (FPW * addr, flash_info_t * info);
+static int write_data (flash_info_t * info, ulong dest, FPW data);
+static void flash_get_offsets (ulong base, flash_info_t * info);
+void inline spin_wheel (void);
+void flash_print_info (flash_info_t * info);
+void flash_unprotect_sectors (FPWV * addr);
+int flash_erase (flash_info_t * info, int s_first, int s_last);
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt);
+
+/*-----------------------------------------------------------------------
+ */
+
+unsigned long flash_init (void)
+{
+	int i;
+	ulong size = 0;
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
+		switch (i) {
+		case 0:
+			flash_get_size ((FPW *) PHYS_FLASH_1, &flash_info[i]);
+			flash_get_offsets (PHYS_FLASH_1, &flash_info[i]);
+			break;
+		default:
+			panic ("configured too many flash banks!\n");
+			break;
+		}
+		size += flash_info[i].size;
+	}
+
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect (FLAG_PROTECT_SET,
+			CONFIG_SYS_FLASH_BASE,
+			CONFIG_SYS_FLASH_BASE + monitor_flash_len - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_get_offsets (ulong base, flash_info_t * info)
+{
+	int i;
+	OrgDef *pOrgDef;
+
+	pOrgDef = OrgIntel_28F256L18T;
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL) {
+		for (i = 0; i < info->sector_count; i++) {
+			if (i > 255) {
+				info->start[i] = base + (i * 0x8000);
+				info->protect[i] = 0;
+			} else {
+				info->start[i] = base +
+						(i * PHYS_FLASH_SECT_SIZE);
+				info->protect[i] = 0;
+			}
+		}
+	}
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_INTEL:
+		printf ("INTEL ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_28F256L18T:
+		printf ("FLASH 28F256L18T\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+		if ((i % 5) == 0)
+			printf ("\n   ");
+		printf (" %08lX%s",
+			info->start[i], info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+	return;
+}
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+static ulong flash_get_size (FPW * addr, flash_info_t * info)
+{
+	volatile FPW value;
+
+	/* Write auto select command: read Manufacturer ID */
+	addr[0x5555] = (FPW) 0x00AA00AA;
+	addr[0x2AAA] = (FPW) 0x00550055;
+	addr[0x5555] = (FPW) 0x00900090;
+
+	mb ();
+	value = addr[0];
+
+	switch (value) {
+
+	case (FPW) INTEL_MANUFACT:
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
+		return (0);		/* no or unknown flash  */
+	}
+
+	mb ();
+	value = addr[1];	/* device ID        */
+	switch (value) {
+
+	case (FPW) (INTEL_ID_28F256L18T):
+		info->flash_id += FLASH_28F256L18T;
+		info->sector_count = 259;
+		info->size = 0x02000000;
+		break;			/* => 32 MB     */
+
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		break;
+	}
+
+	if (info->sector_count > CONFIG_SYS_MAX_FLASH_SECT) {
+		printf ("** ERROR: sector count %d > max (%d) **\n",
+				info->sector_count, CONFIG_SYS_MAX_FLASH_SECT);
+		info->sector_count = CONFIG_SYS_MAX_FLASH_SECT;
+	}
+
+	addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
+
+	return (info->size);
+}
+
+
+/* unprotects a sector for write and erase
+ * on some intel parts, this unprotects the entire chip, but it
+ * wont hurt to call this additional times per sector...
+ */
+void flash_unprotect_sectors (FPWV * addr)
+{
+#define PD_FINTEL_WSMS_READY_MASK    0x0080
+
+	*addr = (FPW) 0x00500050;	/* clear status register */
+
+	/* this sends the clear lock bit command */
+	*addr = (FPW) 0x00600060;
+	*addr = (FPW) 0x00D000D0;
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	int flag, prot, sect;
+	ulong type, start, last;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	type = (info->flash_id & FLASH_VENDMASK);
+	if ((type != FLASH_MAN_INTEL)) {
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+				info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+				prot);
+	} else {
+		printf ("\n");
+	}
+
+
+	start = get_timer (0);
+	last = start;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) {	/* not protected */
+			FPWV *addr = (FPWV *) (info->start[sect]);
+			FPW status;
+
+			printf ("Erasing sector %2d ... ", sect);
+
+			flash_unprotect_sectors (addr);
+
+			/* arm simple, non interrupt dependent timer */
+			reset_timer_masked ();
+
+			*addr = (FPW) 0x00500050;/* clear status register */
+			*addr = (FPW) 0x00200020;/* erase setup */
+			*addr = (FPW) 0x00D000D0;/* erase confirm */
+
+			while (((status =
+				*addr) & (FPW) 0x00800080) !=
+				(FPW) 0x00800080) {
+					if (get_timer_masked () >
+					CONFIG_SYS_FLASH_ERASE_TOUT) {
+					printf ("Timeout\n");
+					/* suspend erase     */
+					*addr = (FPW) 0x00B000B0;
+					/* reset to read mode */
+					*addr = (FPW) 0x00FF00FF;
+					rcode = 1;
+					break;
+				}
+			}
+
+			/* clear status register cmd.   */
+			*addr = (FPW) 0x00500050;
+			*addr = (FPW) 0x00FF00FF;/* resest to read mode */
+			printf (" done\n");
+		}
+	}
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ * 4 - Flash not identified
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	FPW data;
+	int count, i, l, rc, port_width;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+	}
+/* get lower word aligned address */
+#ifdef FLASH_PORT_WIDTH16
+	wp = (addr & ~1);
+	port_width = 2;
+#else
+	wp = (addr & ~3);
+	port_width = 4;
+#endif
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+		cnt -= port_width;
+		if (count++ > 0x800) {
+			spin_wheel ();
+			count = 0;
+		}
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i < port_width; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *) cp);
+	}
+
+	return (write_data (info, wp, SWAP (data)));
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word or halfword to Flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_data (flash_info_t * info, ulong dest, FPW data)
+{
+	FPWV *addr = (FPWV *) dest;
+	ulong status;
+	int flag;
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((*addr & data) != data) {
+		printf ("not erased at %08lx (%x)\n", (ulong) addr, *addr);
+		return (2);
+	}
+	flash_unprotect_sectors (addr);
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+	*addr = (FPW) 0x00400040;	/* write setup */
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait while polling the status register */
+	while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
+		if (get_timer_masked () > CONFIG_SYS_FLASH_WRITE_TOUT) {
+			*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+			return (1);
+		}
+	}
+	*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+	return (0);
+}
+
+void inline spin_wheel (void)
+{
+	static int p = 0;
+	static char w[] = "\\/-";
+
+	printf ("\010%c", w[p]);
+	(++p == 3) ? (p = 0) : 0;
+}
diff -Naur u-boot-2009.01/board/armltd/integratorap/integratorap.c u-boot/board/armltd/integratorap/integratorap.c
--- u-boot-2009.01/board/armltd/integratorap/integratorap.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorap/integratorap.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,656 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * (C) Copyright 2004
+ * ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_PCI
+#include <pci.h>
+#endif
+
+#include <netdev.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void flash__init (void);
+void ether__init (void);
+void peripheral_power_enable (void);
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+#define COMP_MODE_ENABLE ((unsigned int)0x0000EAEF)
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+		"subs %0, %1, #1\n"
+		"bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	/* arch number of Integrator Board */
+	gd->bd->bi_arch_number = MACH_TYPE_INTEGRATOR;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+
+	gd->flags = 0;
+
+#ifdef CONFIG_CM_REMAP
+extern void cm_remap(void);
+	cm_remap();	/* remaps writeable memory to 0x00000000 */
+#endif
+
+	icache_enable ();
+
+	flash__init ();
+	return 0;
+}
+
+
+int misc_init_r (void)
+{
+#ifdef CONFIG_PCI
+	pci_init();
+#endif
+	setenv("verify", "n");
+	return (0);
+}
+
+/*
+ * Initialize PCI Devices, report devices found.
+ */
+#ifdef CONFIG_PCI
+
+#ifndef CONFIG_PCI_PNP
+
+static struct pci_config_table pci_integrator_config_table[] = {
+	{ PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, 0x0f, PCI_ANY_ID,
+	  pci_cfgfunc_config_device, { PCI_ENET0_IOADDR,
+				       PCI_ENET0_MEMADDR,
+				       PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER }},
+	{ }
+};
+#endif
+
+/* V3 access routines */
+#define _V3Write16(o,v) (*(volatile unsigned short *)(PCI_V3_BASE + (unsigned int)(o)) = (unsigned short)(v))
+#define _V3Read16(o)	(*(volatile unsigned short *)(PCI_V3_BASE + (unsigned int)(o)))
+
+#define _V3Write32(o,v) (*(volatile unsigned int *)(PCI_V3_BASE + (unsigned int)(o)) = (unsigned int)(v))
+#define _V3Read32(o)	(*(volatile unsigned int *)(PCI_V3_BASE + (unsigned int)(o)))
+
+/* Compute address necessary to access PCI config space for the given */
+/* bus and device. */
+#define PCI_CONFIG_ADDRESS( __bus, __devfn, __offset ) ({				\
+	unsigned int __address, __devicebit;						\
+	unsigned short __mapaddress;							\
+	unsigned int __dev = PCI_DEV (__devfn); /* FIXME to check!! (slot?) */		\
+											\
+	if (__bus == 0) {								\
+		/* local bus segment so need a type 0 config cycle */			\
+		/* build the PCI configuration "address" with one-hot in A31-A11 */	\
+		__address = PCI_CONFIG_BASE;						\
+		__address |= ((__devfn & 0x07) << 8);					\
+		__address |= __offset & 0xFF;						\
+		__mapaddress = 0x000A;	/* 101=>config cycle, 0=>A1=A0=0 */		\
+		__devicebit = (1 << (__dev + 11));					\
+											\
+		if ((__devicebit & 0xFF000000) != 0) {					\
+			/* high order bits are handled by the MAP register */		\
+			__mapaddress |= (__devicebit >> 16);				\
+		} else {								\
+			/* low order bits handled directly in the address */		\
+			__address |= __devicebit;					\
+		}									\
+	} else {		/* bus !=0 */						\
+		/* not the local bus segment so need a type 1 config cycle */		\
+		/* A31-A24 are don't care (so clear to 0) */				\
+		__mapaddress = 0x000B;	/* 101=>config cycle, 1=>A1&A0 from PCI_CFG */	\
+		__address = PCI_CONFIG_BASE;						\
+		__address |= ((__bus & 0xFF) << 16);	/* bits 23..16 = bus number	*/  \
+		__address |= ((__dev & 0x1F) << 11);	/* bits 15..11 = device number	*/  \
+		__address |= ((__devfn & 0x07) << 8);	/* bits 10..8  = function number */ \
+		__address |= __offset & 0xFF;	/* bits	 7..0  = register number */	\
+	}										\
+	_V3Write16 (V3_LB_MAP1, __mapaddress);						\
+	__address;									\
+})
+
+/* _V3OpenConfigWindow - open V3 configuration window */
+#define _V3OpenConfigWindow() {								\
+	/* Set up base0 to see all 512Mbytes of memory space (not	     */		\
+	/* prefetchable), this frees up base1 for re-use by configuration*/		\
+	/* memory */									\
+											\
+	_V3Write32 (V3_LB_BASE0, ((INTEGRATOR_PCI_BASE & 0xFFF00000) |			\
+				     0x90 | V3_LB_BASE_M_ENABLE));			\
+	/* Set up base1 to point into configuration space, note that MAP1 */		\
+	/* register is set up by pciMakeConfigAddress(). */				\
+											\
+	_V3Write32 (V3_LB_BASE1, ((CPU_PCI_CNFG_ADRS & 0xFFF00000) |			\
+				     0x40 | V3_LB_BASE_M_ENABLE));			\
+}
+
+/* _V3CloseConfigWindow - close V3 configuration window */
+#define _V3CloseConfigWindow() {							\
+    /* Reassign base1 for use by prefetchable PCI memory */				\
+	_V3Write32 (V3_LB_BASE1, (((INTEGRATOR_PCI_BASE + 0x10000000) & 0xFFF00000)	\
+					| 0x84 | V3_LB_BASE_M_ENABLE));			\
+	_V3Write16 (V3_LB_MAP1,								\
+	    (((INTEGRATOR_PCI_BASE + 0x10000000) & 0xFFF00000) >> 16) | 0x0006);	\
+											\
+	/* And shrink base0 back to a 256M window (NOTE: MAP0 already correct) */	\
+											\
+	_V3Write32 (V3_LB_BASE0, ((INTEGRATOR_PCI_BASE & 0xFFF00000) |			\
+			     0x80 | V3_LB_BASE_M_ENABLE));				\
+}
+
+static int pci_integrator_read_byte (struct pci_controller *hose, pci_dev_t dev,
+				     int offset, unsigned char *val)
+{
+	_V3OpenConfigWindow ();
+	*val = *(volatile unsigned char *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
+							       PCI_FUNC (dev),
+							       offset);
+	_V3CloseConfigWindow ();
+
+	return 0;
+}
+
+static int pci_integrator_read__word (struct pci_controller *hose,
+				      pci_dev_t dev, int offset,
+				      unsigned short *val)
+{
+	_V3OpenConfigWindow ();
+	*val = *(volatile unsigned short *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
+								PCI_FUNC (dev),
+								offset);
+	_V3CloseConfigWindow ();
+
+	return 0;
+}
+
+static int pci_integrator_read_dword (struct pci_controller *hose,
+				      pci_dev_t dev, int offset,
+				      unsigned int *val)
+{
+	_V3OpenConfigWindow ();
+	*val = *(volatile unsigned short *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
+								PCI_FUNC (dev),
+								offset);
+	*val |= (*(volatile unsigned int *)
+		 PCI_CONFIG_ADDRESS (PCI_BUS (dev), PCI_FUNC (dev),
+				     (offset + 2))) << 16;
+	_V3CloseConfigWindow ();
+
+	return 0;
+}
+
+static int pci_integrator_write_byte (struct pci_controller *hose,
+				      pci_dev_t dev, int offset,
+				      unsigned char val)
+{
+	_V3OpenConfigWindow ();
+	*(volatile unsigned char *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
+							PCI_FUNC (dev),
+							offset) = val;
+	_V3CloseConfigWindow ();
+
+	return 0;
+}
+
+static int pci_integrator_write_word (struct pci_controller *hose,
+				      pci_dev_t dev, int offset,
+				      unsigned short val)
+{
+	_V3OpenConfigWindow ();
+	*(volatile unsigned short *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
+							 PCI_FUNC (dev),
+							 offset) = val;
+	_V3CloseConfigWindow ();
+
+	return 0;
+}
+
+static int pci_integrator_write_dword (struct pci_controller *hose,
+				       pci_dev_t dev, int offset,
+				       unsigned int val)
+{
+	_V3OpenConfigWindow ();
+	*(volatile unsigned short *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
+							 PCI_FUNC (dev),
+							 offset) = (val & 0xFFFF);
+	*(volatile unsigned short *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
+							 PCI_FUNC (dev),
+							 (offset + 2)) = ((val >> 16) & 0xFFFF);
+	_V3CloseConfigWindow ();
+
+	return 0;
+}
+/******************************
+ * PCI initialisation
+ ******************************/
+
+struct pci_controller integrator_hose = {
+#ifndef CONFIG_PCI_PNP
+	config_table: pci_integrator_config_table,
+#endif
+};
+
+void pci_init_board (void)
+{
+	volatile int i, j;
+	struct pci_controller *hose = &integrator_hose;
+
+	/* setting this register will take the V3 out of reset */
+
+	*(volatile unsigned int *) (INTEGRATOR_SC_PCIENABLE) = 1;
+
+	/* wait a few usecs to settle the device and the PCI bus */
+
+	for (i = 0; i < 100; i++)
+		j = i + 1;
+
+	/* Now write the Base I/O Address Word to V3_BASE + 0x6C */
+
+	*(volatile unsigned short *) (V3_BASE + V3_LB_IO_BASE) =
+		(unsigned short) (V3_BASE >> 16);
+
+	do {
+		*(volatile unsigned char *) (V3_BASE + V3_MAIL_DATA) = 0xAA;
+		*(volatile unsigned char *) (V3_BASE + V3_MAIL_DATA + 4) =
+			0x55;
+	} while (*(volatile unsigned char *) (V3_BASE + V3_MAIL_DATA) != 0xAA
+		 || *(volatile unsigned char *) (V3_BASE + V3_MAIL_DATA +
+						 4) != 0x55);
+
+	/* Make sure that V3 register access is not locked, if it is, unlock it */
+
+	if ((*(volatile unsigned short *) (V3_BASE + V3_SYSTEM) &
+	     V3_SYSTEM_M_LOCK)
+	    == V3_SYSTEM_M_LOCK)
+		*(volatile unsigned short *) (V3_BASE + V3_SYSTEM) = 0xA05F;
+
+	/* Ensure that the slave accesses from PCI are disabled while we */
+	/* setup windows */
+
+	*(volatile unsigned short *) (V3_BASE + V3_PCI_CMD) &=
+		~(V3_COMMAND_M_MEM_EN | V3_COMMAND_M_IO_EN);
+
+	/* Clear RST_OUT to 0; keep the PCI bus in reset until we've finished */
+
+	*(volatile unsigned short *) (V3_BASE + V3_SYSTEM) &=
+		~V3_SYSTEM_M_RST_OUT;
+
+	/* Make all accesses from PCI space retry until we're ready for them */
+
+	*(volatile unsigned short *) (V3_BASE + V3_PCI_CFG) |=
+		V3_PCI_CFG_M_RETRY_EN;
+
+	/* Set up any V3 PCI Configuration Registers that we absolutely have to */
+	/* LB_CFG controls Local Bus protocol. */
+	/* Enable LocalBus byte strobes for READ accesses too. */
+	/* set bit 7 BE_IMODE and bit 6 BE_OMODE */
+
+	*(volatile unsigned short *) (V3_BASE + V3_LB_CFG) |= 0x0C0;
+
+	/* PCI_CMD controls overall PCI operation. */
+	/* Enable PCI bus master. */
+
+	*(volatile unsigned short *) (V3_BASE + V3_PCI_CMD) |= 0x04;
+
+	/* PCI_MAP0 controls where the PCI to CPU memory window is on Local Bus */
+
+	*(volatile unsigned int *) (V3_BASE + V3_PCI_MAP0) =
+		(INTEGRATOR_BOOT_ROM_BASE) | (V3_PCI_MAP_M_ADR_SIZE_512M |
+					      V3_PCI_MAP_M_REG_EN |
+					      V3_PCI_MAP_M_ENABLE);
+
+	/* PCI_BASE0 is the PCI address of the start of the window */
+
+	*(volatile unsigned int *) (V3_BASE + V3_PCI_BASE0) =
+		INTEGRATOR_BOOT_ROM_BASE;
+
+	/* PCI_MAP1 is LOCAL address of the start of the window */
+
+	*(volatile unsigned int *) (V3_BASE + V3_PCI_MAP1) =
+		(INTEGRATOR_HDR0_SDRAM_BASE) | (V3_PCI_MAP_M_ADR_SIZE_1024M |
+						V3_PCI_MAP_M_REG_EN |
+						V3_PCI_MAP_M_ENABLE);
+
+	/* PCI_BASE1 is the PCI address of the start of the window */
+
+	*(volatile unsigned int *) (V3_BASE + V3_PCI_BASE1) =
+		INTEGRATOR_HDR0_SDRAM_BASE;
+
+	/* Set up the windows from local bus memory into PCI configuration, */
+	/* I/O and Memory. */
+	/* PCI I/O, LB_BASE2 and LB_MAP2 are used exclusively for this. */
+
+	*(volatile unsigned short *) (V3_BASE + V3_LB_BASE2) =
+		((CPU_PCI_IO_ADRS >> 24) << 8) | V3_LB_BASE_M_ENABLE;
+	*(volatile unsigned short *) (V3_BASE + V3_LB_MAP2) = 0;
+
+	/* PCI Configuration, use LB_BASE1/LB_MAP1. */
+
+	/* PCI Memory use LB_BASE0/LB_MAP0 and LB_BASE1/LB_MAP1 */
+	/* Map first 256Mbytes as non-prefetchable via BASE0/MAP0 */
+	/* (INTEGRATOR_PCI_BASE == PCI_MEM_BASE) */
+
+	*(volatile unsigned int *) (V3_BASE + V3_LB_BASE0) =
+		INTEGRATOR_PCI_BASE | (0x80 | V3_LB_BASE_M_ENABLE);
+
+	*(volatile unsigned short *) (V3_BASE + V3_LB_MAP0) =
+		((INTEGRATOR_PCI_BASE >> 20) << 0x4) | 0x0006;
+
+	/* Map second 256 Mbytes as prefetchable via BASE1/MAP1 */
+
+	*(volatile unsigned int *) (V3_BASE + V3_LB_BASE1) =
+		INTEGRATOR_PCI_BASE | (0x84 | V3_LB_BASE_M_ENABLE);
+
+	*(volatile unsigned short *) (V3_BASE + V3_LB_MAP1) =
+		(((INTEGRATOR_PCI_BASE + 0x10000000) >> 20) << 4) | 0x0006;
+
+	/* Allow accesses to PCI Configuration space */
+	/* and set up A1, A0 for type 1 config cycles */
+
+	*(volatile unsigned short *) (V3_BASE + V3_PCI_CFG) =
+		((*(volatile unsigned short *) (V3_BASE + V3_PCI_CFG)) &
+		 ~(V3_PCI_CFG_M_RETRY_EN | V3_PCI_CFG_M_AD_LOW1)) |
+		V3_PCI_CFG_M_AD_LOW0;
+
+	/* now we can allow in PCI MEMORY accesses */
+
+	*(volatile unsigned short *) (V3_BASE + V3_PCI_CMD) =
+		(*(volatile unsigned short *) (V3_BASE + V3_PCI_CMD)) |
+		V3_COMMAND_M_MEM_EN;
+
+	/* Set RST_OUT to take the PCI bus is out of reset, PCI devices can */
+	/* initialise and lock the V3 system register so that no one else */
+	/* can play with it */
+
+	*(volatile unsigned short *) (V3_BASE + V3_SYSTEM) =
+		(*(volatile unsigned short *) (V3_BASE + V3_SYSTEM)) |
+		V3_SYSTEM_M_RST_OUT;
+
+	*(volatile unsigned short *) (V3_BASE + V3_SYSTEM) =
+		(*(volatile unsigned short *) (V3_BASE + V3_SYSTEM)) |
+		V3_SYSTEM_M_LOCK;
+
+	/*
+	 * Register the hose
+	 */
+	hose->first_busno = 0;
+	hose->last_busno = 0xff;
+
+	/* System memory space */
+	pci_set_region (hose->regions + 0,
+			0x00000000, 0x40000000, 0x01000000,
+			PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
+
+	/* PCI Memory - config space */
+	pci_set_region (hose->regions + 1,
+			0x00000000, 0x62000000, 0x01000000, PCI_REGION_MEM);
+
+	/* PCI V3 regs */
+	pci_set_region (hose->regions + 2,
+			0x00000000, 0x61000000, 0x00080000, PCI_REGION_MEM);
+
+	/* PCI I/O space */
+	pci_set_region (hose->regions + 3,
+			0x00000000, 0x60000000, 0x00010000, PCI_REGION_IO);
+
+	pci_set_ops (hose,
+		     pci_integrator_read_byte,
+		     pci_integrator_read__word,
+		     pci_integrator_read_dword,
+		     pci_integrator_write_byte,
+		     pci_integrator_write_word, pci_integrator_write_dword);
+
+	hose->region_count = 4;
+
+	pci_register_hose (hose);
+
+	pciauto_config_init (hose);
+	pciauto_config_device (hose, 0);
+
+	hose->last_busno = pci_hose_scan (hose);
+}
+#endif
+
+/******************************
+ Routine:
+ Description:
+******************************/
+void flash__init (void)
+{
+}
+/*************************************************************
+ Routine:ether__init
+ Description: take the Ethernet controller out of reset and wait
+			   for the EEPROM load to complete.
+*************************************************************/
+void ether__init (void)
+{
+}
+
+/******************************
+ Routine:
+ Description:
+******************************/
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size	 = PHYS_SDRAM_1_SIZE;
+
+#ifdef CONFIG_CM_SPD_DETECT
+	{
+extern void dram_query(void);
+	unsigned long cm_reg_sdram;
+	unsigned long sdram_shift;
+
+	dram_query();	/* Assembler accesses to CM registers */
+			/* Queries the SPD values	      */
+
+	/* Obtain the SDRAM size from the CM SDRAM register */
+
+	cm_reg_sdram = *(volatile ulong *)(CM_BASE + OS_SDRAM);
+	/*   Register	      SDRAM size
+	 *
+	 *   0xXXXXXXbbb000bb	 16 MB
+	 *   0xXXXXXXbbb001bb	 32 MB
+	 *   0xXXXXXXbbb010bb	 64 MB
+	 *   0xXXXXXXbbb011bb	128 MB
+	 *   0xXXXXXXbbb100bb	256 MB
+	 *
+	 */
+	sdram_shift		 = ((cm_reg_sdram & 0x0000001C)/4)%4;
+	gd->bd->bi_dram[0].size	 = 0x01000000 << sdram_shift;
+
+	}
+#endif /* CM_SPD_DETECT */
+
+	return 0;
+}
+
+/* The Integrator/AP timer1 is clocked at 24MHz
+ * can be divided by 16 or 256
+ * and is a 16-bit counter
+ */
+/* U-Boot expects a 32 bit timer running at CONFIG_SYS_HZ*/
+static ulong timestamp;		/* U-Boot ticks since startup	      */
+static ulong total_count = 0;	/* Total timer count		      */
+static ulong lastdec;		/* Timer reading at last call	      */
+static ulong div_clock	 = 256; /* Divisor applied to the timer clock */
+static ulong div_timer	 = 1;	/* Divisor to convert timer reading
+				 * change to U-Boot ticks
+				 */
+/* CONFIG_SYS_HZ = CONFIG_SYS_HZ_CLOCK/(div_clock * div_timer) */
+
+#define TIMER_LOAD_VAL 0x0000FFFFL
+#define READ_TIMER ((*(volatile ulong *)(CONFIG_SYS_TIMERBASE+4)) & 0x0000FFFFL)
+
+/* all function return values in U-Boot ticks i.e. (1/CONFIG_SYS_HZ) sec
+ *  - unless otherwise stated
+ */
+
+/* starts a counter
+ * - the Integrator/AP timer issues an interrupt
+ *   each time it reaches zero
+ */
+int interrupt_init (void)
+{
+	/* Load timer with initial value */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 0) = TIMER_LOAD_VAL;
+	/* Set timer to be
+	 *	enabled		  1
+	 *	free-running	  0
+	 *	XX		 00
+	 *	divider 256	 10
+	 *	XX		 00
+	 */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 8) = 0x00000088;
+	total_count = 0;
+	/* init the timestamp and lastdec value */
+	reset_timer_masked();
+
+	div_timer  = CONFIG_SYS_HZ_CLOCK / CONFIG_SYS_HZ;
+	div_timer /= div_clock;
+
+	return (0);
+}
+
+/*
+ * timer without interrupts
+ */
+void reset_timer (void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer (ulong base_ticks)
+{
+	return get_timer_masked () - base_ticks;
+}
+
+void set_timer (ulong ticks)
+{
+	timestamp = ticks;
+	total_count = ticks * div_timer;
+	reset_timer_masked();
+}
+
+/* delay x useconds */
+void udelay (unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	/* Convert to U-Boot ticks */
+	tmo  = usec * CONFIG_SYS_HZ;
+	tmo /= (1000000L);
+
+	tmp  = get_timer_masked();	/* get current timestamp */
+	tmo += tmp;			/* wake up timestamp	 */
+
+	while (get_timer_masked () < tmo) { /* loop till event */
+		/*NOP*/;
+	}
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec	  = READ_TIMER; /* capture current decrementer value   */
+	timestamp = 0;		/* start "advancing" time stamp from 0 */
+}
+
+/* converts the timer reading to U-Boot ticks	       */
+/* the timestamp is the number of ticks since reset    */
+/* This routine does not detect wraps unless called regularly
+   ASSUMES a call at least every 16 seconds to detect every reload */
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER;		/* current count */
+
+	if (now > lastdec) {
+		/* Must have wrapped */
+		total_count += lastdec + TIMER_LOAD_VAL + 1 - now;
+	} else {
+		total_count += lastdec - now;
+	}
+	lastdec	  = now;
+	timestamp = total_count/div_timer;
+
+	return timestamp;
+}
+
+/* waits specified delay value and resets timestamp */
+void udelay_masked (unsigned long usec)
+{
+	udelay(usec);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * Return the timebase clock frequency
+ * i.e. how often the timer decrements
+ */
+ulong get_tbclk (void)
+{
+	return CONFIG_SYS_HZ_CLOCK/div_clock;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	return pci_eth_init(bis);
+}
diff -Naur u-boot-2009.01/board/armltd/integratorap/lowlevel_init.S u-boot/board/armltd/integratorap/lowlevel_init.S
--- u-boot-2009.01/board/armltd/integratorap/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorap/lowlevel_init.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,213 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2004, ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+	/* Reset using CM control register */
+.global reset_cpu
+reset_cpu:
+	mov	r0, #CM_BASE
+	ldr	r1,[r0,#OS_CTRL]
+	orr	r1,r1,#CMMASK_RESET
+	str	r1,[r0,#OS_CTRL]
+
+reset_failed:
+	b	reset_failed
+
+/* Set up the platform, once the cpu has been initialized */
+.globl lowlevel_init
+lowlevel_init:
+	/* If U-Boot has been run after the ARM boot monitor
+	 * then all the necessary actions have been done
+	 * otherwise we are running from user flash mapped to 0x00000000
+	 * --- DO NOT REMAP BEFORE THE CODE HAS BEEN RELOCATED --
+	 * Changes to the (possibly soft) reset defaults of the processor
+	 * itself should be performed in cpu/arm<>/start.S
+	 * This function affects only the core module or board settings
+	 */
+
+#ifdef CONFIG_CM_INIT
+	/* CM has an initialization register
+	 * - bits in it are wired into test-chip pins to force
+	 *   reset defaults
+	 * - may need to change its contents for U-Boot
+	 */
+
+	/* set the desired CM specific value */
+	mov	r2,#CMMASK_LOWVEC	/* Vectors at 0x00000000 for all */
+
+#if defined (CONFIG_CM10200E) || defined (CONFIG_CM10220E)
+	orr	r2,r2,#CMMASK_INIT_102
+#else
+
+#if !defined (CONFIG_CM920T) && !defined (CONFIG_CM920T_ETM) && \
+     !defined (CONFIG_CM940T)
+
+#ifdef	CONFIG_CM_MULTIPLE_SSRAM
+	/* set simple mapping			*/
+	and	r2,r2,#CMMASK_MAP_SIMPLE
+#endif /* #ifdef CONFIG_CM_MULTIPLE_SSRAM	*/
+
+#ifdef	CONFIG_CM_TCRAM
+	/* disable TCRAM			*/
+	and	r2,r2,#CMMASK_TCRAM_DISABLE
+#endif /* #ifdef CONFIG_CM_TCRAM		*/
+
+#if defined (CONFIG_CM926EJ_S) || defined (CONFIG_CM1026EJ_S) || \
+     defined (CONFIG_CM1136JF_S)
+
+	and	r2,r2,#CMMASK_LE
+
+#endif /* cpu with little endian initialization */
+
+	orr	r2,r2,#CMMASK_CMxx6_COMMON
+
+#endif /* CMxx6 code */
+
+#endif /* ARM102xxE value */
+
+	/* read CM_INIT		 */
+	mov	r0, #CM_BASE
+	ldr	r1, [r0, #OS_INIT]
+	/* check against desired bit setting */
+	and	r3,r1,r2
+	cmp	r3,r2
+	beq	init_reg_OK
+
+	/* lock for change */
+	mov	r3, #CMVAL_LOCK1
+	add	r3,r3,#CMVAL_LOCK2
+	str	r3, [r0, #OS_LOCK]
+	/* set desired value */
+	orr	r1,r1,r2
+	/* write & relock CM_INIT */
+	str	r1, [r0, #OS_INIT]
+	mov	r1, #CMVAL_UNLOCK
+	str	r1, [r0, #OS_LOCK]
+
+	/* soft reset so new values used */
+	b	reset_cpu
+
+init_reg_OK:
+
+#endif /* CONFIG_CM_INIT */
+
+	mov	pc, lr
+
+#ifdef	CONFIG_CM_SPD_DETECT
+	/* Fast memory is available for the DRAM data
+	 * - ensure it has been transferred, then summarize the data
+	 *   into a CM register
+	 */
+.globl dram_query
+dram_query:
+	stmfd	r13!,{r4-r6,lr}
+	/* set up SDRAM info					*/
+	/* - based on example code from the CM User Guide */
+	mov	r0, #CM_BASE
+
+readspdbit:
+	ldr	r1, [r0, #OS_SDRAM]	/* read the SDRAM register	*/
+	and	r1, r1, #0x20		/* mask SPD bit (5)		*/
+	cmp	r1, #0x20		/* test if set			*/
+	bne	readspdbit
+
+setupsdram:
+	add	r0, r0, #OS_SPD		/* address the copy of the SDP data	*/
+	ldrb	r1, [r0, #3]		/* number of row address lines		*/
+	ldrb	r2, [r0, #4]		/* number of column address lines	*/
+	ldrb	r3, [r0, #5]		/* number of banks			*/
+	ldrb	r4, [r0, #31]		/* module bank density			*/
+	mul	r5, r4, r3		/* size of SDRAM (MB divided by 4)	*/
+	mov	r5, r5, ASL#2		/* size in MB				*/
+	mov	r0, #CM_BASE		/* reload for later code		*/
+	cmp	r5, #0x10		/* is it 16MB?				*/
+	bne	not16
+	mov	r6, #0x2		/* store size and CAS latency of 2	*/
+	b	writesize
+
+not16:
+	cmp	r5, #0x20		/* is it  32MB? */
+	bne	not32
+	mov	r6, #0x6
+	b	writesize
+
+not32:
+	cmp	r5, #0x40		/* is it  64MB? */
+	bne	not64
+	mov	r6, #0xa
+	b	writesize
+
+not64:
+	cmp	r5, #0x80		/* is it 128MB? */
+	bne	not128
+	mov	r6, #0xe
+	b	writesize
+
+not128:
+	/* if it is none of these sizes then it is either 256MB, or
+	 * there is no SDRAM fitted so default to 256MB
+	 */
+	mov	r6, #0x12
+
+writesize:
+	mov	r1, r1, ASL#8		/* row addr lines from SDRAM reg */
+	orr	r2, r1, r2, ASL#12	/* OR in column address lines	 */
+	orr	r3, r2, r3, ASL#16	/* OR in number of banks	 */
+	orr	r6, r6, r3		/* OR in size and CAS latency	 */
+	str	r6, [r0, #OS_SDRAM]	/* store SDRAM parameters	 */
+
+#endif /* #ifdef CONFIG_CM_SPD_DETECT */
+
+	ldmfd	r13!,{r4-r6,pc}			/* back to caller */
+
+#ifdef	CONFIG_CM_REMAP
+	/* CM remap bit is operational
+	 * - use it to map writeable memory at 0x00000000, in place of flash
+	 */
+.globl cm_remap
+cm_remap:
+	stmfd	r13!,{r4-r10,lr}
+
+	mov	r0, #CM_BASE
+	ldr	r1, [r0, #OS_CTRL]
+	orr	r1, r1, #CMMASK_REMAP	/* set remap and led bits */
+	str	r1, [r0, #OS_CTRL]
+
+	/* Now 0x00000000 is writeable, replace the vectors	*/
+	ldr	r0, =_start	/* r0 <- start of vectors	*/
+	ldr	r2, =_armboot_start	/* r2 <- past vectors	*/
+	sub	r1,r1,r1		/* destination 0x00000000	*/
+
+copy_vec:
+	ldmia	r0!, {r3-r10}		/* copy from source address [r0]	*/
+	stmia	r1!, {r3-r10}		/* copy to	 target address [r1]	*/
+	cmp	r0, r2			/* until source end address [r2]	*/
+	ble	copy_vec
+
+	ldmfd	r13!,{r4-r10,pc}	/* back to caller			*/
+
+#endif /* #ifdef CONFIG_CM_REMAP */
diff -Naur u-boot-2009.01/board/armltd/integratorap/Makefile u-boot/board/armltd/integratorap/Makefile
--- u-boot-2009.01/board/armltd/integratorap/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorap/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,55 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2004
+# ARM Ltd.
+# Philippe Robin, <philippe.robin@arm.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= integratorap.o flash.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/armltd/integratorap/split_by_variant.sh u-boot/board/armltd/integratorap/split_by_variant.sh
--- u-boot-2009.01/board/armltd/integratorap/split_by_variant.sh	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorap/split_by_variant.sh	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,119 @@
+#!/bin/sh
+# ---------------------------------------------------------
+# Set the platform defines
+# ---------------------------------------------------------
+echo -n	"/* Integrator configuration implied "	 > tmp.fil
+echo	" by Makefile target */"		>> tmp.fil
+echo -n	"#define CONFIG_INTEGRATOR"		>> tmp.fil
+echo	" /* Integrator board */"		>> tmp.fil
+echo -n	"#define CONFIG_ARCH_INTEGRATOR"	>> tmp.fil
+echo	" 1 /* Integrator/AP	 */"		>> tmp.fil
+# ---------------------------------------------------------
+#	Set the core module defines according to Core Module
+# ---------------------------------------------------------
+cpu="arm_intcm"
+variant="unknown core module"
+
+if [ "$1" = "" ]
+then
+	echo "$0:: No parameters - using arm_intcm"
+else
+	case "$1" in
+	ap7_config)
+	cpu="arm_intcm"
+	variant="unported core module CM7TDMI"
+	;;
+
+	ap966)
+	cpu="arm_intcm"
+	variant="unported core module CM966E-S"
+	;;
+
+	ap922_config)
+	cpu="arm_intcm"
+	variant="unported core module CM922T"
+	;;
+
+	integratorap_config	|	\
+	ap_config)
+	cpu="arm_intcm"
+	variant="unspecified core module"
+	;;
+
+	ap720t_config)
+	cpu="arm720t"
+	echo -n	"#define CONFIG_CM720T"			>> tmp.fil
+	echo	" 1 /* CPU core is ARM720T */ "		>> tmp.fil
+	variant="Core module CM720T"
+	;;
+
+	ap922_XA10_config)
+	cpu="arm_intcm"
+	variant="unported core module CM922T_XA10"
+	echo -n	"#define CONFIG_CM922T_XA10"		>> tmp.fil
+	echo	" 1 /* CPU core is ARM922T_XA10 */"	>> tmp.fil
+	;;
+
+	ap920t_config)
+	cpu="arm920t"
+	variant="Core module CM920T"
+	echo -n	"#define CONFIG_CM920T"			>> tmp.fil
+	echo	" 1 /* CPU core is ARM920T */"		>> tmp.fil
+	;;
+
+	ap926ejs_config)
+	cpu="arm926ejs"
+	variant="Core module CM926EJ-S"
+	echo -n	"#define CONFIG_CM926EJ_S"		>> tmp.fil
+	echo	" 1 /* CPU core is ARM926EJ-S */ "	>> tmp.fil
+	;;
+
+	ap946es_config)
+	cpu="arm946es"
+	variant="Core module CM946E-S"
+	echo -n	"#define CONFIG_CM946E_S"		>> tmp.fil
+	echo	" 1 /* CPU core is ARM946E-S */ "	>> tmp.fil
+	;;
+
+	*)
+	echo "$0:: Unknown core module"
+	variant="unknown core module"
+	cpu="arm_intcm"
+	;;
+
+	esac
+fi
+
+if [ "$cpu" = "arm_intcm" ]
+then
+	echo "/* Core module undefined/not ported */"	>> tmp.fil
+	echo "#define CONFIG_ARM_INTCM 1"		>> tmp.fil
+	echo -n	"#undef CONFIG_CM_MULTIPLE_SSRAM"	>> tmp.fil
+	echo -n	"	/* CM may not have "		>> tmp.fil
+	echo	"multiple SSRAM mapping */"		>> tmp.fil
+	echo -n	"#undef CONFIG_CM_SPD_DETECT "		>> tmp.fil
+	echo -n	" /* CM may not support SPD "		>> tmp.fil
+	echo	"query */"				>> tmp.fil
+	echo -n	"#undef CONFIG_CM_REMAP	"		>> tmp.fil
+	echo -n	" /* CM may not support "		>> tmp.fil
+	echo	"remapping */"				>> tmp.fil
+	echo -n	"#undef CONFIG_CM_INIT	"		>> tmp.fil
+	echo -n	" /* CM may not have	"		>> tmp.fil
+	echo	"initialization reg */"			>> tmp.fil
+	echo -n	"#undef CONFIG_CM_TCRAM	"		>> tmp.fil
+	echo	" /* CM may not have TCRAM */"		>> tmp.fil
+fi
+
+mkdir -p ${obj}include
+mkdir -p ${obj}board/armltd/integratorap
+mv tmp.fil ${obj}include/config.h
+# ---------------------------------------------------------
+#	Ensure correct core object loaded first in U-Boot image
+# ---------------------------------------------------------
+sed -r 's/CPU_FILE/cpu\/'$cpu'\/start.o/; s/#.*//' ${src}board/armltd/integratorap/u-boot.lds.template > ${obj}board/armltd/integratorap/u-boot.lds
+# ---------------------------------------------------------
+# Complete the configuration
+# ---------------------------------------------------------
+$MKCONFIG -a integratorap arm $cpu integratorap armltd;
+echo "Variant:: $variant with core $cpu"
+
diff -Naur u-boot-2009.01/board/armltd/integratorap/u-boot.lds.template u-boot/board/armltd/integratorap/u-boot.lds.template
--- u-boot-2009.01/board/armltd/integratorap/u-boot.lds.template	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorap/u-boot.lds.template	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,53 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+# Template used during configuration to emsure the core module processor code,
+# from CPU_FILE, is placed at the start of the image */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+		CPU_FILE (.text)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/armltd/integratorcp/config.mk u-boot/board/armltd/integratorcp/config.mk
--- u-boot-2009.01/board/armltd/integratorcp/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorcp/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,11 @@
+#
+# image should be loaded at 0x01000000
+#
+
+TEXT_BASE = 0x01000000
+
+ifneq ($(OBJTREE),$(SRCTREE))
+# We are building u-boot in a separate directory, use generated
+# .lds script from OBJTREE directory.
+LDSCRIPT := $(OBJTREE)/board/$(BOARDDIR)/u-boot.lds
+endif
diff -Naur u-boot-2009.01/board/armltd/integratorcp/flash.c u-boot/board/armltd/integratorcp/flash.c
--- u-boot-2009.01/board/armltd/integratorcp/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorcp/flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,564 @@
+/*
+ * (C) Copyright 2004
+ * Xiaogeng (Shawn) Jin, Agilent Technologies, xiaogeng_jin@agilent.com
+ *
+ * (C) Copyright 2001
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * (C) Copyright 2001-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+
+#define DEBUG
+
+#define PHYS_FLASH_SECT_SIZE	0x00040000	/* 256 KB sectors (x2) */
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];	/* info for FLASH chips */
+
+/* Board support for 1 or 2 flash devices */
+#define FLASH_PORT_WIDTH32
+#undef FLASH_PORT_WIDTH16
+
+#ifdef FLASH_PORT_WIDTH16
+#define FLASH_PORT_WIDTH	ushort
+#define FLASH_PORT_WIDTHV	vu_short
+#define SWAP(x)			__swab16(x)
+#else
+#define FLASH_PORT_WIDTH	ulong
+#define FLASH_PORT_WIDTHV	vu_long
+#define SWAP(x)			__swab32(x)
+#endif
+
+#define FPW	FLASH_PORT_WIDTH
+#define FPWV	FLASH_PORT_WIDTHV
+
+#define mb() __asm__ __volatile__ ("" : : : "memory")
+
+
+/* Flash Organization Structure */
+typedef struct OrgDef {
+	unsigned int sector_number;
+	unsigned int sector_size;
+} OrgDef;
+
+
+/* Flash Organizations */
+OrgDef OrgIntel_28F256L18T[] = {
+	{4, 32 * 1024},				/* 4 * 32kBytes sectors */
+	{255, 128 * 1024},			/* 255 * 128kBytes sectors */
+};
+
+/* CP control register base address */
+#define CPCR_BASE		0xCB000000
+#define CPCR_EXTRABANK		0x8
+#define CPCR_FLASHSIZE		0x4
+#define CPCR_FLWREN		0x2
+#define CPCR_FLVPPEN		0x1
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+unsigned long flash_init (void);
+static ulong flash_get_size (FPW * addr, flash_info_t * info);
+static int write_data (flash_info_t * info, ulong dest, FPW data);
+static void flash_get_offsets (ulong base, flash_info_t * info);
+void inline spin_wheel (void);
+void flash_print_info (flash_info_t * info);
+void flash_unprotect_sectors (FPWV * addr);
+int flash_erase (flash_info_t * info, int s_first, int s_last);
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt);
+
+/*-----------------------------------------------------------------------
+ */
+unsigned long flash_init (void)
+{
+	int i, nbanks;
+	ulong size = 0;
+	vu_long *cpcr = (vu_long *)CPCR_BASE;
+
+	/* Check if there is an extra bank of flash */
+	if (cpcr[1] & CPCR_EXTRABANK)
+		nbanks = 2;
+	else
+		nbanks = 1;
+
+	if (nbanks > CONFIG_SYS_MAX_FLASH_BANKS)
+		nbanks = CONFIG_SYS_MAX_FLASH_BANKS;
+
+	/* Enable flash write */
+	cpcr[1] |= 3;
+
+	for (i = 0; i < nbanks; i++) {
+		flash_get_size ((FPW *)(CONFIG_SYS_FLASH_BASE + size), &flash_info[i]);
+		flash_get_offsets (CONFIG_SYS_FLASH_BASE + size, &flash_info[i]);
+		size += flash_info[i].size;
+	}
+
+#if CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE
+	/* monitor protection */
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_SYS_MONITOR_BASE,
+		       CONFIG_SYS_MONITOR_BASE + monitor_flash_len - 1, &flash_info[0]);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_FLASH
+	/* ENV protection ON */
+	flash_protect(FLAG_PROTECT_SET,
+		      CONFIG_ENV_ADDR,
+		      CONFIG_ENV_ADDR + CONFIG_ENV_SECT_SIZE - 1,
+		      &flash_info[0]);
+#endif
+
+	/* Protect SIB (0x24800000) and bootMonitor (0x24c00000) */
+	flash_protect (FLAG_PROTECT_SET,
+		       flash_info[0].start[62],
+		       flash_info[0].start[63] + PHYS_FLASH_SECT_SIZE - 1,
+		       &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_get_offsets (ulong base, flash_info_t * info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL) {
+		for (i = 0; i < info->sector_count; i++) {
+			info->start[i] = base +	(i * PHYS_FLASH_SECT_SIZE);
+			info->protect[i] = 0;
+		}
+	}
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_INTEL:
+		printf ("INTEL ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	/* Integrator CP board uses 28F640J3C or 28F128J3C parts,
+	 * which have the same device id numbers as 28F640J3A or
+	 * 28F128J3A
+	 */
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_28F256L18T:
+		printf ("FLASH 28F256L18T\n");
+		break;
+	case FLASH_28F640J3A:
+		printf ("FLASH 28F640J3C\n");
+		break;
+	case FLASH_28F128J3A:
+		printf ("FLASH 28F128J3C\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+		if ((i % 5) == 0)
+			printf ("\n   ");
+		printf (" %08lX%s",
+			info->start[i], info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+	return;
+}
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+static ulong flash_get_size (FPW * addr, flash_info_t * info)
+{
+	volatile FPW value;
+	vu_long *cpcr = (vu_long *)CPCR_BASE;
+	int nsects;
+
+	/* Check the flash size */
+	if (cpcr[1] & CPCR_FLASHSIZE)
+		nsects = 128;
+	else
+		nsects = 64;
+
+	if (nsects > CONFIG_SYS_MAX_FLASH_SECT)
+		nsects = CONFIG_SYS_MAX_FLASH_SECT;
+
+	/* Write auto select command: read Manufacturer ID */
+	addr[0x5555] = (FPW) 0x00AA00AA;
+	addr[0x2AAA] = (FPW) 0x00550055;
+	addr[0x5555] = (FPW) 0x00900090;
+
+	mb ();
+	value = addr[0];
+
+	switch (value) {
+
+	case (FPW) INTEL_MANUFACT:
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		addr[0] = (FPW) 0x00FF00FF; /* restore read mode */
+		return (0); /* no or unknown flash */
+	}
+
+	mb ();
+	value = addr[1]; /* device ID */
+	switch (value) {
+
+	case (FPW) (INTEL_ID_28F256L18T):
+		info->flash_id += FLASH_28F256L18T;
+		info->sector_count = 259;
+		info->size = 0x02000000;
+		break;			/* => 32 MB */
+
+	case (FPW) (INTEL_ID_28F640J3A):
+		info->flash_id += FLASH_28F640J3A;
+		info->sector_count = nsects;
+		info->size = nsects * PHYS_FLASH_SECT_SIZE;
+		break;
+
+	case (FPW) (INTEL_ID_28F128J3A):
+		info->flash_id += FLASH_28F128J3A;
+		info->sector_count = nsects;
+		info->size = nsects * PHYS_FLASH_SECT_SIZE;
+		break;
+
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		break;
+	}
+
+	if (info->sector_count > CONFIG_SYS_MAX_FLASH_SECT) {
+		printf ("** ERROR: sector count %d > max (%d) **\n",
+				info->sector_count, CONFIG_SYS_MAX_FLASH_SECT);
+		info->sector_count = CONFIG_SYS_MAX_FLASH_SECT;
+	}
+
+	addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
+
+	return (info->size);
+}
+
+
+/* unprotects a sector for write and erase
+ * on some intel parts, this unprotects the entire chip, but it
+ * wont hurt to call this additional times per sector...
+ */
+void flash_unprotect_sectors (FPWV * addr)
+{
+	FPW status;
+
+	*addr = (FPW) 0x00500050;	/* clear status register */
+
+	/* this sends the clear lock bit command */
+	*addr = (FPW) 0x00600060;
+	*addr = (FPW) 0x00D000D0;
+
+	reset_timer_masked();
+	while (((status = *addr) & (FPW)0x00800080) != 0x00800080) {
+		if (get_timer_masked() > CONFIG_SYS_FLASH_ERASE_TOUT) {
+			printf("Timeout");
+			break;
+		}
+	}
+
+	*addr = (FPW) 0x00FF00FF;
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	int flag, prot, sect;
+	ulong type;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	type = (info->flash_id & FLASH_VENDMASK);
+	if ((type != FLASH_MAN_INTEL)) {
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+				info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+				prot);
+	} else {
+		printf ("\n");
+	}
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) {	/* not protected */
+			FPWV *addr = (FPWV *) (info->start[sect]);
+			FPW status;
+
+			printf ("Erasing sector %2d ... ", sect);
+
+			/* Disable interrupts which might cause a timeout here */
+			flag = disable_interrupts ();
+
+			/* flash_unprotect_sectors (addr); */
+
+			/* arm simple, non interrupt dependent timer */
+			reset_timer_masked ();
+
+			*addr = (FPW) 0x00500050; /* clear status register */
+			*addr = (FPW) 0x00200020; /* erase setup */
+			*addr = (FPW) 0x00D000D0; /* erase confirm */
+			mb();
+
+			udelay(1000); /* Let's wait 1 ms */
+
+			/* re-enable interrupts if necessary */
+			if (flag)
+				enable_interrupts();
+
+			while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
+				if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
+					*addr = (FPW)0x00700070;
+					status = *addr;
+					if ((status & (FPW) 0x00400040) == (FPW) 0x00400040) {
+						/* erase suspended? Resume it */
+						reset_timer_masked();
+						*addr = (FPW) 0x00D000D0;
+					} else {
+#ifdef DEBUG
+						printf ("Timeout,0x%08lx\n", status);
+#else
+						printf("Timeout\n");
+#endif
+
+						*addr = (FPW) 0x00500050;
+						*addr = (FPW) 0x00FF00FF; /* reset to read mode */
+						rcode = 1;
+						break;
+					}
+				}
+			}
+
+			*addr = (FPW) 0x00FF00FF; /* resest to read mode */
+			printf (" done\n");
+		}
+	}
+
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ * 4 - Flash not identified
+ */
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	FPW data;
+	int count, i, l, rc, port_width;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+	}
+/* get lower word aligned address */
+#ifdef FLASH_PORT_WIDTH16
+	wp = (addr & ~1);
+	port_width = 2;
+#else
+	wp = (addr & ~3);
+	port_width = 4;
+#endif
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+			return (rc);
+		}
+		wp += port_width;
+		cnt -= port_width;
+		if (count++ > 0x800) {
+			spin_wheel ();
+			count = 0;
+		}
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i < port_width; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *) cp);
+	}
+
+	return (write_data (info, wp, SWAP (data)));
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word or halfword to Flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_data (flash_info_t * info, ulong dest, FPW data)
+{
+	FPWV *addr = (FPWV *) dest;
+	ulong status;
+	int flag;
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((*addr & data) != data) {
+		printf ("not erased at %08lx (%lx)\n", (ulong) addr, *addr);
+		return (2);
+	}
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* flash_unprotect_sectors (addr); */
+
+	*addr = (FPW) 0x00400040;	/* write setup */
+	*addr = data;
+
+	mb();
+
+	/* re-enable interrupts if necessary */
+	if (flag)
+		enable_interrupts();
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait while polling the status register */
+	while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
+		if (get_timer_masked () > CONFIG_SYS_FLASH_WRITE_TOUT) {
+#ifdef DEBUG
+			*addr = (FPW) 0x00700070;
+			status = *addr;
+			printf("## status=0x%08lx, addr=0x%p\n", status, addr);
+#endif
+			*addr = (FPW) 0x00500050; /* clear status register cmd */
+			*addr = (FPW) 0x00FF00FF; /* restore read mode */
+			return (1);
+		}
+	}
+
+	*addr = (FPW) 0x00FF00FF; /* restore read mode */
+	return (0);
+}
+
+void inline spin_wheel (void)
+{
+	static int p = 0;
+	static char w[] = "\\/-";
+
+	printf ("\010%c", w[p]);
+	(++p == 3) ? (p = 0) : 0;
+}
diff -Naur u-boot-2009.01/board/armltd/integratorcp/integratorcp.c u-boot/board/armltd/integratorcp/integratorcp.c
--- u-boot-2009.01/board/armltd/integratorcp/integratorcp.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorcp/integratorcp.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,279 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * (C) Copyright 2004
+ * ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <div64.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void flash__init (void);
+void ether__init (void);
+void peripheral_power_enable (void);
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+#define COMP_MODE_ENABLE ((unsigned int)0x0000EAEF)
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	/* arch number of Integrator Board */
+	gd->bd->bi_arch_number = MACH_TYPE_CINTEGRATOR;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+
+	gd->flags = 0;
+
+#ifdef CONFIG_CM_REMAP
+extern void cm_remap(void);
+	cm_remap();	/* remaps writeable memory to 0x00000000 */
+#endif
+
+	icache_enable ();
+
+	flash__init ();
+	ether__init ();
+	return 0;
+}
+
+
+int misc_init_r (void)
+{
+	setenv("verify", "n");
+	return (0);
+}
+
+/******************************
+ Routine:
+ Description:
+******************************/
+void flash__init (void)
+{
+}
+/*************************************************************
+ Routine:ether__init
+ Description: take the Ethernet controller out of reset and wait
+	      for the EEPROM load to complete.
+*************************************************************/
+void ether__init (void)
+{
+}
+
+/******************************
+ Routine:
+ Description:
+******************************/
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size	 = PHYS_SDRAM_1_SIZE;
+
+#ifdef CONFIG_CM_SPD_DETECT
+    {
+extern void dram_query(void);
+	unsigned long cm_reg_sdram;
+	unsigned long sdram_shift;
+
+	dram_query();	/* Assembler accesses to CM registers */
+			/* Queries the SPD values	      */
+
+	/* Obtain the SDRAM size from the CM SDRAM register */
+
+	cm_reg_sdram = *(volatile ulong *)(CM_BASE + OS_SDRAM);
+	/*   Register	      SDRAM size
+	 *
+	 *   0xXXXXXXbbb000bb	 16 MB
+	 *   0xXXXXXXbbb001bb	 32 MB
+	 *   0xXXXXXXbbb010bb	 64 MB
+	 *   0xXXXXXXbbb011bb	128 MB
+	 *   0xXXXXXXbbb100bb	256 MB
+	 *
+	 */
+	sdram_shift		 = ((cm_reg_sdram & 0x0000001C)/4)%4;
+	gd->bd->bi_dram[0].size	 = 0x01000000 << sdram_shift;
+
+    }
+#endif /* CM_SPD_DETECT */
+
+	return 0;
+}
+
+/* The Integrator/CP timer1 is clocked at 1MHz
+ * can be divided by 16 or 256
+ * and can be set up as a 32-bit timer
+ */
+/* U-Boot expects a 32 bit timer, running at CONFIG_SYS_HZ */
+/* Keep total timer count to avoid losing decrements < div_timer */
+static unsigned long long total_count = 0;
+static unsigned long long lastdec;	 /* Timer reading at last call	   */
+static unsigned long long div_clock = 1; /* Divisor applied to timer clock */
+static unsigned long long div_timer = 1; /* Divisor to convert timer reading
+					  * change to U-Boot ticks
+					  */
+/* CONFIG_SYS_HZ = CONFIG_SYS_HZ_CLOCK/(div_clock * div_timer) */
+static ulong timestamp;		/* U-Boot ticks since startup	      */
+
+#define TIMER_LOAD_VAL ((ulong)0xFFFFFFFF)
+#define READ_TIMER (*(volatile ulong *)(CONFIG_SYS_TIMERBASE+4))
+
+/* all function return values in U-Boot ticks i.e. (1/CONFIG_SYS_HZ) sec
+ *  - unless otherwise stated
+ */
+
+/* starts up a counter
+ * - the Integrator/CP timer can be set up to issue an interrupt */
+int interrupt_init (void)
+{
+	/* Load timer with initial value */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 0) = TIMER_LOAD_VAL;
+	/* Set timer to be
+	 *	enabled		  1
+	 *	periodic	  1
+	 *	no interrupts	  0
+	 *	X		  0
+	 *	divider 1	 00 == less rounding error
+	 *	32 bit		  1
+	 *	wrapping	  0
+	 */
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 8) = 0x000000C2;
+	/* init the timestamp */
+	total_count = 0ULL;
+	reset_timer_masked();
+
+	div_timer  = (unsigned long long)(CONFIG_SYS_HZ_CLOCK / CONFIG_SYS_HZ);
+	div_timer /= div_clock;
+
+	return (0);
+}
+
+/*
+ * timer without interrupts
+ */
+void reset_timer (void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer (ulong base_ticks)
+{
+	return get_timer_masked () - base_ticks;
+}
+
+void set_timer (ulong ticks)
+{
+	timestamp   = ticks;
+	total_count = (unsigned long long)ticks * div_timer;
+}
+
+/* delay usec useconds */
+void udelay (unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	/* Convert to U-Boot ticks */
+	tmo  = usec * CONFIG_SYS_HZ;
+	tmo /= (1000000L);
+
+	tmp  = get_timer_masked();	/* get current timestamp */
+	tmo += tmp;			/* form target timestamp */
+
+	while (get_timer_masked () < tmo) {/* loop till event */
+		/*NOP*/;
+	}
+}
+
+void reset_timer_masked (void)
+{
+	/* capure current decrementer value    */
+	lastdec	  = (unsigned long long)READ_TIMER;
+	/* start "advancing" time stamp from 0 */
+	timestamp = 0L;
+}
+
+/* converts the timer reading to U-Boot ticks	       */
+/* the timestamp is the number of ticks since reset    */
+ulong get_timer_masked (void)
+{
+	/* get current count */
+	unsigned long long now = (unsigned long long)READ_TIMER;
+
+	if(now > lastdec) {
+		/* Must have wrapped */
+		total_count += lastdec + TIMER_LOAD_VAL + 1 - now;
+	} else {
+		total_count += lastdec - now;
+	}
+	lastdec	  = now;
+
+	/* Reuse "now" */
+	now = total_count;
+	do_div(now, div_timer);
+	timestamp = now;
+
+	return timestamp;
+}
+
+/* waits specified delay value and resets timestamp */
+void udelay_masked (unsigned long usec)
+{
+	udelay(usec);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return (unsigned long long)get_timer(0);
+}
+
+/*
+ * Return the timebase clock frequency
+ * i.e. how often the timer decrements
+ */
+ulong get_tbclk (void)
+{
+	return (ulong)(((unsigned long long)CONFIG_SYS_HZ_CLOCK)/div_clock);
+}
diff -Naur u-boot-2009.01/board/armltd/integratorcp/lowlevel_init.S u-boot/board/armltd/integratorcp/lowlevel_init.S
--- u-boot-2009.01/board/armltd/integratorcp/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorcp/lowlevel_init.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,214 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2003, ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+/* Reset using CM control register */
+.global reset_cpu
+reset_cpu:
+	mov	r0, #CM_BASE
+	ldr	r1,[r0,#OS_CTRL]
+	orr	r1,r1,#CMMASK_RESET
+	str	r1,[r0,#OS_CTRL]
+
+reset_failed:
+	b	reset_failed
+
+/* Set up the platform, once the cpu has been initialized */
+.globl lowlevel_init
+lowlevel_init:
+	/* If U-Boot has been run after the ARM boot monitor
+	 * then all the necessary actions have been done
+	 * otherwise we are running from user flash mapped to 0x00000000
+	 * --- DO NOT REMAP BEFORE THE CODE HAS BEEN RELOCATED --
+	 * Changes to the (possibly soft) reset defaults of the processor
+	 * itself should be performed in cpu/arm<>/start.S
+	 * This function affects only the core module or board settings
+	 */
+
+#ifdef CONFIG_CM_INIT
+	/* CM has an initialization register
+	 * - bits in it are wired into test-chip pins to force
+	 *   reset defaults
+	 * - may need to change its contents for U-Boot
+	 */
+
+	/* set the desired CM specific value */
+	mov	r2,#CMMASK_LOWVEC	/* Vectors at 0x00000000 for all */
+
+#if defined (CONFIG_CM10200E) || defined (CONFIG_CM10220E)
+	orr	r2,r2,#CMMASK_INIT_102
+#else
+
+#if	!defined (CONFIG_CM920T) && !defined (CONFIG_CM920T_ETM) && \
+	!defined (CONFIG_CM940T)
+	/* CMxx6 code	*/
+
+#ifdef	CONFIG_CM_MULTIPLE_SSRAM
+	/* set simple mapping			*/
+	and	r2,r2,#CMMASK_MAP_SIMPLE
+#endif /* #ifdef CONFIG_CM_MULTIPLE_SSRAM	*/
+
+#ifdef	CONFIG_CM_TCRAM
+	/* disable TCRAM			*/
+	and	r2,r2,#CMMASK_TCRAM_DISABLE
+#endif /* #ifdef CONFIG_CM_TCRAM		*/
+
+#if defined (CONFIG_CM926EJ_S) || defined (CONFIG_CM1026EJ_S) || \
+			defined (CONFIG_CM1136JF_S)
+
+	and	r2,r2,#CMMASK_LE
+
+#endif /* cpu with little endian initialization */
+
+	orr	r2,r2,#CMMASK_CMxx6_COMMON
+
+#endif /* CMxx6 code */
+
+#endif /* ARM102xxE value */
+
+	/* read CM_INIT		 */
+	mov	r0, #CM_BASE
+	ldr	r1, [r0, #OS_INIT]
+	/* check against desired bit setting */
+	and	r3,r1,r2
+	cmp	r3,r2
+	beq	init_reg_OK
+
+	/* lock for change */
+	mov	r3, #CMVAL_LOCK1
+	and	r3, r3, #CMVAL_LOCK2
+	str	r3, [r0, #OS_LOCK]
+	/* set desired value */
+	orr	r1,r1,r2
+	/* write & relock CM_INIT */
+	str	r1, [r0, #OS_INIT]
+	mov	r1, #CMVAL_UNLOCK
+	str	r1, [r0, #OS_LOCK]
+
+	/* soft reset so new values used */
+	b	reset_cpu
+
+init_reg_OK:
+
+#endif /* CONFIG_CM_INIT */
+
+	mov	pc, lr
+
+#ifdef	CONFIG_CM_SPD_DETECT
+	/* Fast memory is available for the DRAM data
+	 * - ensure it has been transferred, then summarize the data
+	 *	 into a CM register
+	 */
+.globl dram_query
+dram_query:
+	stmfd	r13!,{r4-r6,lr}
+	/* set up SDRAM info					*/
+	/* - based on example code from the CM User Guide */
+	mov	r0, #CM_BASE
+
+readspdbit:
+	ldr	r1, [r0, #OS_SDRAM]	/* read the SDRAM register */
+	and	r1, r1, #0x20		/* mask SPD bit (5)		 */
+	cmp	r1, #0x20		/* test if set			 */
+	bne	readspdbit
+
+setupsdram:
+	add	r0, r0, #OS_SPD		/* address the copy of the SDP data	*/
+	ldrb	r1, [r0, #3]		/* number of row address lines		*/
+	ldrb	r2, [r0, #4]		/* number of column address lines	*/
+	ldrb	r3, [r0, #5]		/* number of banks			*/
+	ldrb	r4, [r0, #31]		/* module bank density			*/
+	mul	r5, r4, r3		/* size of SDRAM (MB divided by 4)	*/
+	mov	r5, r5, ASL#2		/* size in MB				*/
+	mov	r0, #CM_BASE		/* reload for later code		*/
+	cmp	r5, #0x10		/* is it 16MB?				*/
+	bne	not16
+	mov	r6, #0x2		/* store size and CAS latency of 2	*/
+	b	writesize
+
+not16:
+	cmp	r5, #0x20		/* is it  32MB? */
+	bne	not32
+	mov	r6, #0x6
+	b	writesize
+
+not32:
+	cmp	r5, #0x40		/* is it  64MB? */
+	bne	not64
+	mov	r6, #0xa
+	b	writesize
+
+not64:
+	cmp	r5, #0x80		/* is it 128MB? */
+	bne	not128
+	mov	r6, #0xe
+	b	writesize
+
+not128:
+	/* if it is none of these sizes then it is either 256MB, or
+	 * there is no SDRAM fitted so default to 256MB
+	 */
+	mov	r6, #0x12
+
+writesize:
+	mov	r1, r1, ASL#8		/* row addr lines from SDRAM reg */
+	orr	r2, r1, r2, ASL#12	/* OR in column address lines	 */
+	orr	r3, r2, r3, ASL#16	/* OR in number of banks	 */
+	orr	r6, r6, r3		/* OR in size and CAS latency	 */
+	str	r6, [r0, #OS_SDRAM]	/* store SDRAM parameters	 */
+
+#endif /* #ifdef CONFIG_CM_SPD_DETECT */
+
+	ldmfd	r13!,{r4-r6,pc}			/* back to caller */
+
+#ifdef	CONFIG_CM_REMAP
+	/* CM remap bit is operational
+	 * - use it to map writeable memory at 0x00000000, in place of flash
+	 */
+.globl cm_remap
+cm_remap:
+	stmfd	r13!,{r4-r10,lr}
+
+	mov	r0, #CM_BASE
+	ldr	r1, [r0, #OS_CTRL]
+	orr	r1, r1, #CMMASK_REMAP	/* set remap and led bits */
+	str	r1, [r0, #OS_CTRL]
+
+	/* Now 0x00000000 is writeable, replace the vectors	*/
+	ldr	r0, =_start	/* r0 <- start of vectors	*/
+	ldr	r2, =_armboot_start	/* r2 <- past vectors	*/
+	sub	r1,r1,r1		/* destination 0x00000000	*/
+
+copy_vec:
+	ldmia	r0!, {r3-r10}		/* copy from source address [r0]	*/
+	stmia	r1!, {r3-r10}		/* copy to	 target address [r1]	*/
+	cmp	r0, r2			/* until source end address [r2]	*/
+	ble	copy_vec
+
+	ldmfd	r13!,{r4-r10,pc}	/* back to caller			*/
+
+#endif /* #ifdef CONFIG_CM_REMAP */
diff -Naur u-boot-2009.01/board/armltd/integratorcp/Makefile u-boot/board/armltd/integratorcp/Makefile
--- u-boot-2009.01/board/armltd/integratorcp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorcp/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= integratorcp.o flash.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/armltd/integratorcp/split_by_variant.sh u-boot/board/armltd/integratorcp/split_by_variant.sh
--- u-boot-2009.01/board/armltd/integratorcp/split_by_variant.sh	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorcp/split_by_variant.sh	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,114 @@
+#!/bin/sh
+# ---------------------------------------------------------
+# Set the platform defines
+# ---------------------------------------------------------
+echo -n "/* Integrator configuration implied "   > tmp.fil
+echo    " by Makefile target */"		>> tmp.fil
+echo -n "#define CONFIG_INTEGRATOR"		>> tmp.fil
+echo	 " /* Integrator board */"		>> tmp.fil
+echo -n "#define CONFIG_ARCH_CINTEGRATOR"	>> tmp.fil
+echo     " 1 /* Integrator/CP   */"		>> tmp.fil
+
+cpu="arm_intcm"
+variant="unknown core module"
+
+if [ "$1" = "" ]
+then
+	echo "$0:: No parameters - using arm_intcm"
+else
+	case "$1" in
+	ap966)
+	cpu="arm_intcm"
+	variant="unported core module CM966E-S"
+	;;
+
+	ap922_config)
+	cpu="arm_intcm"
+	variant="unported core module CM922T"
+	;;
+
+	integratorcp_config	|	\
+	cp_config)
+	cpu="arm_intcm"
+	variant="unspecified core module"
+	;;
+
+	cp922_XA10_config)
+	cpu="arm_intcm"
+	variant="unported core module CM922T_XA10"
+	echo -n "#define CONFIG_CM922T_XA10"		>> tmp.fil
+	echo    " 1 /* CPU core is ARM922T_XA10 */"	>> tmp.fil
+	;;
+
+	cp920t_config)
+	cpu="arm920t"
+	variant="Core module CM920T"
+	echo -n "#define CONFIG_CM920T"			>> tmp.fil
+	echo    " 1 /* CPU core is ARM920T */"		>> tmp.fil
+	;;
+
+	cp926ejs_config)
+	cpu="arm926ejs"
+	variant="Core module CM926EJ-S"
+	echo -n "#define CONFIG_CM926EJ_S"		>> tmp.fil
+	echo    " 1 /* CPU core is ARM926EJ-S */ "	>> tmp.fil
+	;;
+
+
+	cp946es_config)
+	cpu="arm946es"
+	variant="Core module CM946E-S"
+	echo -n "#define CONFIG_CM946E_S"		>> tmp.fil
+	echo    " 1 /* CPU core is ARM946E-S */ "	>> tmp.fil
+	;;
+
+	cp1136_config)
+	cpu="arm1136"
+	variant="Core module CM1136EJF-S"
+	echo -n "#define CONFIG_CM1136EJF_S"		>> tmp.fil
+	echo    " 1 /* CPU core is ARM1136JF-S */ "	>> tmp.fil
+	;;
+
+	*)
+	echo "$0:: Unknown core module"
+	variant="unknown core module"
+	cpu="arm_intcm"
+	;;
+
+	esac
+
+fi
+
+if [ "$cpu" = "arm_intcm" ]
+then
+	echo "/* Core module undefined/not ported */"	>> tmp.fil
+	echo "#define CONFIG_ARM_INTCM 1"		>> tmp.fil
+	echo -n "#undef CONFIG_CM_MULTIPLE_SSRAM"	>> tmp.fil
+	echo -n "  /* CM may not have "			>> tmp.fil
+	echo    "multiple SSRAM mapping */"		>> tmp.fil
+	echo -n "#undef CONFIG_CM_SPD_DETECT "		>> tmp.fil
+	echo -n " /* CM may not support SPD "		>> tmp.fil
+	echo    "query */"				>> tmp.fil
+	echo -n "#undef CONFIG_CM_REMAP  "		>> tmp.fil
+	echo -n " /* CM may not support "		>> tmp.fil
+	echo    "remapping */"				>> tmp.fil
+	echo -n "#undef CONFIG_CM_INIT  "		>> tmp.fil
+	echo -n " /* CM may not have  "			>> tmp.fil
+	echo    "initialization reg */"			>> tmp.fil
+	echo -n "#undef CONFIG_CM_TCRAM  "		>> tmp.fil
+	echo    " /* CM may not have TCRAM */"		>> tmp.fil
+fi
+
+mkdir -p ${obj}include
+mkdir -p ${obj}board/armltd/integratorcp
+mv tmp.fil ${obj}include/config.h
+# ---------------------------------------------------------
+#  Ensure correct core object loaded first in U-Boot image
+# ---------------------------------------------------------
+sed -r 's/CPU_FILE/cpu\/'$cpu'\/start.o/; s/#.*//' ${src}board/armltd/integratorcp/u-boot.lds.template > ${obj}board/armltd/integratorcp/u-boot.lds
+# ---------------------------------------------------------
+# Complete the configuration
+# ---------------------------------------------------------
+$MKCONFIG -a integratorcp arm $cpu integratorcp armltd;
+echo "Variant:: $variant with core $cpu"
+
diff -Naur u-boot-2009.01/board/armltd/integratorcp/u-boot.lds.template u-boot/board/armltd/integratorcp/u-boot.lds.template
--- u-boot-2009.01/board/armltd/integratorcp/u-boot.lds.template	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/integratorcp/u-boot.lds.template	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,53 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+# Template used during configuration to emsure the core module processor code,
+# from CPU_FILE, is placed at the start of the image */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+		CPU_FILE (.text)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/armltd/versatile/config.mk u-boot/board/armltd/versatile/config.mk
--- u-boot-2009.01/board/armltd/versatile/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/versatile/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,5 @@
+#
+# image should be loaded at 0x01000000
+#
+
+TEXT_BASE = 0x01000000
diff -Naur u-boot-2009.01/board/armltd/versatile/flash.c u-boot/board/armltd/versatile/flash.c
--- u-boot-2009.01/board/armltd/versatile/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/versatile/flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,514 @@
+/*
+ * (C) Copyright 2001
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * (C) Copyright 2001-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <linux/byteorder/swab.h>
+
+#define PHYS_FLASH_SECT_SIZE	0x00020000	/* 256 KB sectors (x2) */
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];	/* info for FLASH chips    */
+
+/* Board support for 1 or 2 flash devices */
+#define FLASH_PORT_WIDTH32
+#undef FLASH_PORT_WIDTH16
+
+#ifdef FLASH_PORT_WIDTH16
+#define FLASH_PORT_WIDTH		ushort
+#define FLASH_PORT_WIDTHV		vu_short
+#define SWAP(x)			__swab16(x)
+#else
+#define FLASH_PORT_WIDTH		ulong
+#define FLASH_PORT_WIDTHV		vu_long
+#define SWAP(x)			__swab32(x)
+#endif
+
+#define FPW	FLASH_PORT_WIDTH
+#define FPWV	FLASH_PORT_WIDTHV
+
+#define mb() __asm__ __volatile__ ("" : : : "memory")
+
+
+/* Flash Organization Structure */
+typedef struct OrgDef {
+	unsigned int sector_number;
+	unsigned int sector_size;
+} OrgDef;
+
+
+/* Flash Organizations */
+OrgDef OrgIntel_28F256K3[] = {
+	{256, 128 * 1024},		/* 256 * 128kBytes sectors */
+};
+
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+unsigned long flash_init (void);
+static ulong flash_get_size (FPW * addr, flash_info_t * info);
+static int write_data (flash_info_t * info, ulong dest, FPW data);
+static void flash_get_offsets (ulong base, flash_info_t * info);
+void inline spin_wheel (void);
+void flash_print_info (flash_info_t * info);
+void flash_unprotect_sectors (FPWV * addr);
+int flash_erase (flash_info_t * info, int s_first, int s_last);
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt);
+
+/*-----------------------------------------------------------------------
+ */
+
+static void flash_vpp(int on)
+{
+	unsigned int tmp;
+
+	tmp = *(unsigned int *)(VERSATILE_FLASHCTRL);
+
+	if (on)
+	    tmp |= VERSATILE_FLASHPROG_FLVPPEN;
+	else
+	    tmp &= ~VERSATILE_FLASHPROG_FLVPPEN;
+
+	*(unsigned int *)(VERSATILE_FLASHCTRL) = tmp;
+}
+
+unsigned long flash_init (void)
+{
+	int i;
+	ulong size = 0;
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
+		switch (i) {
+		case 0:
+		        flash_vpp(1);
+			flash_get_size ((FPW *) PHYS_FLASH_1, &flash_info[i]);
+			flash_get_offsets (PHYS_FLASH_1, &flash_info[i]);
+			flash_vpp(0);
+			break;
+		default:
+			panic ("configured too many flash banks!\n");
+			break;
+		}
+		size += flash_info[i].size;
+	}
+
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect (FLAG_PROTECT_SET,
+			CONFIG_SYS_FLASH_BASE,
+			CONFIG_SYS_FLASH_BASE + monitor_flash_len - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_get_offsets (ulong base, flash_info_t * info)
+{
+	int i;
+	OrgDef *pOrgDef;
+
+	pOrgDef = OrgIntel_28F256K3;
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL) {
+		for (i = 0; i < info->sector_count; i++) {
+			if (i > 255) {
+				info->start[i] = base + (i * 0x8000);
+				info->protect[i] = 0;
+			} else {
+				info->start[i] = base +
+						(i * PHYS_FLASH_SECT_SIZE);
+				info->protect[i] = 0;
+			}
+		}
+	}
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_INTEL:
+		printf ("INTEL ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_28F256L18T:
+		printf ("FLASH 28F256L18T\n");
+		break;
+	case FLASH_28F256K3:
+		printf ("FLASH 28F256K3\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+		if ((i % 5) == 0)
+			printf ("\n   ");
+		printf (" %08lX%s",
+			info->start[i], info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+	return;
+}
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+static ulong flash_get_size (FPW * addr, flash_info_t * info)
+{
+	volatile FPW value;
+
+	/* Write auto select command: read Manufacturer ID */
+	addr[0x5555] = (FPW) 0x00AA00AA;
+	addr[0x2AAA] = (FPW) 0x00550055;
+	addr[0x5555] = (FPW) 0x00900090;
+
+	mb ();
+	value = addr[0];
+	switch (value) {
+
+	case (FPW) INTEL_MANUFACT:
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
+		return (0);		/* no or unknown flash  */
+	}
+
+	mb ();
+	value = addr[1];	/* device ID        */
+	switch (value) {
+
+	case (FPW) (INTEL_ID_28F256L18T):
+		info->flash_id += FLASH_28F256L18T;
+		info->sector_count = 259;
+		info->size = 0x02000000;
+		break;			/* => 32 MB     */
+
+	case (FPW)(INTEL_ID_28F256K3):
+		info->flash_id += FLASH_28F256K3;
+		info->sector_count = 256;
+		info->size = 0x02000000;
+		break;
+
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		break;
+	}
+
+	if (info->sector_count > CONFIG_SYS_MAX_FLASH_SECT) {
+		printf ("** ERROR: sector count %d > max (%d) **\n",
+				info->sector_count, CONFIG_SYS_MAX_FLASH_SECT);
+		info->sector_count = CONFIG_SYS_MAX_FLASH_SECT;
+	}
+
+	addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
+
+	return (info->size);
+}
+
+
+/* unprotects a sector for write and erase
+ * on some intel parts, this unprotects the entire chip, but it
+ * wont hurt to call this additional times per sector...
+ */
+void flash_unprotect_sectors (FPWV * addr)
+{
+#define PD_FINTEL_WSMS_READY_MASK    0x0080
+
+	*addr = (FPW) 0x00500050;	/* clear status register */
+
+	/* this sends the clear lock bit command */
+	*addr = (FPW) 0x00600060;
+	*addr = (FPW) 0x00D000D0;
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	int flag, prot, sect;
+	ulong type, start, last;
+	int rcode = 0;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	type = (info->flash_id & FLASH_VENDMASK);
+	if ((type != FLASH_MAN_INTEL)) {
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+				info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+				prot);
+	} else {
+		printf ("\n");
+	}
+
+	flash_vpp(1);
+
+	start = get_timer (0);
+	last = start;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) {	/* not protected */
+			FPWV *addr = (FPWV *) (info->start[sect]);
+			FPW status;
+
+			printf ("Erasing sector %2d ... ", sect);
+
+			flash_unprotect_sectors (addr);
+
+			/* arm simple, non interrupt dependent timer */
+			reset_timer_masked ();
+
+			*addr = (FPW) 0x00500050;/* clear status register */
+			*addr = (FPW) 0x00200020;/* erase setup */
+			*addr = (FPW) 0x00D000D0;/* erase confirm */
+
+			while (((status =
+				*addr) & (FPW) 0x00800080) !=
+				(FPW) 0x00800080) {
+					if (get_timer_masked () >
+					CONFIG_SYS_FLASH_ERASE_TOUT) {
+					printf ("Timeout\n");
+					/* suspend erase     */
+					*addr = (FPW) 0x00B000B0;
+					/* reset to read mode */
+					*addr = (FPW) 0x00FF00FF;
+					rcode = 1;
+					break;
+				}
+			}
+
+			/* clear status register cmd.   */
+			*addr = (FPW) 0x00500050;
+			*addr = (FPW) 0x00FF00FF;/* resest to read mode */
+			printf (" done\n");
+		}
+	}
+
+	flash_vpp(0);
+
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ * 4 - Flash not identified
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	FPW data;
+	int count, i, l, rc, port_width;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		return 4;
+	}
+/* get lower word aligned address */
+#ifdef FLASH_PORT_WIDTH16
+	wp = (addr & ~1);
+	port_width = 2;
+#else
+	wp = (addr & ~3);
+	port_width = 4;
+#endif
+
+	flash_vpp(1);
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < port_width && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < port_width; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+			flash_vpp(0);
+			return (rc);
+		}
+		wp += port_width;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	count = 0;
+	while (cnt >= port_width) {
+		data = 0;
+		for (i = 0; i < port_width; ++i) {
+			data = (data << 8) | *src++;
+		}
+		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
+			flash_vpp(0);
+			return (rc);
+		}
+		wp += port_width;
+		cnt -= port_width;
+		if (count++ > 0x800) {
+			spin_wheel ();
+			count = 0;
+		}
+	}
+
+	if (cnt == 0) {
+		flash_vpp(0);
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i < port_width; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *) cp);
+	}
+
+	rc = write_data (info, wp, SWAP (data));
+
+	flash_vpp(0);
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word or halfword to Flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_data (flash_info_t * info, ulong dest, FPW data)
+{
+	FPWV *addr = (FPWV *) dest;
+	ulong status;
+	int flag;
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((*addr & data) != data) {
+		printf ("not erased at %08lx (%lx)\n", (ulong) addr, (ulong) *addr);
+		return (2);
+	}
+
+	flash_vpp(1);
+
+	flash_unprotect_sectors (addr);
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+	*addr = (FPW) 0x00400040;	/* write setup */
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait while polling the status register */
+	while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
+		if (get_timer_masked () > CONFIG_SYS_FLASH_WRITE_TOUT) {
+			*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+			flash_vpp(0);
+			return (1);
+		}
+	}
+	*addr = (FPW) 0x00FF00FF;	/* restore read mode */
+	flash_vpp(0);
+	return (0);
+}
+
+void inline spin_wheel (void)
+{
+	static int p = 0;
+	static char w[] = "\\/-";
+
+	printf ("\010%c", w[p]);
+	(++p == 3) ? (p = 0) : 0;
+}
diff -Naur u-boot-2009.01/board/armltd/versatile/lowlevel_init.S u-boot/board/armltd/versatile/lowlevel_init.S
--- u-boot-2009.01/board/armltd/versatile/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/versatile/lowlevel_init.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,34 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2003, ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+/* Set up the platform, once the cpu has been initialized */
+.globl lowlevel_init
+lowlevel_init:
+
+	/* All done by Versatile's boot monitor! */
+	mov pc, lr
diff -Naur u-boot-2009.01/board/armltd/versatile/Makefile u-boot/board/armltd/versatile/Makefile
--- u-boot-2009.01/board/armltd/versatile/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/versatile/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= versatile.o flash.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/armltd/versatile/split_by_variant.sh u-boot/board/armltd/versatile/split_by_variant.sh
--- u-boot-2009.01/board/armltd/versatile/split_by_variant.sh	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/versatile/split_by_variant.sh	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,42 @@
+#!/bin/sh
+# ---------------------------------------------------------
+#  Set the core module defines according to Core Module
+# ---------------------------------------------------------
+# ---------------------------------------------------------
+# Set up the Versatile type define
+# ---------------------------------------------------------
+
+mkdir -p ${obj}include
+variant=PB926EJ-S
+if [ "$1" = "" ]
+then
+	echo "$0:: No parameters - using versatilepb_config"
+	echo "#define CONFIG_ARCH_VERSATILE_PB" > ${obj}include/config.h
+	variant=PB926EJ-S
+else
+	case "$1" in
+	versatilepb_config	|	\
+	versatile_config)
+	echo "#define CONFIG_ARCH_VERSATILE_PB" > ${obj}include/config.h
+	;;
+
+	versatileab_config)
+	echo "#define CONFIG_ARCH_VERSATILE_AB" > ${obj}include/config.h
+	variant=AB926EJ-S
+	;;
+
+
+	*)
+	echo "$0:: Unrecognised config - using versatilepb_config"
+	echo "#define CONFIG_ARCH_VERSATILE_PB" > ${obj}include/config.h
+	variant=PB926EJ-S
+	;;
+
+	esac
+
+fi
+# ---------------------------------------------------------
+# Complete the configuration
+# ---------------------------------------------------------
+$MKCONFIG -a versatile arm arm926ejs versatile armltd versatile
+echo "Variant:: $variant"
diff -Naur u-boot-2009.01/board/armltd/versatile/u-boot.lds u-boot/board/armltd/versatile/u-boot.lds
--- u-boot-2009.01/board/armltd/versatile/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/versatile/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,51 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss (NOLOAD) : { *(.bss) . = ALIGN(4); }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/armltd/versatile/versatile.c u-boot/board/armltd/versatile/versatile.c
--- u-boot-2009.01/board/armltd/versatile/versatile.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/armltd/versatile/versatile.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,98 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * (C) Copyright 2004
+ * ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+    printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+#define COMP_MODE_ENABLE ((unsigned int)0x0000EAEF)
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+		"subs %0, %1, #1\n"
+		"bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	/*
+	 * set clock frequency:
+	 *	VERSATILE_REFCLK is 32KHz
+	 *	VERSATILE_TIMCLK is 1MHz
+	 */
+	*(volatile unsigned int *)(VERSATILE_SCTL_BASE) |=
+	  ((VERSATILE_TIMCLK << VERSATILE_TIMER1_EnSel) | (VERSATILE_TIMCLK << VERSATILE_TIMER2_EnSel) |
+	   (VERSATILE_TIMCLK << VERSATILE_TIMER3_EnSel) | (VERSATILE_TIMCLK << VERSATILE_TIMER4_EnSel));
+
+	/* arch number of Versatile Board */
+	gd->bd->bi_arch_number = MACH_TYPE_VERSATILE_PB;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+
+	gd->flags = 0;
+
+	icache_enable ();
+
+	return 0;
+}
+
+
+int misc_init_r (void)
+{
+	setenv("verify", "n");
+	return (0);
+}
+
+/******************************
+ Routine:
+ Description:
+******************************/
+int dram_init (void)
+{
+	return 0;
+}
diff -Naur u-boot-2009.01/board/barco/barco.c u-boot/board/barco/barco.c
--- u-boot-2009.01/board/barco/barco.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/barco/barco.c	2009-02-26 14:03:58.000000000 +0100
@@ -292,7 +292,7 @@
 {
 #if 0
 	if (argc > 1) {
-		printf ("Usage:\n (%d) %s\n", argc, cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 #endif
@@ -306,19 +306,19 @@
 
 U_BOOT_CMD (
 		try_working, 1, 1, barcobcd_boot_image,
-		" try_working - check flash value and boot the appropriate image\n",
+		"check flash value and boot the appropriate image",
 		"\n"
 	  );
 
 U_BOOT_CMD (
 		boot_working, 1, 1, barcobcd_boot_image,
-		" boot_working - check flash value and boot the appropriate image\n",
+		"check flash value and boot the appropriate image",
 		"\n"
 	  );
 
 U_BOOT_CMD (
 		boot_default, 1, 1, barcobcd_boot_image,
-		" boot_default - check flash value and boot the appropriate image\n",
+		"check flash value and boot the appropriate image",
 		"\n"
 	  );
 /*
diff -Naur u-boot-2009.01/board/bc3450/cmd_bc3450.c u-boot/board/bc3450/cmd_bc3450.c
--- u-boot-2009.01/board/bc3450/cmd_bc3450.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bc3450/cmd_bc3450.c	2009-02-26 14:03:58.000000000 +0100
@@ -194,7 +194,7 @@
 }
 
 U_BOOT_CMD (dip, 1, 1, cmd_dip,
-	    "dip     - read dip switch and config inputs\n",
+	    "read dip switch and config inputs",
 	    "\n"
 	    "     - prints the state of the dip switch and/or\n"
 	    "       external configuration inputs as hex value.\n"
@@ -228,7 +228,7 @@
 }
 
 U_BOOT_CMD (buz, 2, 1, cmd_buz,
-	    "buz     - turns buzzer on/off\n",
+	    "turns buzzer on/off",
 	    "\n" "buz <on/off>\n" "     - turns the buzzer on or off\n");
 #endif /* CONFIG_BC3450_BUZZER */
 
@@ -322,7 +322,7 @@
 }
 
 U_BOOT_CMD (fp, 3, 1, cmd_fp,
-	    "fp      - front panes access functions\n",
+	    "front panes access functions",
 	    "\n"
 	    "fp bl <on/off>\n"
 	    "     - turns the CCFL backlight of the display on/off\n"
@@ -523,7 +523,7 @@
 }
 
 U_BOOT_CMD (temp, 3, 1, cmd_temp,
-	    "temp    - print current temperature\n",
+	    "print current temperature",
 	    "\n" "temp\n" "     - print current temperature\n");
 
 #ifdef CONFIG_BC3450_CAN
@@ -816,7 +816,7 @@
 	return 1;
 }
 
-U_BOOT_CMD (test, 2, 1, cmd_test, "test    - unit test routines\n", "\n"
+U_BOOT_CMD (test, 2, 1, cmd_test, "unit test routines", "\n"
 #ifdef CONFIG_BC3450_CAN
 	    "test can\n"
 	    "     - connect CAN1 (X8) with CAN2 (X9) for this test\n"
diff -Naur u-boot-2009.01/board/bf533-ezkit/bf533-ezkit.c u-boot/board/bf533-ezkit/bf533-ezkit.c
--- u-boot-2009.01/board/bf533-ezkit/bf533-ezkit.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf533-ezkit/bf533-ezkit.c	2009-02-26 14:03:58.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * U-boot - ezkit533.c
+ * U-boot - main board file
  *
- * Copyright (c) 2005-2007 Analog Devices Inc.
+ * Copyright (c) 2005-2008 Analog Devices Inc.
  *
  * (C) Copyright 2000-2004
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
@@ -26,9 +26,8 @@
  */
 
 #include <common.h>
-#if defined(CONFIG_MISC_INIT_R)
 #include "psd4256.h"
-#endif
+#include "flash-defines.h"
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -41,24 +40,11 @@
 
 phys_size_t initdram(int board_type)
 {
-#ifdef DEBUG
-	int brate;
-	char *tmp = getenv("baudrate");
-	brate = simple_strtoul(tmp, NULL, 16);
-	printf("Serial Port initialized with Baud rate = %x\n", brate);
-	printf("SDRAM attributes:\n");
-	printf("tRCD %d SCLK Cycles,tRP %d SCLK Cycles,tRAS %d SCLK Cycles"
-	       "tWR %d SCLK Cycles,CAS Latency %d SCLK cycles \n",
-	       3, 3, 6, 2, 3);
-	printf("SDRAM Begin: 0x%x\n", CONFIG_SYS_SDRAM_BASE);
-	printf("Bank size = %d MB\n", CONFIG_SYS_MAX_RAM_SIZE >> 20);
-#endif
 	gd->bd->bi_memstart = CONFIG_SYS_SDRAM_BASE;
 	gd->bd->bi_memsize = CONFIG_SYS_MAX_RAM_SIZE;
-	return CONFIG_SYS_MAX_RAM_SIZE;
+	return gd->bd->bi_memsize;
 }
 
-#if defined(CONFIG_MISC_INIT_R)
 /* miscellaneous platform dependent initialisations */
 int misc_init_r(void)
 {
@@ -71,4 +57,3 @@
 
 	return 0;
 }
-#endif
diff -Naur u-boot-2009.01/board/bf533-ezkit/flash.c u-boot/board/bf533-ezkit/flash.c
--- u-boot-2009.01/board/bf533-ezkit/flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf533-ezkit/flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -29,6 +29,10 @@
 #include <asm/io.h>
 #include "flash-defines.h"
 
+int AFP_NumSectors = 40;
+long AFP_SectorSize1 = 0x10000;
+int AFP_SectorSize2 = 0x4000;
+
 void flash_reset(void)
 {
 	reset_flash();
@@ -123,7 +127,7 @@
 		printf("ST Microelectronics ");
 		break;
 	default:
-		printf("Unknown Vendor: (0x%08X) ", info->flash_id);
+		printf("Unknown Vendor: (0x%08lX) ", info->flash_id);
 		break;
 	}
 	for (i = 0; i < info->sector_count; ++i) {
@@ -211,7 +215,7 @@
 		read_flash(ulOffset, &d);
 		if (d != 0xffff) {
 			printf
-			    ("Flash not erased at offset 0x%x Please erase to reprogram \n",
+			    ("Flash not erased at offset 0x%lx Please erase to reprogram\n",
 			     ulOffset);
 			return FLASH_FAIL;
 		}
@@ -230,7 +234,7 @@
 		read_flash(ulOffset, &d);
 		if (d != 0xffff) {
 			printf
-			    ("Flash not erased at offset 0x%x Please erase to reprogram \n",
+			    ("Flash not erased at offset 0x%lx Please erase to reprogram\n",
 			     ulOffset);
 			return FLASH_FAIL;
 		}
diff -Naur u-boot-2009.01/board/bf533-ezkit/flash-defines.h u-boot/board/bf533-ezkit/flash-defines.h
--- u-boot-2009.01/board/bf533-ezkit/flash-defines.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf533-ezkit/flash-defines.h	2009-02-26 14:03:58.000000000 +0100
@@ -50,6 +50,7 @@
 #define FLASH_SIZE		0x220000
 #define FLASH_MAN_ST		2
 #define CONFIG_SYS_FLASH0_BASE		0x20000000
+#define CONFIG_SYS_FLASH1_BASE		0x20200000
 #define RESET_VAL		0xF0
 
 flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
@@ -68,9 +69,6 @@
 void get_sector_number(long lOffset, int *pnSector);
 int GetSectorProtectionStatus(flash_info_t * info, int nSector);
 int GetOffset(int nBlock);
-int AFP_NumSectors = 40;
-long AFP_SectorSize1 = 0x10000;
-int AFP_SectorSize2 = 0x4000;
 
 #define WRITESEQ1		0x0AAA
 #define WRITESEQ2		0x0554
diff -Naur u-boot-2009.01/board/bf533-ezkit/Makefile u-boot/board/bf533-ezkit/Makefile
--- u-boot-2009.01/board/bf533-ezkit/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf533-ezkit/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -29,11 +29,11 @@
 
 LIB	= $(obj)lib$(BOARD).a
 
-COBJS	:= $(BOARD).o flash.o
+COBJS-y	:= $(BOARD).o flash.o
 
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
 
 $(LIB):	$(obj).depend $(OBJS) $(SOBJS) $(obj)u-boot.lds
 	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
diff -Naur u-boot-2009.01/board/bf533-stamp/bf533-stamp.c u-boot/board/bf533-stamp/bf533-stamp.c
--- u-boot-2009.01/board/bf533-stamp/bf533-stamp.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf533-stamp/bf533-stamp.c	2009-02-26 14:03:58.000000000 +0100
@@ -49,43 +49,28 @@
 
 phys_size_t initdram(int board_type)
 {
-#ifdef DEBUG
-	printf("SDRAM attributes:\n");
-	printf
-	    ("  tRCD:%d Cycles; tRP:%d Cycles; tRAS:%d Cycles; tWR:%d Cycles; "
-	     "CAS Latency:%d cycles\n", (SDRAM_tRCD >> 15), (SDRAM_tRP >> 11),
-	     (SDRAM_tRAS >> 6), (SDRAM_tWR >> 19), (SDRAM_CL >> 2));
-	printf("SDRAM Begin: 0x%x\n", CONFIG_SYS_SDRAM_BASE);
-	printf("Bank size = %d MB\n", 128);
-#endif
 	gd->bd->bi_memstart = CONFIG_SYS_SDRAM_BASE;
 	gd->bd->bi_memsize = CONFIG_SYS_MAX_RAM_SIZE;
-	return (gd->bd->bi_memsize);
+	return gd->bd->bi_memsize;
 }
 
+/* PF0 and PF1 are used to switch between the ethernet and flash:
+ *         PF0  PF1
+ *  flash:  0    0
+ *  ether:  1    0
+ */
 void swap_to(int device_id)
 {
-
-	if (device_id == ETHERNET) {
-		*pFIO_DIR = PF0;
-		SSYNC();
-		*pFIO_FLAG_S = PF0;
-		SSYNC();
-	} else if (device_id == FLASH) {
-		*pFIO_DIR = (PF4 | PF3 | PF2 | PF1 | PF0);
-		*pFIO_FLAG_S = (PF4 | PF3 | PF2);
-		*pFIO_MASKA_D = (PF8 | PF6 | PF5);
-		*pFIO_MASKB_D = (PF7);
-		*pFIO_POLAR = (PF8 | PF6 | PF5);
-		*pFIO_EDGE = (PF8 | PF7 | PF6 | PF5);
-		*pFIO_INEN = (PF8 | PF7 | PF6 | PF5);
-		*pFIO_FLAG_D = (PF4 | PF3 | PF2);
-		SSYNC();
-	} else {
-		printf("Unknown bank to switch\n");
-	}
-
-	return;
+	bfin_write_FIO_DIR(bfin_read_FIO_DIR() | PF1 | PF0);
+	SSYNC();
+	bfin_write_FIO_FLAG_C(PF1);
+	if (device_id == ETHERNET)
+		bfin_write_FIO_FLAG_S(PF0);
+	else if (device_id == FLASH)
+		bfin_write_FIO_FLAG_C(PF0);
+	else
+		printf("Unknown device to switch\n");
+	SSYNC();
 }
 
 #if defined(CONFIG_MISC_INIT_R)
@@ -113,9 +98,6 @@
 	if (cf_stat) {
 		printf("Booting from COMPACT flash\n");
 
-		/* Set cycle time for CF */
-		*(volatile unsigned long *)ambctl1 = CF_AMBCTL1VAL;
-
 		for (i = 0; i < 0x1000; i++)
 			asm("nop;");
 		for (i = 0; i < 0x1000; i++)
diff -Naur u-boot-2009.01/board/bf533-stamp/bf533-stamp.h u-boot/board/bf533-stamp/bf533-stamp.h
--- u-boot-2009.01/board/bf533-stamp/bf533-stamp.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf533-stamp/bf533-stamp.h	2009-02-26 14:03:58.000000000 +0100
@@ -34,9 +34,6 @@
 extern volatile unsigned long *ambctl1;
 extern volatile unsigned long *amgctl;
 
-extern unsigned long pll_div_fact;
-extern void serial_setbrg(void);
-
 /* Definitions used in  Compact Flash Boot support */
 #define FIO_EDGE_CF_BITS	0x0000
 #define FIO_POLAR_CF_BITS	0x0000
diff -Naur u-boot-2009.01/board/bf533-stamp/Makefile u-boot/board/bf533-stamp/Makefile
--- u-boot-2009.01/board/bf533-stamp/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf533-stamp/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # U-boot - Makefile
 #
-# Copyright (c) 2005-2007 Analog Device Inc.
+# Copyright (c) 2005-2008 Analog Device Inc.
 #
 # (C) Copyright 2000-2006
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
@@ -29,11 +29,13 @@
 
 LIB	= $(obj)lib$(BOARD).a
 
-COBJS	:= $(BOARD).o spi_flash.o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
+COBJS-y	:= $(BOARD).o
+COBJS-$(CONFIG_CMD_EEPROM) += spi_flash.o
+COBJS-$(CONFIG_VIDEO) += video.o
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
 
 $(LIB):	$(obj).depend $(OBJS) $(SOBJS) $(obj)u-boot.lds
 	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
diff -Naur u-boot-2009.01/board/bf533-stamp/video.c u-boot/board/bf533-stamp/video.c
--- u-boot-2009.01/board/bf533-stamp/video.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/bf533-stamp/video.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,167 @@
+/*
+ * BF533-STAMP splash driver
+ *
+ * Copyright (c) 2006-2008 Analog Devices Inc.
+ * (C) Copyright 2000
+ * Paolo Scaffardi, AIRVENT SAM s.p.a - RIMINI(ITALY), arsenio@tin.it
+ * (C) Copyright 2002
+ * Wolfgang Denk, wd@denx.de
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <stdarg.h>
+#include <common.h>
+#include <config.h>
+#include <malloc.h>
+#include <asm/blackfin.h>
+#include <asm/mach-common/bits/dma.h>
+#include <i2c.h>
+#include <linux/types.h>
+#include <devices.h>
+
+int gunzip(void *, int, unsigned char *, unsigned long *);
+
+#define DMA_SIZE16	2
+
+#include <asm/mach-common/bits/ppi.h>
+
+#define NTSC_FRAME_ADDR 0x06000000
+#include "video.h"
+
+/* NTSC OUTPUT SIZE  720 * 240 */
+#define VERTICAL	2
+#define HORIZONTAL	4
+
+int is_vblank_line(const int line)
+{
+	/*
+	 *  This array contains a single bit for each line in
+	 *  an NTSC frame.
+	 */
+	if ((line <= 18) || (line >= 264 && line <= 281) || (line == 528))
+		return true;
+
+	return false;
+}
+
+int NTSC_framebuffer_init(char *base_address)
+{
+	const int NTSC_frames = 1;
+	const int NTSC_lines = 525;
+	char *dest = base_address;
+	int frame_num, line_num;
+
+	for (frame_num = 0; frame_num < NTSC_frames; ++frame_num) {
+		for (line_num = 1; line_num <= NTSC_lines; ++line_num) {
+			unsigned int code;
+			int offset = 0;
+			int i;
+
+			if (is_vblank_line(line_num))
+				offset++;
+
+			if (line_num > 266 || line_num < 3)
+				offset += 2;
+
+			/* Output EAV code */
+			code = system_code_map[offset].eav;
+			write_dest_byte((char)(code >> 24) & 0xff);
+			write_dest_byte((char)(code >> 16) & 0xff);
+			write_dest_byte((char)(code >> 8) & 0xff);
+			write_dest_byte((char)(code) & 0xff);
+
+			/* Output horizontal blanking */
+			for (i = 0; i < 67 * 2; ++i) {
+				write_dest_byte(0x80);
+				write_dest_byte(0x10);
+			}
+
+			/* Output SAV */
+			code = system_code_map[offset].sav;
+			write_dest_byte((char)(code >> 24) & 0xff);
+			write_dest_byte((char)(code >> 16) & 0xff);
+			write_dest_byte((char)(code >> 8) & 0xff);
+			write_dest_byte((char)(code) & 0xff);
+
+			/* Output empty horizontal data */
+			for (i = 0; i < 360 * 2; ++i) {
+				write_dest_byte(0x80);
+				write_dest_byte(0x10);
+			}
+		}
+	}
+
+	return dest - base_address;
+}
+
+void fill_frame(char *Frame, int Value)
+{
+	int *OddPtr32;
+	int OddLine;
+	int *EvenPtr32;
+	int EvenLine;
+	int i;
+	int *data;
+	int m, n;
+
+	/* fill odd and even frames */
+	for (OddLine = 22, EvenLine = 285; OddLine < 263; OddLine++, EvenLine++) {
+		OddPtr32 = (int *)((Frame + (OddLine * 1716)) + 276);
+		EvenPtr32 = (int *)((Frame + (EvenLine * 1716)) + 276);
+		for (i = 0; i < 360; i++, OddPtr32++, EvenPtr32++) {
+			*OddPtr32 = Value;
+			*EvenPtr32 = Value;
+		}
+	}
+
+	for (m = 0; m < VERTICAL; m++) {
+		data = (int *)u_boot_logo.data;
+		for (OddLine = (22 + m), EvenLine = (285 + m);
+		     OddLine < (u_boot_logo.height * VERTICAL) + (22 + m);
+		     OddLine += VERTICAL, EvenLine += VERTICAL) {
+			OddPtr32 = (int *)((Frame + ((OddLine) * 1716)) + 276);
+			EvenPtr32 =
+			    (int *)((Frame + ((EvenLine) * 1716)) + 276);
+			for (i = 0; i < u_boot_logo.width / 2; i++) {
+				/* enlarge one pixel to m x n */
+				for (n = 0; n < HORIZONTAL; n++) {
+					*OddPtr32++ = *data;
+					*EvenPtr32++ = *data;
+				}
+				data++;
+			}
+		}
+	}
+}
+
+static void video_init(char *NTSCFrame)
+{
+	NTSC_framebuffer_init(NTSCFrame);
+	fill_frame(NTSCFrame, BLUE);
+
+	bfin_write_PPI_CONTROL(0x0082);
+	bfin_write_PPI_FRAME(0x020D);
+
+	bfin_write_DMA0_START_ADDR(NTSCFrame);
+	bfin_write_DMA0_X_COUNT(0x035A);
+	bfin_write_DMA0_X_MODIFY(0x0002);
+	bfin_write_DMA0_Y_COUNT(0x020D);
+	bfin_write_DMA0_Y_MODIFY(0x0002);
+	bfin_write_DMA0_CONFIG(0x1015);
+	bfin_write_PPI_CONTROL(0x0083);
+}
+
+int drv_video_init(void)
+{
+	device_t videodev;
+
+	video_init((void *)NTSC_FRAME_ADDR);
+
+	memset(&videodev, 0, sizeof(videodev));
+	strcpy(videodev.name, "video");
+	videodev.ext = DEV_EXT_VIDEO;
+	videodev.flags = DEV_FLAGS_SYSTEM;
+
+	return device_register(&videodev);
+}
diff -Naur u-boot-2009.01/board/bf533-stamp/video.h u-boot/board/bf533-stamp/video.h
--- u-boot-2009.01/board/bf533-stamp/video.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/bf533-stamp/video.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,25 @@
+#include <video_logo.h>
+#define write_dest_byte(val) {*dest++=val;}
+#define BLACK   (0x01800180)	/* black pixel pattern   */
+#define BLUE    (0x296E29F0)	/* blue pixel pattern    */
+#define RED     (0x51F0515A)	/* red pixel pattern     */
+#define MAGENTA (0x6ADE6ACA)	/* magenta pixel pattern */
+#define GREEN   (0x91229136)	/* green pixel pattern   */
+#define CYAN    (0xAA10AAA6)	/* cyan pixel pattern    */
+#define YELLOW  (0xD292D210)	/* yellow pixel pattern  */
+#define WHITE   (0xFE80FE80)	/* white pixel pattern   */
+
+#define true	1
+#define false	0
+
+typedef struct {
+	unsigned int sav;
+	unsigned int eav;
+} system_code_type;
+
+const system_code_type system_code_map[] = {
+	{ 0xFF000080, 0xFF00009D },
+	{ 0xFF0000AB, 0xFF0000B6 },
+	{ 0xFF0000C7, 0xFF0000DA },
+	{ 0xFF0000EC, 0xFF0000F1 },
+};
diff -Naur u-boot-2009.01/board/bf537-stamp/bf537-stamp.c u-boot/board/bf537-stamp/bf537-stamp.c
--- u-boot-2009.01/board/bf537-stamp/bf537-stamp.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf537-stamp/bf537-stamp.c	2009-02-26 14:03:58.000000000 +0100
@@ -34,22 +34,6 @@
 #include <asm/mach-common/bits/bootrom.h>
 #include <netdev.h>
 
-/**
- * is_valid_ether_addr - Determine if the given Ethernet address is valid
- * @addr: Pointer to a six-byte array containing the Ethernet address
- *
- * Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not
- * a multicast address, and is not FF:FF:FF:FF:FF:FF.
- *
- * Return true if the address is valid.
- */
-static inline int is_valid_ether_addr(const u8 * addr)
-{
-	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
-	 * explicitly check for it here. */
-	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
-}
-
 DECLARE_GLOBAL_DATA_PTR;
 
 #define POST_WORD_ADDR 0xFF903FFC
@@ -100,21 +84,9 @@
 
 phys_size_t initdram(int board_type)
 {
-#ifdef DEBUG
-	int brate;
-	char *tmp = getenv("baudrate");
-	brate = simple_strtoul(tmp, NULL, 16);
-	printf("Serial Port initialized with Baud rate = %x\n", brate);
-	printf("SDRAM attributes:\n");
-	printf("tRCD %d SCLK Cycles,tRP %d SCLK Cycles,tRAS %d SCLK Cycles"
-	       "tWR %d SCLK Cycles,CAS Latency %d SCLK cycles \n",
-	       3, 3, 6, 2, 3);
-	printf("SDRAM Begin: 0x%x\n", CONFIG_SYS_SDRAM_BASE);
-	printf("Bank size = %d MB\n", CONFIG_SYS_MAX_RAM_SIZE >> 20);
-#endif
 	gd->bd->bi_memstart = CONFIG_SYS_SDRAM_BASE;
 	gd->bd->bi_memsize = CONFIG_SYS_MAX_RAM_SIZE;
-	return CONFIG_SYS_MAX_RAM_SIZE;
+	return gd->bd->bi_memsize;
 }
 
 #if defined(CONFIG_MISC_INIT_R)
diff -Naur u-boot-2009.01/board/bf537-stamp/cmd_bf537led.c u-boot/board/bf537-stamp/cmd_bf537led.c
--- u-boot-2009.01/board/bf537-stamp/cmd_bf537led.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf537-stamp/cmd_bf537led.c	2009-02-26 14:03:58.000000000 +0100
@@ -196,6 +196,6 @@
 
 /* Register information for u-boot to find this command */
 U_BOOT_CMD(led, 3, 1, do_bf537led,
-	   "led- Control BF537 stamp LEDs\n", USAGE_LONG);
+	   "Control BF537 stamp LEDs", USAGE_LONG);
 
 #endif
diff -Naur u-boot-2009.01/board/bf537-stamp/Makefile u-boot/board/bf537-stamp/Makefile
--- u-boot-2009.01/board/bf537-stamp/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf537-stamp/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -29,11 +29,13 @@
 
 LIB	= $(obj)lib$(BOARD).a
 
-COBJS	:= $(BOARD).o post-memory.o spi_flash.o cmd_bf537led.o nand.o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
+COBJS-y	:= $(BOARD).o post-memory.o cmd_bf537led.o
+COBJS-$(CONFIG_CMD_EEPROM) += spi_flash.o
+COBJS-$(CONFIG_CMD_NAND)   += nand.o
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
 
 $(LIB):	$(obj).depend $(OBJS) $(SOBJS) $(obj)u-boot.lds
 	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
diff -Naur u-boot-2009.01/board/bf537-stamp/nand.c u-boot/board/bf537-stamp/nand.c
--- u-boot-2009.01/board/bf537-stamp/nand.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf537-stamp/nand.c	2009-02-26 14:03:58.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2006 Aubrey.Li, aubrey.li@analog.com
+ * Copyright (c) 2006-2007 Analog Devices Inc.
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -23,8 +23,6 @@
 #include <common.h>
 #include <asm/io.h>
 
-#if defined(CONFIG_CMD_NAND)
-
 #include <nand.h>
 
 #define CONCAT(a,b,c,d) a ## b ## c ## d
@@ -43,11 +41,11 @@
 	u32 IO_ADDR_W = (u32) this->IO_ADDR_W;
 
 	if (ctrl & NAND_CTRL_CHANGE) {
-		if( ctrl & NAND_CLE )
+		if (ctrl & NAND_CLE)
 			IO_ADDR_W = CONFIG_SYS_NAND_BASE + BFIN_NAND_CLE;
 		else
 			IO_ADDR_W = CONFIG_SYS_NAND_BASE;
-		if( ctrl & NAND_ALE )
+		if (ctrl & NAND_ALE)
 			IO_ADDR_W = CONFIG_SYS_NAND_BASE + BFIN_NAND_ALE;
 		else
 			IO_ADDR_W = CONFIG_SYS_NAND_BASE;
@@ -100,4 +98,3 @@
 
 	return 0;
 }
-#endif
diff -Naur u-boot-2009.01/board/bf537-stamp/post-memory.c u-boot/board/bf537-stamp/post-memory.c
--- u-boot-2009.01/board/bf537-stamp/post-memory.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf537-stamp/post-memory.c	2009-02-26 14:03:58.000000000 +0100
@@ -21,10 +21,10 @@
 void post_init_uart(int sclk);
 
 const int pll[CCLK_NUM][SCLK_NUM][2] = {
-	{{20, 4}, {20, 5}, {20, 10}},	/* CCLK = 500M */
-	{{16, 4}, {16, 5}, {16, 8}},	/* CCLK = 400M */
-	{{8, 2}, {8, 4}, {8, 5}},	/* CCLK = 200M */
-	{{4, 1}, {4, 2}, {4, 4}}	/* CCLK = 100M */
+	{ {20, 4}, {20, 5}, {20, 10} },	/* CCLK = 500M */
+	{ {16, 4}, {16, 5}, {16, 8} },	/* CCLK = 400M */
+	{ {8, 2}, {8, 4}, {8, 5} },	/* CCLK = 200M */
+	{ {4, 1}, {4, 2}, {4, 4} }	/* CCLK = 100M */
 };
 const char *const log[CCLK_NUM][SCLK_NUM] = {
 	{"CCLK-500MHz SCLK-125MHz:    Writing...\0",
@@ -119,7 +119,8 @@
 {
 
 	int i = 0;
-	for (i = 0; i < 0x80000; i++) ;
+	for (i = 0; i < 0x80000; i++)
+		;
 	i = 0;
 	while ((buff[i] != '\0') && (i != 100)) {
 		while (!(*pUART_LSR & 0x20)) ;
@@ -127,7 +128,8 @@
 		SSYNC();
 		i++;
 	}
-	for (i = 0; i < 0x80000; i++) ;
+	for (i = 0; i < 0x80000; i++)
+		;
 }
 
 /* Using sw10-PF5 as the hotkey */
@@ -150,9 +152,8 @@
 			value = 0;
 			goto key_pressed;
 		}
-		if (value != 0) {
+		if (value != 0)
 			goto key_pressed;
-		}
 		for (n = 0; n < KEY_DELAY; n++)
 			asm("nop");
 	}
@@ -164,9 +165,8 @@
 			value = 0;
 			goto key_pressed;
 		}
-		if (value != 0) {
+		if (value != 0)
 			goto key_pressed;
-		}
 		for (n = 0; n < KEY_DELAY; n++)
 			asm("nop");
 	}
@@ -178,9 +178,8 @@
 			value = 0;
 			goto key_pressed;
 		}
-		if (value != 0) {
+		if (value != 0)
 			goto key_pressed;
-		}
 		for (n = 0; n < KEY_DELAY; n++)
 			asm("nop");
 	}
diff -Naur u-boot-2009.01/board/bf537-stamp/spi_flash.c u-boot/board/bf537-stamp/spi_flash.c
--- u-boot-2009.01/board/bf537-stamp/spi_flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf537-stamp/spi_flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -3,7 +3,7 @@
  *
  * Enter bugs at http://blackfin.uclinux.org/
  *
- * Copyright (c) 2005-2007 Analog Devices Inc.
+ * Copyright (c) 2005-2008 Analog Devices Inc.
  *
  * Licensed under the GPL-2 or later.
  */
@@ -163,7 +163,9 @@
 
 #define	TIMEOUT	5000	/* timeout of 5 seconds */
 
-/* BF54x support */
+/* If part has multiple SPI flashes, assume SPI0 as that is
+ * the one we can boot off of ...
+ */
 #ifndef pSPI_CTL
 # define pSPI_CTL  pSPI0_CTL
 # define pSPI_BAUD pSPI0_BAUD
@@ -171,23 +173,14 @@
 # define pSPI_RDBR pSPI0_RDBR
 # define pSPI_STAT pSPI0_STAT
 # define pSPI_TDBR pSPI0_TDBR
-# define SPI0_SCK	0x0001
-# define SPI0_MOSI	0x0004
-# define SPI0_MISO	0x0002
-# define SPI0_SEL1	0x0010
 #endif
 
 /* Default to the SPI SSEL that we boot off of:
  *	BF54x, BF537, (everything new?): SSEL1
- *	BF533, BF561: SSEL2
+ *	BF51x, BF533, BF561: SSEL2
  */
 #ifndef CONFIG_SPI_FLASH_SSEL
-# if defined(__ADSPBF531__) || defined(__ADSPBF532__) || \
-     defined(__ADSPBF533__) || defined(__ADSPBF561__)
-#  define CONFIG_SPI_FLASH_SSEL 2
-# else
-#  define CONFIG_SPI_FLASH_SSEL 1
-# endif
+# define CONFIG_SPI_FLASH_SSEL BFIN_BOOT_SPI_SSEL
 #endif
 #define SSEL_MASK (1 << CONFIG_SPI_FLASH_SSEL)
 
@@ -200,12 +193,15 @@
 
 	/* enable SPI pins: SSEL, MOSI, MISO, SCK */
 #ifdef __ADSPBF54x__
-	*pPORTE_FER |= (SPI0_SCK | SPI0_MOSI | SPI0_MISO | SPI0_SEL1);
+	*pPORTE_FER |= (PE0 | PE1 | PE2 | PE4);
 #elif defined(__ADSPBF534__) || defined(__ADSPBF536__) || defined(__ADSPBF537__)
 	*pPORTF_FER |= (PF10 | PF11 | PF12 | PF13);
 #elif defined(__ADSPBF52x__)
 	bfin_write_PORTG_MUX((bfin_read_PORTG_MUX() & ~PORT_x_MUX_0_MASK) | PORT_x_MUX_0_FUNC_3);
 	bfin_write_PORTG_FER(bfin_read_PORTG_FER() | PG1 | PG2 | PG3 | PG4);
+#elif defined(__ADSPBF51x__)
+	bfin_write_PORTG_MUX((bfin_read_PORTG_MUX() & ~PORT_x_MUX_7_MASK) | PORT_x_MUX_7_FUNC_1);
+	bfin_write_PORTG_FER(bfin_read_PORTG_FER() | PG12 | PG13 | PG14 | PG15);
 #endif
 
 	/* initate communication upon write of TDBR */
@@ -797,8 +793,8 @@
 		ret = 1;
 	else
 		printf("SPI Device: %s 0x%02X (%s) 0x%02X 0x%02X\n"
-			"Parameters: num sectors = %i, sector size = %i, write size = %i\n"
-			"Flash Size: %i mbit (%i mbyte)\n"
+			"Parameters: num sectors = %lu, sector size = %lu, write size = %i\n"
+			"Flash Size: %lu mbit (%lu mbyte)\n"
 			"Status: 0x%02X\n",
 			flash.flash->name, flash.manufacturer_id, flash.manufacturer->name,
 			flash.device_id1, flash.device_id2, flash.num_sectors,
diff -Naur u-boot-2009.01/board/bf561-ezkit/bf561-ezkit.c u-boot/board/bf561-ezkit/bf561-ezkit.c
--- u-boot-2009.01/board/bf561-ezkit/bf561-ezkit.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf561-ezkit/bf561-ezkit.c	2009-02-26 14:03:58.000000000 +0100
@@ -39,19 +39,7 @@
 
 phys_size_t initdram(int board_type)
 {
-#ifdef DEBUG
-	int brate;
-	char *tmp = getenv("baudrate");
-	brate = simple_strtoul(tmp, NULL, 16);
-	printf("Serial Port initialized with Baud rate = %x\n", brate);
-	printf("SDRAM attributes:\n");
-	printf("tRCD %d SCLK Cycles,tRP %d SCLK Cycles,tRAS %d SCLK Cycles"
-	       "tWR %d SCLK Cycles,CAS Latency %d SCLK cycles \n",
-	       3, 3, 6, 2, 3);
-	printf("SDRAM Begin: 0x%x\n", CONFIG_SYS_SDRAM_BASE);
-	printf("Bank size = %d MB\n", CONFIG_SYS_MAX_RAM_SIZE >> 20);
-#endif
 	gd->bd->bi_memstart = CONFIG_SYS_SDRAM_BASE;
 	gd->bd->bi_memsize = CONFIG_SYS_MAX_RAM_SIZE;
-	return CONFIG_SYS_MAX_RAM_SIZE;
+	return gd->bd->bi_memsize;
 }
diff -Naur u-boot-2009.01/board/bf561-ezkit/Makefile u-boot/board/bf561-ezkit/Makefile
--- u-boot-2009.01/board/bf561-ezkit/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/bf561-ezkit/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -29,11 +29,11 @@
 
 LIB	= $(obj)lib$(BOARD).a
 
-COBJS	:= $(BOARD).o
+COBJS-y	:= $(BOARD).o
 
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
 
 $(LIB):	$(obj).depend $(OBJS) $(SOBJS) $(obj)u-boot.lds
 	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
diff -Naur u-boot-2009.01/board/BuS/EB+MCF-EV123/EB+MCF-EV123.c u-boot/board/BuS/EB+MCF-EV123/EB+MCF-EV123.c
--- u-boot-2009.01/board/BuS/EB+MCF-EV123/EB+MCF-EV123.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/BuS/EB+MCF-EV123/EB+MCF-EV123.c	2009-02-26 14:03:58.000000000 +0100
@@ -144,7 +144,7 @@
 		rcode = 0;
 		break;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		rcode = 1;
 		break;
 	}
@@ -155,7 +155,7 @@
 
 U_BOOT_CMD(
 	vcimage,	2,	0,	do_vcimage,
-	"vcimage - loads an image to Display\n",
+	"loads an image to Display",
 	"vcimage addr\n"
 );
 
diff -Naur u-boot-2009.01/board/cm5200/cmd_cm5200.c u-boot/board/cm5200/cmd_cm5200.c
--- u-boot-2009.01/board/cm5200/cmd_cm5200.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/cm5200/cmd_cm5200.c	2009-02-26 14:03:58.000000000 +0100
@@ -435,7 +435,7 @@
 
 U_BOOT_CMD(
 	fkt,	4,	1,	cmd_fkt,
-	"fkt     - Function test routines\n",
+	"Function test routines",
 	"i2c\n"
 	"     - Test I2C communication\n"
 	"fkt led\n"
diff -Naur u-boot-2009.01/board/dave/common/pci.c u-boot/board/dave/common/pci.c
--- u-boot-2009.01/board/dave/common/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/dave/common/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -179,7 +179,7 @@
   /* System memory space */
   pci_set_region(hose->regions + 0,
 		 0x00000000, 0x00000000, 0x01000000,
-		 PCI_REGION_MEM | PCI_REGION_MEMORY);
+		 PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
   /* PCI Memory space */
   pci_set_region(hose->regions + 1,
diff -Naur u-boot-2009.01/board/davedenx/qong/config.mk u-boot/board/davedenx/qong/config.mk
--- u-boot-2009.01/board/davedenx/qong/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/davedenx/qong/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1 @@
+TEXT_BASE = 0x8ff00000
diff -Naur u-boot-2009.01/board/davedenx/qong/lowlevel_init.S u-boot/board/davedenx/qong/lowlevel_init.S
--- u-boot-2009.01/board/davedenx/qong/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/davedenx/qong/lowlevel_init.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2009, Emcraft Systems, Ilya Yanok <yanok@emcraft.com>
+ *
+ * Based on board/freescale/mx31ads/lowlevel_init.S
+ * by Guennadi Liakhovetski.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/arch/mx31-regs.h>
+
+.macro REG reg, val
+	ldr r2, =\reg
+	ldr r3, =\val
+	str r3, [r2]
+.endm
+
+.macro REG8 reg, val
+	ldr r2, =\reg
+	ldr r3, =\val
+	strb r3, [r2]
+.endm
+
+.macro DELAY loops
+	ldr r2, =\loops
+1:
+	subs	r2, r2, #1
+	nop
+	bcs 1b
+.endm
+
+/* RedBoot: To support 133MHz DDR */
+.macro init_drive_strength
+	/*
+	 * Disable maximum drive strength SDRAM/DDR lines by clearing DSE1 bits
+	 * in SW_PAD_CTL registers
+	 */
+
+	/* SDCLK */
+	ldr r1, =IOMUXC_SW_PAD_CTL(0x2b)
+	ldr r0, [r1, #0x6C]
+	bic r0, r0, #(1 << 12)
+	str r0, [r1, #0x6C]
+
+	/* CAS */
+	ldr r0, [r1, #0x70]
+	bic r0, r0, #(1 << 22)
+	str r0, [r1, #0x70]
+
+	/* RAS */
+	ldr r0, [r1, #0x74]
+	bic r0, r0, #(1 << 2)
+	str r0, [r1, #0x74]
+
+	/* CS2 (CSD0) */
+	ldr r0, [r1, #0x7C]
+	bic r0, r0, #(1 << 22)
+	str r0, [r1, #0x7C]
+
+	/* DQM3 */
+	ldr r0, [r1, #0x84]
+	bic r0, r0, #(1 << 22)
+	str r0, [r1, #0x84]
+
+	/* DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2DC) */
+	ldr r2, =22	/* (0x2E0 - 0x288) / 4 = 22 */
+pad_loop:
+	ldr r0, [r1, #0x88]
+	bic r0, r0, #(1 << 22)
+	bic r0, r0, #(1 << 12)
+	bic r0, r0, #(1 << 2)
+	str r0, [r1, #0x88]
+	add r1, r1, #4
+	subs r2, r2, #0x1
+	bne pad_loop
+.endm /* init_drive_strength */
+
+.globl lowlevel_init
+lowlevel_init:
+
+	init_drive_strength
+
+	/* Image Processing Unit: */
+	/* Too early to switch display on? */
+	/* Switch on Display Interface */
+	REG	IPU_CONF, IPU_CONF_DI_EN
+	/* Clock Control Module: */
+	REG	CCM_CCMR, 0x074B0BF5		/* Use CKIH, MCU PLL off */
+
+	DELAY 0x40000
+
+	REG	CCM_CCMR, 0x074B0BF5 | CCMR_MPE			/* MCU PLL on */
+	/* Switch to MCU PLL */
+	REG	CCM_CCMR, (0x074B0BF5 | CCMR_MPE) & ~CCMR_MDS
+
+	/* 399-133-66.5 */
+	ldr	r0, =CCM_BASE
+	ldr	r1, =0xFF871650
+	/* PDR0 */
+	str	r1, [r0, #0x4]
+	ldr	r1, MPCTL_PARAM_399
+	/* MPCTL */
+	str	r1, [r0, #0x10]
+
+	/* Set UPLL=240MHz, USB=60MHz */
+	ldr	r1, =0x49FCFE7F
+	/* PDR1 */
+	str	r1, [r0, #0x8]
+	ldr	r1, UPCTL_PARAM_240
+	/* UPCTL */
+	str	r1, [r0, #0x14]
+	/* default CLKO to 1/8 of the ARM core */
+	mov	r1, #0x00000208
+	/* COSR */
+	str	r1, [r0, #0x1c]
+
+	/* Default: 1, 4, 12, 1 */
+	REG	CCM_SPCTL, PLL_PD(1) | PLL_MFD(4) | PLL_MFI(12) | PLL_MFN(1)
+
+	/* B8xxxxxx - NAND, 8xxxxxxx - CSD0 RAM */
+	REG	0xB8001010, 0x00000004
+	REG	0xB8001004, ((3 << 21) | /* tXP */	\
+			     (0 << 20) | /* tWTR */	\
+			     (2 << 18) | /* tRP */	\
+			     (1 << 16) | /* tMRD */	\
+			     (0 << 15) | /* tWR */	\
+			     (5 << 12) | /* tRAS */	\
+			     (1 << 10) | /* tRRD */	\
+			     (3 << 8)  | /* tCAS */	\
+			     (2 << 4)  | /* tRCD */	\
+			     (7 << 0)    /* tRC */ )
+	REG	0xB8001000, 0x92100000
+	REG	0x80000f00, 0x12344321
+	REG	0xB8001000, 0xa2100000
+	REG	0x80000000, 0x12344321
+	REG	0x80000000, 0x12344321
+	REG	0xB8001000, 0xb2100000
+	REG8	0x80000033, 0xda
+	REG8	0x81000000, 0xff
+	REG	0xB8001000, ((1 << 31) |				\
+			     (0 << 28) |				\
+			     (0 << 27) |				\
+			     (3 << 24) | /* 14 rows */			\
+			     (2 << 20) | /* 10 cols */			\
+			     (2 << 16) |				\
+			     (4 << 13) | /* 3.91us (64ms/16384) */	\
+			     (0 << 10) |				\
+			     (0 << 8)  |				\
+			     (1 << 7)  |				\
+			     (0 << 0))
+	REG	0x80000000, 0xDEADBEEF
+	REG	0xB8001010, 0x0000000c
+
+	mov	pc, lr
+
+MPCTL_PARAM_399:
+	.word (((1 - 1) << 26) + ((52 - 1) << 16) + (7 << 10) + (35 << 0))
+UPCTL_PARAM_240:
+	.word (((2 - 1) << 26) + ((13 - 1) << 16) + (9 << 10) + (3  << 0))
diff -Naur u-boot-2009.01/board/davedenx/qong/Makefile u-boot/board/davedenx/qong/Makefile
--- u-boot-2009.01/board/davedenx/qong/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/davedenx/qong/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,53 @@
+#
+# (C) Copyright 2009
+# Ilya Yanok, Emcraft Systems Ltd, <yanok@emcraft.com>
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= qong.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/davedenx/qong/qong.c u-boot/board/davedenx/qong/qong.c
--- u-boot-2009.01/board/davedenx/qong/qong.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/davedenx/qong/qong.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,166 @@
+/*
+ *
+ * (c) 2009 Emcraft Systems, Ilya Yanok <yanok@emcraft.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/arch/mx31.h>
+#include <asm/arch/mx31-regs.h>
+#include "qong_fpga.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = get_ram_size((volatile void *)PHYS_SDRAM_1,
+			PHYS_SDRAM_1_SIZE);
+
+	return 0;
+}
+
+int board_init (void)
+{
+	/* Chip selects */
+	/* CS0: Nor Flash #0 - it must be init'ed when executing from DDR */
+	/* Assumptions: HCLK = 133 MHz, tACC = 130ns */
+	__REG(CSCR_U(0)) = ((0 << 31)	| /* SP */
+						(0 << 30)	| /* WP */
+						(0 << 28)	| /* BCD */
+						(0 << 24)	| /* BCS */
+						(0 << 22)	| /* PSZ */
+						(0 << 21)	| /* PME */
+						(0 << 20)	| /* SYNC */
+						(0 << 16)	| /* DOL */
+						(3 << 14)	| /* CNC */
+						(21 << 8)	| /* WSC */
+						(0 << 7)	| /* EW */
+						(0 << 4)	| /* WWS */
+						(6 << 0)	  /* EDC */
+					   );
+
+	__REG(CSCR_L(0)) = ((2 << 28)	| /* OEA */
+						(1 << 24)	| /* OEN */
+						(3 << 20)	| /* EBWA */
+						(3 << 16)	| /* EBWN */
+						(1 << 12)	| /* CSA */
+						(1 << 11)	| /* EBC */
+						(5 << 8)	| /* DSZ */
+						(1 << 4)	| /* CSN */
+						(0 << 3)	| /* PSR */
+						(0 << 2)	| /* CRE */
+						(0 << 1)	| /* WRAP */
+						(1 << 0)	  /* CSEN */
+					   );
+
+	__REG(CSCR_A(0)) = ((2 << 28)	| /* EBRA */
+						(1 << 24)	| /* EBRN */
+						(2 << 20)	| /* RWA */
+						(2 << 16)	| /* RWN */
+						(0 << 15)	| /* MUM */
+						(0 << 13)	| /* LAH */
+						(2 << 10)	| /* LBN */
+						(0 << 8)	| /* LBA */
+						(0 << 6)	| /* DWW */
+						(0 << 4)	| /* DCT */
+						(0 << 3)	| /* WWU */
+						(0 << 2)	| /* AGE */
+						(0 << 1)	| /* CNC2 */
+						(0 << 0)	  /* FCE */
+					   );
+
+#ifdef CONFIG_QONG_FPGA
+	/* CS1: FPGA/Network Controller/GPIO */
+	/* 16-bit, no DTACK */
+	__REG(CSCR_U(1)) = 0x00000A01;
+	__REG(CSCR_L(1)) = 0x20040501;
+	__REG(CSCR_A(1)) = 0x04020C00;
+
+	/* setup pins for FPGA */
+	mx31_gpio_mux(IOMUX_MODE(0x76, MUX_CTL_GPIO));
+	mx31_gpio_mux(IOMUX_MODE(0x7e, MUX_CTL_GPIO));
+	mx31_gpio_mux(IOMUX_MODE(0x91, MUX_CTL_OUT_FUNC | MUX_CTL_IN_GPIO));
+	mx31_gpio_mux(IOMUX_MODE(0x92, MUX_CTL_GPIO));
+	mx31_gpio_mux(IOMUX_MODE(0x93, MUX_CTL_GPIO));
+#endif
+
+	/* setup pins for UART1 */
+	mx31_gpio_mux(MUX_RXD1__UART1_RXD_MUX);
+	mx31_gpio_mux(MUX_TXD1__UART1_TXD_MUX);
+	mx31_gpio_mux(MUX_RTS1__UART1_RTS_B);
+	mx31_gpio_mux(MUX_CTS1__UART1_CTS_B);
+
+	/* board id for linux */
+	gd->bd->bi_arch_number = MACH_TYPE_QONG;
+	gd->bd->bi_boot_params = (0x80000100);	/* adress of boot parameters */
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf("Board: DAVE/DENX QongEVB-LITE\n");
+	return 0;
+}
+
+int misc_init_r (void)
+{
+#ifdef CONFIG_QONG_FPGA
+	u32 tmp;
+
+	/* FPGA reset */
+	/* rstn = 0 */
+	tmp = __REG(GPIO2_BASE + GPIO_DR);
+	tmp &= (~(1 << QONG_FPGA_RST_PIN));
+	__REG(GPIO2_BASE + GPIO_DR) = tmp;
+	/* set the GPIO as output */
+	tmp = __REG(GPIO2_BASE + GPIO_GDIR);
+	tmp |= (1 << QONG_FPGA_RST_PIN);
+	__REG(GPIO2_BASE + GPIO_GDIR) = tmp;
+	/* wait */
+	udelay(30);
+	/* rstn = 1 */
+	tmp = __REG(GPIO2_BASE + GPIO_DR);
+	tmp |= (1 << QONG_FPGA_RST_PIN);
+	__REG(GPIO2_BASE + GPIO_DR) = tmp;
+	/* set interrupt pin as input */
+	__REG(GPIO2_BASE + GPIO_GDIR) = tmp | (1 << QONG_FPGA_IRQ_PIN);
+	/* wait while the FPGA starts */
+	udelay(300);
+
+	tmp = *(volatile u32*)QONG_FPGA_CTRL_VERSION;
+	printf("FPGA:  ");
+	printf("version register = %u.%u.%u\n",
+		(tmp & 0xF000) >> 12, (tmp & 0x0F00) >> 8, tmp & 0x00FF);
+#endif
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_QONG_FPGA) && defined(CONFIG_DNET)
+	return dnet_eth_initialize(0, (void *)CONFIG_DNET_BASE, -1);
+#else
+	return 0;
+#endif
+}
diff -Naur u-boot-2009.01/board/davedenx/qong/qong_fpga.h u-boot/board/davedenx/qong/qong_fpga.h
--- u-boot-2009.01/board/davedenx/qong/qong_fpga.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/davedenx/qong/qong_fpga.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,40 @@
+/*
+ *
+ * (c) 2009 Emcraft Systems, Ilya Yanok <yanok@emcraft.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef QONG_FPGA_H
+#define QONG_FPGA_H
+
+#ifdef CONFIG_QONG_FPGA
+#define QONG_FPGA_CTRL_BASE		CONFIG_FPGA_BASE
+#define QONG_FPGA_CTRL_VERSION		(QONG_FPGA_CTRL_BASE + 0x00000000)
+#define QONG_FPGA_PERIPH_SIZE		(1 << 24)
+
+#define	QONG_FPGA_TCK_PIN		26
+#define	QONG_FPGA_TMS_PIN		25
+#define	QONG_FPGA_TDI_PIN		8
+#define	QONG_FPGA_TDO_PIN		7
+#define	QONG_FPGA_RST_PIN		16
+#define	QONG_FPGA_IRQ_PIN		8
+#endif
+
+#endif /* QONG_FPGA_H */
diff -Naur u-boot-2009.01/board/davedenx/qong/u-boot.lds u-boot/board/davedenx/qong/u-boot.lds
--- u-boot-2009.01/board/davedenx/qong/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/davedenx/qong/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2009
+ * Ilya Yanok, Emcraft Systems Ltd, <yanok@emcraft.com>
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text :
+	{
+		cpu/arm1136/start.o	(.text)
+		*(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/davinci/common/psc.c u-boot/board/davinci/common/psc.c
--- u-boot-2009.01/board/davinci/common/psc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/davinci/common/psc.c	2009-02-26 14:03:58.000000000 +0100
@@ -26,6 +26,14 @@
 #include <common.h>
 #include <asm/arch/hardware.h>
 
+#define PINMUX0_EMACEN (1 << 31)
+#define PINMUX0_AECS5  (1 << 11)
+#define PINMUX0_AECS4  (1 << 10)
+
+#define PINMUX1_I2C    (1 <<  7)
+#define PINMUX1_UART1  (1 <<  1)
+#define PINMUX1_UART0  (1 <<  0)
+
 /*
  * The DM6446 includes two separate power domains: "Always On" and "DSP". The
  * "Always On" power domain is always on when the chip is on. The "Always On"
@@ -115,3 +123,60 @@
 	REG(PSC_GBLCTL) &= ~0x1f;
 }
 #endif /* CONFIG_SYS_USE_DSPLINK */
+
+void davinci_enable_uart0(void)
+{
+	lpsc_on(DAVINCI_LPSC_UART0);
+
+	/* Bringup UART0 out of reset */
+	REG(UART0_PWREMU_MGMT) = 0x0000e003;
+
+	/* Enable UART0 MUX lines */
+	REG(PINMUX1) |= PINMUX1_UART0;
+}
+
+#ifdef CONFIG_DRIVER_TI_EMAC
+void davinci_enable_emac(void)
+{
+	lpsc_on(DAVINCI_LPSC_EMAC);
+	lpsc_on(DAVINCI_LPSC_EMAC_WRAPPER);
+	lpsc_on(DAVINCI_LPSC_MDIO);
+
+	/* Enable GIO3.3V cells used for EMAC */
+	REG(VDD3P3V_PWDN) = 0;
+
+	/* Enable EMAC. */
+	REG(PINMUX0) |= PINMUX0_EMACEN;
+}
+#endif
+
+void davinci_enable_i2c(void)
+{
+	lpsc_on(DAVINCI_LPSC_I2C);
+
+	/* Enable I2C pin Mux */
+	REG(PINMUX1) |= PINMUX1_I2C;
+}
+
+void davinci_errata_workarounds(void)
+{
+	/*
+	 * Workaround for TMS320DM6446 errata 1.3.22:
+	 *   PSC: PTSTAT Register Does Not Clear After Warm/Maximum Reset
+	 *   Revision(s) Affected: 1.3 and earlier
+	 */
+	REG(PSC_SILVER_BULLET) = 0;
+
+	/*
+	 * Set the PR_OLD_COUNT bits in the Bus Burst Priority Register (PBBPR)
+	 * as suggested in TMS320DM6446 errata 2.1.2:
+	 *
+	 * On DM6446 Silicon Revision 2.1 and earlier, under certain conditions
+	 * low priority modules can occupy the bus and prevent high priority
+	 * modules like the VPSS from getting the required DDR2 throughput.
+	 * A hex value of 0x20 should provide a good ARM (cache enabled)
+	 * performance and still allow good utilization by the VPSS or other
+	 * modules.
+	 */
+	REG(VBPR) = 0x20;
+}
diff -Naur u-boot-2009.01/board/davinci/common/psc.h u-boot/board/davinci/common/psc.h
--- u-boot-2009.01/board/davinci/common/psc.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/davinci/common/psc.h	2009-02-26 14:03:58.000000000 +0100
@@ -24,5 +24,9 @@
 
 void lpsc_on(unsigned int id);
 void dsp_on(void);
+void davinci_enable_uart0(void);
+void davinci_enable_emac(void);
+void davinci_enable_i2c(void);
+void davinci_errata_workarounds(void);
 
 #endif /* __PSC_H */
diff -Naur u-boot-2009.01/board/davinci/dvevm/dvevm.c u-boot/board/davinci/dvevm/dvevm.c
--- u-boot-2009.01/board/davinci/dvevm/dvevm.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/davinci/dvevm/dvevm.c	2009-02-26 14:03:58.000000000 +0100
@@ -27,7 +27,6 @@
 #include <common.h>
 #include <i2c.h>
 #include <asm/arch/hardware.h>
-#include <asm/arch/emac_defs.h>
 #include "../common/psc.h"
 #include "../common/misc.h"
 
@@ -41,41 +40,26 @@
 	/* address of boot parameters */
 	gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
 
-	/* Workaround for TMS320DM6446 errata 1.3.22 */
-	REG(PSC_SILVER_BULLET) = 0;
+	/* Configure AEMIF pins (although this should be configured at boot time
+	 * with pull-up/pull-down resistors) */
+	REG(PINMUX0) = 0x00000c1f;
+
+	davinci_errata_workarounds();
 
 	/* Power on required peripherals */
-	lpsc_on(DAVINCI_LPSC_EMAC);
-	lpsc_on(DAVINCI_LPSC_EMAC_WRAPPER);
-	lpsc_on(DAVINCI_LPSC_MDIO);
-	lpsc_on(DAVINCI_LPSC_I2C);
-	lpsc_on(DAVINCI_LPSC_UART0);
-	lpsc_on(DAVINCI_LPSC_TIMER1);
 	lpsc_on(DAVINCI_LPSC_GPIO);
+	lpsc_on(DAVINCI_LPSC_USB);
 
 #if !defined(CONFIG_SYS_USE_DSPLINK)
 	/* Powerup the DSP */
 	dsp_on();
 #endif /* CONFIG_SYS_USE_DSPLINK */
 
-	/* Bringup UART0 out of reset */
-	REG(UART0_PWREMU_MGMT) = 0x0000e003;
-
-	/* Enable GIO3.3V cells used for EMAC */
-	REG(VDD3P3V_PWDN) = 0;
-
-	/* Enable UART0 MUX lines */
-	REG(PINMUX1) |= 1;
-
-	/* Enable EMAC and AEMIF pins */
-	REG(PINMUX0) = 0x80000c1f;
-
-	/* Enable I2C pin Mux */
-	REG(PINMUX1) |= (1 << 7);
-
-	/* Set the Bus Priority Register to appropriate value */
-	REG(VBPR) = 0x20;
+	davinci_enable_uart0();
+	davinci_enable_emac();
+	davinci_enable_i2c();
 
+	lpsc_on(DAVINCI_LPSC_TIMER1);
 	timer_init();
 
 	return(0);
@@ -101,3 +85,25 @@
 
 	return(0);
 }
+
+#ifdef CONFIG_USB_DAVINCI
+
+/* IO Expander I2C address and USB VBUS enable mask */
+#define IOEXP_I2C_ADDR 0x3A
+#define IOEXP_VBUSEN_MASK 1
+
+/*
+ * This function enables USB VBUS by writting to IO expander using I2C.
+ * Note that the I2C is already initialized at this stage. This
+ * function is used by davinci specific USB wrapper code.
+ */
+void enable_vbus(void)
+{
+	uchar data;  /* IO Expander data to enable VBUS */
+
+	/* Write to IO expander to enable VBUS */
+	i2c_read(IOEXP_I2C_ADDR, 0, 0, &data, 1);
+	data &= ~IOEXP_VBUSEN_MASK;
+	i2c_write(IOEXP_I2C_ADDR, 0, 0, &data, 1);
+}
+#endif
diff -Naur u-boot-2009.01/board/davinci/schmoogie/schmoogie.c u-boot/board/davinci/schmoogie/schmoogie.c
--- u-boot-2009.01/board/davinci/schmoogie/schmoogie.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/davinci/schmoogie/schmoogie.c	2009-02-26 14:03:58.000000000 +0100
@@ -27,7 +27,6 @@
 #include <common.h>
 #include <i2c.h>
 #include <asm/arch/hardware.h>
-#include <asm/arch/emac_defs.h>
 #include "../common/psc.h"
 #include "../common/misc.h"
 
@@ -41,16 +40,13 @@
 	/* address of boot parameters */
 	gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
 
-	/* Workaround for TMS320DM6446 errata 1.3.22 */
-	REG(PSC_SILVER_BULLET) = 0;
+	/* Configure AEMIF pins (although this should be configured at boot time
+	 * with pull-up/pull-down resistors) */
+	REG(PINMUX0) = 0x00000c1f;
+
+	davinci_errata_workarounds();
 
 	/* Power on required peripherals */
-	lpsc_on(DAVINCI_LPSC_EMAC);
-	lpsc_on(DAVINCI_LPSC_EMAC_WRAPPER);
-	lpsc_on(DAVINCI_LPSC_MDIO);
-	lpsc_on(DAVINCI_LPSC_I2C);
-	lpsc_on(DAVINCI_LPSC_UART0);
-	lpsc_on(DAVINCI_LPSC_TIMER1);
 	lpsc_on(DAVINCI_LPSC_GPIO);
 
 #if !defined(CONFIG_SYS_USE_DSPLINK)
@@ -58,24 +54,11 @@
 	dsp_on();
 #endif /* CONFIG_SYS_USE_DSPLINK */
 
-	/* Bringup UART0 out of reset */
-	REG(UART0_PWREMU_MGMT) = 0x0000e003;
-
-	/* Enable GIO3.3V cells used for EMAC */
-	REG(VDD3P3V_PWDN) = 0;
-
-	/* Enable UART0 MUX lines */
-	REG(PINMUX1) |= 1;
-
-	/* Enable EMAC and AEMIF pins */
-	REG(PINMUX0) = 0x80000c1f;
-
-	/* Enable I2C pin Mux */
-	REG(PINMUX1) |= (1 << 7);
-
-	/* Set the Bus Priority Register to appropriate value */
-	REG(VBPR) = 0x20;
+	davinci_enable_uart0();
+	davinci_enable_emac();
+	davinci_enable_i2c();
 
+	lpsc_on(DAVINCI_LPSC_TIMER1);
 	timer_init();
 
 	return(0);
@@ -87,7 +70,7 @@
 	int		i = 0;
 
 	/* Set serial number from UID chip */
-	u_int8_t	crc_tbl[256] = {
+	const u_int8_t	crc_tbl[256] = {
 			0x00, 0x5e, 0xbc, 0xe2, 0x61, 0x3f, 0xdd, 0x83,
 			0xc2, 0x9c, 0x7e, 0x20, 0xa3, 0xfd, 0x1f, 0x41,
 			0x9d, 0xc3, 0x21, 0x7f, 0xfc, 0xa2, 0x40, 0x1e,
diff -Naur u-boot-2009.01/board/davinci/sffsdr/sffsdr.c u-boot/board/davinci/sffsdr/sffsdr.c
--- u-boot-2009.01/board/davinci/sffsdr/sffsdr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/davinci/sffsdr/sffsdr.c	2009-02-26 14:03:58.000000000 +0100
@@ -30,7 +30,6 @@
 #include <common.h>
 #include <i2c.h>
 #include <asm/arch/hardware.h>
-#include <asm/arch/emac_defs.h>
 #include "../common/psc.h"
 #include "../common/misc.h"
 
@@ -51,16 +50,9 @@
 	/* address of boot parameters */
 	gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
 
-	/* Workaround for TMS320DM6446 errata 1.3.22 */
-	REG(PSC_SILVER_BULLET) = 0;
+	davinci_errata_workarounds();
 
 	/* Power on required peripherals */
-	lpsc_on(DAVINCI_LPSC_EMAC);
-	lpsc_on(DAVINCI_LPSC_EMAC_WRAPPER);
-	lpsc_on(DAVINCI_LPSC_MDIO);
-	lpsc_on(DAVINCI_LPSC_I2C);
-	lpsc_on(DAVINCI_LPSC_UART0);
-	lpsc_on(DAVINCI_LPSC_TIMER1);
 	lpsc_on(DAVINCI_LPSC_GPIO);
 
 #if !defined(CONFIG_SYS_USE_DSPLINK)
@@ -68,24 +60,11 @@
 	dsp_on();
 #endif /* CONFIG_SYS_USE_DSPLINK */
 
-	/* Bringup UART0 out of reset */
-	REG(UART0_PWREMU_MGMT) = 0x0000e003;
-
-	/* Enable GIO3.3V cells used for EMAC */
-	REG(VDD3P3V_PWDN) = 0;
-
-	/* Enable UART0 MUX lines */
-	REG(PINMUX1) |= 1;
-
-	/* Enable EMAC and AEMIF pins */
-	REG(PINMUX0) = 0x80000c1f;
-
-	/* Enable I2C pin Mux */
-	REG(PINMUX1) |= (1 << 7);
-
-	/* Set the Bus Priority Register to appropriate value */
-	REG(VBPR) = 0x20;
+	davinci_enable_uart0();
+	davinci_enable_emac();
+	davinci_enable_i2c();
 
+	lpsc_on(DAVINCI_LPSC_TIMER1);
 	timer_init();
 
 	return(0);
diff -Naur u-boot-2009.01/board/davinci/sonata/sonata.c u-boot/board/davinci/sonata/sonata.c
--- u-boot-2009.01/board/davinci/sonata/sonata.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/davinci/sonata/sonata.c	2009-02-26 14:03:58.000000000 +0100
@@ -26,7 +26,6 @@
 
 #include <common.h>
 #include <asm/arch/hardware.h>
-#include <asm/arch/emac_defs.h>
 #include "../common/psc.h"
 #include "../common/misc.h"
 
@@ -40,16 +39,13 @@
 	/* address of boot parameters */
 	gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
 
-	/* Workaround for TMS320DM6446 errata 1.3.22 */
-	REG(PSC_SILVER_BULLET) = 0;
+	/* Configure AEMIF pins (although this should be configured at boot time
+	 * with pull-up/pull-down resistors) */
+	REG(PINMUX0) = 0x00000c1f;
+
+	davinci_errata_workarounds();
 
 	/* Power on required peripherals */
-	lpsc_on(DAVINCI_LPSC_EMAC);
-	lpsc_on(DAVINCI_LPSC_EMAC_WRAPPER);
-	lpsc_on(DAVINCI_LPSC_MDIO);
-	lpsc_on(DAVINCI_LPSC_I2C);
-	lpsc_on(DAVINCI_LPSC_UART0);
-	lpsc_on(DAVINCI_LPSC_TIMER1);
 	lpsc_on(DAVINCI_LPSC_GPIO);
 
 #if !defined(CONFIG_SYS_USE_DSPLINK)
@@ -57,24 +53,11 @@
 	dsp_on();
 #endif /* CONFIG_SYS_USE_DSPLINK */
 
-	/* Bringup UART0 out of reset */
-	REG(UART0_PWREMU_MGMT) = 0x0000e003;
-
-	/* Enable GIO3.3V cells used for EMAC */
-	REG(VDD3P3V_PWDN) = 0;
-
-	/* Enable UART0 MUX lines */
-	REG(PINMUX1) |= 1;
-
-	/* Enable EMAC and AEMIF pins */
-	REG(PINMUX0) = 0x80000c1f;
-
-	/* Enable I2C pin Mux */
-	REG(PINMUX1) |= (1 << 7);
-
-	/* Set the Bus Priority Register to appropriate value */
-	REG(VBPR) = 0x20;
+	davinci_enable_uart0();
+	davinci_enable_emac();
+	davinci_enable_i2c();
 
+	lpsc_on(DAVINCI_LPSC_TIMER1);
 	timer_init();
 
 	return(0);
diff -Naur u-boot-2009.01/board/delta/delta.c u-boot/board/delta/delta.c
--- u-boot-2009.01/board/delta/delta.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/delta/delta.c	2009-02-26 14:03:58.000000000 +0100
@@ -259,7 +259,7 @@
 
 U_BOOT_CMD(
 	   kbd,	1,	1,	do_kbd,
-	   "kbd     - read keyboard status\n",
+	   "read keyboard status",
 	   NULL
 );
 
diff -Naur u-boot-2009.01/board/delta/lowlevel_init.S u-boot/board/delta/lowlevel_init.S
--- u-boot-2009.01/board/delta/lowlevel_init.S	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/delta/lowlevel_init.S	2009-02-26 14:03:58.000000000 +0100
@@ -74,7 +74,7 @@
 	/* 3. wait nop power up waiting period (200ms)
 	 * optimization: Steps 4+6 can be done during this
 	 */
-	wait #300
+	wait #0x300
 
 	/* 4. Perform an initial Rcomp-calibration cycle */
 	ldr		r0, =RCOMP
diff -Naur u-boot-2009.01/board/eltec/bab7xx/pci.c u-boot/board/eltec/bab7xx/pci.c
--- u-boot-2009.01/board/eltec/bab7xx/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/eltec/bab7xx/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -50,7 +50,7 @@
     * so we need (CONFIG_SYS_PCI_MEMORY_SIZE-1)
     */
 	CONFIG_SYS_PCI_MEMORY_SIZE-1,
-	PCI_REGION_MEM | PCI_REGION_MEMORY);
+	PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
     /* PCI memory space */
     pci_set_region(hose->regions + 1,
diff -Naur u-boot-2009.01/board/eltec/elppc/pci.c u-boot/board/eltec/elppc/pci.c
--- u-boot-2009.01/board/eltec/elppc/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/eltec/elppc/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -45,7 +45,7 @@
 	CONFIG_SYS_PCI_MEMORY_BUS,
 	CONFIG_SYS_PCI_MEMORY_PHYS,
 	CONFIG_SYS_PCI_MEMORY_SIZE,
-	PCI_REGION_MEM | PCI_REGION_MEMORY);
+	PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
     /* PCI memory space */
     pci_set_region(hose->regions + 1,
diff -Naur u-boot-2009.01/board/emk/common/flash.c u-boot/board/emk/common/flash.c
--- u-boot-2009.01/board/emk/common/flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/emk/common/flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -82,7 +82,7 @@
 static ulong flash_get_size(FPWV *addr, flash_info_t *info);
 static void flash_reset(flash_info_t *info);
 static int write_word_amd(flash_info_t *info, FPWV *dest, FPW data);
-static flash_info_t *flash_get_info(ulong base);
+flash_info_t *flash_get_info(ulong base);
 
 /*-----------------------------------------------------------------------
  * flash_init()
@@ -142,7 +142,7 @@
 /*-----------------------------------------------------------------------
  */
 
-static flash_info_t *flash_get_info(ulong base)
+flash_info_t *flash_get_info(ulong base)
 {
 	int i;
 	flash_info_t * info;
diff -Naur u-boot-2009.01/board/eNET/config.mk u-boot/board/eNET/config.mk
--- u-boot-2009.01/board/eNET/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/eNET/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# (C) Copyright 2002
+# Daniel Engstrm, Omicron Ceti AB, daniel@omicron.se.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+TEXT_BASE = 0x38040000
diff -Naur u-boot-2009.01/board/eNET/eNET.c u-boot/board/eNET/eNET.c
--- u-boot-2009.01/board/eNET/eNET.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/eNET/eNET.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,167 @@
+/*
+ * (C) Copyright 2008
+ * Graeme Russ, graeme.russ@gmail.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/ic/sc520.h>
+
+#ifdef CONFIG_HW_WATCHDOG
+#include <watchdog.h>
+#endif
+
+#include "hardware.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#undef SC520_CDP_DEBUG
+
+#ifdef	SC520_CDP_DEBUG
+#define	PRINTF(fmt,args...)	printf (fmt ,##args)
+#else
+#define PRINTF(fmt,args...)
+#endif
+
+unsigned long monitor_flash_len = CONFIG_SYS_MONITOR_LEN;
+
+void init_sc520_enet (void)
+{
+	/* Set CPU Speed to 100MHz */
+	write_mmcr_byte(SC520_CPUCTL, 1);
+	gd->cpu_clk = 100000000;
+
+	/* wait at least one millisecond */
+	asm("movl	$0x2000,%%ecx\n"
+	    "wait_loop:	pushl %%ecx\n"
+	    "popl	%%ecx\n"
+	    "loop wait_loop\n": : : "ecx");
+
+	/* turn on the SDRAM write buffer */
+	write_mmcr_byte(SC520_DBCTL, 0x11);
+
+	/* turn on the cache and disable write through */
+	asm("movl	%%cr0, %%eax\n"
+	    "andl	$0x9fffffff, %%eax\n"
+	    "movl	%%eax, %%cr0\n"  : : : "eax");
+}
+
+/*
+ * Miscellaneous platform dependent initializations
+ */
+int board_init(void)
+{
+	init_sc520_enet();
+
+	write_mmcr_byte(SC520_GPCSRT, 0x01);		/* GP Chip Select Recovery Time */
+	write_mmcr_byte(SC520_GPCSPW, 0x07);		/* GP Chip Select Pulse Width */
+	write_mmcr_byte(SC520_GPCSOFF, 0x00);		/* GP Chip Select Offset */
+	write_mmcr_byte(SC520_GPRDW, 0x05);		/* GP Read pulse width */
+	write_mmcr_byte(SC520_GPRDOFF, 0x01);		/* GP Read offset */
+	write_mmcr_byte(SC520_GPWRW, 0x05);		/* GP Write pulse width */
+	write_mmcr_byte(SC520_GPWROFF, 0x01);		/* GP Write offset */
+
+	write_mmcr_word(SC520_PIODATA15_0, 0x0630);	/* PIO15_PIO0 Data */
+	write_mmcr_word(SC520_PIODATA31_16, 0x2000);	/* PIO31_PIO16 Data */
+	write_mmcr_word(SC520_PIODIR31_16, 0x2000);	/* GPIO Direction */
+	write_mmcr_word(SC520_PIODIR15_0, 0x87b5);	/* GPIO Direction */
+	write_mmcr_word(SC520_PIOPFS31_16, 0x0dfe);	/* GPIO pin function 31-16 reg */
+	write_mmcr_word(SC520_PIOPFS15_0, 0x200a);	/* GPIO pin function 15-0 reg */
+	write_mmcr_byte(SC520_CSPFS, 0x00f8);		/* Chip Select Pin Function Select */
+
+	write_mmcr_long(SC520_PAR2, 0x200713f8);	/* Uart A (GPCS0, 0x013f8, 8 Bytes) */
+	write_mmcr_long(SC520_PAR3, 0x2c0712f8);	/* Uart B (GPCS3, 0x012f8, 8 Bytes) */
+	write_mmcr_long(SC520_PAR4, 0x300711f8);	/* Uart C (GPCS4, 0x011f8, 8 Bytes) */
+	write_mmcr_long(SC520_PAR5, 0x340710f8);	/* Uart D (GPCS5, 0x010f8, 8 Bytes) */
+	write_mmcr_long(SC520_PAR6, 0xe3ffc000);	/* SDRAM (0x00000000, 128MB) */
+	write_mmcr_long(SC520_PAR7, 0xaa3fd000);	/* StrataFlash (ROMCS1, 0x10000000, 16MB) */
+	write_mmcr_long(SC520_PAR8, 0xca3fd100);	/* StrataFlash (ROMCS2, 0x11000000, 16MB) */
+	write_mmcr_long(SC520_PAR9, 0x4203d900);	/* SRAM (GPCS0, 0x19000000, 1MB) */
+	write_mmcr_long(SC520_PAR10, 0x4e03d910);	/* SRAM (GPCS3, 0x19100000, 1MB) */
+	write_mmcr_long(SC520_PAR11, 0x50018100);	/* DP-RAM (GPCS4, 0x18100000, 4kB) */
+	write_mmcr_long(SC520_PAR12, 0x54020000);	/* CFLASH1 (0x200000000, 4kB) */
+	write_mmcr_long(SC520_PAR13, 0x5c020001);	/* CFLASH2 (0x200010000, 4kB) */
+/*	write_mmcr_long(SC520_PAR14, 0x8bfff800); */	/* BOOTCS at  0x18000000 */
+/*	write_mmcr_long(SC520_PAR15, 0x38201000); */	/* LEDs etc (GPCS6, 0x1000, 20 Bytes */
+
+	/* Disable Watchdog */
+	write_mmcr_word(0x0cb0, 0x3333);
+	write_mmcr_word(0x0cb0, 0xcccc);
+	write_mmcr_word(0x0cb0, 0x0000);
+
+	/* Chip Select Configuration */
+	write_mmcr_word(SC520_BOOTCSCTL, 0x0033);
+	write_mmcr_word(SC520_ROMCS1CTL, 0x0615);
+	write_mmcr_word(SC520_ROMCS2CTL, 0x0615);
+
+	write_mmcr_byte(SC520_ADDDECCTL, 0x02);
+	write_mmcr_byte(SC520_UART1CTL, 0x07);
+	write_mmcr_byte(SC520_SYSARBCTL,0x06);
+	write_mmcr_word(SC520_SYSARBMENB, 0x0003);
+
+	/* Crystal is 33.000MHz */
+	gd->bus_clk = 33000000;
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	init_sc520_dram();
+	return 0;
+}
+
+void show_boot_progress(int val)
+{
+	uchar led_mask;
+
+	led_mask = 0x00;
+
+	if (val < 0)
+		led_mask |= LED_ERR_BITMASK;
+
+	led_mask |= (uchar)(val & 0x001f);
+	outb(led_mask, LED_LATCH_ADDRESS);
+}
+
+
+int last_stage_init(void)
+{
+	int minor;
+	int major;
+
+	major = minor = 0;
+
+	printf("Serck Controls eNET\n");
+
+	return 0;
+}
+
+ulong board_flash_get_legacy (ulong base, int banknum, flash_info_t * info)
+{
+	if (banknum == 0) {	/* non-CFI boot flash */
+		info->portwidth = FLASH_CFI_8BIT;
+		info->chipwidth = FLASH_CFI_BY8;
+		info->interface = FLASH_CFI_X8;
+		return 1;
+	} else
+		return 0;
+}
diff -Naur u-boot-2009.01/board/eNET/eNET_start16.S u-boot/board/eNET/eNET_start16.S
--- u-boot-2009.01/board/eNET/eNET_start16.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/eNET/eNET_start16.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,90 @@
+/*
+ * (C) Copyright 2008
+ * Graeme Russ, graeme.russ@gmail.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * 16bit initialization code.
+ * This code have to map the area of the boot flash
+ * that is used by U-boot to its final destination.
+ */
+
+/* #include <asm/ic/sc520_defs.h> */
+
+#include "hardware.h"
+
+.text
+.section .start16, "ax"
+.code16
+.globl board_init16
+board_init16:
+	/* Alias MMCR to 0xdf000 */
+	movw	$0xfffc, %dx
+	movl	$0x800df0cb, %eax
+	outl	%eax, %dx
+
+	/* Set ds to point to MMCR alias */
+	movw	$0xdf00, %ax
+	movw	%ax, %ds
+
+	/* Map PAR for Boot Flash (BOOTCS, 512kB @ 0x380000000) */
+	movl    $0x00c0, %edi		/* SC520_PAR14 */
+	movl	$0x8bfff800, %eax	/* TODO: Check this */
+	movl	%eax, (%di)
+
+	/* Map PAR for LED, Hex Switches (GPCS6, 20 Bytes @ 0x1000) */
+	movl    $0x00c4, %edi		/* SC520_PAR15 */
+	movl	$0x38201000, %eax
+	movl	%eax, (%di)
+
+	/* Disable SDRAM write buffer */
+	movw    $0x0040, %di		/* SC520_DBCTL */
+	xorw    %ax, %ax
+	movb    %al, (%di)
+
+	/* Disabe MMCR alias */
+	movw	$0xfffc, %dx
+	movl	$0x000000cb, %eax
+	outl	%eax, %dx
+
+	/* the return address is stored in bp */
+	jmp	*%bp
+
+.section .bios, "ax"
+.code16
+.globl realmode_reset
+realmode_reset:
+	/* Alias MMCR to 0xdf000 */
+	movw	$0xfffc, %dx
+	movl	$0x800df0cb, %eax
+	outl	%eax, %dx
+
+	/* Set ds to point to MMCR alias */
+	movw	$0xdf00, %ax
+	movw	%ax, %ds
+
+	/* issue software reset thorugh MMCR */
+	movl    $0xd72, %edi
+	movb	$0x01, %al
+	movb	%al, (%di)
+
+1:	hlt
+	jmp	1
diff -Naur u-boot-2009.01/board/eNET/eNET_start.S u-boot/board/eNET/eNET_start.S
--- u-boot-2009.01/board/eNET/eNET_start.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/eNET/eNET_start.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,50 @@
+/*
+ * (C) Copyright 2008
+ * Graeme Russ, graeme.russ@gmail.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "hardware.h"
+
+/* board early intialization */
+.globl early_board_init
+early_board_init:
+	/* No 32-bit board specific initialisation */
+	jmp	*%ebp		/* return to caller */
+
+.globl show_boot_progress_asm
+show_boot_progress_asm:
+
+	movb	%al, %dl	/* Create Working Copy */
+	andb	$0x80, %dl	/* Mask in only Error bit */
+	shrb	$0x02, %dl	/* Shift Error bit to Error LED */
+	andb	$0x0f, %al	/* Mask out 'Error' bit */
+	orb	%dl, %al	/* Mask in ERR LED */
+	movw	$LED_LATCH_ADDRESS, %dx
+	outb	%al, %dx
+	jmp	*%ebp		/* return to caller */
+
+.globl cpu_halt_asm
+cpu_halt_asm:
+	movb	$0x0f, %al
+	movw	$LED_LATCH_ADDRESS, %dx
+	outb	%al, %dx
+	hlt
+	jmp cpu_halt_asm
diff -Naur u-boot-2009.01/board/eNET/hardware.h u-boot/board/eNET/hardware.h
--- u-boot-2009.01/board/eNET/hardware.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/eNET/hardware.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,35 @@
+/*
+ * (C) Copyright 2008
+ * Graeme Russ, graeme.russ@gmail.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef HARDWARE_H_
+#define HARDWARE_H_
+
+#define LED_LATCH_ADDRESS	0x1002
+#define LED_RUN_BITMASK		0x01
+#define LED_1_BITMASK		0x02
+#define LED_2_BITMASK		0x04
+#define LED_RX_BITMASK		0x08
+#define LED_TX_BITMASK		0x10
+#define LED_ERR_BITMASK		0x20
+
+#endif /* HARDWARE_H_ */
diff -Naur u-boot-2009.01/board/eNET/Makefile u-boot/board/eNET/Makefile
--- u-boot-2009.01/board/eNET/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/eNET/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,57 @@
+#
+# (C) Copyright 2008
+# Graeme Russ, graeme.russ@gmail.com.
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2002
+# Daniel Engstrm, Omicron Ceti AB, daniel@omicron.se.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= eNET.o
+SOBJS	:= eNET_start16.o eNET_start.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/eNET/u-boot.lds u-boot/board/eNET/u-boot.lds
--- u-boot-2009.01/board/eNET/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/eNET/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,90 @@
+/*
+ * (C) Copyright 2002
+ * Daniel Engstrm, Omicron Ceti AB, daniel@omicron.se.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(_start)
+
+SECTIONS
+{
+	. = 0x38040000;		/* Location of bootcode in flash */
+	.text  : { *(.text); }
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) *(.rodata.str1.1) *(.rodata.str1.32) }
+
+	_i386boot_text_size = SIZEOF(.text) + SIZEOF(.rodata);
+
+	. = 0x03FF0000;		/* Ram data segment to use */
+	_i386boot_romdata_dest = ABSOLUTE(.);
+	.data : AT ( LOADADDR(.rodata) + SIZEOF(.rodata) ) { *(.data) }
+	_i386boot_romdata_start = LOADADDR(.data);
+
+	. = ALIGN(4);
+	.got : AT ( LOADADDR(.data) + SIZEOF(.data) ) { *(.got) }
+
+	. = ALIGN(4);
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+	_i386boot_cmd_start = LOADADDR(.u_boot_cmd);
+
+	_i386boot_romdata_size = SIZEOF(.data) + SIZEOF(.got) + SIZEOF(.u_boot_cmd);
+
+	. = ALIGN(4);
+	_i386boot_bss_start = ABSOLUTE(.);
+	.bss (NOLOAD) : { *(.bss) }
+	_i386boot_bss_size = SIZEOF(.bss);
+
+	/* 16bit realmode trampoline code */
+	.realmode 0x7c0 : AT ( LOADADDR(.got) + SIZEOF(.got) + SIZEOF(.u_boot_cmd)) { *(.realmode) }
+
+	_i386boot_realmode = LOADADDR(.realmode);
+	_i386boot_realmode_size = SIZEOF(.realmode);
+
+	/* 16bit BIOS emulation code (just enough to boot Linux) */
+	.bios 0 : AT ( LOADADDR(.realmode) + SIZEOF(.realmode) ) { *(.bios) }
+
+	_i386boot_bios = LOADADDR(.bios);
+	_i386boot_bios_size = SIZEOF(.bios);
+
+	/* The load addresses below assumes that the flash
+	 * will be mapped so that 0x387f0000 == 0xffff0000
+	 * at reset time
+	 *
+	 * The fe00 and ff00 offsets of the start32 and start16
+	 * segments are arbitrary, the just have to be mapped
+	 * at reset and the code have to fit.
+	 * The fff0 offset of resetvec is important, however.
+	 */
+
+	. = 0xfffffe00;
+	.start32 : AT (0x3807fe00) { *(.start32); }
+
+	. = 0xf800;
+	.start16 : AT (0x3807f800) { *(.start16); }
+
+	. = 0xfff0;
+	.resetvec : AT (0x3807fff0) { *(.resetvec); }
+	_i386boot_end = (LOADADDR(.resetvec) + SIZEOF(.resetvec) );
+}
diff -Naur u-boot-2009.01/board/esd/ar405/ar405.c u-boot/board/esd/ar405/ar405.c
--- u-boot-2009.01/board/esd/ar405/ar405.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/ar405/ar405.c	2009-02-26 14:03:58.000000000 +0100
@@ -247,7 +247,7 @@
 }
 U_BOOT_CMD(
 	digtest,	3,	1,	do_digtest,
-	"digtest - Test digital in-/output\n",
+	"Test digital in-/output",
 	NULL
 	);
 
@@ -341,7 +341,7 @@
 }
 U_BOOT_CMD(
 	anatest,	2,	1,	do_anatest,
-	"anatest - Test analog in-/output\n",
+	"Test analog in-/output",
 	NULL
 	);
 
@@ -408,7 +408,7 @@
 }
 U_BOOT_CMD(
 	inctest,	3,	1,	do_inctest,
-	"inctest - Test incremental encoder inputs\n",
+	"Test incremental encoder inputs",
 	NULL
 	);
 #endif
diff -Naur u-boot-2009.01/board/esd/cms700/cms700.c u-boot/board/esd/cms700/cms700.c
--- u-boot-2009.01/board/esd/cms700/cms700.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/cms700/cms700.c	2009-02-26 14:03:58.000000000 +0100
@@ -198,7 +198,7 @@
 }
 
 U_BOOT_CMD(eepwren,	2,	0,	do_eep_wren,
-	   "eepwren - Enable / disable / query EEPROM write access\n",
+	   "Enable / disable / query EEPROM write access",
 	   NULL);
 #endif /* #if defined(CONFIG_SYS_EEPROM_WREN) */
 
diff -Naur u-boot-2009.01/board/esd/common/auto_update.c u-boot/board/esd/common/auto_update.c
--- u-boot-2009.01/board/esd/common/auto_update.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/common/auto_update.c	2009-02-26 14:03:58.000000000 +0100
@@ -550,7 +550,7 @@
 }
 U_BOOT_CMD(
 	autoupd,	1,	1,	auto_update,
-	"autoupd - Automatically update images\n",
+	"Automatically update images",
 	NULL
 );
 #endif /* CONFIG_AUTO_UPDATE */
diff -Naur u-boot-2009.01/board/esd/common/cmd_loadpci.c u-boot/board/esd/common/cmd_loadpci.c
--- u-boot-2009.01/board/esd/common/cmd_loadpci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/common/cmd_loadpci.c	2009-02-26 14:03:58.000000000 +0100
@@ -123,7 +123,7 @@
 
 U_BOOT_CMD(
 	loadpci,	1,	1,	do_loadpci,
-	"loadpci - Wait for pci bootcmd and boot it\n",
+	"Wait for pci bootcmd and boot it",
 	NULL
 	);
 
diff -Naur u-boot-2009.01/board/esd/common/lcd.c u-boot/board/esd/common/lcd.c
--- u-boot-2009.01/board/esd/common/lcd.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/common/lcd.c	2009-02-26 14:03:58.000000000 +0100
@@ -346,7 +346,7 @@
 	char *str;
 #endif
 	if (argc != 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -372,6 +372,6 @@
 
 U_BOOT_CMD(
 	esdbmp,	2,	1,	do_esdbmp,
-	"esdbmp   - display BMP image\n",
+	"display BMP image",
 	"<imageAddr> - display image\n"
 );
diff -Naur u-boot-2009.01/board/esd/common/pci.c u-boot/board/esd/common/pci.c
--- u-boot-2009.01/board/esd/common/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/common/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -179,7 +179,7 @@
   /* System memory space */
   pci_set_region(hose->regions + 0,
 		 0x00000000, 0x00000000, 0x01000000,
-		 PCI_REGION_MEM | PCI_REGION_MEMORY);
+		 PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
   /* PCI Memory space */
   pci_set_region(hose->regions + 1,
diff -Naur u-boot-2009.01/board/esd/common/xilinx_jtag/micro.c u-boot/board/esd/common/xilinx_jtag/micro.c
--- u-boot-2009.01/board/esd/common/xilinx_jtag/micro.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/common/xilinx_jtag/micro.c	2009-02-26 14:03:58.000000000 +0100
@@ -1859,6 +1859,6 @@
 }
 U_BOOT_CMD(
 	cpld,	1,	1,	do_cpld,
-	"cpld    - Program onboard CPLD\n",
+	"Program onboard CPLD",
 	NULL
 	);
diff -Naur u-boot-2009.01/board/esd/cpci2dp/cpci2dp.c u-boot/board/esd/cpci2dp/cpci2dp.c
--- u-boot-2009.01/board/esd/cpci2dp/cpci2dp.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/cpci2dp/cpci2dp.c	2009-02-26 14:03:58.000000000 +0100
@@ -176,7 +176,7 @@
 
 U_BOOT_CMD(
 	eepwren,	2,	0,	do_eep_wren,
-	"eepwren - Enable / disable / query EEPROM write access\n",
+	"Enable / disable / query EEPROM write access",
 	NULL
 	);
 #endif /* #if defined(CONFIG_SYS_EEPROM_WREN) */
diff -Naur u-boot-2009.01/board/esd/cpci405/cpci405.c u-boot/board/esd/cpci405/cpci405.c
--- u-boot-2009.01/board/esd/cpci405/cpci405.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/cpci405/cpci405.c	2009-02-26 14:03:58.000000000 +0100
@@ -689,7 +689,7 @@
 }
 U_BOOT_CMD(
 	onewire,	1,	1,	do_onewire,
-	"onewire - Read 1-write ID\n",
+	"Read 1-write ID",
 	NULL
 	);
 
@@ -750,7 +750,7 @@
 }
 U_BOOT_CMD(
 	getbpip,	1,	1,	do_get_bpip,
-	"getbpip - Update IP-Address with Backplane IP-Address\n",
+	"Update IP-Address with Backplane IP-Address",
 	NULL
 	);
 
@@ -786,7 +786,7 @@
 }
 U_BOOT_CMD(
 	setbpip,	2,	1,	do_set_bpip,
-	"setbpip - Write Backplane IP-Address\n",
+	"Write Backplane IP-Address",
 	NULL
 	);
 
diff -Naur u-boot-2009.01/board/esd/cpci5200/cpci5200.c u-boot/board/esd/cpci5200/cpci5200.c
--- u-boot-2009.01/board/esd/cpci5200/cpci5200.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/cpci5200/cpci5200.c	2009-02-26 14:03:58.000000000 +0100
@@ -294,5 +294,5 @@
 }
 
 U_BOOT_CMD(writepci, 3, 1, do_writepci,
-	   "writepci- Write some data to pcibus\n",
+	   "Write some data to pcibus",
 	   "<addr> <size>\n" "        - Write some data to pcibus.\n");
diff -Naur u-boot-2009.01/board/esd/cpci750/cpci750.c u-boot/board/esd/cpci750/cpci750.c
--- u-boot-2009.01/board/esd/cpci750/cpci750.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/cpci750/cpci750.c	2009-02-26 14:03:58.000000000 +0100
@@ -993,6 +993,6 @@
 
 U_BOOT_CMD(
 	show_config,	1,	1,	do_show_config,
-	"show_config - Show Marvell strapping register\n",
+	"Show Marvell strapping register",
 	"Show Marvell strapping register (ResetSampleLow ResetSampleHigh)\n"
 	);
diff -Naur u-boot-2009.01/board/esd/dasa_sim/cmd_dasa_sim.c u-boot/board/esd/dasa_sim/cmd_dasa_sim.c
--- u-boot-2009.01/board/esd/dasa_sim/cmd_dasa_sim.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/dasa_sim/cmd_dasa_sim.c	2009-02-26 14:03:58.000000000 +0100
@@ -220,14 +220,14 @@
 		return 0;
 	}
 
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 
 }
 
 U_BOOT_CMD(
 	pci9054, 3, 1, do_pci9054,
-	"pci9054 - PLX PCI9054 EEPROM access\n",
+	"PLX PCI9054 EEPROM access",
 	"pci9054 info - print EEPROM values\n"
 	"pci9054 update - updates EEPROM with default values\n"
 );
diff -Naur u-boot-2009.01/board/esd/du440/du440.c u-boot/board/esd/du440/du440.c
--- u-boot-2009.01/board/esd/du440/du440.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/du440/du440.c	2009-02-26 14:03:58.000000000 +0100
@@ -606,7 +606,7 @@
 }
 U_BOOT_CMD(
 	dcf77, 1, 1, do_dcf77,
-	"dcf77   - Check DCF77 receiver\n",
+	"Check DCF77 receiver",
 	NULL
 	);
 
@@ -656,7 +656,7 @@
 }
 U_BOOT_CMD(
 	hubinit, 1, 1, do_hubinit,
-	"hubinit - Initialize USB hub\n",
+	"Initialize USB hub",
 	NULL
 	);
 #endif /* CONFIG_I2C_MULTI_BUS */
@@ -789,7 +789,7 @@
 }
 U_BOOT_CMD(
 	sbe, 2, 0, do_setup_boot_eeprom,
-	"sbe     - setup boot eeprom\n",
+	"setup boot eeprom",
 	NULL
 	);
 
@@ -863,7 +863,7 @@
 }
 
 U_BOOT_CMD(eepwren, 2, 0, do_eep_wren,
-	   "eepwren - Enable / disable / query EEPROM write access\n",
+	   "Enable / disable / query EEPROM write access",
 	   NULL);
 #endif /* #if defined(CONFIG_SYS_EEPROM_WREN) */
 
@@ -914,7 +914,7 @@
 }
 U_BOOT_CMD(
 	wpi,	1,	1,	do_waitpwrirq,
-	"wpi     - Wait for power change interrupt\n",
+	"Wait for power change interrupt",
 	NULL
 	);
 
@@ -959,7 +959,7 @@
 }
 U_BOOT_CMD(
 	dviinit, 1, 1, do_dviinit,
-	"dviinit - Initialize DVI Panellink transmitter\n",
+	"Initialize DVI Panellink transmitter",
 	NULL
 	);
 
@@ -999,7 +999,7 @@
 }
 U_BOOT_CMD(
 	time,	CONFIG_SYS_MAXARGS,	1,	do_time,
-	"time    - run command and output execution time\n",
+	"run command and output execution time",
 	NULL
 	);
 
@@ -1049,6 +1049,6 @@
 }
 U_BOOT_CMD(
 	gfxdemo,	CONFIG_SYS_MAXARGS,	1,	do_gfxdemo,
-	"gfxdemo - demo\n",
+	"demo",
 	NULL
 	);
diff -Naur u-boot-2009.01/board/esd/hh405/hh405.c u-boot/board/esd/hh405/hh405.c
--- u-boot-2009.01/board/esd/hh405/hh405.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/hh405/hh405.c	2009-02-26 14:03:58.000000000 +0100
@@ -733,7 +733,7 @@
 }
 
 U_BOOT_CMD(eepwren,	2,	0,	do_eep_wren,
-	   "eepwren - Enable / disable / query EEPROM write access\n",
+	   "Enable / disable / query EEPROM write access",
 	   NULL);
 #endif /* #if defined(CONFIG_SYS_EEPROM_WREN) */
 
diff -Naur u-boot-2009.01/board/esd/ocrtc/cmd_ocrtc.c u-boot/board/esd/ocrtc/cmd_ocrtc.c
--- u-boot-2009.01/board/esd/ocrtc/cmd_ocrtc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/ocrtc/cmd_ocrtc.c	2009-02-26 14:03:58.000000000 +0100
@@ -54,7 +54,7 @@
 }
 U_BOOT_CMD(
 	setdevice,	1,	1,	do_setdevice,
-	"setdevice - Set device number on pci adapter boards\n",
+	"Set device number on pci adapter boards",
 	NULL
 );
 
@@ -77,7 +77,7 @@
 }
 U_BOOT_CMD(
 	getdevice,	1,	1,	do_getdevice,
-	"getdevice - Get device number and set slot env variable\n",
+	"Get device number and set slot env variable",
 	NULL
 );
 
diff -Naur u-boot-2009.01/board/esd/pci405/cmd_pci405.c u-boot/board/esd/pci405/cmd_pci405.c
--- u-boot-2009.01/board/esd/pci405/cmd_pci405.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/pci405/cmd_pci405.c	2009-02-26 14:03:58.000000000 +0100
@@ -108,7 +108,7 @@
 }
 U_BOOT_CMD(
 	loadpci,	1,	1,	do_loadpci,
-	"loadpci - Wait for pci-image and boot it\n",
+	"Wait for pci-image and boot it",
 	NULL
 );
 #endif
diff -Naur u-boot-2009.01/board/esd/pci405/pci405.c u-boot/board/esd/pci405/pci405.c
--- u-boot-2009.01/board/esd/pci405/pci405.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/pci405/pci405.c	2009-02-26 14:03:58.000000000 +0100
@@ -375,7 +375,7 @@
 
 U_BOOT_CMD(
 	wpeeprom,	2,	1,	do_wpeeprom,
-	"wpeeprom - Check/Enable/Disable I2C EEPROM write protection\n",
+	"Check/Enable/Disable I2C EEPROM write protection",
 	"wpeeprom\n"
 	"    - check I2C EEPROM write protection state\n"
 	"wpeeprom 1\n"
diff -Naur u-boot-2009.01/board/esd/pf5200/pf5200.c u-boot/board/esd/pf5200/pf5200.c
--- u-boot-2009.01/board/esd/pf5200/pf5200.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/pf5200/pf5200.c	2009-02-26 14:03:58.000000000 +0100
@@ -294,7 +294,7 @@
 	return (0);
 }
 
-U_BOOT_CMD(poweroff, 1, 1, do_poweroff, "poweroff- Switch off power\n", NULL);
+U_BOOT_CMD(poweroff, 1, 1, do_poweroff, "Switch off power", NULL);
 
 int phypower(int flag)
 {
@@ -338,7 +338,7 @@
 }
 
 U_BOOT_CMD(phypower, 2, 2, do_phypower,
-	   "phypower- Switch power of ethernet phy\n", NULL);
+	   "Switch power of ethernet phy", NULL);
 
 int do_writepci(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
@@ -369,5 +369,5 @@
 }
 
 U_BOOT_CMD(writepci, 3, 1, do_writepci,
-	   "writepci- Write some data to pcibus\n",
+	   "Write some data to pcibus",
 	   "<addr> <size>\n" "        - Write some data to pcibus.\n");
diff -Naur u-boot-2009.01/board/esd/plu405/plu405.c u-boot/board/esd/plu405/plu405.c
--- u-boot-2009.01/board/esd/plu405/plu405.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/plu405/plu405.c	2009-02-26 14:03:58.000000000 +0100
@@ -333,6 +333,6 @@
 }
 
 U_BOOT_CMD(eepwren,	2,	0,	do_eep_wren,
-	   "eepwren - Enable / disable / query EEPROM write access\n",
+	   "Enable / disable / query EEPROM write access",
 	   NULL);
 #endif /* #if defined(CONFIG_SYS_EEPROM_WREN) */
diff -Naur u-boot-2009.01/board/esd/pmc405/config.mk u-boot/board/esd/pmc405/config.mk
--- u-boot-2009.01/board/esd/pmc405/config.mk	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/pmc405/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -21,8 +21,4 @@
 # MA 02111-1307 USA
 #
 
-#
-# esd PMC405 boards
-#
-
-TEXT_BASE = 0xFFFC0000
+TEXT_BASE = 0xFFF80000
diff -Naur u-boot-2009.01/board/esd/pmc405/pmc405.c u-boot/board/esd/pmc405/pmc405.c
--- u-boot-2009.01/board/esd/pmc405/pmc405.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/pmc405/pmc405.c	2009-02-26 14:03:58.000000000 +0100
@@ -2,7 +2,7 @@
  * (C) Copyright 2001-2003
  * Stefan Roese, DENX Software Engineering, sr@denx.de.
  *
- * (C) Copyright 2005
+ * (C) Copyright 2005-2009
  * Matthias Fuchs, esd gmbh germany, matthias.fuchs@esd-electronics.com
  *
  * See file CREDITS for list of people who contributed to this
@@ -26,6 +26,7 @@
 
 #include <common.h>
 #include <asm/processor.h>
+#include <asm/io.h>
 #include <command.h>
 #include <malloc.h>
 
@@ -40,7 +41,6 @@
 };
 int filesize = sizeof(fpgadata);
 
-
 int board_early_init_f (void)
 {
 	/*
@@ -55,107 +55,104 @@
 	 * IRQ 30 (EXT IRQ 5) PCI INTA; active low; level sensitive
 	 * IRQ 31 (EXT IRQ 6) COMPACT FLASH; active high; level sensitive
 	 */
-	mtdcr(uicsr, 0xFFFFFFFF);       /* clear all ints */
-	mtdcr(uicer, 0x00000000);       /* disable all ints */
-	mtdcr(uiccr, 0x00000000);       /* set all to be non-critical*/
-	mtdcr(uicpr, 0xFFFFFF81);       /* set int polarities */
-	mtdcr(uictr, 0x10000000);       /* set int trigger levels */
-	mtdcr(uicvcr, 0x00000001);      /* set vect base=0,INT0 highest priority*/
-	mtdcr(uicsr, 0xFFFFFFFF);       /* clear all ints */
+	mtdcr(uicsr, 0xFFFFFFFF); /* clear all ints */
+	mtdcr(uicer, 0x00000000); /* disable all ints */
+	mtdcr(uiccr, 0x00000000); /* set all to be non-critical*/
+	mtdcr(uicpr, 0xFFFFFF81); /* set int polarities */
+	mtdcr(uictr, 0x10000000); /* set int trigger levels */
+	mtdcr(uicvcr, 0x00000001); /* set vect base=0, INT0 highest priority */
+	mtdcr(uicsr, 0xFFFFFFFF); /* clear all ints */
 
 	/*
-	 * EBC Configuration Register: set ready timeout to 512 ebc-clks -> ca. 15 us
+	 * EBC Configuration Register:
+	 * set ready timeout to 512 ebc-clks -> ca. 15 us
 	 */
 	mtebc (epcr, 0xa8400000);
 
 	/*
 	 * Setup GPIO pins
 	 */
-
-	mtdcr(cntrl0, mfdcr(cntrl0) | ((CONFIG_SYS_FPGA_INIT | \
-					CONFIG_SYS_FPGA_DONE | \
-					CONFIG_SYS_XEREADY | \
-					CONFIG_SYS_NONMONARCH | \
+	mtdcr(cntrl0, mfdcr(cntrl0) | ((CONFIG_SYS_FPGA_INIT |
+					CONFIG_SYS_FPGA_DONE |
+					CONFIG_SYS_XEREADY |
+					CONFIG_SYS_NONMONARCH |
 					CONFIG_SYS_REV1_2) << 5));
 
-	if (!(in32(GPIO0_IR) & CONFIG_SYS_REV1_2)) {
+	if (!(in_be32((void *)GPIO0_IR) & CONFIG_SYS_REV1_2)) {
 		/* rev 1.2 boards */
-		mtdcr(cntrl0, mfdcr(cntrl0) | ((CONFIG_SYS_INTA_FAKE | \
+		mtdcr(cntrl0, mfdcr(cntrl0) | ((CONFIG_SYS_INTA_FAKE |
 						CONFIG_SYS_SELF_RST) << 5));
 	}
 
-	out32(GPIO0_OR, 0);
-	out32(GPIO0_TCR, CONFIG_SYS_FPGA_PRG | CONFIG_SYS_FPGA_CLK | CONFIG_SYS_FPGA_DATA | CONFIG_SYS_XEREADY); /* setup for output */
+	out_be32((void *)GPIO0_OR, CONFIG_SYS_VPEN);
+	/* setup for output */
+	out_be32((void *)GPIO0_TCR, CONFIG_SYS_FPGA_PRG | CONFIG_SYS_FPGA_CLK |
+		 CONFIG_SYS_FPGA_DATA | CONFIG_SYS_XEREADY | CONFIG_SYS_VPEN);
 
-	/* - check if rev1_2 is low, then:
-	 * - set/reset CONFIG_SYS_INTA_FAKE/CONFIG_SYS_SELF_RST in TCR to assert INTA# or SELFRST#
+	/*
+	 * - check if rev1_2 is low, then:
+	 * - set/reset CONFIG_SYS_INTA_FAKE/CONFIG_SYS_SELF_RST
+	 *   in TCR to assert INTA# or SELFRST#
 	 */
-
 	return 0;
 }
 
-
-/* ------------------------------------------------------------------------- */
-
-
 int misc_init_r (void)
 {
 	/* adjust flash start and offset */
 	gd->bd->bi_flashstart = 0 - gd->bd->bi_flashsize;
 	gd->bd->bi_flashoffset = 0;
 
-	out32(GPIO0_OR, in32(GPIO0_OR) | CONFIG_SYS_XEREADY); /* deassert EREADY# */
+	/* deassert EREADY# */
+	out_be32((void *)GPIO0_OR,
+		 in_be32((void *)GPIO0_OR) | CONFIG_SYS_XEREADY);
 	return (0);
 }
 
 ushort pmc405_pci_subsys_deviceid(void)
 {
 	ulong val;
-	val = in32(GPIO0_IR);
+
+	val = in_be32((void *)GPIO0_IR);
 	if (!(val & CONFIG_SYS_REV1_2)) { /* low=rev1.2 */
-		if (val & CONFIG_SYS_NONMONARCH) { /* monarch# signal */
+		/* check monarch# signal */
+		if (val & CONFIG_SYS_NONMONARCH)
 			return CONFIG_SYS_PCI_SUBSYS_DEVICEID_NONMONARCH;
-		}
 		return CONFIG_SYS_PCI_SUBSYS_DEVICEID_MONARCH;
 	}
 	return CONFIG_SYS_PCI_SUBSYS_DEVICEID_NONMONARCH;
 }
 
 /*
- * Check Board Identity:
+ * Check Board Identity
  */
 int checkboard (void)
 {
 	ulong val;
-
 	char str[64];
-	int i = getenv_r ("serial#", str, sizeof(str));
+	int i = getenv_r("serial#", str, sizeof(str));
 
 	puts ("Board: ");
 
-	if (i == -1) {
+	if (i == -1)
 		puts ("### No HW ID - assuming PMC405");
-	} else {
+	else
 		puts(str);
-	}
 
-	val = in32(GPIO0_IR);
+	val = in_be32((void *)GPIO0_IR);
 	if (!(val & CONFIG_SYS_REV1_2)) { /* low=rev1.2 */
 		puts(" rev1.2 (");
-		if (val & CONFIG_SYS_NONMONARCH) { /* monarch# signal */
+		if (val & CONFIG_SYS_NONMONARCH) /* monarch# signal */
 			puts("non-");
-		}
 		puts("monarch)");
-	} else {
+	} else
 		puts(" <=rev1.1");
-	}
 
 	putc ('\n');
 
 	return 0;
 }
 
-/* ------------------------------------------------------------------------- */
 void reset_phy(void)
 {
 #ifdef CONFIG_LXT971_NO_SLEEP
@@ -166,43 +163,3 @@
 	lxt971_no_sleep();
 #endif
 }
-
-
-int do_cantest(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
-{
-	ulong addr;
-	volatile uchar *ptr;
-	volatile uchar val;
-	int i;
-
-	addr = simple_strtol (argv[1], NULL, 16) + 0x16;
-
-	i = 0;
-	for (;;) {
-		ptr = (uchar *)addr;
-		for (i=0; i<8; i++) {
-			*ptr = i;
-			val = *ptr;
-
-			if (val != i) {
-				printf("ERROR: addr=%p write=0x%02X, read=0x%02X\n", ptr, i, val);
-				return 0;
-			}
-
-			/* Abort if ctrl-c was pressed */
-			if (ctrlc()) {
-				puts("\nAbort\n");
-				return 0;
-			}
-
-			ptr++;
-		}
-	}
-
-	return 0;
-}
-U_BOOT_CMD(
-	cantest,	3,	1,	do_cantest,
-	"cantest - Test CAN controller",
-	NULL
-	);
diff -Naur u-boot-2009.01/board/esd/pmc440/cmd_pmc440.c u-boot/board/esd/pmc440/cmd_pmc440.c
--- u-boot-2009.01/board/esd/pmc440/cmd_pmc440.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/pmc440/cmd_pmc440.c	2009-02-26 14:03:58.000000000 +0100
@@ -98,7 +98,7 @@
 }
 U_BOOT_CMD(
 	waithci,	1,	1,	do_waithci,
-	"waithci - Wait for host control interrupt\n",
+	"Wait for host control interrupt",
 	NULL
 	);
 
@@ -258,7 +258,7 @@
 }
 U_BOOT_CMD(
 	fifo,	5,	1,	do_fifo,
-	"fifo    - Fifo module operations\n",
+	"Fifo module operations",
 	"wait\nfifo read\n"
 	"fifo write fifo(0..3) data [cnt=1]\n"
 	"fifo write address(>=4) data [cnt=1]\n"
@@ -336,7 +336,7 @@
 }
 U_BOOT_CMD(
 	sbe, 4, 0, do_setup_bootstrap_eeprom,
-	"sbe     - setup bootstrap eeprom\n",
+	"setup bootstrap eeprom",
 	"<cpufreq:400|533|667> [<console-uart:0|1> [<bringup delay (0..20s)>]]"
 	);
 
@@ -399,7 +399,7 @@
 }
 U_BOOT_CMD(
 	painit,	1,	1,	do_painit,
-	"painit  - prepare PciAccess system\n",
+	"prepare PciAccess system",
 	NULL
 	);
 #endif /* CONFIG_PRAM */
@@ -411,7 +411,7 @@
 }
 U_BOOT_CMD(
 	selfreset,	1,	1,	do_selfreset,
-	"selfreset- assert self-reset# signal\n",
+	"assert self-reset# signal",
 	NULL
 	);
 
@@ -448,7 +448,7 @@
 }
 U_BOOT_CMD(
 	resetout,	2,	1,	do_resetout,
-	"resetout - assert PMC-RESETOUT# signal\n",
+	"assert PMC-RESETOUT# signal",
 	NULL
 	);
 
@@ -480,7 +480,7 @@
 }
 U_BOOT_CMD(
 	inta,	2,	1,	do_inta,
-	"inta    - Assert/Deassert or query INTA# state in non-monarch mode\n",
+	"Assert/Deassert or query INTA# state in non-monarch mode",
 	NULL
 	);
 
@@ -513,7 +513,7 @@
 }
 U_BOOT_CMD(
 	pmm,	2,	1,	do_pmm,
-	"pmm     - Setup pmm[1] registers\n",
+	"Setup pmm[1] registers",
 	"<pciaddr> (pciaddr will be aligned to 256MB)\n"
 	);
 
@@ -549,7 +549,7 @@
 	return state;
 }
 U_BOOT_CMD(eepwren, 2, 0, do_eep_wren,
-	   "eepwren - Enable / disable / query EEPROM write access\n",
+	   "Enable / disable / query EEPROM write access",
 	   NULL);
 #endif /* #if defined(CONFIG_SYS_EEPROM_WREN) */
 
diff -Naur u-boot-2009.01/board/esd/tasreg/tasreg.c u-boot/board/esd/tasreg/tasreg.c
--- u-boot-2009.01/board/esd/tasreg/tasreg.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/tasreg/tasreg.c	2009-02-26 14:03:58.000000000 +0100
@@ -248,7 +248,7 @@
 }
 U_BOOT_CMD(
 	iploop,	2,	1,	do_iploop,
-	"iploop - iprobe loop <addr>\n",
+	"iprobe loop <addr>",
 	NULL
 	);
 
@@ -301,7 +301,7 @@
 }
 U_BOOT_CMD(
 	codec,	1,	1,	do_codec,
-	"codec - Enable codec\n",
+	"Enable codec",
 	NULL
 	);
 
@@ -334,7 +334,7 @@
 }
 U_BOOT_CMD(
 	saa,	5,	1,	do_saa,
-	"saa    - Write to SAA1064 <addr> <instr> <cntrl> <data>\n",
+	"Write to SAA1064 <addr> <instr> <cntrl> <data>",
 	NULL
 	);
 
@@ -373,7 +373,7 @@
 }
 U_BOOT_CMD(
 	iwrite,	6,	1,	do_iwrite,
-	"iwrite - Write n bytes to I2C-device\n",
+	"Write n bytes to I2C-device",
 	"addr cnt data0 ... datan\n"
 	);
 
@@ -405,7 +405,7 @@
 }
 U_BOOT_CMD(
 	iread,	3,	1,	do_iread,
-	"iread  - Read from I2C <addr> <cnt>\n",
+	"Read from I2C <addr> <cnt>",
 	NULL
 	);
 
@@ -443,7 +443,7 @@
 }
 U_BOOT_CMD(
 	ireadl,	2,	1,	do_ireadl,
-	"ireadl - Read-loop from I2C <addr>\n",
+	"Read-loop from I2C <addr>",
 	NULL
 	);
 #endif
diff -Naur u-boot-2009.01/board/esd/voh405/voh405.c u-boot/board/esd/voh405/voh405.c
--- u-boot-2009.01/board/esd/voh405/voh405.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/esd/voh405/voh405.c	2009-02-26 14:03:58.000000000 +0100
@@ -392,6 +392,6 @@
 }
 
 U_BOOT_CMD(eepwren,	2,	0,	do_eep_wren,
-	   "eepwren - Enable / disable / query EEPROM write access\n",
+	   "Enable / disable / query EEPROM write access",
 	   NULL);
 #endif /* #if defined(CONFIG_SYS_EEPROM_WREN) */
diff -Naur u-boot-2009.01/board/etin/debris/flash.c u-boot/board/etin/debris/flash.c
--- u-boot-2009.01/board/etin/debris/flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/etin/debris/flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -27,6 +27,7 @@
 #include <asm/processor.h>
 #include <asm/pci_io.h>
 #include <mpc824x.h>
+#include <asm/mmu.h>
 
 int (*do_flash_erase)(flash_info_t*, uint32_t, uint32_t);
 int (*write_dword)(flash_info_t*, ulong, uint64_t);
diff -Naur u-boot-2009.01/board/etin/kvme080/kvme080.c u-boot/board/etin/kvme080/kvme080.c
--- u-boot-2009.01/board/etin/kvme080/kvme080.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/etin/kvme080/kvme080.c	2009-02-26 14:03:58.000000000 +0100
@@ -27,6 +27,7 @@
 #include <i2c.h>
 #include <netdev.h>
 #include <asm/processor.h>
+#include <asm/mmu.h>
 
 int checkboard(void)
 {
diff -Naur u-boot-2009.01/board/evb64260/flash.c u-boot/board/evb64260/flash.c
--- u-boot-2009.01/board/evb64260/flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/evb64260/flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -54,7 +54,6 @@
 static ulong flash_get_size (int portwidth, vu_long *addr, flash_info_t *info);
 static int write_word (flash_info_t *info, ulong dest, ulong data);
 static void flash_get_offsets (ulong base, flash_info_t *info);
-static flash_info_t *flash_get_info(ulong base);
 
 /*-----------------------------------------------------------------------
  */
@@ -178,7 +177,7 @@
 /*-----------------------------------------------------------------------
  */
 
-static flash_info_t *flash_get_info(ulong base)
+flash_info_t *flash_get_info(ulong base)
 {
 	int i;
 	flash_info_t * info;
diff -Naur u-boot-2009.01/board/evb64260/zuma_pbb.c u-boot/board/evb64260/zuma_pbb.c
--- u-boot-2009.01/board/evb64260/zuma_pbb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/evb64260/zuma_pbb.c	2009-02-26 14:03:58.000000000 +0100
@@ -202,19 +202,19 @@
 
 U_BOOT_CMD(
 	zinit,	 1,	 0,	 do_zuma_init_pbb,
-	"zinit   - init zuma pbb\n",
+	"init zuma pbb",
 	"\n"
 	"    - init zuma pbb\n"
 );
 U_BOOT_CMD(
 	zdtest,	  3,	  1,	  do_zuma_test_dma,
-	"zdtest  - run dma test\n",
+	"run dma test",
 	"[cmd [count]]\n"
 	"    - run dma cmd (w=0,v=1,cp=2,cmp=3,wi=4,vi=5), count bytes\n"
 );
 U_BOOT_CMD(
 	zminit,	  1,	  0,	  do_zuma_init_mbox,
-	"zminit  - init zuma mbox\n",
+	"init zuma mbox",
 	"\n"
 	"    - init zuma mbox\n"
 );
diff -Naur u-boot-2009.01/board/freescale/common/pixis.c u-boot/board/freescale/common/pixis.c
--- u-boot-2009.01/board/freescale/common/pixis.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/common/pixis.c	2009-02-26 14:03:58.000000000 +0100
@@ -280,7 +280,7 @@
 
 U_BOOT_CMD(
 	   diswd, 1, 0, pixis_disable_watchdog_cmd,
-	   "diswd	- Disable watchdog timer \n",
+	   "Disable watchdog timer",
 	   NULL);
 
 #ifdef CONFIG_PIXIS_SGMII_CMD
@@ -539,7 +539,7 @@
 
 U_BOOT_CMD(
 	pixis_reset, CONFIG_SYS_MAXARGS, 1, pixis_reset_cmd,
-	"pixis_reset - Reset the board using the FPGA sequencer\n",
+	"Reset the board using the FPGA sequencer",
 	"    pixis_reset\n"
 	"    pixis_reset [altbank]\n"
 	"    pixis_reset altbank wd\n"
diff -Naur u-boot-2009.01/board/freescale/common/sgmii_riser.c u-boot/board/freescale/common/sgmii_riser.c
--- u-boot-2009.01/board/freescale/common/sgmii_riser.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/common/sgmii_riser.c	2009-02-26 14:03:58.000000000 +0100
@@ -14,6 +14,8 @@
 
 #include <config.h>
 #include <common.h>
+#include <net.h>
+#include <libfdt.h>
 #include <tsec.h>
 
 void fsl_sgmii_riser_init(struct tsec_info_struct *tsec_info, int num)
@@ -24,3 +26,66 @@
 		if (tsec_info[i].flags & TSEC_SGMII)
 			tsec_info[i].phyaddr += SGMII_RISER_PHY_OFFSET;
 }
+
+void fsl_sgmii_riser_fdt_fixup(void *fdt)
+{
+	struct eth_device *dev;
+	int node;
+	int i = -1;
+	int etsec_num = 0;
+
+	node = fdt_path_offset(fdt, "/aliases");
+	if (node < 0)
+		return;
+
+	while ((dev = eth_get_dev_by_index(++i)) != NULL) {
+		struct tsec_private *priv;
+		int enet_node;
+		char enet[16];
+		const u32 *phyh;
+		int phynode;
+		const char *model;
+		const char *path;
+
+		printf("Updating PHY address for %s\n", dev->name);
+		if (!strstr(dev->name, "eTSEC"))
+			continue;
+
+		sprintf(enet, "ethernet%d", etsec_num++);
+		path = fdt_getprop(fdt, node, enet, NULL);
+		if (!path) {
+			debug("No alias for %s\n", enet);
+			continue;
+		}
+
+		enet_node = fdt_path_offset(fdt, path);
+		if (enet_node < 0)
+			continue;
+
+		model = fdt_getprop(fdt, enet_node, "model", NULL);
+
+		printf("%s's model is %s\n", enet, model);
+		/*
+		 * We only want to do this to eTSECs.  On some platforms
+		 * there are more than one type of gianfar-style ethernet
+		 * controller, and as we are creating an implicit connection
+		 * between ethernet nodes and eTSEC devices, it is best to
+		 * make the connection use as much explicit information
+		 * as exists.
+		 */
+		if (!strstr(model, "TSEC"))
+			continue;
+
+		phyh = fdt_getprop(fdt, enet_node, "phy-handle", NULL);
+		if (!phyh)
+			continue;
+
+		phynode = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(*phyh));
+
+		priv = dev->priv;
+
+		printf("Device flags are %x\n", priv->flags);
+		if (priv->flags & TSEC_SGMII)
+			fdt_setprop_cell(fdt, phynode, "reg", priv->phyaddr);
+	}
+}
diff -Naur u-boot-2009.01/board/freescale/common/sgmii_riser.h u-boot/board/freescale/common/sgmii_riser.h
--- u-boot-2009.01/board/freescale/common/sgmii_riser.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/common/sgmii_riser.h	2009-02-26 14:03:58.000000000 +0100
@@ -13,3 +13,4 @@
  */
 
 void fsl_sgmii_riser_init(struct tsec_info_struct *tsec_info, int num);
+void fsl_sgmii_riser_fdt_fixup(void *fdt);
diff -Naur u-boot-2009.01/board/freescale/common/sys_eeprom.c u-boot/board/freescale/common/sys_eeprom.c
--- u-boot-2009.01/board/freescale/common/sys_eeprom.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/common/sys_eeprom.c	2009-02-26 14:03:58.000000000 +0100
@@ -328,7 +328,7 @@
 			prog_eeprom();
 			break;
 		default:
-			printf("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			break;
 		}
 
@@ -362,7 +362,7 @@
 		break;
 	case 'h':	/* help */
 	default:
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		break;
 	}
 
diff -Naur u-boot-2009.01/board/freescale/mpc8315erdb/mpc8315erdb.c u-boot/board/freescale/mpc8315erdb/mpc8315erdb.c
--- u-boot-2009.01/board/freescale/mpc8315erdb/mpc8315erdb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8315erdb/mpc8315erdb.c	2009-02-26 14:03:58.000000000 +0100
@@ -30,6 +30,7 @@
 #include <pci.h>
 #include <mpc83xx.h>
 #include <netdev.h>
+#include <asm/io.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -95,12 +96,45 @@
 	}
 };
 
+static struct pci_region pcie_regions_0[] = {
+	{
+		.bus_start = CONFIG_SYS_PCIE1_MEM_BASE,
+		.phys_start = CONFIG_SYS_PCIE1_MEM_PHYS,
+		.size = CONFIG_SYS_PCIE1_MEM_SIZE,
+		.flags = PCI_REGION_MEM,
+	},
+	{
+		.bus_start = CONFIG_SYS_PCIE1_IO_BASE,
+		.phys_start = CONFIG_SYS_PCIE1_IO_PHYS,
+		.size = CONFIG_SYS_PCIE1_IO_SIZE,
+		.flags = PCI_REGION_IO,
+	},
+};
+
+static struct pci_region pcie_regions_1[] = {
+	{
+		.bus_start = CONFIG_SYS_PCIE2_MEM_BASE,
+		.phys_start = CONFIG_SYS_PCIE2_MEM_PHYS,
+		.size = CONFIG_SYS_PCIE2_MEM_SIZE,
+		.flags = PCI_REGION_MEM,
+	},
+	{
+		.bus_start = CONFIG_SYS_PCIE2_IO_BASE,
+		.phys_start = CONFIG_SYS_PCIE2_IO_PHYS,
+		.size = CONFIG_SYS_PCIE2_IO_SIZE,
+		.flags = PCI_REGION_IO,
+	},
+};
+
 void pci_init_board(void)
 {
 	volatile immap_t *immr = (volatile immap_t *)CONFIG_SYS_IMMR;
+	volatile sysconf83xx_t *sysconf = &immr->sysconf;
 	volatile clk83xx_t *clk = (volatile clk83xx_t *)&immr->clk;
 	volatile law83xx_t *pci_law = immr->sysconf.pcilaw;
+	volatile law83xx_t *pcie_law = sysconf->pcielaw;
 	struct pci_region *reg[] = { pci_regions };
+	struct pci_region *pcie_reg[] = { pcie_regions_0, pcie_regions_1, };
 	int warmboot;
 
 	/* Enable all 3 PCI_CLK_OUTPUTs. */
@@ -119,6 +153,24 @@
 	warmboot |= immr->pmc.pmccr1 & PMCCR1_POWER_OFF;
 
 	mpc83xx_pci_init(1, reg, warmboot);
+
+	/* Configure the clock for PCIE controller */
+	clrsetbits_be32(&clk->sccr, SCCR_PCIEXP1CM | SCCR_PCIEXP2CM,
+				    SCCR_PCIEXP1CM_1 | SCCR_PCIEXP2CM_1);
+
+	/* Deassert the resets in the control register */
+	out_be32(&sysconf->pecr1, 0xE0008000);
+	out_be32(&sysconf->pecr2, 0xE0008000);
+	udelay(2000);
+
+	/* Configure PCI Express Local Access Windows */
+	out_be32(&pcie_law[0].bar, CONFIG_SYS_PCIE1_BASE & LAWBAR_BAR);
+	out_be32(&pcie_law[0].ar, LBLAWAR_EN | LBLAWAR_512MB);
+
+	out_be32(&pcie_law[1].bar, CONFIG_SYS_PCIE2_BASE & LAWBAR_BAR);
+	out_be32(&pcie_law[1].ar, LBLAWAR_EN | LBLAWAR_512MB);
+
+	mpc83xx_pcie_init(2, pcie_reg, warmboot);
 }
 
 #if defined(CONFIG_OF_BOARD_SETUP)
diff -Naur u-boot-2009.01/board/freescale/mpc832xemds/pci.c u-boot/board/freescale/mpc832xemds/pci.c
--- u-boot-2009.01/board/freescale/mpc832xemds/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc832xemds/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -228,7 +228,7 @@
 		       CONFIG_SYS_PCI_SLV_MEM_LOCAL,
 		       CONFIG_SYS_PCI_SLV_MEM_BUS,
 		       CONFIG_SYS_PCI_SLV_MEM_SIZE,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose[0].region_count = 4;
 
diff -Naur u-boot-2009.01/board/freescale/mpc8349emds/pci.c u-boot/board/freescale/mpc8349emds/pci.c
--- u-boot-2009.01/board/freescale/mpc8349emds/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8349emds/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -171,15 +171,10 @@
 void pci_init_board(void)
 {
 	volatile immap_t *immr = (volatile immap_t *)CONFIG_SYS_IMMR;
-	volatile clk83xx_t *clk = (volatile clk83xx_t *)&immr->clk;
 	volatile law83xx_t *pci_law = immr->sysconf.pcilaw;
 	volatile pcictrl83xx_t *pci_ctrl = &immr->pci_ctrl[0];
 	struct pci_region *reg[] = { pci1_regions };
 
-	/* Enable all 8 PCI_CLK_OUTPUTS */
-	clk->occr = 0xff000000;
-	udelay(2000);
-
 	/* Configure PCI Local Access Windows */
 	pci_law[0].bar = CONFIG_SYS_PCI1_MEM_PHYS & LAWBAR_BAR;
 	pci_law[0].ar = LAWAR_EN | LAWAR_SIZE_1G;
@@ -187,8 +182,6 @@
 	pci_law[1].bar = CONFIG_SYS_PCI1_IO_PHYS & LAWBAR_BAR;
 	pci_law[1].ar = LAWAR_EN | LAWAR_SIZE_4M;
 
-	udelay(2000);
-
 	mpc83xx_pci_init(1, reg, 0);
 
 	/* Configure PCI Inbound Translation Windows (3 1MB windows) */
diff -Naur u-boot-2009.01/board/freescale/mpc8349itx/pci.c u-boot/board/freescale/mpc8349itx/pci.c
--- u-boot-2009.01/board/freescale/mpc8349itx/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8349itx/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -210,7 +210,7 @@
 	pci_set_region(hose->regions + 3,
 		       CONFIG_PCI_SYS_MEM_BUS,
 		       CONFIG_PCI_SYS_MEM_PHYS,
-		       gd->ram_size, PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       gd->ram_size, PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose->region_count = 4;
 
@@ -301,7 +301,7 @@
 	pci_set_region(hose->regions + 3,
 		       CONFIG_PCI_SYS_MEM_BUS,
 		       CONFIG_PCI_SYS_MEM_PHYS,
-		       gd->ram_size, PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       gd->ram_size, PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose->region_count = 4;
 
diff -Naur u-boot-2009.01/board/freescale/mpc8360emds/pci.c u-boot/board/freescale/mpc8360emds/pci.c
--- u-boot-2009.01/board/freescale/mpc8360emds/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8360emds/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -228,7 +228,7 @@
 		       CONFIG_SYS_PCI_SLV_MEM_LOCAL,
 		       CONFIG_SYS_PCI_SLV_MEM_BUS,
 		       CONFIG_SYS_PCI_SLV_MEM_SIZE,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose[0].region_count = 4;
 
diff -Naur u-boot-2009.01/board/freescale/mpc837xemds/mpc837xemds.c u-boot/board/freescale/mpc837xemds/mpc837xemds.c
--- u-boot-2009.01/board/freescale/mpc837xemds/mpc837xemds.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc837xemds/mpc837xemds.c	2009-02-26 14:03:58.000000000 +0100
@@ -18,10 +18,12 @@
 #include <tsec.h>
 #include <libfdt.h>
 #include <fdt_support.h>
+#include "pci.h"
 #include "../common/pq-mds-pib.h"
 
 int board_early_init_f(void)
 {
+	struct immap __iomem *im = (struct immap __iomem *)CONFIG_SYS_IMMR;
 	u8 *bcsr = (u8 *)CONFIG_SYS_BCSR;
 
 	/* Enable flash write */
@@ -29,6 +31,18 @@
 	/* Clear all of the interrupt of BCSR */
 	bcsr[0xe] = 0xff;
 
+#ifdef CONFIG_MMC
+	/* Set SPI_SD, SER_SD, and IRQ4_WP so that SD signals go through */
+	bcsr[0xc] |= 0x4c;
+
+	/* Set proper bits in SICR to allow SD signals through */
+	clrsetbits_be32(&im->sysconf.sicrl, SICRL_USB_B, SICRL_USB_B_SD);
+
+	clrsetbits_be32(&im->sysconf.sicrh, (SICRH_GPIO2_E | SICRH_SPI),
+			(SICRH_GPIO2_E_SD | SICRH_SPI_SD));
+
+#endif
+
 #ifdef CONFIG_FSL_SERDES
 	immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
 	u32 spridr = in_be32(&immr->sysconf.spridr);
@@ -37,25 +51,21 @@
 	switch (PARTID_NO_E(spridr)) {
 	case SPR_8377:
 		fsl_setup_serdes(CONFIG_FSL_SERDES1, FSL_SERDES_PROTO_SATA,
-				 FSL_SERDES_CLK_100, FSL_SERDES_VDD_1V);
-		fsl_setup_serdes(CONFIG_FSL_SERDES2, FSL_SERDES_PROTO_PEX,
-				 FSL_SERDES_CLK_100, FSL_SERDES_VDD_1V);
+				FSL_SERDES_CLK_100, FSL_SERDES_VDD_1V);
 		break;
 	case SPR_8378:
 		fsl_setup_serdes(CONFIG_FSL_SERDES1, FSL_SERDES_PROTO_SGMII,
-				 FSL_SERDES_CLK_125, FSL_SERDES_VDD_1V);
-		fsl_setup_serdes(CONFIG_FSL_SERDES2, FSL_SERDES_PROTO_PEX,
-				 FSL_SERDES_CLK_100, FSL_SERDES_VDD_1V);
+				FSL_SERDES_CLK_125, FSL_SERDES_VDD_1V);
 		break;
 	case SPR_8379:
 		fsl_setup_serdes(CONFIG_FSL_SERDES1, FSL_SERDES_PROTO_SATA,
-				 FSL_SERDES_CLK_100, FSL_SERDES_VDD_1V);
+				FSL_SERDES_CLK_100, FSL_SERDES_VDD_1V);
 		fsl_setup_serdes(CONFIG_FSL_SERDES2, FSL_SERDES_PROTO_SATA,
-				 FSL_SERDES_CLK_100, FSL_SERDES_VDD_1V);
+				FSL_SERDES_CLK_100, FSL_SERDES_VDD_1V);
 		break;
 	default:
 		printf("serdes not configured: unknown CPU part number: "
-		       "%04x\n", spridr >> 16);
+				"%04x\n", spridr >> 16);
 		break;
 	}
 #endif /* CONFIG_FSL_SERDES */
@@ -316,6 +326,7 @@
 	ft_pci_setup(blob, bd);
 	if (board_pci_host_broken())
 		ft_pci_fixup(blob, bd);
+	ft_pcie_fixup(blob, bd);
 #endif
 }
 #endif /* CONFIG_OF_BOARD_SETUP */
diff -Naur u-boot-2009.01/board/freescale/mpc837xemds/pci.c u-boot/board/freescale/mpc837xemds/pci.c
--- u-boot-2009.01/board/freescale/mpc837xemds/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc837xemds/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -16,7 +16,9 @@
 #include <mpc83xx.h>
 #include <pci.h>
 #include <i2c.h>
+#include <fdt_support.h>
 #include <asm/fsl_i2c.h>
+#include <asm/fsl_serdes.h>
 
 #if defined(CONFIG_PCI)
 static struct pci_region pci_regions[] = {
@@ -40,15 +42,59 @@
 	}
 };
 
+static struct pci_region pcie_regions_0[] = {
+	{
+		.bus_start = CONFIG_SYS_PCIE1_MEM_BASE,
+		.phys_start = CONFIG_SYS_PCIE1_MEM_PHYS,
+		.size = CONFIG_SYS_PCIE1_MEM_SIZE,
+		.flags = PCI_REGION_MEM,
+	},
+	{
+		.bus_start = CONFIG_SYS_PCIE1_IO_BASE,
+		.phys_start = CONFIG_SYS_PCIE1_IO_PHYS,
+		.size = CONFIG_SYS_PCIE1_IO_SIZE,
+		.flags = PCI_REGION_IO,
+	},
+};
+
+static struct pci_region pcie_regions_1[] = {
+	{
+		.bus_start = CONFIG_SYS_PCIE2_MEM_BASE,
+		.phys_start = CONFIG_SYS_PCIE2_MEM_PHYS,
+		.size = CONFIG_SYS_PCIE2_MEM_SIZE,
+		.flags = PCI_REGION_MEM,
+	},
+	{
+		.bus_start = CONFIG_SYS_PCIE2_IO_BASE,
+		.phys_start = CONFIG_SYS_PCIE2_IO_PHYS,
+		.size = CONFIG_SYS_PCIE2_IO_SIZE,
+		.flags = PCI_REGION_IO,
+	},
+};
+
+static int is_pex_x2(void)
+{
+	const char *pex_x2 = getenv("pex_x2");
+
+	if (pex_x2 && !strcmp(pex_x2, "yes"))
+		return 1;
+	return 0;
+}
+
 void pci_init_board(void)
 {
 	volatile immap_t *immr = (volatile immap_t *)CONFIG_SYS_IMMR;
+	volatile sysconf83xx_t *sysconf = &immr->sysconf;
 	volatile clk83xx_t *clk = (volatile clk83xx_t *)&immr->clk;
 	volatile law83xx_t *pci_law = immr->sysconf.pcilaw;
+	volatile law83xx_t *pcie_law = sysconf->pcielaw;
 	struct pci_region *reg[] = { pci_regions };
+	struct pci_region *pcie_reg[] = { pcie_regions_0, pcie_regions_1, };
+	u32 spridr = in_be32(&immr->sysconf.spridr);
+	int pex2 = is_pex_x2();
 
 	if (board_pci_host_broken())
-		return;
+		goto skip_pci;
 
 	/* Enable all 5 PCI_CLK_OUTPUTS */
 	clk->occr |= 0xf8000000;
@@ -64,5 +110,46 @@
 	udelay(2000);
 
 	mpc83xx_pci_init(1, reg, 0);
+skip_pci:
+	/* There is no PEX in MPC8379 parts. */
+	if (PARTID_NO_E(spridr) == SPR_8379)
+		return;
+
+	/* Configure the clock for PCIE controller */
+	clrsetbits_be32(&clk->sccr, SCCR_PCIEXP1CM | SCCR_PCIEXP2CM,
+				    SCCR_PCIEXP1CM_1 | SCCR_PCIEXP2CM_1);
+
+	/* Deassert the resets in the control register */
+	out_be32(&sysconf->pecr1, 0xE0008000);
+	if (!pex2)
+		out_be32(&sysconf->pecr2, 0xE0008000);
+	udelay(2000);
+
+	/* Configure PCI Express Local Access Windows */
+	out_be32(&pcie_law[0].bar, CONFIG_SYS_PCIE1_BASE & LAWBAR_BAR);
+	out_be32(&pcie_law[0].ar, LBLAWAR_EN | LBLAWAR_512MB);
+
+	out_be32(&pcie_law[1].bar, CONFIG_SYS_PCIE2_BASE & LAWBAR_BAR);
+	out_be32(&pcie_law[1].ar, LBLAWAR_EN | LBLAWAR_512MB);
+
+	if (pex2)
+		fsl_setup_serdes(CONFIG_FSL_SERDES2, FSL_SERDES_PROTO_PEX_X2,
+				 FSL_SERDES_CLK_100, FSL_SERDES_VDD_1V);
+	else
+		fsl_setup_serdes(CONFIG_FSL_SERDES2, FSL_SERDES_PROTO_PEX,
+				 FSL_SERDES_CLK_100, FSL_SERDES_VDD_1V);
+
+	mpc83xx_pcie_init(pex2 ? 1 : 2, pcie_reg, 0);
+}
+
+void ft_pcie_fixup(void *blob, bd_t *bd)
+{
+	const char *status = "disabled (PCIE1 is x2)";
+
+	if (!is_pex_x2())
+		return;
+
+	do_fixup_by_path(blob, "pci2", "status", status,
+			 strlen(status) + 1, 1);
 }
 #endif /* CONFIG_PCI */
diff -Naur u-boot-2009.01/board/freescale/mpc837xemds/pci.h u-boot/board/freescale/mpc837xemds/pci.h
--- u-boot-2009.01/board/freescale/mpc837xemds/pci.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/freescale/mpc837xemds/pci.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef __BOARD_MPC837XEMDS_PCI_H
+#define __BOARD_MPC837XEMDS_PCI_H
+
+extern void ft_pcie_fixup(void *blob, bd_t *bd);
+
+#endif /* __BOARD_MPC837XEMDS_PCI_H */
diff -Naur u-boot-2009.01/board/freescale/mpc8536ds/ddr.c u-boot/board/freescale/mpc8536ds/ddr.c
--- u-boot-2009.01/board/freescale/mpc8536ds/ddr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8536ds/ddr.c	2009-02-26 14:03:58.000000000 +0100
@@ -79,4 +79,10 @@
 	 *	- number of DIMMs installed
 	 */
 	popts->half_strength_driver_enable = 0;
+
+	/*
+	 * For wake up arp feature, we need enable auto self refresh
+	 */
+	popts->auto_self_refresh_en = 1;
+	popts->sr_it = 0x6;
 }
diff -Naur u-boot-2009.01/board/freescale/mpc8536ds/law.c u-boot/board/freescale/mpc8536ds/law.c
--- u-boot-2009.01/board/freescale/mpc8536ds/law.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8536ds/law.c	2009-02-26 14:03:58.000000000 +0100
@@ -30,14 +30,14 @@
 struct law_entry law_table[] = {
 	SET_LAW(CONFIG_SYS_PCI1_MEM_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_PCI),
 	SET_LAW(CONFIG_SYS_PCI1_IO_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_PCI),
-	SET_LAW(CONFIG_SYS_FLASH_BASE, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
 	SET_LAW(CONFIG_SYS_PCIE1_MEM_PHYS, LAWAR_SIZE_128M, LAW_TRGT_IF_PCIE_1),
 	SET_LAW(CONFIG_SYS_PCIE1_IO_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_PCIE_1),
 	SET_LAW(CONFIG_SYS_PCIE2_MEM_PHYS, LAWAR_SIZE_128M, LAW_TRGT_IF_PCIE_2),
 	SET_LAW(CONFIG_SYS_PCIE2_IO_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_PCIE_2),
 	SET_LAW(CONFIG_SYS_PCIE3_MEM_PHYS, LAWAR_SIZE_512M, LAW_TRGT_IF_PCIE_3),
 	SET_LAW(CONFIG_SYS_PCIE3_IO_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_PCIE_3),
-	SET_LAW(PIXIS_BASE, LAW_SIZE_4K, LAW_TRGT_IF_LBC),
+	SET_LAW(PIXIS_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_LBC),
 	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_LBC),
 };
 
diff -Naur u-boot-2009.01/board/freescale/mpc8536ds/mpc8536ds.c u-boot/board/freescale/mpc8536ds/mpc8536ds.c
--- u-boot-2009.01/board/freescale/mpc8536ds/mpc8536ds.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8536ds/mpc8536ds.c	2009-02-26 14:03:58.000000000 +0100
@@ -37,12 +37,27 @@
 #include <fdt_support.h>
 #include <tsec.h>
 #include <netdev.h>
+#include <sata.h>
 
 #include "../common/pixis.h"
 #include "../common/sgmii_riser.h"
 
 phys_size_t fixed_sdram(void);
 
+int board_early_init_f (void)
+{
+#ifdef CONFIG_MMC
+	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+
+	setbits_be32(&gur->pmuxcr,
+			(MPC85xx_PMUXCR_SD_DATA |
+			 MPC85xx_PMUXCR_SDHC_CD |
+			 MPC85xx_PMUXCR_SDHC_WP));
+
+#endif
+	return 0;
+}
+
 int checkboard (void)
 {
 	printf ("Board: MPC8536DS, System ID: 0x%02x, "
@@ -192,14 +207,14 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE3_MEM_BASE,
+			       CONFIG_SYS_PCIE3_MEM_BUS,
 			       CONFIG_SYS_PCIE3_MEM_PHYS,
 			       CONFIG_SYS_PCIE3_MEM_SIZE,
 			       PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE3_IO_BASE,
+			       CONFIG_SYS_PCIE3_IO_BUS,
 			       CONFIG_SYS_PCIE3_IO_PHYS,
 			       CONFIG_SYS_PCIE3_IO_SIZE,
 			       PCI_REGION_IO);
@@ -247,22 +262,22 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE1_MEM_BASE,
+			       CONFIG_SYS_PCIE1_MEM_BUS,
 			       CONFIG_SYS_PCIE1_MEM_PHYS,
 			       CONFIG_SYS_PCIE1_MEM_SIZE,
 			       PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE1_IO_BASE,
+			       CONFIG_SYS_PCIE1_IO_BUS,
 			       CONFIG_SYS_PCIE1_IO_PHYS,
 			       CONFIG_SYS_PCIE1_IO_SIZE,
 			       PCI_REGION_IO);
 
-#ifdef CONFIG_SYS_PCIE1_MEM_BASE2
+#ifdef CONFIG_SYS_PCIE1_MEM_BUS2
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE1_MEM_BASE2,
+			       CONFIG_SYS_PCIE1_MEM_BUS2,
 			       CONFIG_SYS_PCIE1_MEM_PHYS2,
 			       CONFIG_SYS_PCIE1_MEM_SIZE2,
 			       PCI_REGION_MEM);
@@ -310,22 +325,22 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE2_MEM_BASE,
+			       CONFIG_SYS_PCIE2_MEM_BUS,
 			       CONFIG_SYS_PCIE2_MEM_PHYS,
 			       CONFIG_SYS_PCIE2_MEM_SIZE,
 			       PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE2_IO_BASE,
+			       CONFIG_SYS_PCIE2_IO_BUS,
 			       CONFIG_SYS_PCIE2_IO_PHYS,
 			       CONFIG_SYS_PCIE2_IO_SIZE,
 			       PCI_REGION_IO);
 
-#ifdef CONFIG_SYS_PCIE2_MEM_BASE2
+#ifdef CONFIG_SYS_PCIE2_MEM_BUS2
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE2_MEM_BASE2,
+			       CONFIG_SYS_PCIE2_MEM_BUS2,
 			       CONFIG_SYS_PCIE2_MEM_PHYS2,
 			       CONFIG_SYS_PCIE2_MEM_SIZE2,
 			       PCI_REGION_MEM);
@@ -378,22 +393,22 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCI1_MEM_BASE,
+			       CONFIG_SYS_PCI1_MEM_BUS,
 			       CONFIG_SYS_PCI1_MEM_PHYS,
 			       CONFIG_SYS_PCI1_MEM_SIZE,
 			       PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCI1_IO_BASE,
+			       CONFIG_SYS_PCI1_IO_BUS,
 			       CONFIG_SYS_PCI1_IO_PHYS,
 			       CONFIG_SYS_PCI1_IO_SIZE,
 			       PCI_REGION_IO);
 
-#ifdef CONFIG_SYS_PCI1_MEM_BASE2
+#ifdef CONFIG_SYS_PCI1_MEM_BUS2
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCI1_MEM_BASE2,
+			       CONFIG_SYS_PCI1_MEM_BUS2,
 			       CONFIG_SYS_PCI1_MEM_PHYS2,
 			       CONFIG_SYS_PCI1_MEM_SIZE2,
 			       PCI_REGION_MEM);
@@ -433,7 +448,7 @@
 	/* invalidate existing TLB entry for flash + promjet */
 	disable_tlb(flash_esel);
 
-	set_tlb(1, flashbase, flashbase,		/* tlb, epn, rpn */
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,	/* tlb, epn, rpn */
 		MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,	/* perms, wimge */
 		0, flash_esel, BOOKE_PAGESZ_256M, 1);	/* ts, esel, tsize, iprot */
 
@@ -582,15 +597,15 @@
 }
 #endif
 
-int is_sata_supported(void)
+int sata_initialize(void)
 {
 	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
 	uint sdrs2_io_sel =
 		(gur->pordevsr & MPC85xx_PORDEVSR_SRDS2_IO_SEL) >> 27;
 	if (sdrs2_io_sel & 0x04)
-		return 0;
+		return 1;
 
-	return 1;
+	return __sata_initialize();
 }
 
 int board_eth_init(bd_t *bis)
@@ -624,8 +639,10 @@
 		return 0;
 	}
 
+#ifdef CONFIG_FSL_SGMII_RISER
 	if ((sdrs2_io_sel == 4) || (sdrs2_io_sel == 6))
 		fsl_sgmii_riser_init(tsec_info, num);
+#endif
 
 	tsec_eth_init(bis, tsec_info, num);
 #endif
@@ -652,5 +669,8 @@
 #ifdef CONFIG_PCIE1
 	ft_fsl_pci_setup(blob, "pci3", &pcie3_hose);
 #endif
+#ifdef CONFIG_FSL_SGMII_RISER
+	fsl_sgmii_riser_fdt_fixup(blob);
+#endif
 }
 #endif
diff -Naur u-boot-2009.01/board/freescale/mpc8536ds/tlb.c u-boot/board/freescale/mpc8536ds/tlb.c
--- u-boot-2009.01/board/freescale/mpc8536ds/tlb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8536ds/tlb.c	2009-02-26 14:03:58.000000000 +0100
@@ -41,7 +41,7 @@
 		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
 		      0, 0, BOOKE_PAGESZ_4K, 0),
 
-	SET_TLB_ENTRY(0, PIXIS_BASE, PIXIS_BASE,
+	SET_TLB_ENTRY(0, PIXIS_BASE, PIXIS_BASE_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 0, BOOKE_PAGESZ_4K, 0),
 
@@ -53,17 +53,17 @@
 
 	/* W**G* - Flash/promjet, localbus */
 	/* This will be changed to *I*G* after relocation to RAM. */
-	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE,
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
 		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
 		      0, 1, BOOKE_PAGESZ_256M, 1),
 
 	/* *I*G* - PCI */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_PHYS, CONFIG_SYS_PCI1_MEM_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT, CONFIG_SYS_PCI1_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 2, BOOKE_PAGESZ_1G, 1),
 
 	/* *I*G* - PCI I/O */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_IO_PHYS, CONFIG_SYS_PCI1_IO_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_IO_VIRT, CONFIG_SYS_PCI1_IO_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 3, BOOKE_PAGESZ_256K, 1),
 
diff -Naur u-boot-2009.01/board/freescale/mpc8540ads/ddr.c u-boot/board/freescale/mpc8540ads/ddr.c
--- u-boot-2009.01/board/freescale/mpc8540ads/ddr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8540ads/ddr.c	2009-02-26 14:03:58.000000000 +0100
@@ -65,6 +65,9 @@
 	 */
 	popts->write_data_delay = 3;
 
+	/* 2T timing enable */
+	popts->twoT_en = 1;
+
 	/*
 	 * Factors to consider for half-strength driver enable:
 	 *	- number of DIMMs installed
diff -Naur u-boot-2009.01/board/freescale/mpc8540ads/law.c u-boot/board/freescale/mpc8540ads/law.c
--- u-boot-2009.01/board/freescale/mpc8540ads/law.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8540ads/law.c	2009-02-26 14:03:58.000000000 +0100
@@ -52,7 +52,7 @@
 	/* This is not so much the SDRAM map as it is the whole localbus map. */
 	SET_LAW(CONFIG_SYS_LBC_SDRAM_BASE, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
 	SET_LAW(CONFIG_SYS_PCI1_IO_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_PCI),
-	SET_LAW(CONFIG_SYS_RIO_MEM_BASE, LAWAR_SIZE_512M, LAW_TRGT_IF_RIO),
+	SET_LAW(CONFIG_SYS_RIO_MEM_PHYS, LAWAR_SIZE_512M, LAW_TRGT_IF_RIO),
 };
 
 int num_law_entries = ARRAY_SIZE(law_table);
diff -Naur u-boot-2009.01/board/freescale/mpc8540ads/tlb.c u-boot/board/freescale/mpc8540ads/tlb.c
--- u-boot-2009.01/board/freescale/mpc8540ads/tlb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8540ads/tlb.c	2009-02-26 14:03:58.000000000 +0100
@@ -54,7 +54,7 @@
 	 * TLB 1:	256M	Non-cacheable, guarded
 	 * 0x80000000	256M	PCI1 MEM First half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_PHYS, CONFIG_SYS_PCI1_MEM_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT, CONFIG_SYS_PCI1_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 1, BOOKE_PAGESZ_256M, 1),
 
@@ -62,7 +62,7 @@
 	 * TLB 2:	256M	Non-cacheable, guarded
 	 * 0x90000000	256M	PCI1 MEM Second half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT + 0x10000000, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 2, BOOKE_PAGESZ_256M, 1),
 
@@ -70,7 +70,7 @@
 	 * TLB 3:	256M	Non-cacheable, guarded
 	 * 0xc0000000	256M	Rapid IO MEM First half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_BASE, CONFIG_SYS_RIO_MEM_BASE,
+	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_VIRT, CONFIG_SYS_RIO_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 3, BOOKE_PAGESZ_256M, 1),
 
@@ -78,7 +78,7 @@
 	 * TLB 4:	256M	Non-cacheable, guarded
 	 * 0xd0000000	256M	Rapid IO MEM Second half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_BASE + 0x10000000, CONFIG_SYS_RIO_MEM_BASE + 0x10000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_VIRT + 0x10000000, CONFIG_SYS_RIO_MEM_PHYS + 0x10000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 4, BOOKE_PAGESZ_256M, 1),
 
diff -Naur u-boot-2009.01/board/freescale/mpc8541cds/tlb.c u-boot/board/freescale/mpc8541cds/tlb.c
--- u-boot-2009.01/board/freescale/mpc8541cds/tlb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8541cds/tlb.c	2009-02-26 14:03:58.000000000 +0100
@@ -54,7 +54,7 @@
 	 * TLB 1:	256M	Non-cacheable, guarded
 	 * 0x80000000	256M	PCI1 MEM First half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_PHYS, CONFIG_SYS_PCI1_MEM_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT, CONFIG_SYS_PCI1_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 1, BOOKE_PAGESZ_256M, 1),
 
@@ -62,7 +62,7 @@
 	 * TLB 2:	256M	Non-cacheable, guarded
 	 * 0x90000000	256M	PCI1 MEM Second half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT + 0x10000000, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 2, BOOKE_PAGESZ_256M, 1),
 
@@ -70,7 +70,7 @@
 	 * TLB 3:	256M	Non-cacheable, guarded
 	 * 0xa0000000	256M	PCI2 MEM First half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI2_MEM_PHYS, CONFIG_SYS_PCI2_MEM_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI2_MEM_VIRT, CONFIG_SYS_PCI2_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 3, BOOKE_PAGESZ_256M, 1),
 
@@ -78,7 +78,7 @@
 	 * TLB 4:	256M	Non-cacheable, guarded
 	 * 0xb0000000	256M	PCI2 MEM Second half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI2_MEM_PHYS + 0x10000000, CONFIG_SYS_PCI2_MEM_PHYS + 0x10000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI2_MEM_VIRT + 0x10000000, CONFIG_SYS_PCI2_MEM_PHYS + 0x10000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 4, BOOKE_PAGESZ_256M, 1),
 
diff -Naur u-boot-2009.01/board/freescale/mpc8544ds/ddr.c u-boot/board/freescale/mpc8544ds/ddr.c
--- u-boot-2009.01/board/freescale/mpc8544ds/ddr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8544ds/ddr.c	2009-02-26 14:03:58.000000000 +0100
@@ -75,6 +75,9 @@
 	 */
 	popts->write_data_delay = 3;
 
+	/* 2T timing enable */
+	popts->twoT_en = 1;
+
 	/*
 	 * Factors to consider for half-strength driver enable:
 	 *	- number of DIMMs installed
diff -Naur u-boot-2009.01/board/freescale/mpc8544ds/mpc8544ds.c u-boot/board/freescale/mpc8544ds/mpc8544ds.c
--- u-boot-2009.01/board/freescale/mpc8544ds/mpc8544ds.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8544ds/mpc8544ds.c	2009-02-26 14:03:58.000000000 +0100
@@ -139,22 +139,22 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE3_MEM_BASE,
+			       CONFIG_SYS_PCIE3_MEM_BUS,
 			       CONFIG_SYS_PCIE3_MEM_PHYS,
 			       CONFIG_SYS_PCIE3_MEM_SIZE,
 			       PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE3_IO_BASE,
+			       CONFIG_SYS_PCIE3_IO_BUS,
 			       CONFIG_SYS_PCIE3_IO_PHYS,
 			       CONFIG_SYS_PCIE3_IO_SIZE,
 			       PCI_REGION_IO);
 
-#ifdef CONFIG_SYS_PCIE3_MEM_BASE2
+#ifdef CONFIG_SYS_PCIE3_MEM_BUS2
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE3_MEM_BASE2,
+			       CONFIG_SYS_PCIE3_MEM_BUS2,
 			       CONFIG_SYS_PCIE3_MEM_PHYS2,
 			       CONFIG_SYS_PCIE3_MEM_SIZE2,
 			       PCI_REGION_MEM);
@@ -173,7 +173,7 @@
 		 * Activate ULI1575 legacy chip by performing a fake
 		 * memory access.  Needed to make ULI RTC work.
 		 */
-		in_be32((u32 *)CONFIG_SYS_PCIE3_MEM_BASE);
+		in_be32((u32 *)CONFIG_SYS_PCIE3_MEM_BUS);
 	} else {
 		printf ("    PCIE3: disabled\n");
 	}
@@ -206,22 +206,22 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE1_MEM_BASE,
+			       CONFIG_SYS_PCIE1_MEM_BUS,
 			       CONFIG_SYS_PCIE1_MEM_PHYS,
 			       CONFIG_SYS_PCIE1_MEM_SIZE,
 			       PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE1_IO_BASE,
+			       CONFIG_SYS_PCIE1_IO_BUS,
 			       CONFIG_SYS_PCIE1_IO_PHYS,
 			       CONFIG_SYS_PCIE1_IO_SIZE,
 			       PCI_REGION_IO);
 
-#ifdef CONFIG_SYS_PCIE1_MEM_BASE2
+#ifdef CONFIG_SYS_PCIE1_MEM_BUS2
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE1_MEM_BASE2,
+			       CONFIG_SYS_PCIE1_MEM_BUS2,
 			       CONFIG_SYS_PCIE1_MEM_PHYS2,
 			       CONFIG_SYS_PCIE1_MEM_SIZE2,
 			       PCI_REGION_MEM);
@@ -269,22 +269,22 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE2_MEM_BASE,
+			       CONFIG_SYS_PCIE2_MEM_BUS,
 			       CONFIG_SYS_PCIE2_MEM_PHYS,
 			       CONFIG_SYS_PCIE2_MEM_SIZE,
 			       PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE2_IO_BASE,
+			       CONFIG_SYS_PCIE2_IO_BUS,
 			       CONFIG_SYS_PCIE2_IO_PHYS,
 			       CONFIG_SYS_PCIE2_IO_SIZE,
 			       PCI_REGION_IO);
 
-#ifdef CONFIG_SYS_PCIE2_MEM_BASE2
+#ifdef CONFIG_SYS_PCIE2_MEM_BUS2
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE2_MEM_BASE2,
+			       CONFIG_SYS_PCIE2_MEM_BUS2,
 			       CONFIG_SYS_PCIE2_MEM_PHYS2,
 			       CONFIG_SYS_PCIE2_MEM_SIZE2,
 			       PCI_REGION_MEM);
@@ -337,22 +337,22 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCI1_MEM_BASE,
+			       CONFIG_SYS_PCI1_MEM_BUS,
 			       CONFIG_SYS_PCI1_MEM_PHYS,
 			       CONFIG_SYS_PCI1_MEM_SIZE,
 			       PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCI1_IO_BASE,
+			       CONFIG_SYS_PCI1_IO_BUS,
 			       CONFIG_SYS_PCI1_IO_PHYS,
 			       CONFIG_SYS_PCI1_IO_SIZE,
 			       PCI_REGION_IO);
 
-#ifdef CONFIG_SYS_PCIE3_MEM_BASE2
+#ifdef CONFIG_SYS_PCIE3_MEM_BUS2
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE3_MEM_BASE2,
+			       CONFIG_SYS_PCIE3_MEM_BUS2,
 			       CONFIG_SYS_PCIE3_MEM_PHYS2,
 			       CONFIG_SYS_PCIE3_MEM_SIZE2,
 			       PCI_REGION_MEM);
@@ -497,5 +497,8 @@
 #ifdef CONFIG_PCIE3
 	ft_fsl_pci_setup(blob, "pci3", &pcie2_hose);
 #endif
+#ifdef CONFIG_FSL_SGMII_RISER
+	fsl_sgmii_riser_fdt_fixup(blob);
+#endif
 }
 #endif
diff -Naur u-boot-2009.01/board/freescale/mpc8544ds/tlb.c u-boot/board/freescale/mpc8544ds/tlb.c
--- u-boot-2009.01/board/freescale/mpc8544ds/tlb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8544ds/tlb.c	2009-02-26 14:03:58.000000000 +0100
@@ -52,21 +52,21 @@
 	 * TLB 1:	1G	Non-cacheable, guarded
 	 * 0x80000000	1G	PCIE  8,9,a,b
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE_PHYS, CONFIG_SYS_PCIE_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE_VIRT, CONFIG_SYS_PCIE_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 1, BOOKE_PAGESZ_1G, 1),
 
 	/*
 	 * TLB 2:	256M	Non-cacheable, guarded
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI_PHYS, CONFIG_SYS_PCI_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI_VIRT, CONFIG_SYS_PCI_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 2, BOOKE_PAGESZ_256M, 1),
 
 	/*
 	 * TLB 3:	256M	Non-cacheable, guarded
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI_PHYS + 0x10000000, CONFIG_SYS_PCI_PHYS + 0x10000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI_VIRT + 0x10000000, CONFIG_SYS_PCI_PHYS + 0x10000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 3, BOOKE_PAGESZ_256M, 1),
 
diff -Naur u-boot-2009.01/board/freescale/mpc8548cds/mpc8548cds.c u-boot/board/freescale/mpc8548cds/mpc8548cds.c
--- u-boot-2009.01/board/freescale/mpc8548cds/mpc8548cds.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8548cds/mpc8548cds.c	2009-02-26 14:03:58.000000000 +0100
@@ -306,14 +306,14 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCI1_MEM_BASE,
+			       CONFIG_SYS_PCI1_MEM_BUS,
 			       CONFIG_SYS_PCI1_MEM_PHYS,
 			       CONFIG_SYS_PCI1_MEM_SIZE,
 			       PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCI1_IO_BASE,
+			       CONFIG_SYS_PCI1_IO_BUS,
 			       CONFIG_SYS_PCI1_IO_PHYS,
 			       CONFIG_SYS_PCI1_IO_SIZE,
 			       PCI_REGION_IO);
@@ -390,14 +390,14 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE1_MEM_BASE,
+			       CONFIG_SYS_PCIE1_MEM_BUS,
 			       CONFIG_SYS_PCIE1_MEM_PHYS,
 			       CONFIG_SYS_PCIE1_MEM_SIZE,
 			       PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCIE1_IO_BASE,
+			       CONFIG_SYS_PCIE1_IO_BUS,
 			       CONFIG_SYS_PCIE1_IO_PHYS,
 			       CONFIG_SYS_PCIE1_IO_SIZE,
 			       PCI_REGION_IO);
diff -Naur u-boot-2009.01/board/freescale/mpc8548cds/tlb.c u-boot/board/freescale/mpc8548cds/tlb.c
--- u-boot-2009.01/board/freescale/mpc8548cds/tlb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8548cds/tlb.c	2009-02-26 14:03:58.000000000 +0100
@@ -54,7 +54,7 @@
 	 * TLB 1:	1G	Non-cacheable, guarded
 	 * 0x80000000	1G	PCI1/PCIE  8,9,a,b
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI_PHYS, CONFIG_SYS_PCI_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI_VIRT, CONFIG_SYS_PCI_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 1, BOOKE_PAGESZ_1G, 1),
 
@@ -62,14 +62,14 @@
 	/*
 	 * TLB 2:	256M	Non-cacheable, guarded
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_BASE, CONFIG_SYS_RIO_MEM_BASE,
+	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_VIRT, CONFIG_SYS_RIO_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 2, BOOKE_PAGESZ_256M, 1),
 
 	/*
 	 * TLB 3:	256M	Non-cacheable, guarded
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_BASE + 0x10000000, CONFIG_SYS_RIO_MEM_BASE + 0x10000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_VIRT + 0x10000000, CONFIG_SYS_RIO_MEM_PHYS + 0x10000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 3, BOOKE_PAGESZ_256M, 1),
 #endif
diff -Naur u-boot-2009.01/board/freescale/mpc8555cds/tlb.c u-boot/board/freescale/mpc8555cds/tlb.c
--- u-boot-2009.01/board/freescale/mpc8555cds/tlb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8555cds/tlb.c	2009-02-26 14:03:58.000000000 +0100
@@ -54,7 +54,7 @@
 	 * TLB 1:	256M	Non-cacheable, guarded
 	 * 0x80000000	256M	PCI1 MEM First half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_PHYS, CONFIG_SYS_PCI1_MEM_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT, CONFIG_SYS_PCI1_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 1, BOOKE_PAGESZ_256M, 1),
 
@@ -62,7 +62,7 @@
 	 * TLB 2:	256M	Non-cacheable, guarded
 	 * 0x90000000	256M	PCI1 MEM Second half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT + 0x10000000, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 2, BOOKE_PAGESZ_256M, 1),
 
@@ -70,7 +70,7 @@
 	 * TLB 3:	256M	Non-cacheable, guarded
 	 * 0xa0000000	256M	PCI2 MEM First half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI2_MEM_PHYS, CONFIG_SYS_PCI2_MEM_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI2_MEM_VIRT, CONFIG_SYS_PCI2_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 3, BOOKE_PAGESZ_256M, 1),
 
@@ -78,7 +78,7 @@
 	 * TLB 4:	256M	Non-cacheable, guarded
 	 * 0xb0000000	256M	PCI2 MEM Second half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI2_MEM_PHYS + 0x10000000, CONFIG_SYS_PCI2_MEM_PHYS + 0x10000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI2_MEM_VIRT + 0x10000000, CONFIG_SYS_PCI2_MEM_PHYS + 0x10000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 4, BOOKE_PAGESZ_256M, 1),
 
diff -Naur u-boot-2009.01/board/freescale/mpc8560ads/ddr.c u-boot/board/freescale/mpc8560ads/ddr.c
--- u-boot-2009.01/board/freescale/mpc8560ads/ddr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8560ads/ddr.c	2009-02-26 14:03:58.000000000 +0100
@@ -65,6 +65,9 @@
 	 */
 	popts->write_data_delay = 3;
 
+	/* 2T timing enable */
+	popts->twoT_en = 1;
+
 	/*
 	 * Factors to consider for half-strength driver enable:
 	 *	- number of DIMMs installed
diff -Naur u-boot-2009.01/board/freescale/mpc8560ads/law.c u-boot/board/freescale/mpc8560ads/law.c
--- u-boot-2009.01/board/freescale/mpc8560ads/law.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8560ads/law.c	2009-02-26 14:03:58.000000000 +0100
@@ -52,7 +52,7 @@
 	/* This is not so much the SDRAM map as it is the whole localbus map. */
 	SET_LAW(CONFIG_SYS_LBC_SDRAM_BASE, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
 	SET_LAW(CONFIG_SYS_PCI1_IO_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_PCI),
-	SET_LAW(CONFIG_SYS_RIO_MEM_BASE, LAWAR_SIZE_512M, LAW_TRGT_IF_RIO),
+	SET_LAW(CONFIG_SYS_RIO_MEM_PHYS, LAWAR_SIZE_512M, LAW_TRGT_IF_RIO),
 };
 
 int num_law_entries = ARRAY_SIZE(law_table);
diff -Naur u-boot-2009.01/board/freescale/mpc8560ads/tlb.c u-boot/board/freescale/mpc8560ads/tlb.c
--- u-boot-2009.01/board/freescale/mpc8560ads/tlb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8560ads/tlb.c	2009-02-26 14:03:58.000000000 +0100
@@ -54,7 +54,7 @@
 	 * TLB 1:	256M	Non-cacheable, guarded
 	 * 0x80000000	256M	PCI1 MEM First half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_PHYS, CONFIG_SYS_PCI1_MEM_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT, CONFIG_SYS_PCI1_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 1, BOOKE_PAGESZ_256M, 1),
 
@@ -62,7 +62,7 @@
 	 * TLB 2:	256M	Non-cacheable, guarded
 	 * 0x90000000	256M	PCI1 MEM Second half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT + 0x10000000, CONFIG_SYS_PCI1_MEM_PHYS + 0x10000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 2, BOOKE_PAGESZ_256M, 1),
 
@@ -70,7 +70,7 @@
 	 * TLB 3:	256M	Non-cacheable, guarded
 	 * 0xc0000000	256M	Rapid IO MEM First half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_BASE, CONFIG_SYS_RIO_MEM_BASE,
+	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_VIRT, CONFIG_SYS_RIO_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 3, BOOKE_PAGESZ_256M, 1),
 
@@ -78,7 +78,7 @@
 	 * TLB 4:	256M	Non-cacheable, guarded
 	 * 0xd0000000	256M	Rapid IO MEM Second half
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_BASE + 0x10000000, CONFIG_SYS_RIO_MEM_BASE + 0x10000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_RIO_MEM_VIRT + 0x10000000, CONFIG_SYS_RIO_MEM_PHYS + 0x10000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 4, BOOKE_PAGESZ_256M, 1),
 
diff -Naur u-boot-2009.01/board/freescale/mpc8568mds/law.c u-boot/board/freescale/mpc8568mds/law.c
--- u-boot-2009.01/board/freescale/mpc8568mds/law.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8568mds/law.c	2009-02-26 14:03:58.000000000 +0100
@@ -54,7 +54,7 @@
 	SET_LAW(CONFIG_SYS_PCIE1_MEM_PHYS, LAW_SIZE_512M, LAW_TRGT_IF_PCIE_1),
 	SET_LAW(CONFIG_SYS_PCI1_IO_PHYS, LAW_SIZE_8M, LAW_TRGT_IF_PCI),
 	SET_LAW(CONFIG_SYS_PCIE1_IO_PHYS, LAW_SIZE_8M, LAW_TRGT_IF_PCIE_1),
-	SET_LAW(CONFIG_SYS_SRIO_MEM_BASE, LAW_SIZE_512M, LAW_TRGT_IF_RIO),
+	SET_LAW(CONFIG_SYS_SRIO_MEM_PHYS, LAW_SIZE_512M, LAW_TRGT_IF_RIO),
 	/* LBC window - maps 256M.  That's SDRAM, BCSR, PIBs, and Flash */
 	SET_LAW(CONFIG_SYS_LBC_SDRAM_BASE, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
 };
diff -Naur u-boot-2009.01/board/freescale/mpc8568mds/mpc8568mds.c u-boot/board/freescale/mpc8568mds/mpc8568mds.c
--- u-boot-2009.01/board/freescale/mpc8568mds/mpc8568mds.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8568mds/mpc8568mds.c	2009-02-26 14:03:58.000000000 +0100
@@ -397,14 +397,14 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-				CONFIG_SYS_PCI1_MEM_BASE,
+				CONFIG_SYS_PCI1_MEM_BUS,
 				CONFIG_SYS_PCI1_MEM_PHYS,
 				CONFIG_SYS_PCI1_MEM_SIZE,
 				PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-				CONFIG_SYS_PCI1_IO_BASE,
+				CONFIG_SYS_PCI1_IO_BUS,
 				CONFIG_SYS_PCI1_IO_PHYS,
 				CONFIG_SYS_PCI1_IO_SIZE,
 				PCI_REGION_IO);
@@ -450,14 +450,14 @@
 
 		/* outbound memory */
 		pci_set_region(r++,
-				CONFIG_SYS_PCIE1_MEM_BASE,
+				CONFIG_SYS_PCIE1_MEM_BUS,
 				CONFIG_SYS_PCIE1_MEM_PHYS,
 				CONFIG_SYS_PCIE1_MEM_SIZE,
 				PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-				CONFIG_SYS_PCIE1_IO_BASE,
+				CONFIG_SYS_PCIE1_IO_BUS,
 				CONFIG_SYS_PCIE1_IO_PHYS,
 				CONFIG_SYS_PCIE1_IO_SIZE,
 				PCI_REGION_IO);
diff -Naur u-boot-2009.01/board/freescale/mpc8568mds/tlb.c u-boot/board/freescale/mpc8568mds/tlb.c
--- u-boot-2009.01/board/freescale/mpc8568mds/tlb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8568mds/tlb.c	2009-02-26 14:03:58.000000000 +0100
@@ -64,7 +64,7 @@
 	 * 0x80000000	512M	PCI1 MEM
 	 * 0xa0000000	512M	PCIe MEM
 	 */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_PHYS, CONFIG_SYS_PCI1_MEM_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCI1_MEM_VIRT, CONFIG_SYS_PCI1_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 2, BOOKE_PAGESZ_1G, 1),
 
diff -Naur u-boot-2009.01/board/freescale/mpc8572ds/law.c u-boot/board/freescale/mpc8572ds/law.c
--- u-boot-2009.01/board/freescale/mpc8572ds/law.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8572ds/law.c	2009-02-26 14:03:58.000000000 +0100
@@ -28,14 +28,14 @@
 #include <asm/mmu.h>
 
 struct law_entry law_table[] = {
-	SET_LAW(CONFIG_SYS_FLASH_BASE, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
 	SET_LAW(CONFIG_SYS_PCIE1_MEM_PHYS, LAWAR_SIZE_512M, LAW_TRGT_IF_PCIE_1),
 	SET_LAW(CONFIG_SYS_PCIE1_IO_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_PCIE_1),
 	SET_LAW(CONFIG_SYS_PCIE2_MEM_PHYS, LAWAR_SIZE_512M, LAW_TRGT_IF_PCIE_2),
 	SET_LAW(CONFIG_SYS_PCIE2_IO_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_PCIE_2),
 	SET_LAW(CONFIG_SYS_PCIE3_MEM_PHYS, LAWAR_SIZE_512M, LAW_TRGT_IF_PCIE_3),
 	SET_LAW(CONFIG_SYS_PCIE3_IO_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_PCIE_3),
-	SET_LAW(PIXIS_BASE, LAW_SIZE_4K, LAW_TRGT_IF_LBC),
+	SET_LAW(PIXIS_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_LBC),
 	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_LBC),
 };
 
diff -Naur u-boot-2009.01/board/freescale/mpc8572ds/mpc8572ds.c u-boot/board/freescale/mpc8572ds/mpc8572ds.c
--- u-boot-2009.01/board/freescale/mpc8572ds/mpc8572ds.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8572ds/mpc8572ds.c	2009-02-26 14:03:58.000000000 +0100
@@ -42,8 +42,12 @@
 
 int checkboard (void)
 {
-	printf ("Board: MPC8572DS, System ID: 0x%02x, "
-		"System Version: 0x%02x, FPGA Version: 0x%02x\n",
+	puts ("Board: MPC8572DS ");
+#ifdef CONFIG_PHYS_64BIT
+	puts ("(36-bit addrmap) ");
+#endif
+	printf ("Sys ID: 0x%02x, "
+		"Sys Ver: 0x%02x, FPGA Ver: 0x%02x\n",
 		in8(PIXIS_BASE + PIXIS_ID), in8(PIXIS_BASE + PIXIS_VER),
 		in8(PIXIS_BASE + PIXIS_PVER));
 	return 0;
@@ -185,14 +189,14 @@
 
 			/* outbound memory */
 			pci_set_region(r++,
-					CONFIG_SYS_PCIE3_MEM_BASE,
+					CONFIG_SYS_PCIE3_MEM_BUS,
 					CONFIG_SYS_PCIE3_MEM_PHYS,
 					CONFIG_SYS_PCIE3_MEM_SIZE,
 					PCI_REGION_MEM);
 
 			/* outbound io */
 			pci_set_region(r++,
-					CONFIG_SYS_PCIE3_IO_BASE,
+					CONFIG_SYS_PCIE3_IO_BUS,
 					CONFIG_SYS_PCIE3_IO_PHYS,
 					CONFIG_SYS_PCIE3_IO_SIZE,
 					PCI_REGION_IO);
@@ -215,9 +219,11 @@
 
 			pci_hose_read_config_dword(hose, PCI_BDF(2, 0x1d, 0 ),
 					PCI_BASE_ADDRESS_1, &temp32);
-			if (temp32 >= CONFIG_SYS_PCIE3_MEM_PHYS) {
-				debug(" uli1572 read to %x\n", temp32);
-				in_be32((unsigned *)temp32);
+			if (temp32 >= CONFIG_SYS_PCIE3_MEM_BUS) {
+				void *p = pci_mem_to_virt(PCI_BDF(2, 0x1d, 0),
+								temp32, 4, 0);
+				debug(" uli1572 read to %p\n", p);
+				in_be32(p);
 			}
 		} else {
 			printf ("    PCIE3: disabled\n");
@@ -252,14 +258,14 @@
 
 			/* outbound memory */
 			pci_set_region(r++,
-					CONFIG_SYS_PCIE2_MEM_BASE,
+					CONFIG_SYS_PCIE2_MEM_BUS,
 					CONFIG_SYS_PCIE2_MEM_PHYS,
 					CONFIG_SYS_PCIE2_MEM_SIZE,
 					PCI_REGION_MEM);
 
 			/* outbound io */
 			pci_set_region(r++,
-					CONFIG_SYS_PCIE2_IO_BASE,
+					CONFIG_SYS_PCIE2_IO_BUS,
 					CONFIG_SYS_PCIE2_IO_PHYS,
 					CONFIG_SYS_PCIE2_IO_SIZE,
 					PCI_REGION_IO);
@@ -307,14 +313,14 @@
 
 			/* outbound memory */
 			pci_set_region(r++,
-					CONFIG_SYS_PCIE1_MEM_BASE,
+					CONFIG_SYS_PCIE1_MEM_BUS,
 					CONFIG_SYS_PCIE1_MEM_PHYS,
 					CONFIG_SYS_PCIE1_MEM_SIZE,
 					PCI_REGION_MEM);
 
 			/* outbound io */
 			pci_set_region(r++,
-					CONFIG_SYS_PCIE1_IO_BASE,
+					CONFIG_SYS_PCIE1_IO_BUS,
 					CONFIG_SYS_PCIE1_IO_PHYS,
 					CONFIG_SYS_PCIE1_IO_SIZE,
 					PCI_REGION_IO);
@@ -358,7 +364,7 @@
 	/* invalidate existing TLB entry for flash + promjet */
 	disable_tlb(flash_esel);
 
-	set_tlb(1, flashbase, flashbase,		/* tlb, epn, rpn */
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,	/* tlb, epn, rpn */
 			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,	/* perms, wimge */
 			0, flash_esel, BOOKE_PAGESZ_256M, 1);	/* ts, esel, tsize, iprot */
 
@@ -540,7 +546,9 @@
 		return 0;
 	}
 
+#ifdef CONFIG_FSL_SGMII_RISER
 	fsl_sgmii_riser_init(tsec_info, num);
+#endif
 
 	tsec_eth_init(bis, tsec_info, num);
 
@@ -554,7 +562,8 @@
 
 void ft_board_setup(void *blob, bd_t *bd)
 {
-	ulong base, size;
+	phys_addr_t base;
+	phys_size_t size;
 
 	ft_cpu_setup(blob, bd);
 
@@ -572,6 +581,9 @@
 #ifdef CONFIG_PCIE1
 	ft_fsl_pci_setup(blob, "pci2", &pcie1_hose);
 #endif
+#ifdef CONFIG_FSL_SGMII_RISER
+	fsl_sgmii_riser_fdt_fixup(blob);
+#endif
 }
 #endif
 
diff -Naur u-boot-2009.01/board/freescale/mpc8572ds/tlb.c u-boot/board/freescale/mpc8572ds/tlb.c
--- u-boot-2009.01/board/freescale/mpc8572ds/tlb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8572ds/tlb.c	2009-02-26 14:03:58.000000000 +0100
@@ -54,26 +54,26 @@
 
 	/* W**G* - Flash/promjet, localbus */
 	/* This will be changed to *I*G* after relocation to RAM. */
-	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE,
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
 		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
 		      0, 2, BOOKE_PAGESZ_256M, 1),
 
 	/* *I*G* - PCI */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_PHYS, CONFIG_SYS_PCIE3_MEM_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_VIRT, CONFIG_SYS_PCIE3_MEM_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 3, BOOKE_PAGESZ_1G, 1),
 
 	/* *I*G* - PCI */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_PHYS + 0x40000000, CONFIG_SYS_PCIE3_MEM_PHYS + 0x40000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_VIRT + 0x40000000, CONFIG_SYS_PCIE3_MEM_PHYS + 0x40000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 4, BOOKE_PAGESZ_256M, 1),
 
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_PHYS + 0x50000000, CONFIG_SYS_PCIE3_MEM_PHYS + 0x50000000,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_VIRT + 0x50000000, CONFIG_SYS_PCIE3_MEM_PHYS + 0x50000000,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 5, BOOKE_PAGESZ_256M, 1),
 
 	/* *I*G* - PCI I/O */
-	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_IO_PHYS, CONFIG_SYS_PCIE3_IO_PHYS,
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_IO_VIRT, CONFIG_SYS_PCIE3_IO_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 6, BOOKE_PAGESZ_256K, 1),
 
@@ -82,7 +82,7 @@
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 7, BOOKE_PAGESZ_1M, 1),
 
-	SET_TLB_ENTRY(1, PIXIS_BASE, PIXIS_BASE,
+	SET_TLB_ENTRY(1, PIXIS_BASE, PIXIS_BASE_PHYS,
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 8, BOOKE_PAGESZ_4K, 1),
 };
diff -Naur u-boot-2009.01/board/freescale/mpc8610hpcd/ddr.c u-boot/board/freescale/mpc8610hpcd/ddr.c
--- u-boot-2009.01/board/freescale/mpc8610hpcd/ddr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8610hpcd/ddr.c	2009-02-26 14:03:58.000000000 +0100
@@ -74,6 +74,9 @@
 	 */
 	popts->write_data_delay = 3;
 
+	/* 2T timing enable */
+	popts->twoT_en = 1;
+
 	/*
 	 * Factors to consider for half-strength driver enable:
 	 *	- number of DIMMs installed
diff -Naur u-boot-2009.01/board/freescale/mpc8610hpcd/mpc8610hpcd.c u-boot/board/freescale/mpc8610hpcd/mpc8610hpcd.c
--- u-boot-2009.01/board/freescale/mpc8610hpcd/mpc8610hpcd.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8610hpcd/mpc8610hpcd.c	2009-02-26 14:03:58.000000000 +0100
@@ -484,3 +484,11 @@
 {
 	return pci_eth_init(bis);
 }
+
+void board_reset(void)
+{
+	out8(PIXIS_BASE + PIXIS_RST, 0);
+
+	while (1)
+		;
+}
diff -Naur u-boot-2009.01/board/freescale/mpc8610hpcd/mpc8610hpcd_diu.c u-boot/board/freescale/mpc8610hpcd/mpc8610hpcd_diu.c
--- u-boot-2009.01/board/freescale/mpc8610hpcd/mpc8610hpcd_diu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8610hpcd/mpc8610hpcd_diu.c	2009-02-26 14:03:58.000000000 +0100
@@ -116,7 +116,7 @@
 	unsigned int addr;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -138,7 +138,7 @@
 
 U_BOOT_CMD(
 	diufb, CONFIG_SYS_MAXARGS, 1, mpc8610diu_init_show_bmp,
-	"diufb init | addr - Init or Display BMP file\n",
+	"Init or Display BMP file",
 	"init\n    - initialize DIU\n"
 	"addr\n    - display bmp at address 'addr'\n"
 	);
diff -Naur u-boot-2009.01/board/freescale/mpc8641hpcn/ddr.c u-boot/board/freescale/mpc8641hpcn/ddr.c
--- u-boot-2009.01/board/freescale/mpc8641hpcn/ddr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8641hpcn/ddr.c	2009-02-26 14:03:58.000000000 +0100
@@ -162,4 +162,6 @@
 		}
 	}
 
+	/* 2T timing enable */
+	popts->twoT_en = 1;
 }
diff -Naur u-boot-2009.01/board/freescale/mpc8641hpcn/mpc8641hpcn.c u-boot/board/freescale/mpc8641hpcn/mpc8641hpcn.c
--- u-boot-2009.01/board/freescale/mpc8641hpcn/mpc8641hpcn.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/freescale/mpc8641hpcn/mpc8641hpcn.c	2009-02-26 14:03:58.000000000 +0100
@@ -163,23 +163,23 @@
 		}
 		debug("\n");
 
-		/* inbound */
-		r += fsl_pci_setup_inbound_windows(r);
-
 		/* outbound memory */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCI1_MEM_BASE,
+			       CONFIG_SYS_PCI1_MEM_BUS,
 			       CONFIG_SYS_PCI1_MEM_PHYS,
 			       CONFIG_SYS_PCI1_MEM_SIZE,
 			       PCI_REGION_MEM);
 
 		/* outbound io */
 		pci_set_region(r++,
-			       CONFIG_SYS_PCI1_IO_BASE,
+			       CONFIG_SYS_PCI1_IO_BUS,
 			       CONFIG_SYS_PCI1_IO_PHYS,
 			       CONFIG_SYS_PCI1_IO_SIZE,
 			       PCI_REGION_IO);
 
+		/* inbound */
+		r += fsl_pci_setup_inbound_windows(r);
+
 		hose->region_count = r - hose->regions;
 
 		hose->first_busno=first_free_busno;
@@ -195,7 +195,7 @@
 		 * Activate ULI1575 legacy chip by performing a fake
 		 * memory access.  Needed to make ULI RTC work.
 		 */
-		in_be32((unsigned *) ((char *)(CONFIG_SYS_PCI1_MEM_BASE
+		in_be32((unsigned *) ((char *)(CONFIG_SYS_PCI1_MEM_VIRT
 				       + CONFIG_SYS_PCI1_MEM_SIZE - 0x1000000)));
 
 	} else {
@@ -212,23 +212,23 @@
 	struct pci_controller *hose = &pci2_hose;
 	struct pci_region *r = hose->regions;
 
-	/* inbound */
-	r += fsl_pci_setup_inbound_windows(r);
-
 	/* outbound memory */
 	pci_set_region(r++,
-		       CONFIG_SYS_PCI2_MEM_BASE,
+		       CONFIG_SYS_PCI2_MEM_BUS,
 		       CONFIG_SYS_PCI2_MEM_PHYS,
 		       CONFIG_SYS_PCI2_MEM_SIZE,
 		       PCI_REGION_MEM);
 
 	/* outbound io */
 	pci_set_region(r++,
-		       CONFIG_SYS_PCI2_IO_BASE,
+		       CONFIG_SYS_PCI2_IO_BUS,
 		       CONFIG_SYS_PCI2_IO_PHYS,
 		       CONFIG_SYS_PCI2_IO_SIZE,
 		       PCI_REGION_IO);
 
+	/* inbound */
+	r += fsl_pci_setup_inbound_windows(r);
+
 	hose->region_count = r - hose->regions;
 
 	hose->first_busno=first_free_busno;
@@ -363,3 +363,11 @@
 	cpu_eth_init(bis);
 	return pci_eth_init(bis);
 }
+
+void board_reset(void)
+{
+	out8(PIXIS_BASE + PIXIS_RST, 0);
+
+	while (1)
+		;
+}
diff -Naur u-boot-2009.01/board/g2000/g2000.c u-boot/board/g2000/g2000.c
--- u-boot-2009.01/board/g2000/g2000.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/g2000/g2000.c	2009-02-26 14:03:58.000000000 +0100
@@ -185,7 +185,7 @@
 }
 U_BOOT_CMD(
 	dumpebc,	1,	1,	do_dumpebc,
-	"dumpebc - Dump all EBC registers\n",
+	"Dump all EBC registers",
 	NULL
 );
 
@@ -207,7 +207,7 @@
 }
 U_BOOT_CMD(
 	dumpdcr,	1,	1,	do_dumpdcr,
-	"dumpdcr - Dump all DCR registers\n",
+	"Dump all DCR registers",
 	NULL
 );
 
@@ -271,7 +271,7 @@
 }
 U_BOOT_CMD(
 	dumpspr,	1,	1,	do_dumpspr,
-	"dumpspr - Dump all SPR registers\n",
+	"Dump all SPR registers",
 	NULL
 );
 #endif
diff -Naur u-boot-2009.01/board/gdsys/gdppc440etx/config.mk u-boot/board/gdsys/gdppc440etx/config.mk
--- u-boot-2009.01/board/gdsys/gdppc440etx/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/gdsys/gdppc440etx/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# G&D 440EP/GR ETX-Module
+#
+
+#TEXT_BASE = 0x00001000
+
+ifeq ($(ramsym),1)
+TEXT_BASE = 0xFBD00000
+else
+TEXT_BASE = 0xFFF80000
+endif
+
+PLATFORM_CPPFLAGS += -DCONFIG_440=1
+
+ifeq ($(debug),1)
+PLATFORM_CPPFLAGS += -DDEBUG
+endif
+
+ifeq ($(dbcr),1)
+PLATFORM_CPPFLAGS += -DCONFIG_SYS_INIT_DBCR=0x8cff0000
+endif
diff -Naur u-boot-2009.01/board/gdsys/gdppc440etx/gdppc440etx.c u-boot/board/gdsys/gdppc440etx/gdppc440etx.c
--- u-boot-2009.01/board/gdsys/gdppc440etx/gdppc440etx.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/gdsys/gdppc440etx/gdppc440etx.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,323 @@
+/*
+ * (C) Copyright 2008
+ * Dirk Eibach,  Guntermann & Drunck GmbH, eibach@gdsys.de
+ *
+ * Based on board/amcc/yosemite/yosemite.c
+ * (C) Copyright 2006-2007
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <ppc4xx.h>
+#include <asm/processor.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* info for FLASH chips */
+extern flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
+
+int board_early_init_f(void)
+{
+	register uint reg;
+
+	/*
+	 * Setup the external bus controller/chip selects
+	 */
+	mfebc(xbcfg, reg);
+	mtebc(xbcfg, reg | 0x04000000);		/* Set ATC */
+
+	/*
+	 * Setup the GPIO pins
+	 */
+
+	/* setup Address lines for flash size 64Meg. */
+	out32(GPIO0_OSRL, in32(GPIO0_OSRL) | 0x54000000);
+	out32(GPIO0_TSRL, in32(GPIO0_TSRL) | 0x54000000);
+	out32(GPIO0_ISR1L, in32(GPIO0_ISR1L) | 0x54000000);
+
+	/* setup emac */
+	out32(GPIO0_TCR, in32(GPIO0_TCR) | 0xC080);
+	out32(GPIO0_TSRL, in32(GPIO0_TSRL) | 0x40);
+	out32(GPIO0_ISR1L, in32(GPIO0_ISR1L) | 0x55);
+	out32(GPIO0_OSRH, in32(GPIO0_OSRH) | 0x50004000);
+	out32(GPIO0_ISR1H, in32(GPIO0_ISR1H) | 0x00440000);
+
+	/* UART0 and UART1*/
+	out32(GPIO1_TCR, in32(GPIO1_TCR)     | 0x16000000);
+	out32(GPIO1_OSRL, in32(GPIO1_OSRL)   | 0x02180000);
+	out32(GPIO1_ISR1L, in32(GPIO1_ISR1L) | 0x00400000);
+	out32(GPIO1_ISR2L, in32(GPIO1_ISR2L) | 0x04010000);
+
+	/* disable boot-eeprom WP */
+	out32(GPIO0_OSRL, in32(GPIO0_OSRL) & ~0x00C00000);
+	out32(GPIO0_TSRL, in32(GPIO0_TSRL) & ~0x00C00000);
+	out32(GPIO0_ISR1L, in32(GPIO0_ISR1L) & ~0x00C00000);
+	out32(GPIO0_TCR, in32(GPIO0_TCR) | 0x08000000);
+	out32(GPIO0_OR, in32(GPIO0_OR) & ~0x08000000);
+
+	/* external interrupts IRQ0...3 */
+	out32(GPIO1_TCR, in32(GPIO1_TCR) & ~0x00f00000);
+	out32(GPIO1_TSRL, in32(GPIO1_TSRL) & ~0x00005500);
+	out32(GPIO1_ISR1L, in32(GPIO1_ISR1L) | 0x00005500);
+
+
+	/*
+	 * Setup the interrupt controller polarities, triggers, etc.
+	 */
+	mtdcr(uic0sr, 0xffffffff);	/* clear all */
+	mtdcr(uic0er, 0x00000000);	/* disable all */
+	mtdcr(uic0cr, 0x00000009);	/* ATI & UIC1 crit are critical */
+	mtdcr(uic0pr, 0xfffffe13);	/* per ref-board manual */
+	mtdcr(uic0tr, 0x01c00008);	/* per ref-board manual */
+	mtdcr(uic0vr, 0x00000001);	/* int31 highest, base=0x000 */
+	mtdcr(uic0sr, 0xffffffff);	/* clear all */
+
+	mtdcr(uic1sr, 0xffffffff);	/* clear all */
+	mtdcr(uic1er, 0x00000000);	/* disable all */
+	mtdcr(uic1cr, 0x00000000);	/* all non-critical */
+	mtdcr(uic1pr, 0xffffe0ff);	/* per ref-board manual */
+	mtdcr(uic1tr, 0x00ffc000);	/* per ref-board manual */
+	mtdcr(uic1vr, 0x00000001);	/* int31 highest, base=0x000 */
+	mtdcr(uic1sr, 0xffffffff);	/* clear all */
+
+	/*
+	 * Setup other serial configuration
+	 */
+	mfsdr(sdr_pci0, reg);
+	mtsdr(sdr_pci0, 0x80000000 | reg);	/* PCI arbiter enabled */
+	mtsdr(sdr_pfc0, 0x00003e00);	/* Pin function */
+	mtsdr(sdr_pfc1, 0x00048000);	/* Pin function: UART0 has 4 pins */
+
+	return 0;
+}
+
+int misc_init_r(void)
+{
+	uint pbcr;
+	int size_val;
+	uint sz;
+
+	/* Re-do sizing to get full correct info */
+	mfebc(pb0cr, pbcr);
+
+	if (gd->bd->bi_flashsize > 0x08000000)
+		panic("Max. flash banksize is 128 MB!\n");
+
+	for (sz = gd->bd->bi_flashsize, size_val = 7;
+	    ((sz & 0x08000000) == 0) && (size_val > 0); --size_val)
+		sz <<= 1;
+
+	pbcr = (pbcr & 0x0001ffff) | gd->bd->bi_flashstart | (size_val << 17);
+	mtebc(pb0cr, pbcr);
+
+	/* adjust flash start and offset */
+	gd->bd->bi_flashstart = 0 - gd->bd->bi_flashsize;
+	gd->bd->bi_flashoffset = 0;
+
+	/* Monitor protection ON by default */
+	(void)flash_protect(FLAG_PROTECT_SET,
+			    -CONFIG_SYS_MONITOR_LEN,
+			    0xffffffff,
+			    &flash_info[0]);
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	char *s = getenv("serial#");
+
+	printf("Board: GDPPC440ETX - G&D PPC440EP/GR ETX-module");
+
+	if (s != NULL) {
+		puts(", serial# ");
+		puts(s);
+	}
+	putc('\n');
+
+	return 0;
+}
+
+/*
+ * pci_pre_init
+ *
+ * This routine is called just prior to registering the hose and gives
+ * the board the opportunity to check things. Returning a value of zero
+ * indicates that things are bad & PCI initialization should be aborted.
+ *
+ *	Different boards may wish to customize the pci controller structure
+ *	(add regions, override default access routines, etc) or perform
+ *	certain pre-initialization actions.
+ *
+ */
+#if defined(CONFIG_PCI)
+int pci_pre_init(struct pci_controller *hose)
+{
+	unsigned long addr;
+
+	/*
+	 * Set priority for all PLB3 devices to 0.
+	 * Set PLB3 arbiter to fair mode.
+	 */
+	mfsdr(sdr_amp1, addr);
+	mtsdr(sdr_amp1, (addr & 0x000000FF) | 0x0000FF00);
+	addr = mfdcr(plb3_acr);
+	mtdcr(plb3_acr, addr | 0x80000000);
+
+	/*
+	 * Set priority for all PLB4 devices to 0.
+	 */
+	mfsdr(sdr_amp0, addr);
+	mtsdr(sdr_amp0, (addr & 0x000000FF) | 0x0000FF00);
+	addr = mfdcr(plb4_acr) | 0xa0000000;	/* Was 0x8---- */
+	mtdcr(plb4_acr, addr);
+
+	/*
+	 * Set Nebula PLB4 arbiter to fair mode.
+	 */
+	/* Segment0 */
+	addr = (mfdcr(plb0_acr) & ~plb0_acr_ppm_mask) | plb0_acr_ppm_fair;
+	addr = (addr & ~plb0_acr_hbu_mask) | plb0_acr_hbu_enabled;
+	addr = (addr & ~plb0_acr_rdp_mask) | plb0_acr_rdp_4deep;
+	addr = (addr & ~plb0_acr_wrp_mask) | plb0_acr_wrp_2deep;
+	mtdcr(plb0_acr, addr);
+
+	/* Segment1 */
+	addr = (mfdcr(plb1_acr) & ~plb1_acr_ppm_mask) | plb1_acr_ppm_fair;
+	addr = (addr & ~plb1_acr_hbu_mask) | plb1_acr_hbu_enabled;
+	addr = (addr & ~plb1_acr_rdp_mask) | plb1_acr_rdp_4deep;
+	addr = (addr & ~plb1_acr_wrp_mask) | plb1_acr_wrp_2deep;
+	mtdcr(plb1_acr, addr);
+
+	/* enable 66 MHz ext. Clock */
+	out32(GPIO1_TCR, in32(GPIO1_TCR) | 0x00008000);
+	out32(GPIO1_OR, in32(GPIO1_OR) | 0x00008000);
+
+	return 1;
+}
+#endif	/* defined(CONFIG_PCI) */
+
+/*
+ * pci_target_init
+ *
+ * The bootstrap configuration provides default settings for the pci
+ * inbound map (PIM). But the bootstrap config choices are limited and
+ * may not be sufficient for a given board.
+ *
+ */
+#if defined(CONFIG_PCI) && defined(CONFIG_SYS_PCI_TARGET_INIT)
+void pci_target_init(struct pci_controller *hose)
+{
+	/*
+	 * Set up Direct MMIO registers
+	 */
+
+	/*
+	 * PowerPC440 EP PCI Master configuration.
+	 * Map one 1Gig range of PLB/processor addresses to PCI memory space.
+	 *       PLB address 0xA0000000-0xDFFFFFFF
+	 *   ==> PCI address 0xA0000000-0xDFFFFFFF
+	 *   Use byte reversed out routines to handle endianess.
+	 * Make this region non-prefetchable.
+	 */
+	out32r(PCIX0_PMM0MA, 0x00000000); 	/* disabled b4 setting */
+	out32r(PCIX0_PMM0LA, CONFIG_SYS_PCI_MEMBASE);
+	out32r(PCIX0_PMM0PCILA, CONFIG_SYS_PCI_MEMBASE);
+	out32r(PCIX0_PMM0PCIHA, 0x00000000);
+	out32r(PCIX0_PMM0MA, 0xE0000001); /* 512M, no prefetch, enable region */
+
+	out32r(PCIX0_PMM1MA, 0x00000000);	/* disabled b4 setting */
+	out32r(PCIX0_PMM1LA, CONFIG_SYS_PCI_MEMBASE2);
+	out32r(PCIX0_PMM1PCILA, CONFIG_SYS_PCI_MEMBASE2);
+	out32r(PCIX0_PMM1PCIHA, 0x00000000);
+	out32r(PCIX0_PMM1MA, 0xE0000001); /* 512M, no prefetch, enable region */
+
+	out32r(PCIX0_PTM1MS, 0x00000001);
+	out32r(PCIX0_PTM1LA, 0);
+	out32r(PCIX0_PTM2MS, 0);
+	out32r(PCIX0_PTM2LA, 0);
+
+	/*
+	 * Set up Configuration registers
+	 */
+
+	/* Program the board's subsystem id/vendor id */
+	pci_write_config_word(0, PCI_SUBSYSTEM_VENDOR_ID,
+			      CONFIG_SYS_PCI_SUBSYS_VENDORID);
+	pci_write_config_word(0, PCI_SUBSYSTEM_ID, CONFIG_SYS_PCI_SUBSYS_ID);
+
+	/* Configure command register as bus master */
+	pci_write_config_word(0, PCI_COMMAND, PCI_COMMAND_MASTER);
+
+	/* 240nS PCI clock */
+	pci_write_config_word(0, PCI_LATENCY_TIMER, 1);
+
+	/* No error reporting */
+	pci_write_config_word(0, PCI_ERREN, 0);
+
+	pci_write_config_dword(0, PCI_BRDGOPT2, 0x00000101);
+
+}
+#endif	/* defined(CONFIG_PCI) && defined(CONFIG_SYS_PCI_TARGET_INIT) */
+
+/*
+ *  pci_master_init
+ *
+ */
+#if defined(CONFIG_PCI) && defined(CONFIG_SYS_PCI_MASTER_INIT)
+void pci_master_init(struct pci_controller *hose)
+{
+	unsigned short temp_short;
+
+	/*
+	 * Write the PowerPC440 EP PCI Configuration regs.
+	 *   Enable PowerPC440 EP to be a master on the PCI bus (PMM).
+	 *   Enable PowerPC440 EP to act as a PCI memory target (PTM).
+	 */
+	pci_read_config_word(0, PCI_COMMAND, &temp_short);
+	pci_write_config_word(0, PCI_COMMAND,
+			      temp_short | PCI_COMMAND_MASTER |
+			      PCI_COMMAND_MEMORY);
+}
+#endif	/* defined(CONFIG_PCI) && defined(CONFIG_SYS_PCI_MASTER_INIT) */
+
+/*
+ *  is_pci_host
+ *
+ *	This routine is called to determine if a pci scan should be
+ *	performed. With various hardware environments (especially cPCI and
+ *	PPMC) it's insufficient to depend on the state of the arbiter enable
+ *	bit in the strap register, or generic host/adapter assumptions.
+ *
+ *	Rather than hard-code a bad assumption in the general 440 code, the
+ *	440 pci code requires the board to decide at runtime.
+ *
+ *	Return 0 for adapter mode, non-zero for host (monarch) mode.
+ *
+ *
+ */
+#if defined(CONFIG_PCI)
+int is_pci_host(struct pci_controller *hose)
+{
+	return 1;
+}
+#endif	/* defined(CONFIG_PCI) */
diff -Naur u-boot-2009.01/board/gdsys/gdppc440etx/init.S u-boot/board/gdsys/gdppc440etx/init.S
--- u-boot-2009.01/board/gdsys/gdppc440etx/init.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/gdsys/gdppc440etx/init.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+* (C) Copyright 2008
+* Dirk Eibach,  Guntermann & Drunck GmbH, eibach@gdsys.de
+*
+* based on board/amcc/yosemite/init.S
+* original Copyright not specified there
+*
+* See file CREDITS for list of people who contributed to this
+* project.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; either version 2 of
+* the License, or (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 USA
+*/
+
+#include <ppc_asm.tmpl>
+#include <config.h>
+
+#include <asm/mmu.h>
+
+/**************************************************************************
+ * TLB TABLE
+ *
+ * This table is used by the cpu boot code to setup the initial tlb
+ * entries. Rather than make broad assumptions in the cpu source tree,
+ * this table lets each board set things up however they like.
+ *
+ *  Pointer to the table is returned in r1
+ *
+ *************************************************************************/
+
+    .section .bootpg,"ax"
+    .globl tlbtab
+
+tlbtab:
+    tlbtab_start
+
+    /*
+     * BOOT_CS (FLASH) must be first. Before relocation SA_I can be off to use
+     * the speed up boot process. It is patched after relocation to enable SA_I
+     */
+    tlbentry( CONFIG_SYS_BOOT_BASE_ADDR, SZ_256M, CONFIG_SYS_BOOT_BASE_ADDR,
+	0, AC_R|AC_W|AC_X|SA_G/*|SA_I*/)
+
+    /* TLB-entry for init-ram in dcache (SA_I must be turned off!) */
+    tlbentry( CONFIG_SYS_INIT_RAM_ADDR, SZ_64K, CONFIG_SYS_INIT_RAM_ADDR,
+	0, AC_R|AC_W|AC_X|SA_G )
+
+    tlbentry( CONFIG_SYS_SDRAM_BASE, SZ_256M, CONFIG_SYS_SDRAM_BASE,
+	0, AC_R|AC_W|AC_X|SA_G|SA_I )
+    tlbentry( CONFIG_SYS_PCI_BASE, SZ_256M, CONFIG_SYS_PCI_BASE,
+	0, AC_R|AC_W|SA_G|SA_I )
+
+    /* PCI */
+    tlbentry( CONFIG_SYS_PCI_MEMBASE, SZ_256M, CONFIG_SYS_PCI_MEMBASE,
+	0, AC_R|AC_W|SA_G|SA_I )
+    tlbentry( CONFIG_SYS_PCI_MEMBASE1, SZ_256M, CONFIG_SYS_PCI_MEMBASE1,
+	0, AC_R|AC_W|SA_G|SA_I )
+    tlbentry( CONFIG_SYS_PCI_MEMBASE2, SZ_256M, CONFIG_SYS_PCI_MEMBASE2,
+	0, AC_R|AC_W|SA_G|SA_I )
+    tlbentry( CONFIG_SYS_PCI_MEMBASE3, SZ_256M, CONFIG_SYS_PCI_MEMBASE3,
+	0, AC_R|AC_W|SA_G|SA_I )
+
+    tlbtab_end
diff -Naur u-boot-2009.01/board/gdsys/gdppc440etx/Makefile u-boot/board/gdsys/gdppc440etx/Makefile
--- u-boot-2009.01/board/gdsys/gdppc440etx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/gdsys/gdppc440etx/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2002-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	= $(BOARD).o
+SOBJS	= init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/gdsys/gdppc440etx/u-boot.lds u-boot/board/gdsys/gdppc440etx/u-boot.lds
--- u-boot-2009.01/board/gdsys/gdppc440etx/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/gdsys/gdppc440etx/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,144 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+/* Do we need any of these for elf?
+   __DYNAMIC = 0;    */
+SECTIONS
+{
+  .resetvec 0xFFFFFFFC :
+  {
+    *(.resetvec)
+  } = 0xffff
+
+  .bootpg 0xFFFFF000 :
+  {
+    cpu/ppc4xx/start.o	(.bootpg)
+  } = 0xffff
+
+  /* Read-only sections, merged into text segment: */
+  . = + SIZEOF_HEADERS;
+  .interp : { *(.interp) }
+  .hash          : { *(.hash)		}
+  .dynsym        : { *(.dynsym)		}
+  .dynstr        : { *(.dynstr)		}
+  .rel.text      : { *(.rel.text)		}
+  .rela.text     : { *(.rela.text)	}
+  .rel.data      : { *(.rel.data)		}
+  .rela.data     : { *(.rela.data)	}
+  .rel.rodata    : { *(.rel.rodata)	}
+  .rela.rodata   : { *(.rela.rodata)	}
+  .rel.got       : { *(.rel.got)		}
+  .rela.got      : { *(.rela.got)		}
+  .rel.ctors     : { *(.rel.ctors)	}
+  .rela.ctors    : { *(.rela.ctors)	}
+  .rel.dtors     : { *(.rel.dtors)	}
+  .rela.dtors    : { *(.rela.dtors)	}
+  .rel.bss       : { *(.rel.bss)		}
+  .rela.bss      : { *(.rela.bss)		}
+  .rel.plt       : { *(.rel.plt)		}
+  .rela.plt      : { *(.rela.plt)		}
+  .init          : { *(.init)	}
+  .plt : { *(.plt) }
+  .text      :
+  {
+    /* WARNING - the following is hand-optimized to fit within	*/
+    /* the sector layout of our flash chips!	XXX FIXME XXX	*/
+
+    cpu/ppc4xx/start.o	(.text)
+    board/gdsys/gdppc440etx/init.o	(.text)
+
+    *(.text)
+    *(.fixup)
+    *(.got1)
+  }
+  _etext = .;
+  PROVIDE (etext = .);
+  .rodata    :
+  {
+    *(.rodata)
+    *(.rodata1)
+    *(.rodata.str1.4)
+    *(.eh_frame)
+  }
+  .fini      : { *(.fini)    } =0
+  .ctors     : { *(.ctors)   }
+  .dtors     : { *(.dtors)   }
+
+  /* Read-write section, merged into data segment: */
+  . = (. + 0x00FF) & 0xFFFFFF00;
+  _erotext = .;
+  PROVIDE (erotext = .);
+  .reloc   :
+  {
+    *(.got)
+    _GOT2_TABLE_ = .;
+    *(.got2)
+    _FIXUP_TABLE_ = .;
+    *(.fixup)
+  }
+  __got2_entries = (_FIXUP_TABLE_ - _GOT2_TABLE_) >>2;
+  __fixup_entries = (. - _FIXUP_TABLE_)>>2;
+
+  .data    :
+  {
+    *(.data)
+    *(.data1)
+    *(.sdata)
+    *(.sdata2)
+    *(.dynamic)
+    CONSTRUCTORS
+  }
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  . = .;
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+
+  . = .;
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  . = ALIGN(256);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(256);
+  __init_end = .;
+
+  __bss_start = .;
+  .bss (NOLOAD)       :
+  {
+   *(.sbss) *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+   . = ALIGN(4);
+  }
+  _end = . ;
+  PROVIDE (end = .);
+}
diff -Naur u-boot-2009.01/board/hymod/bsp.c u-boot/board/hymod/bsp.c
--- u-boot-2009.01/board/hymod/bsp.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/hymod/bsp.c	2009-02-26 14:03:58.000000000 +0100
@@ -272,12 +272,12 @@
 		break;
 	}
 
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 U_BOOT_CMD(
 	fpga,	6,	1,	do_fpga,
-	"fpga    - FPGA sub-system\n",
+	"FPGA sub-system",
 	"load [type] addr size\n"
 	"  - write the configuration data at memory address `addr',\n"
 	"    size `size' bytes, into the FPGA of type `type' (either\n"
@@ -324,7 +324,7 @@
 		/* fall through ... */
 
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -336,7 +336,7 @@
 }
 U_BOOT_CMD(
 	eeclear,	1,	0,	do_eecl,
-	"eeclear - Clear the eeprom on a Hymod board \n",
+	"Clear the eeprom on a Hymod board",
 	"[type]\n"
 	"  - write zeroes into the EEPROM on the board of type `type'\n"
 	"    (`type' is either `main' or `mezz' - default `main')\n"
diff -Naur u-boot-2009.01/board/in-circuit/icnova/config.mk u-boot/board/in-circuit/icnova/config.mk
--- u-boot-2009.01/board/in-circuit/icnova/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/in-circuit/icnova/config.mk	2009-03-18 11:17:01.535342197 +0100
@@ -0,0 +1,5 @@
+PLATFORM_RELFLAGS	+= -ffunction-sections -fdata-sections
+PLATFORM_LDFLAGS	+= --gc-sections
+TEXT_BASE		= 0x00000000
+LDSCRIPT		= $(obj)board/in-circuit/icnova/u-boot.lds
+CONFIG_ATMEL_USART	= y
diff -Naur u-boot-2009.01/board/in-circuit/icnova/flash2x8.c u-boot/board/in-circuit/icnova/flash2x8.c
--- u-boot-2009.01/board/in-circuit/icnova/flash2x8.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/in-circuit/icnova/flash2x8.c	2009-03-07 20:19:40.000000000 +0100
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/sections.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+flash_info_t flash_info[1];
+
+static void flash_identify(uint16_t *flash, flash_info_t *info)
+{
+	unsigned long flags;
+
+	flags = disable_interrupts();
+
+	dcache_flush_unlocked();
+
+	writew(0xaaaa, flash + 0x555);
+	writew(0x5555, flash + 0xaaa);
+	writew(0x9090, flash + 0x555);
+	info->flash_id = readl(flash);
+	writew(0xf0f0, flash);
+
+	readw(flash);
+
+	if (flags)
+		enable_interrupts();
+}
+
+#if CONFIG_SYS_FLASH_SECT > CONFIG_SYS_MAX_FLASH_SECT
+# error Flash has more sectors than allowed at max
+#endif
+
+unsigned long flash_init(void)
+{
+	unsigned long addr;
+	unsigned int i;
+
+	flash_info[0].size = CONFIG_SYS_FLASH_SIZE;
+	flash_info[0].sector_count = CONFIG_SYS_FLASH_SECT;
+
+	flash_identify(uncached((void *)CONFIG_SYS_FLASH_BASE), &flash_info[0]);
+
+	for (i=0, addr =0;
+			i < CONFIG_SYS_MAX_FLASH_SECT;
+			i++,addr+=(CONFIG_SYS_FLASH_SIZE/CONFIG_SYS_FLASH_SECT))
+		flash_info[0].start[i] = addr;
+
+	return CONFIG_SYS_FLASH_SIZE;
+}
+
+void flash_print_info(flash_info_t *info)
+{
+	int i;
+	printf("Flash: Vendor ID: 0x%02lx, Product ID: 0x%02lx\n",
+	       info->flash_id >> 16, info->flash_id & 0xffff);
+	printf("Size: %ld MB in %d sectors\n",
+	       info->size >> 10, info->sector_count);
+	for(i=0; i<CONFIG_SYS_FLASH_SECT; i++)
+		printf("\tSect %i @ 0x%08x\n",i, flash_info[0].start[i]);
+}
+
+int flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+	unsigned long flags;
+	unsigned long start_time;
+	uint16_t *fb, *sb;
+	unsigned int i;
+	int ret;
+	uint16_t status;
+
+	if ((s_first < 0) || (s_first > s_last)
+	    || (s_last >= info->sector_count)) {
+		puts("Error: first and/or last sector out of range\n");
+		return ERR_INVAL;
+	}
+
+	for (i = s_first; i < s_last; i++)
+		if (info->protect[i]) {
+			printf("Error: sector %d is protected\n", i);
+			return ERR_PROTECTED;
+		}
+
+	fb = (uint16_t *)uncached(info->start[0]);
+
+	dcache_flush_unlocked();
+
+	for (i = s_first; (i <= s_last) && !ctrlc(); i++) {
+		printf("Erasing sector %3d...", i);
+
+		sb = (uint16_t *)uncached(info->start[i]);
+
+		flags = disable_interrupts();
+
+		start_time = get_timer(0);
+
+		/* Unlock sector */
+		writew(0xaaaa, fb + 0x555);
+		writew(0x7070, sb);
+
+		/* Erase sector */
+		writew(0xaaaa, fb + 0x555);
+		writew(0x5555, fb + 0xaaa);
+		writew(0x8080, fb + 0x555);
+		writew(0xaaaa, fb + 0x555);
+		writew(0x5555, fb + 0xaaa);
+		writew(0x3030, sb);
+
+		/* Wait for completion */
+		ret = ERR_OK;
+		do {
+			/* TODO: Timeout */
+			status = readw(sb);
+		} while ((status != 0xffff) /*&& !(status & 0x2828)*/);
+
+		writew(0xf0f0, fb);
+
+		/*
+		 * Make sure the command actually makes it to the bus
+		 * before we re-enable interrupts.
+		 */
+		readw(fb);
+
+		if (flags)
+			enable_interrupts();
+
+		if (status != 0xffff) {
+			printf("Flash erase error at address 0x%p: 0x%02x\n",
+			       sb, status);
+			ret = ERR_PROG_ERROR;
+			break;
+		}
+	}
+
+	if (ctrlc())
+		printf("User interrupt!\n");
+
+	return ERR_OK;
+}
+
+int write_buff(flash_info_t *info, uchar *src,
+			   ulong addr, ulong count)
+{
+	unsigned long flags;
+	uint16_t *base, *p, *s, *end;
+	uint16_t word, status, status1;
+	int ret = ERR_OK;
+
+	if (addr < info->start[0]
+	    || (addr + count) > (info->start[0] + info->size)
+	    || (addr + count) < addr) {
+		puts("Error: invalid address range\n");
+		return ERR_INVAL;
+	}
+
+	if (addr & 1 || count & 1 || (unsigned int)src & 1) {
+		puts("Error: misaligned source, destination or count\n");
+		return ERR_ALIGN;
+	}
+
+	base = (uint16_t *)uncached(info->start[0]);
+	end = (uint16_t *)uncached(addr + count);
+
+	flags = disable_interrupts();
+
+	dcache_flush_unlocked();
+	sync_write_buffer();
+
+	for (p = (uint16_t *)uncached(addr), s = (uint16_t *)src;
+	     p < end && !ctrlc(); p++, s++) {
+		word = *s;
+
+		writew(0xaaaa, base + 0x555);
+		writew(0x5555, base + 0xaaa);
+		writew(0xa0a0, base + 0x555);
+		writew(word, p);
+
+		sync_write_buffer();
+
+		/* Wait for completion */
+		status1 = readw(p);
+		do {
+			/* TODO: Timeout */
+			status = status1;
+			status1 = readw(p);
+		} while (((status ^ status1) & 0x4040)	/* toggled */
+			 /*&& !(status1 & 0x2828)*/);		/* error bits */
+
+		/*
+		 * We'll need to check once again for toggle bit
+		 * because the toggle bit may stop toggling as I/O5
+		 * changes to "1" (ref at49bv642.pdf p9)
+		 */
+		status1 = readw(p);
+		status = readw(p);
+		if ((status ^ status1) & 0x4040) {
+			printf("Flash write error at address 0x%p: "
+			       "0x%02x != 0x%02x\n",
+			       p, status,word);
+			ret = ERR_PROG_ERROR;
+			writew(0xf0f0, base);
+			readw(base);
+			break;
+		}
+
+		writew(0xf0f0, base);
+		readw(base);
+	}
+
+	if (flags)
+		enable_interrupts();
+
+	return ret;
+}
diff -Naur u-boot-2009.01/board/in-circuit/icnova/flash.c u-boot/board/in-circuit/icnova/flash.c
--- u-boot-2009.01/board/in-circuit/icnova/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/in-circuit/icnova/flash.c	2009-02-26 14:35:20.000000000 +0100
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/sections.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+flash_info_t flash_info[1];
+
+static void flash_identify(uint16_t *flash, flash_info_t *info)
+{
+	unsigned long flags;
+
+	flags = disable_interrupts();
+
+	dcache_flush_unlocked();
+
+	writew(0xaa, flash + 0x555);
+	writew(0x55, flash + 0xaaa);
+	writew(0x90, flash + 0x555);
+	info->flash_id = readl(flash);
+	writew(0xff, flash);
+
+	readw(flash);
+
+	if (flags)
+		enable_interrupts();
+}
+
+unsigned long flash_init(void)
+{
+	unsigned long addr;
+	unsigned int i;
+
+	flash_info[0].size = CONFIG_SYS_FLASH_SIZE;
+	flash_info[0].sector_count = 135;
+
+	flash_identify(uncached((void *)CONFIG_SYS_FLASH_BASE), &flash_info[0]);
+
+	for (i = 0, addr = 0; i < 8; i++, addr += 0x2000)
+		flash_info[0].start[i] = addr;
+	for (; i < flash_info[0].sector_count; i++, addr += 0x10000)
+		flash_info[0].start[i] = addr;
+
+	return CONFIG_SYS_FLASH_SIZE;
+}
+
+void flash_print_info(flash_info_t *info)
+{
+	printf("Flash: Vendor ID: 0x%02lx, Product ID: 0x%02lx\n",
+	       info->flash_id >> 16, info->flash_id & 0xffff);
+	printf("Size: %ld MB in %d sectors\n",
+	       info->size >> 10, info->sector_count);
+}
+
+int flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+	unsigned long flags;
+	unsigned long start_time;
+	uint16_t *fb, *sb;
+	unsigned int i;
+	int ret;
+	uint16_t status;
+
+	if ((s_first < 0) || (s_first > s_last)
+	    || (s_last >= info->sector_count)) {
+		puts("Error: first and/or last sector out of range\n");
+		return ERR_INVAL;
+	}
+
+	for (i = s_first; i < s_last; i++)
+		if (info->protect[i]) {
+			printf("Error: sector %d is protected\n", i);
+			return ERR_PROTECTED;
+		}
+
+	fb = (uint16_t *)uncached(info->start[0]);
+
+	dcache_flush_unlocked();
+
+	for (i = s_first; (i <= s_last) && !ctrlc(); i++) {
+		printf("Erasing sector %3d...", i);
+
+		sb = (uint16_t *)uncached(info->start[i]);
+
+		flags = disable_interrupts();
+
+		start_time = get_timer(0);
+
+		/* Unlock sector */
+		writew(0xaa, fb + 0x555);
+		writew(0x70, sb);
+
+		/* Erase sector */
+		writew(0xaa, fb + 0x555);
+		writew(0x55, fb + 0xaaa);
+		writew(0x80, fb + 0x555);
+		writew(0xaa, fb + 0x555);
+		writew(0x55, fb + 0xaaa);
+		writew(0x30, sb);
+
+		/* Wait for completion */
+		ret = ERR_OK;
+		do {
+			/* TODO: Timeout */
+			status = readw(sb);
+		} while ((status != 0xffff) && !(status & 0x28));
+
+		writew(0xf0, fb);
+
+		/*
+		 * Make sure the command actually makes it to the bus
+		 * before we re-enable interrupts.
+		 */
+		readw(fb);
+
+		if (flags)
+			enable_interrupts();
+
+		if (status != 0xffff) {
+			printf("Flash erase error at address 0x%p: 0x%02x\n",
+			       sb, status);
+			ret = ERR_PROG_ERROR;
+			break;
+		}
+	}
+
+	if (ctrlc())
+		printf("User interrupt!\n");
+
+	return ERR_OK;
+}
+
+int write_buff(flash_info_t *info, uchar *src,
+			   ulong addr, ulong count)
+{
+	unsigned long flags;
+	uint16_t *base, *p, *s, *end;
+	uint16_t word, status, status1;
+	int ret = ERR_OK;
+
+	if (addr < info->start[0]
+	    || (addr + count) > (info->start[0] + info->size)
+	    || (addr + count) < addr) {
+		puts("Error: invalid address range\n");
+		return ERR_INVAL;
+	}
+
+	if (addr & 1 || count & 1 || (unsigned int)src & 1) {
+		puts("Error: misaligned source, destination or count\n");
+		return ERR_ALIGN;
+	}
+
+	base = (uint16_t *)uncached(info->start[0]);
+	end = (uint16_t *)uncached(addr + count);
+
+	flags = disable_interrupts();
+
+	dcache_flush_unlocked();
+	sync_write_buffer();
+
+	for (p = (uint16_t *)uncached(addr), s = (uint16_t *)src;
+	     p < end && !ctrlc(); p++, s++) {
+		word = *s;
+
+		writew(0xaa, base + 0x555);
+		writew(0x55, base + 0xaaa);
+		writew(0xa0, base + 0x555);
+		writew(word, p);
+
+		sync_write_buffer();
+
+		/* Wait for completion */
+		status1 = readw(p);
+		do {
+			/* TODO: Timeout */
+			status = status1;
+			status1 = readw(p);
+		} while (((status ^ status1) & 0x40)	/* toggled */
+			 && !(status1 & 0x28));		/* error bits */
+
+		/*
+		 * We'll need to check once again for toggle bit
+		 * because the toggle bit may stop toggling as I/O5
+		 * changes to "1" (ref at49bv642.pdf p9)
+		 */
+		status1 = readw(p);
+		status = readw(p);
+		if ((status ^ status1) & 0x40) {
+			printf("Flash write error at address 0x%p: "
+			       "0x%02x != 0x%02x\n",
+			       p, status,word);
+			ret = ERR_PROG_ERROR;
+			writew(0xf0, base);
+			readw(base);
+			break;
+		}
+
+		writew(0xf0, base);
+		readw(base);
+	}
+
+	if (flags)
+		enable_interrupts();
+
+	return ret;
+}
diff -Naur u-boot-2009.01/board/in-circuit/icnova/icnova.c u-boot/board/in-circuit/icnova/icnova.c
--- u-boot-2009.01/board/in-circuit/icnova/icnova.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/in-circuit/icnova/icnova.c	2009-03-12 11:12:13.000000000 +0100
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm/sdram.h>
+#include <asm/arch/clk.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/hmatrix.h>
+#include <netdev.h>
+
+#ifdef CONFIG_CMD_NAND
+#include <nand.h>
+#include <linux/mtd/mtd.h>
+#include "../../../cpu/at32ap/hsmc3.h"
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static const struct sdram_config sdram_config = {
+	.data_bits	= SDRAM_DATA_32BIT,
+	.row_bits	= 13,
+	.col_bits	= 9,
+	.bank_bits	= 2,
+	.cas		= 2,
+	.twr		= 2,
+	.trc		= 7,
+	.trp		= 2,
+	.trcd		= 2,
+	.tras		= 4,
+	.txsr		= 7,
+	/* 7.81 us */
+	.refresh_period	= (781 * (SDRAMC_BUS_HZ / 1000)) / 100000,
+};
+
+int board_early_init_f(void)
+{
+	/* Enable SDRAM in the EBI mux */
+	hmatrix_slave_write(EBI, SFR, HMATRIX_BIT(EBI_SDRAM_ENABLE));
+
+	gpio_enable_ebi();
+#ifdef CONFIG_USART0
+	gpio_enable_usart0();
+#endif
+#ifdef CONFIG_USART1
+	gpio_enable_usart1();
+#endif
+#ifdef CONFIG_USART2
+	gpio_enable_usart2();
+#endif
+#ifdef CONFIG_USART3
+	gpio_enable_usart3();
+#endif
+#ifdef CONFIG_MACB
+	gpio_select_pio(GPIO_PIN_PB30, GPIOF_OUTPUT);
+	gpio_set_value(GPIO_PIN_PB30, 0);
+	gpio_select_pio(GPIO_PIN_PB29, GPIOF_OUTPUT);
+	gpio_set_value(GPIO_PIN_PB29, 0);
+	udelay(100);
+	gpio_set_value(GPIO_PIN_PB29, 1);
+	gpio_enable_macb0();
+#endif
+#ifdef CONFIG_MACB2
+	gpio_enable_macb1();
+#endif
+#ifdef CONFIG_MMC
+	gpio_enable_mmci();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_NAND
+static void icnova_nand_hwctl(struct mtd_info *mtd, int cmd, unsigned int ctrl) {
+	struct nand_chip *this = mtd->priv;
+
+	//putc(0x20); putc(0x08); // SPACE BS
+	//putc(0x20); putc(0x08); // SPACE BS
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if(ctrl & NAND_NCE) {
+			//printf("NAND_CE ");
+			gpio_set_value(GPIO_PIN_PE16, 1);
+			gpio_set_value(CFG_NAND_CE, 0);
+		} else {
+			//printf("NAND_NCE");
+			gpio_set_value(CFG_NAND_CE, 1);
+			gpio_set_value(GPIO_PIN_PE16, 0);
+		}
+	}
+
+	if(cmd == NAND_CMD_NONE) {
+		//printf("\n");
+		return;
+	}
+	//udelay(1000);
+
+	//printf("0x%x ", cmd);
+	if (ctrl & NAND_CLE) {
+		//printf("CLE\n");
+		writeb(cmd, uncached(this->IO_ADDR_W + (1 << CFG_NAND_CLE)));
+	} else {
+		//printf("ALE\n");
+		writeb(cmd, uncached(this->IO_ADDR_W + (1 << CFG_NAND_ALE)));
+	}
+
+	return;
+}
+
+static int icnova_nand_rdy(struct mtd_info *mtd) {
+	int ret;
+	//udelay(100);
+	ret = gpio_get_value(CFG_NAND_RDY);
+	//udelay(20);
+	return ret;
+}
+
+int board_nand_init(struct nand_chip *nand) {
+	/* Setup SMC-Timings */
+	//hsmc3_writel(CYCLE3, 0x00090009);
+	//hsmc3_writel(PULSE3, 0x04030403);
+	//hsmc3_writel(SETUP3, 0x00010001);
+	//hsmc3_writel(MODE3,  0x00020003);
+	hsmc3_writel(CYCLE3, 0x00090009);
+	hsmc3_writel(PULSE3, 0x07050705);
+	hsmc3_writel(SETUP3, 0x00020002);
+	hsmc3_writel(MODE3,  0x00020003);
+	// Enable NAND-Logic
+	hmatrix_slave_write(EBI, SFR, 
+			hmatrix_slave_read(EBI, SFR) | 
+			HMATRIX_BIT(EBI_NAND_ENABLE));
+	
+
+	/* Setup GPIO-Lines */
+	gpio_select_pio(CFG_NAND_CE, GPIOF_OUTPUT);
+	gpio_select_pio(GPIO_PIN_PE16, GPIOF_OUTPUT);
+	gpio_set_value(CFG_NAND_CE, 1);
+	gpio_select_pio(CFG_NAND_RDY, GPIOF_PULLUP);
+
+	/* Setup NAND-Struct */
+	nand->chip_delay = 50;
+	nand->ecc.mode = NAND_ECC_SOFT;
+	nand->cmd_ctrl = icnova_nand_hwctl;
+	nand->dev_ready = icnova_nand_rdy;
+
+	return 0;
+
+}
+#endif
+
+phys_size_t initdram(int board_type)
+{
+	unsigned long expected_size;
+	unsigned long actual_size;
+	void *sdram_base;
+
+	sdram_base = map_physmem(EBI_SDRAM_BASE, EBI_SDRAM_SIZE, MAP_NOCACHE);
+
+	expected_size = sdram_init(sdram_base, &sdram_config);
+	actual_size = get_ram_size(sdram_base, expected_size);
+
+	unmap_physmem(sdram_base, EBI_SDRAM_SIZE);
+
+	if (expected_size != actual_size)
+		printf("Warning: Only %lu of %lu MiB SDRAM is working\n",
+				actual_size >> 20, expected_size >> 20);
+
+	return actual_size;
+}
+
+void board_init_info(void)
+{
+	gd->bd->bi_phy_id[0] = 0x00;
+#ifdef CONFIG_MACB2
+	gd->bd->bi_phy_id[1] = 0x00;
+#endif
+}
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bi)
+{
+	macb_eth_initialize(0, (void *)MACB0_BASE, bi->bi_phy_id[0]);
+#ifdef CONFIG_MACB2
+	macb_eth_initialize(1, (void *)MACB1_BASE, bi->bi_phy_id[1]);
+#endif
+	return 0;
+}
+#endif
diff -Naur u-boot-2009.01/board/in-circuit/icnova/Makefile u-boot/board/in-circuit/icnova/Makefile
--- u-boot-2009.01/board/in-circuit/icnova/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/in-circuit/icnova/Makefile	2009-02-27 11:00:19.000000000 +0100
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2001-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# Copyright (C) 2005-2006 Atmel Corporation
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/include/config.mk
+
+LIB	:= $(obj)lib$(BOARD).a
+
+COBJS	:= $(BOARD).o flash.o
+
+sinclude Makefile.$(BNAME)
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+$(LIB): $(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/in-circuit/icnova/Makefile.icnova_oemplus u-boot/board/in-circuit/icnova/Makefile.icnova_oemplus
--- u-boot-2009.01/board/in-circuit/icnova/Makefile.icnova_oemplus	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/in-circuit/icnova/Makefile.icnova_oemplus	2009-02-26 14:46:18.000000000 +0100
@@ -0,0 +1,2 @@
+
+COBJS := $(BOARD).o flash2x8.o
diff -Naur u-boot-2009.01/board/in-circuit/icnova/nand.c u-boot/board/in-circuit/icnova/nand.c
--- u-boot-2009.01/board/in-circuit/icnova/nand.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/in-circuit/icnova/nand.c	2009-02-27 12:19:07.000000000 +0100
@@ -0,0 +1,5 @@
+
+void nand_init(void) {
+	gpio_select_pio(CFG_NAND_CE, GPIOF_OUTPUT);
+	gpio_select_pir(CFG_NAND_RDY, GPIOF_PULLUP);
+}
diff -Naur u-boot-2009.01/board/in-circuit/icnova/u-boot.lds u-boot/board/in-circuit/icnova/u-boot.lds
--- u-boot-2009.01/board/in-circuit/icnova/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/in-circuit/icnova/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,73 @@
+/* -*- Fundamental -*-
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+OUTPUT_FORMAT("elf32-avr32", "elf32-avr32", "elf32-avr32")
+OUTPUT_ARCH(avr32)
+ENTRY(_start)
+
+SECTIONS
+{
+	. = 0;
+	_text = .;
+	.text : {
+		*(.exception.text)
+		*(.text)
+		*(.text.*)
+	}
+	_etext = .;
+
+	.rodata : {
+		*(.rodata)
+		*(.rodata.*)
+	}
+
+	. = ALIGN(8);
+	_data = .;
+	.data : {
+		*(.data)
+		*(.data.*)
+	}
+
+	. = ALIGN(4);
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : {
+		KEEP(*(.u_boot_cmd))
+	}
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	_got = .;
+	.got : {
+		*(.got)
+	}
+	_egot = .;
+
+	. = ALIGN(8);
+	_edata = .;
+
+	.bss (NOLOAD) : {
+		*(.bss)
+		*(.bss.*)
+	}
+	. = ALIGN(8);
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/integratorap/config.mk u-boot/board/integratorap/config.mk
--- u-boot-2009.01/board/integratorap/config.mk	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorap/config.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-#
-# image should be loaded at 0x01000000
-#
-
-TEXT_BASE = 0x01000000
-
-ifneq ($(OBJTREE),$(SRCTREE))
-# We are building u-boot in a separate directory, use generated
-# .lds script from OBJTREE directory.
-LDSCRIPT := $(OBJTREE)/board/$(BOARDDIR)/u-boot.lds
-endif
diff -Naur u-boot-2009.01/board/integratorap/flash.c u-boot/board/integratorap/flash.c
--- u-boot-2009.01/board/integratorap/flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorap/flash.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,473 +0,0 @@
-/*
- * (C) Copyright 2001
- * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
- *
- * (C) Copyright 2001-2004
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * (C) Copyright 2003
- * Texas Instruments, <www.ti.com>
- * Kshitij Gupta <Kshitij@ti.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <linux/byteorder/swab.h>
-
-#define PHYS_FLASH_SECT_SIZE	0x00020000	/* 256 KB sectors (x2) */
-flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];	/* info for FLASH chips    */
-
-/* Board support for 1 or 2 flash devices */
-#undef FLASH_PORT_WIDTH32
-#define FLASH_PORT_WIDTH16
-
-#ifdef FLASH_PORT_WIDTH16
-#define FLASH_PORT_WIDTH		ushort
-#define FLASH_PORT_WIDTHV		vu_short
-#define SWAP(x)			__swab16(x)
-#else
-#define FLASH_PORT_WIDTH		ulong
-#define FLASH_PORT_WIDTHV		vu_long
-#define SWAP(x)			__swab32(x)
-#endif
-
-#define FPW	FLASH_PORT_WIDTH
-#define FPWV	FLASH_PORT_WIDTHV
-
-#define mb() __asm__ __volatile__ ("" : : : "memory")
-
-
-/* Flash Organization Structure */
-typedef struct OrgDef {
-	unsigned int sector_number;
-	unsigned int sector_size;
-} OrgDef;
-
-
-/* Flash Organizations */
-OrgDef OrgIntel_28F256L18T[] = {
-	{4, 32 * 1024},				/* 4 * 32kBytes sectors */
-	{255, 128 * 1024},			/* 255 * 128kBytes sectors */
-};
-
-
-/*-----------------------------------------------------------------------
- * Functions
- */
-unsigned long flash_init (void);
-static ulong flash_get_size (FPW * addr, flash_info_t * info);
-static int write_data (flash_info_t * info, ulong dest, FPW data);
-static void flash_get_offsets (ulong base, flash_info_t * info);
-void inline spin_wheel (void);
-void flash_print_info (flash_info_t * info);
-void flash_unprotect_sectors (FPWV * addr);
-int flash_erase (flash_info_t * info, int s_first, int s_last);
-int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt);
-
-/*-----------------------------------------------------------------------
- */
-
-unsigned long flash_init (void)
-{
-	int i;
-	ulong size = 0;
-	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
-		switch (i) {
-		case 0:
-			flash_get_size ((FPW *) PHYS_FLASH_1, &flash_info[i]);
-			flash_get_offsets (PHYS_FLASH_1, &flash_info[i]);
-			break;
-		default:
-			panic ("configured too many flash banks!\n");
-			break;
-		}
-		size += flash_info[i].size;
-	}
-
-	/* Protect monitor and environment sectors
-	 */
-	flash_protect (FLAG_PROTECT_SET,
-			CONFIG_SYS_FLASH_BASE,
-			CONFIG_SYS_FLASH_BASE + monitor_flash_len - 1, &flash_info[0]);
-
-	return size;
-}
-
-/*-----------------------------------------------------------------------
- */
-static void flash_get_offsets (ulong base, flash_info_t * info)
-{
-	int i;
-	OrgDef *pOrgDef;
-
-	pOrgDef = OrgIntel_28F256L18T;
-	if (info->flash_id == FLASH_UNKNOWN) {
-		return;
-	}
-
-	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL) {
-		for (i = 0; i < info->sector_count; i++) {
-			if (i > 255) {
-				info->start[i] = base + (i * 0x8000);
-				info->protect[i] = 0;
-			} else {
-				info->start[i] = base +
-						(i * PHYS_FLASH_SECT_SIZE);
-				info->protect[i] = 0;
-			}
-		}
-	}
-}
-
-/*-----------------------------------------------------------------------
- */
-void flash_print_info (flash_info_t * info)
-{
-	int i;
-
-	if (info->flash_id == FLASH_UNKNOWN) {
-		printf ("missing or unknown FLASH type\n");
-		return;
-	}
-
-	switch (info->flash_id & FLASH_VENDMASK) {
-	case FLASH_MAN_INTEL:
-		printf ("INTEL ");
-		break;
-	default:
-		printf ("Unknown Vendor ");
-		break;
-	}
-
-	switch (info->flash_id & FLASH_TYPEMASK) {
-	case FLASH_28F256L18T:
-		printf ("FLASH 28F256L18T\n");
-		break;
-	default:
-		printf ("Unknown Chip Type\n");
-		break;
-	}
-
-	printf ("  Size: %ld MB in %d Sectors\n",
-			info->size >> 20, info->sector_count);
-
-	printf ("  Sector Start Addresses:");
-	for (i = 0; i < info->sector_count; ++i) {
-		if ((i % 5) == 0)
-			printf ("\n   ");
-		printf (" %08lX%s",
-			info->start[i], info->protect[i] ? " (RO)" : "     ");
-	}
-	printf ("\n");
-	return;
-}
-
-/*
- * The following code cannot be run from FLASH!
- */
-static ulong flash_get_size (FPW * addr, flash_info_t * info)
-{
-	volatile FPW value;
-
-	/* Write auto select command: read Manufacturer ID */
-	addr[0x5555] = (FPW) 0x00AA00AA;
-	addr[0x2AAA] = (FPW) 0x00550055;
-	addr[0x5555] = (FPW) 0x00900090;
-
-	mb ();
-	value = addr[0];
-
-	switch (value) {
-
-	case (FPW) INTEL_MANUFACT:
-		info->flash_id = FLASH_MAN_INTEL;
-		break;
-
-	default:
-		info->flash_id = FLASH_UNKNOWN;
-		info->sector_count = 0;
-		info->size = 0;
-		addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
-		return (0);		/* no or unknown flash  */
-	}
-
-	mb ();
-	value = addr[1];	/* device ID        */
-	switch (value) {
-
-	case (FPW) (INTEL_ID_28F256L18T):
-		info->flash_id += FLASH_28F256L18T;
-		info->sector_count = 259;
-		info->size = 0x02000000;
-		break;			/* => 32 MB     */
-
-	default:
-		info->flash_id = FLASH_UNKNOWN;
-		break;
-	}
-
-	if (info->sector_count > CONFIG_SYS_MAX_FLASH_SECT) {
-		printf ("** ERROR: sector count %d > max (%d) **\n",
-				info->sector_count, CONFIG_SYS_MAX_FLASH_SECT);
-		info->sector_count = CONFIG_SYS_MAX_FLASH_SECT;
-	}
-
-	addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
-
-	return (info->size);
-}
-
-
-/* unprotects a sector for write and erase
- * on some intel parts, this unprotects the entire chip, but it
- * wont hurt to call this additional times per sector...
- */
-void flash_unprotect_sectors (FPWV * addr)
-{
-#define PD_FINTEL_WSMS_READY_MASK    0x0080
-
-	*addr = (FPW) 0x00500050;	/* clear status register */
-
-	/* this sends the clear lock bit command */
-	*addr = (FPW) 0x00600060;
-	*addr = (FPW) 0x00D000D0;
-}
-
-
-/*-----------------------------------------------------------------------
- */
-
-int flash_erase (flash_info_t * info, int s_first, int s_last)
-{
-	int flag, prot, sect;
-	ulong type, start, last;
-	int rcode = 0;
-
-	if ((s_first < 0) || (s_first > s_last)) {
-		if (info->flash_id == FLASH_UNKNOWN) {
-			printf ("- missing\n");
-		} else {
-			printf ("- no sectors to erase\n");
-		}
-		return 1;
-	}
-
-	type = (info->flash_id & FLASH_VENDMASK);
-	if ((type != FLASH_MAN_INTEL)) {
-		printf ("Can't erase unknown flash type %08lx - aborted\n",
-				info->flash_id);
-		return 1;
-	}
-
-	prot = 0;
-	for (sect = s_first; sect <= s_last; ++sect) {
-		if (info->protect[sect]) {
-			prot++;
-		}
-	}
-
-	if (prot) {
-		printf ("- Warning: %d protected sectors will not be erased!\n",
-				prot);
-	} else {
-		printf ("\n");
-	}
-
-
-	start = get_timer (0);
-	last = start;
-
-	/* Disable interrupts which might cause a timeout here */
-	flag = disable_interrupts ();
-
-	/* Start erase on unprotected sectors */
-	for (sect = s_first; sect <= s_last; sect++) {
-		if (info->protect[sect] == 0) {	/* not protected */
-			FPWV *addr = (FPWV *) (info->start[sect]);
-			FPW status;
-
-			printf ("Erasing sector %2d ... ", sect);
-
-			flash_unprotect_sectors (addr);
-
-			/* arm simple, non interrupt dependent timer */
-			reset_timer_masked ();
-
-			*addr = (FPW) 0x00500050;/* clear status register */
-			*addr = (FPW) 0x00200020;/* erase setup */
-			*addr = (FPW) 0x00D000D0;/* erase confirm */
-
-			while (((status =
-				*addr) & (FPW) 0x00800080) !=
-				(FPW) 0x00800080) {
-					if (get_timer_masked () >
-					CONFIG_SYS_FLASH_ERASE_TOUT) {
-					printf ("Timeout\n");
-					/* suspend erase     */
-					*addr = (FPW) 0x00B000B0;
-					/* reset to read mode */
-					*addr = (FPW) 0x00FF00FF;
-					rcode = 1;
-					break;
-				}
-			}
-
-			/* clear status register cmd.   */
-			*addr = (FPW) 0x00500050;
-			*addr = (FPW) 0x00FF00FF;/* resest to read mode */
-			printf (" done\n");
-		}
-	}
-	return rcode;
-}
-
-/*-----------------------------------------------------------------------
- * Copy memory to flash, returns:
- * 0 - OK
- * 1 - write timeout
- * 2 - Flash not erased
- * 4 - Flash not identified
- */
-
-int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
-{
-	ulong cp, wp;
-	FPW data;
-	int count, i, l, rc, port_width;
-
-	if (info->flash_id == FLASH_UNKNOWN) {
-		return 4;
-	}
-/* get lower word aligned address */
-#ifdef FLASH_PORT_WIDTH16
-	wp = (addr & ~1);
-	port_width = 2;
-#else
-	wp = (addr & ~3);
-	port_width = 4;
-#endif
-
-	/*
-	 * handle unaligned start bytes
-	 */
-	if ((l = addr - wp) != 0) {
-		data = 0;
-		for (i = 0, cp = wp; i < l; ++i, ++cp) {
-			data = (data << 8) | (*(uchar *) cp);
-		}
-		for (; i < port_width && cnt > 0; ++i) {
-			data = (data << 8) | *src++;
-			--cnt;
-			++cp;
-		}
-		for (; cnt == 0 && i < port_width; ++i, ++cp) {
-			data = (data << 8) | (*(uchar *) cp);
-		}
-
-		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
-			return (rc);
-		}
-		wp += port_width;
-	}
-
-	/*
-	 * handle word aligned part
-	 */
-	count = 0;
-	while (cnt >= port_width) {
-		data = 0;
-		for (i = 0; i < port_width; ++i) {
-			data = (data << 8) | *src++;
-		}
-		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
-			return (rc);
-		}
-		wp += port_width;
-		cnt -= port_width;
-		if (count++ > 0x800) {
-			spin_wheel ();
-			count = 0;
-		}
-	}
-
-	if (cnt == 0) {
-		return (0);
-	}
-
-	/*
-	 * handle unaligned tail bytes
-	 */
-	data = 0;
-	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
-		data = (data << 8) | *src++;
-		--cnt;
-	}
-	for (; i < port_width; ++i, ++cp) {
-		data = (data << 8) | (*(uchar *) cp);
-	}
-
-	return (write_data (info, wp, SWAP (data)));
-}
-
-/*-----------------------------------------------------------------------
- * Write a word or halfword to Flash, returns:
- * 0 - OK
- * 1 - write timeout
- * 2 - Flash not erased
- */
-static int write_data (flash_info_t * info, ulong dest, FPW data)
-{
-	FPWV *addr = (FPWV *) dest;
-	ulong status;
-	int flag;
-
-	/* Check if Flash is (sufficiently) erased */
-	if ((*addr & data) != data) {
-		printf ("not erased at %08lx (%x)\n", (ulong) addr, *addr);
-		return (2);
-	}
-	flash_unprotect_sectors (addr);
-	/* Disable interrupts which might cause a timeout here */
-	flag = disable_interrupts ();
-	*addr = (FPW) 0x00400040;	/* write setup */
-	*addr = data;
-
-	/* arm simple, non interrupt dependent timer */
-	reset_timer_masked ();
-
-	/* wait while polling the status register */
-	while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
-		if (get_timer_masked () > CONFIG_SYS_FLASH_WRITE_TOUT) {
-			*addr = (FPW) 0x00FF00FF;	/* restore read mode */
-			return (1);
-		}
-	}
-	*addr = (FPW) 0x00FF00FF;	/* restore read mode */
-	return (0);
-}
-
-void inline spin_wheel (void)
-{
-	static int p = 0;
-	static char w[] = "\\/-";
-
-	printf ("\010%c", w[p]);
-	(++p == 3) ? (p = 0) : 0;
-}
diff -Naur u-boot-2009.01/board/integratorap/integratorap.c u-boot/board/integratorap/integratorap.c
--- u-boot-2009.01/board/integratorap/integratorap.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorap/integratorap.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,656 +0,0 @@
-/*
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Marius Groeger <mgroeger@sysgo.de>
- *
- * (C) Copyright 2002
- * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
- *
- * (C) Copyright 2003
- * Texas Instruments, <www.ti.com>
- * Kshitij Gupta <Kshitij@ti.com>
- *
- * (C) Copyright 2004
- * ARM Ltd.
- * Philippe Robin, <philippe.robin@arm.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-
-#ifdef CONFIG_PCI
-#include <pci.h>
-#endif
-
-#include <netdev.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-void flash__init (void);
-void ether__init (void);
-void peripheral_power_enable (void);
-
-#if defined(CONFIG_SHOW_BOOT_PROGRESS)
-void show_boot_progress(int progress)
-{
-	printf("Boot reached stage %d\n", progress);
-}
-#endif
-
-#define COMP_MODE_ENABLE ((unsigned int)0x0000EAEF)
-
-static inline void delay (unsigned long loops)
-{
-	__asm__ volatile ("1:\n"
-		"subs %0, %1, #1\n"
-		"bne 1b":"=r" (loops):"0" (loops));
-}
-
-/*
- * Miscellaneous platform dependent initialisations
- */
-
-int board_init (void)
-{
-	/* arch number of Integrator Board */
-	gd->bd->bi_arch_number = MACH_TYPE_INTEGRATOR;
-
-	/* adress of boot parameters */
-	gd->bd->bi_boot_params = 0x00000100;
-
-	gd->flags = 0;
-
-#ifdef CONFIG_CM_REMAP
-extern void cm_remap(void);
-	cm_remap();	/* remaps writeable memory to 0x00000000 */
-#endif
-
-	icache_enable ();
-
-	flash__init ();
-	return 0;
-}
-
-
-int misc_init_r (void)
-{
-#ifdef CONFIG_PCI
-	pci_init();
-#endif
-	setenv("verify", "n");
-	return (0);
-}
-
-/*
- * Initialize PCI Devices, report devices found.
- */
-#ifdef CONFIG_PCI
-
-#ifndef CONFIG_PCI_PNP
-
-static struct pci_config_table pci_integrator_config_table[] = {
-	{ PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, 0x0f, PCI_ANY_ID,
-	  pci_cfgfunc_config_device, { PCI_ENET0_IOADDR,
-				       PCI_ENET0_MEMADDR,
-				       PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER }},
-	{ }
-};
-#endif
-
-/* V3 access routines */
-#define _V3Write16(o,v) (*(volatile unsigned short *)(PCI_V3_BASE + (unsigned int)(o)) = (unsigned short)(v))
-#define _V3Read16(o)	(*(volatile unsigned short *)(PCI_V3_BASE + (unsigned int)(o)))
-
-#define _V3Write32(o,v) (*(volatile unsigned int *)(PCI_V3_BASE + (unsigned int)(o)) = (unsigned int)(v))
-#define _V3Read32(o)	(*(volatile unsigned int *)(PCI_V3_BASE + (unsigned int)(o)))
-
-/* Compute address necessary to access PCI config space for the given */
-/* bus and device. */
-#define PCI_CONFIG_ADDRESS( __bus, __devfn, __offset ) ({				\
-	unsigned int __address, __devicebit;						\
-	unsigned short __mapaddress;							\
-	unsigned int __dev = PCI_DEV (__devfn); /* FIXME to check!! (slot?) */		\
-											\
-	if (__bus == 0) {								\
-		/* local bus segment so need a type 0 config cycle */			\
-		/* build the PCI configuration "address" with one-hot in A31-A11 */	\
-		__address = PCI_CONFIG_BASE;						\
-		__address |= ((__devfn & 0x07) << 8);					\
-		__address |= __offset & 0xFF;						\
-		__mapaddress = 0x000A;	/* 101=>config cycle, 0=>A1=A0=0 */		\
-		__devicebit = (1 << (__dev + 11));					\
-											\
-		if ((__devicebit & 0xFF000000) != 0) {					\
-			/* high order bits are handled by the MAP register */		\
-			__mapaddress |= (__devicebit >> 16);				\
-		} else {								\
-			/* low order bits handled directly in the address */		\
-			__address |= __devicebit;					\
-		}									\
-	} else {		/* bus !=0 */						\
-		/* not the local bus segment so need a type 1 config cycle */		\
-		/* A31-A24 are don't care (so clear to 0) */				\
-		__mapaddress = 0x000B;	/* 101=>config cycle, 1=>A1&A0 from PCI_CFG */	\
-		__address = PCI_CONFIG_BASE;						\
-		__address |= ((__bus & 0xFF) << 16);	/* bits 23..16 = bus number	*/  \
-		__address |= ((__dev & 0x1F) << 11);	/* bits 15..11 = device number	*/  \
-		__address |= ((__devfn & 0x07) << 8);	/* bits 10..8  = function number */ \
-		__address |= __offset & 0xFF;	/* bits	 7..0  = register number */	\
-	}										\
-	_V3Write16 (V3_LB_MAP1, __mapaddress);						\
-	__address;									\
-})
-
-/* _V3OpenConfigWindow - open V3 configuration window */
-#define _V3OpenConfigWindow() {								\
-	/* Set up base0 to see all 512Mbytes of memory space (not	     */		\
-	/* prefetchable), this frees up base1 for re-use by configuration*/		\
-	/* memory */									\
-											\
-	_V3Write32 (V3_LB_BASE0, ((INTEGRATOR_PCI_BASE & 0xFFF00000) |			\
-				     0x90 | V3_LB_BASE_M_ENABLE));			\
-	/* Set up base1 to point into configuration space, note that MAP1 */		\
-	/* register is set up by pciMakeConfigAddress(). */				\
-											\
-	_V3Write32 (V3_LB_BASE1, ((CPU_PCI_CNFG_ADRS & 0xFFF00000) |			\
-				     0x40 | V3_LB_BASE_M_ENABLE));			\
-}
-
-/* _V3CloseConfigWindow - close V3 configuration window */
-#define _V3CloseConfigWindow() {							\
-    /* Reassign base1 for use by prefetchable PCI memory */				\
-	_V3Write32 (V3_LB_BASE1, (((INTEGRATOR_PCI_BASE + 0x10000000) & 0xFFF00000)	\
-					| 0x84 | V3_LB_BASE_M_ENABLE));			\
-	_V3Write16 (V3_LB_MAP1,								\
-	    (((INTEGRATOR_PCI_BASE + 0x10000000) & 0xFFF00000) >> 16) | 0x0006);	\
-											\
-	/* And shrink base0 back to a 256M window (NOTE: MAP0 already correct) */	\
-											\
-	_V3Write32 (V3_LB_BASE0, ((INTEGRATOR_PCI_BASE & 0xFFF00000) |			\
-			     0x80 | V3_LB_BASE_M_ENABLE));				\
-}
-
-static int pci_integrator_read_byte (struct pci_controller *hose, pci_dev_t dev,
-				     int offset, unsigned char *val)
-{
-	_V3OpenConfigWindow ();
-	*val = *(volatile unsigned char *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
-							       PCI_FUNC (dev),
-							       offset);
-	_V3CloseConfigWindow ();
-
-	return 0;
-}
-
-static int pci_integrator_read__word (struct pci_controller *hose,
-				      pci_dev_t dev, int offset,
-				      unsigned short *val)
-{
-	_V3OpenConfigWindow ();
-	*val = *(volatile unsigned short *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
-								PCI_FUNC (dev),
-								offset);
-	_V3CloseConfigWindow ();
-
-	return 0;
-}
-
-static int pci_integrator_read_dword (struct pci_controller *hose,
-				      pci_dev_t dev, int offset,
-				      unsigned int *val)
-{
-	_V3OpenConfigWindow ();
-	*val = *(volatile unsigned short *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
-								PCI_FUNC (dev),
-								offset);
-	*val |= (*(volatile unsigned int *)
-		 PCI_CONFIG_ADDRESS (PCI_BUS (dev), PCI_FUNC (dev),
-				     (offset + 2))) << 16;
-	_V3CloseConfigWindow ();
-
-	return 0;
-}
-
-static int pci_integrator_write_byte (struct pci_controller *hose,
-				      pci_dev_t dev, int offset,
-				      unsigned char val)
-{
-	_V3OpenConfigWindow ();
-	*(volatile unsigned char *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
-							PCI_FUNC (dev),
-							offset) = val;
-	_V3CloseConfigWindow ();
-
-	return 0;
-}
-
-static int pci_integrator_write_word (struct pci_controller *hose,
-				      pci_dev_t dev, int offset,
-				      unsigned short val)
-{
-	_V3OpenConfigWindow ();
-	*(volatile unsigned short *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
-							 PCI_FUNC (dev),
-							 offset) = val;
-	_V3CloseConfigWindow ();
-
-	return 0;
-}
-
-static int pci_integrator_write_dword (struct pci_controller *hose,
-				       pci_dev_t dev, int offset,
-				       unsigned int val)
-{
-	_V3OpenConfigWindow ();
-	*(volatile unsigned short *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
-							 PCI_FUNC (dev),
-							 offset) = (val & 0xFFFF);
-	*(volatile unsigned short *) PCI_CONFIG_ADDRESS (PCI_BUS (dev),
-							 PCI_FUNC (dev),
-							 (offset + 2)) = ((val >> 16) & 0xFFFF);
-	_V3CloseConfigWindow ();
-
-	return 0;
-}
-/******************************
- * PCI initialisation
- ******************************/
-
-struct pci_controller integrator_hose = {
-#ifndef CONFIG_PCI_PNP
-	config_table: pci_integrator_config_table,
-#endif
-};
-
-void pci_init_board (void)
-{
-	volatile int i, j;
-	struct pci_controller *hose = &integrator_hose;
-
-	/* setting this register will take the V3 out of reset */
-
-	*(volatile unsigned int *) (INTEGRATOR_SC_PCIENABLE) = 1;
-
-	/* wait a few usecs to settle the device and the PCI bus */
-
-	for (i = 0; i < 100; i++)
-		j = i + 1;
-
-	/* Now write the Base I/O Address Word to V3_BASE + 0x6C */
-
-	*(volatile unsigned short *) (V3_BASE + V3_LB_IO_BASE) =
-		(unsigned short) (V3_BASE >> 16);
-
-	do {
-		*(volatile unsigned char *) (V3_BASE + V3_MAIL_DATA) = 0xAA;
-		*(volatile unsigned char *) (V3_BASE + V3_MAIL_DATA + 4) =
-			0x55;
-	} while (*(volatile unsigned char *) (V3_BASE + V3_MAIL_DATA) != 0xAA
-		 || *(volatile unsigned char *) (V3_BASE + V3_MAIL_DATA +
-						 4) != 0x55);
-
-	/* Make sure that V3 register access is not locked, if it is, unlock it */
-
-	if ((*(volatile unsigned short *) (V3_BASE + V3_SYSTEM) &
-	     V3_SYSTEM_M_LOCK)
-	    == V3_SYSTEM_M_LOCK)
-		*(volatile unsigned short *) (V3_BASE + V3_SYSTEM) = 0xA05F;
-
-	/* Ensure that the slave accesses from PCI are disabled while we */
-	/* setup windows */
-
-	*(volatile unsigned short *) (V3_BASE + V3_PCI_CMD) &=
-		~(V3_COMMAND_M_MEM_EN | V3_COMMAND_M_IO_EN);
-
-	/* Clear RST_OUT to 0; keep the PCI bus in reset until we've finished */
-
-	*(volatile unsigned short *) (V3_BASE + V3_SYSTEM) &=
-		~V3_SYSTEM_M_RST_OUT;
-
-	/* Make all accesses from PCI space retry until we're ready for them */
-
-	*(volatile unsigned short *) (V3_BASE + V3_PCI_CFG) |=
-		V3_PCI_CFG_M_RETRY_EN;
-
-	/* Set up any V3 PCI Configuration Registers that we absolutely have to */
-	/* LB_CFG controls Local Bus protocol. */
-	/* Enable LocalBus byte strobes for READ accesses too. */
-	/* set bit 7 BE_IMODE and bit 6 BE_OMODE */
-
-	*(volatile unsigned short *) (V3_BASE + V3_LB_CFG) |= 0x0C0;
-
-	/* PCI_CMD controls overall PCI operation. */
-	/* Enable PCI bus master. */
-
-	*(volatile unsigned short *) (V3_BASE + V3_PCI_CMD) |= 0x04;
-
-	/* PCI_MAP0 controls where the PCI to CPU memory window is on Local Bus */
-
-	*(volatile unsigned int *) (V3_BASE + V3_PCI_MAP0) =
-		(INTEGRATOR_BOOT_ROM_BASE) | (V3_PCI_MAP_M_ADR_SIZE_512M |
-					      V3_PCI_MAP_M_REG_EN |
-					      V3_PCI_MAP_M_ENABLE);
-
-	/* PCI_BASE0 is the PCI address of the start of the window */
-
-	*(volatile unsigned int *) (V3_BASE + V3_PCI_BASE0) =
-		INTEGRATOR_BOOT_ROM_BASE;
-
-	/* PCI_MAP1 is LOCAL address of the start of the window */
-
-	*(volatile unsigned int *) (V3_BASE + V3_PCI_MAP1) =
-		(INTEGRATOR_HDR0_SDRAM_BASE) | (V3_PCI_MAP_M_ADR_SIZE_1024M |
-						V3_PCI_MAP_M_REG_EN |
-						V3_PCI_MAP_M_ENABLE);
-
-	/* PCI_BASE1 is the PCI address of the start of the window */
-
-	*(volatile unsigned int *) (V3_BASE + V3_PCI_BASE1) =
-		INTEGRATOR_HDR0_SDRAM_BASE;
-
-	/* Set up the windows from local bus memory into PCI configuration, */
-	/* I/O and Memory. */
-	/* PCI I/O, LB_BASE2 and LB_MAP2 are used exclusively for this. */
-
-	*(volatile unsigned short *) (V3_BASE + V3_LB_BASE2) =
-		((CPU_PCI_IO_ADRS >> 24) << 8) | V3_LB_BASE_M_ENABLE;
-	*(volatile unsigned short *) (V3_BASE + V3_LB_MAP2) = 0;
-
-	/* PCI Configuration, use LB_BASE1/LB_MAP1. */
-
-	/* PCI Memory use LB_BASE0/LB_MAP0 and LB_BASE1/LB_MAP1 */
-	/* Map first 256Mbytes as non-prefetchable via BASE0/MAP0 */
-	/* (INTEGRATOR_PCI_BASE == PCI_MEM_BASE) */
-
-	*(volatile unsigned int *) (V3_BASE + V3_LB_BASE0) =
-		INTEGRATOR_PCI_BASE | (0x80 | V3_LB_BASE_M_ENABLE);
-
-	*(volatile unsigned short *) (V3_BASE + V3_LB_MAP0) =
-		((INTEGRATOR_PCI_BASE >> 20) << 0x4) | 0x0006;
-
-	/* Map second 256 Mbytes as prefetchable via BASE1/MAP1 */
-
-	*(volatile unsigned int *) (V3_BASE + V3_LB_BASE1) =
-		INTEGRATOR_PCI_BASE | (0x84 | V3_LB_BASE_M_ENABLE);
-
-	*(volatile unsigned short *) (V3_BASE + V3_LB_MAP1) =
-		(((INTEGRATOR_PCI_BASE + 0x10000000) >> 20) << 4) | 0x0006;
-
-	/* Allow accesses to PCI Configuration space */
-	/* and set up A1, A0 for type 1 config cycles */
-
-	*(volatile unsigned short *) (V3_BASE + V3_PCI_CFG) =
-		((*(volatile unsigned short *) (V3_BASE + V3_PCI_CFG)) &
-		 ~(V3_PCI_CFG_M_RETRY_EN | V3_PCI_CFG_M_AD_LOW1)) |
-		V3_PCI_CFG_M_AD_LOW0;
-
-	/* now we can allow in PCI MEMORY accesses */
-
-	*(volatile unsigned short *) (V3_BASE + V3_PCI_CMD) =
-		(*(volatile unsigned short *) (V3_BASE + V3_PCI_CMD)) |
-		V3_COMMAND_M_MEM_EN;
-
-	/* Set RST_OUT to take the PCI bus is out of reset, PCI devices can */
-	/* initialise and lock the V3 system register so that no one else */
-	/* can play with it */
-
-	*(volatile unsigned short *) (V3_BASE + V3_SYSTEM) =
-		(*(volatile unsigned short *) (V3_BASE + V3_SYSTEM)) |
-		V3_SYSTEM_M_RST_OUT;
-
-	*(volatile unsigned short *) (V3_BASE + V3_SYSTEM) =
-		(*(volatile unsigned short *) (V3_BASE + V3_SYSTEM)) |
-		V3_SYSTEM_M_LOCK;
-
-	/*
-	 * Register the hose
-	 */
-	hose->first_busno = 0;
-	hose->last_busno = 0xff;
-
-	/* System memory space */
-	pci_set_region (hose->regions + 0,
-			0x00000000, 0x40000000, 0x01000000,
-			PCI_REGION_MEM | PCI_REGION_MEMORY);
-
-	/* PCI Memory - config space */
-	pci_set_region (hose->regions + 1,
-			0x00000000, 0x62000000, 0x01000000, PCI_REGION_MEM);
-
-	/* PCI V3 regs */
-	pci_set_region (hose->regions + 2,
-			0x00000000, 0x61000000, 0x00080000, PCI_REGION_MEM);
-
-	/* PCI I/O space */
-	pci_set_region (hose->regions + 3,
-			0x00000000, 0x60000000, 0x00010000, PCI_REGION_IO);
-
-	pci_set_ops (hose,
-		     pci_integrator_read_byte,
-		     pci_integrator_read__word,
-		     pci_integrator_read_dword,
-		     pci_integrator_write_byte,
-		     pci_integrator_write_word, pci_integrator_write_dword);
-
-	hose->region_count = 4;
-
-	pci_register_hose (hose);
-
-	pciauto_config_init (hose);
-	pciauto_config_device (hose, 0);
-
-	hose->last_busno = pci_hose_scan (hose);
-}
-#endif
-
-/******************************
- Routine:
- Description:
-******************************/
-void flash__init (void)
-{
-}
-/*************************************************************
- Routine:ether__init
- Description: take the Ethernet controller out of reset and wait
-			   for the EEPROM load to complete.
-*************************************************************/
-void ether__init (void)
-{
-}
-
-/******************************
- Routine:
- Description:
-******************************/
-int dram_init (void)
-{
-	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
-	gd->bd->bi_dram[0].size	 = PHYS_SDRAM_1_SIZE;
-
-#ifdef CONFIG_CM_SPD_DETECT
-	{
-extern void dram_query(void);
-	unsigned long cm_reg_sdram;
-	unsigned long sdram_shift;
-
-	dram_query();	/* Assembler accesses to CM registers */
-			/* Queries the SPD values	      */
-
-	/* Obtain the SDRAM size from the CM SDRAM register */
-
-	cm_reg_sdram = *(volatile ulong *)(CM_BASE + OS_SDRAM);
-	/*   Register	      SDRAM size
-	 *
-	 *   0xXXXXXXbbb000bb	 16 MB
-	 *   0xXXXXXXbbb001bb	 32 MB
-	 *   0xXXXXXXbbb010bb	 64 MB
-	 *   0xXXXXXXbbb011bb	128 MB
-	 *   0xXXXXXXbbb100bb	256 MB
-	 *
-	 */
-	sdram_shift		 = ((cm_reg_sdram & 0x0000001C)/4)%4;
-	gd->bd->bi_dram[0].size	 = 0x01000000 << sdram_shift;
-
-	}
-#endif /* CM_SPD_DETECT */
-
-	return 0;
-}
-
-/* The Integrator/AP timer1 is clocked at 24MHz
- * can be divided by 16 or 256
- * and is a 16-bit counter
- */
-/* U-Boot expects a 32 bit timer running at CONFIG_SYS_HZ*/
-static ulong timestamp;		/* U-Boot ticks since startup	      */
-static ulong total_count = 0;	/* Total timer count		      */
-static ulong lastdec;		/* Timer reading at last call	      */
-static ulong div_clock	 = 256; /* Divisor applied to the timer clock */
-static ulong div_timer	 = 1;	/* Divisor to convert timer reading
-				 * change to U-Boot ticks
-				 */
-/* CONFIG_SYS_HZ = CONFIG_SYS_HZ_CLOCK/(div_clock * div_timer) */
-
-#define TIMER_LOAD_VAL 0x0000FFFFL
-#define READ_TIMER ((*(volatile ulong *)(CONFIG_SYS_TIMERBASE+4)) & 0x0000FFFFL)
-
-/* all function return values in U-Boot ticks i.e. (1/CONFIG_SYS_HZ) sec
- *  - unless otherwise stated
- */
-
-/* starts a counter
- * - the Integrator/AP timer issues an interrupt
- *   each time it reaches zero
- */
-int interrupt_init (void)
-{
-	/* Load timer with initial value */
-	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 0) = TIMER_LOAD_VAL;
-	/* Set timer to be
-	 *	enabled		  1
-	 *	free-running	  0
-	 *	XX		 00
-	 *	divider 256	 10
-	 *	XX		 00
-	 */
-	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 8) = 0x00000088;
-	total_count = 0;
-	/* init the timestamp and lastdec value */
-	reset_timer_masked();
-
-	div_timer  = CONFIG_SYS_HZ_CLOCK / CONFIG_SYS_HZ;
-	div_timer /= div_clock;
-
-	return (0);
-}
-
-/*
- * timer without interrupts
- */
-void reset_timer (void)
-{
-	reset_timer_masked ();
-}
-
-ulong get_timer (ulong base_ticks)
-{
-	return get_timer_masked () - base_ticks;
-}
-
-void set_timer (ulong ticks)
-{
-	timestamp = ticks;
-	total_count = ticks * div_timer;
-	reset_timer_masked();
-}
-
-/* delay x useconds */
-void udelay (unsigned long usec)
-{
-	ulong tmo, tmp;
-
-	/* Convert to U-Boot ticks */
-	tmo  = usec * CONFIG_SYS_HZ;
-	tmo /= (1000000L);
-
-	tmp  = get_timer_masked();	/* get current timestamp */
-	tmo += tmp;			/* wake up timestamp	 */
-
-	while (get_timer_masked () < tmo) { /* loop till event */
-		/*NOP*/;
-	}
-}
-
-void reset_timer_masked (void)
-{
-	/* reset time */
-	lastdec	  = READ_TIMER; /* capture current decrementer value   */
-	timestamp = 0;		/* start "advancing" time stamp from 0 */
-}
-
-/* converts the timer reading to U-Boot ticks	       */
-/* the timestamp is the number of ticks since reset    */
-/* This routine does not detect wraps unless called regularly
-   ASSUMES a call at least every 16 seconds to detect every reload */
-ulong get_timer_masked (void)
-{
-	ulong now = READ_TIMER;		/* current count */
-
-	if (now > lastdec) {
-		/* Must have wrapped */
-		total_count += lastdec + TIMER_LOAD_VAL + 1 - now;
-	} else {
-		total_count += lastdec - now;
-	}
-	lastdec	  = now;
-	timestamp = total_count/div_timer;
-
-	return timestamp;
-}
-
-/* waits specified delay value and resets timestamp */
-void udelay_masked (unsigned long usec)
-{
-	udelay(usec);
-}
-
-/*
- * This function is derived from PowerPC code (read timebase as long long).
- * On ARM it just returns the timer value.
- */
-unsigned long long get_ticks(void)
-{
-	return get_timer(0);
-}
-
-/*
- * Return the timebase clock frequency
- * i.e. how often the timer decrements
- */
-ulong get_tbclk (void)
-{
-	return CONFIG_SYS_HZ_CLOCK/div_clock;
-}
-
-int board_eth_init(bd_t *bis)
-{
-	return pci_eth_init(bis);
-}
diff -Naur u-boot-2009.01/board/integratorap/lowlevel_init.S u-boot/board/integratorap/lowlevel_init.S
--- u-boot-2009.01/board/integratorap/lowlevel_init.S	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorap/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,213 +0,0 @@
-/*
- * Board specific setup info
- *
- * (C) Copyright 2004, ARM Ltd.
- * Philippe Robin, <philippe.robin@arm.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <version.h>
-
-	/* Reset using CM control register */
-.global reset_cpu
-reset_cpu:
-	mov	r0, #CM_BASE
-	ldr	r1,[r0,#OS_CTRL]
-	orr	r1,r1,#CMMASK_RESET
-	str	r1,[r0,#OS_CTRL]
-
-reset_failed:
-	b	reset_failed
-
-/* Set up the platform, once the cpu has been initialized */
-.globl lowlevel_init
-lowlevel_init:
-	/* If U-Boot has been run after the ARM boot monitor
-	 * then all the necessary actions have been done
-	 * otherwise we are running from user flash mapped to 0x00000000
-	 * --- DO NOT REMAP BEFORE THE CODE HAS BEEN RELOCATED --
-	 * Changes to the (possibly soft) reset defaults of the processor
-	 * itself should be performed in cpu/arm<>/start.S
-	 * This function affects only the core module or board settings
-	 */
-
-#ifdef CONFIG_CM_INIT
-	/* CM has an initialization register
-	 * - bits in it are wired into test-chip pins to force
-	 *   reset defaults
-	 * - may need to change its contents for U-Boot
-	 */
-
-	/* set the desired CM specific value */
-	mov	r2,#CMMASK_LOWVEC	/* Vectors at 0x00000000 for all */
-
-#if defined (CONFIG_CM10200E) || defined (CONFIG_CM10220E)
-	orr	r2,r2,#CMMASK_INIT_102
-#else
-
-#if !defined (CONFIG_CM920T) && !defined (CONFIG_CM920T_ETM) && \
-     !defined (CONFIG_CM940T)
-
-#ifdef	CONFIG_CM_MULTIPLE_SSRAM
-	/* set simple mapping			*/
-	and	r2,r2,#CMMASK_MAP_SIMPLE
-#endif /* #ifdef CONFIG_CM_MULTIPLE_SSRAM	*/
-
-#ifdef	CONFIG_CM_TCRAM
-	/* disable TCRAM			*/
-	and	r2,r2,#CMMASK_TCRAM_DISABLE
-#endif /* #ifdef CONFIG_CM_TCRAM		*/
-
-#if defined (CONFIG_CM926EJ_S) || defined (CONFIG_CM1026EJ_S) || \
-     defined (CONFIG_CM1136JF_S)
-
-	and	r2,r2,#CMMASK_LE
-
-#endif /* cpu with little endian initialization */
-
-	orr	r2,r2,#CMMASK_CMxx6_COMMON
-
-#endif /* CMxx6 code */
-
-#endif /* ARM102xxE value */
-
-	/* read CM_INIT		 */
-	mov	r0, #CM_BASE
-	ldr	r1, [r0, #OS_INIT]
-	/* check against desired bit setting */
-	and	r3,r1,r2
-	cmp	r3,r2
-	beq	init_reg_OK
-
-	/* lock for change */
-	mov	r3, #CMVAL_LOCK1
-	add	r3,r3,#CMVAL_LOCK2
-	str	r3, [r0, #OS_LOCK]
-	/* set desired value */
-	orr	r1,r1,r2
-	/* write & relock CM_INIT */
-	str	r1, [r0, #OS_INIT]
-	mov	r1, #CMVAL_UNLOCK
-	str	r1, [r0, #OS_LOCK]
-
-	/* soft reset so new values used */
-	b	reset_cpu
-
-init_reg_OK:
-
-#endif /* CONFIG_CM_INIT */
-
-	mov	pc, lr
-
-#ifdef	CONFIG_CM_SPD_DETECT
-	/* Fast memory is available for the DRAM data
-	 * - ensure it has been transferred, then summarize the data
-	 *   into a CM register
-	 */
-.globl dram_query
-dram_query:
-	stmfd	r13!,{r4-r6,lr}
-	/* set up SDRAM info					*/
-	/* - based on example code from the CM User Guide */
-	mov	r0, #CM_BASE
-
-readspdbit:
-	ldr	r1, [r0, #OS_SDRAM]	/* read the SDRAM register	*/
-	and	r1, r1, #0x20		/* mask SPD bit (5)		*/
-	cmp	r1, #0x20		/* test if set			*/
-	bne	readspdbit
-
-setupsdram:
-	add	r0, r0, #OS_SPD		/* address the copy of the SDP data	*/
-	ldrb	r1, [r0, #3]		/* number of row address lines		*/
-	ldrb	r2, [r0, #4]		/* number of column address lines	*/
-	ldrb	r3, [r0, #5]		/* number of banks			*/
-	ldrb	r4, [r0, #31]		/* module bank density			*/
-	mul	r5, r4, r3		/* size of SDRAM (MB divided by 4)	*/
-	mov	r5, r5, ASL#2		/* size in MB				*/
-	mov	r0, #CM_BASE		/* reload for later code		*/
-	cmp	r5, #0x10		/* is it 16MB?				*/
-	bne	not16
-	mov	r6, #0x2		/* store size and CAS latency of 2	*/
-	b	writesize
-
-not16:
-	cmp	r5, #0x20		/* is it  32MB? */
-	bne	not32
-	mov	r6, #0x6
-	b	writesize
-
-not32:
-	cmp	r5, #0x40		/* is it  64MB? */
-	bne	not64
-	mov	r6, #0xa
-	b	writesize
-
-not64:
-	cmp	r5, #0x80		/* is it 128MB? */
-	bne	not128
-	mov	r6, #0xe
-	b	writesize
-
-not128:
-	/* if it is none of these sizes then it is either 256MB, or
-	 * there is no SDRAM fitted so default to 256MB
-	 */
-	mov	r6, #0x12
-
-writesize:
-	mov	r1, r1, ASL#8		/* row addr lines from SDRAM reg */
-	orr	r2, r1, r2, ASL#12	/* OR in column address lines	 */
-	orr	r3, r2, r3, ASL#16	/* OR in number of banks	 */
-	orr	r6, r6, r3		/* OR in size and CAS latency	 */
-	str	r6, [r0, #OS_SDRAM]	/* store SDRAM parameters	 */
-
-#endif /* #ifdef CONFIG_CM_SPD_DETECT */
-
-	ldmfd	r13!,{r4-r6,pc}			/* back to caller */
-
-#ifdef	CONFIG_CM_REMAP
-	/* CM remap bit is operational
-	 * - use it to map writeable memory at 0x00000000, in place of flash
-	 */
-.globl cm_remap
-cm_remap:
-	stmfd	r13!,{r4-r10,lr}
-
-	mov	r0, #CM_BASE
-	ldr	r1, [r0, #OS_CTRL]
-	orr	r1, r1, #CMMASK_REMAP	/* set remap and led bits */
-	str	r1, [r0, #OS_CTRL]
-
-	/* Now 0x00000000 is writeable, replace the vectors	*/
-	ldr	r0, =_start	/* r0 <- start of vectors	*/
-	ldr	r2, =_armboot_start	/* r2 <- past vectors	*/
-	sub	r1,r1,r1		/* destination 0x00000000	*/
-
-copy_vec:
-	ldmia	r0!, {r3-r10}		/* copy from source address [r0]	*/
-	stmia	r1!, {r3-r10}		/* copy to	 target address [r1]	*/
-	cmp	r0, r2			/* until source end address [r2]	*/
-	ble	copy_vec
-
-	ldmfd	r13!,{r4-r10,pc}	/* back to caller			*/
-
-#endif /* #ifdef CONFIG_CM_REMAP */
diff -Naur u-boot-2009.01/board/integratorap/Makefile u-boot/board/integratorap/Makefile
--- u-boot-2009.01/board/integratorap/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorap/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-#
-# (C) Copyright 2000-2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# (C) Copyright 2004
-# ARM Ltd.
-# Philippe Robin, <philippe.robin@arm.com>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= $(obj)lib$(BOARD).a
-
-COBJS	:= integratorap.o flash.o
-SOBJS	:= lowlevel_init.o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
-
-$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
-	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
-
-clean:
-	rm -f $(SOBJS) $(OBJS)
-
-distclean:	clean
-	rm -f $(LIB) core *.bak $(obj).depend
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff -Naur u-boot-2009.01/board/integratorap/split_by_variant.sh u-boot/board/integratorap/split_by_variant.sh
--- u-boot-2009.01/board/integratorap/split_by_variant.sh	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorap/split_by_variant.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,119 +0,0 @@
-#!/bin/sh
-# ---------------------------------------------------------
-# Set the platform defines
-# ---------------------------------------------------------
-echo -n	"/* Integrator configuration implied "	 > tmp.fil
-echo	" by Makefile target */"		>> tmp.fil
-echo -n	"#define CONFIG_INTEGRATOR"		>> tmp.fil
-echo	" /* Integrator board */"		>> tmp.fil
-echo -n	"#define CONFIG_ARCH_INTEGRATOR"	>> tmp.fil
-echo	" 1 /* Integrator/AP	 */"		>> tmp.fil
-# ---------------------------------------------------------
-#	Set the core module defines according to Core Module
-# ---------------------------------------------------------
-cpu="arm_intcm"
-variant="unknown core module"
-
-if [ "$1" = "" ]
-then
-	echo "$0:: No parameters - using arm_intcm"
-else
-	case "$1" in
-	ap7_config)
-	cpu="arm_intcm"
-	variant="unported core module CM7TDMI"
-	;;
-
-	ap966)
-	cpu="arm_intcm"
-	variant="unported core module CM966E-S"
-	;;
-
-	ap922_config)
-	cpu="arm_intcm"
-	variant="unported core module CM922T"
-	;;
-
-	integratorap_config	|	\
-	ap_config)
-	cpu="arm_intcm"
-	variant="unspecified core module"
-	;;
-
-	ap720t_config)
-	cpu="arm720t"
-	echo -n	"#define CONFIG_CM720T"			>> tmp.fil
-	echo	" 1 /* CPU core is ARM720T */ "		>> tmp.fil
-	variant="Core module CM720T"
-	;;
-
-	ap922_XA10_config)
-	cpu="arm_intcm"
-	variant="unported core module CM922T_XA10"
-	echo -n	"#define CONFIG_CM922T_XA10"		>> tmp.fil
-	echo	" 1 /* CPU core is ARM922T_XA10 */"	>> tmp.fil
-	;;
-
-	ap920t_config)
-	cpu="arm920t"
-	variant="Core module CM920T"
-	echo -n	"#define CONFIG_CM920T"			>> tmp.fil
-	echo	" 1 /* CPU core is ARM920T */"		>> tmp.fil
-	;;
-
-	ap926ejs_config)
-	cpu="arm926ejs"
-	variant="Core module CM926EJ-S"
-	echo -n	"#define CONFIG_CM926EJ_S"		>> tmp.fil
-	echo	" 1 /* CPU core is ARM926EJ-S */ "	>> tmp.fil
-	;;
-
-	ap946es_config)
-	cpu="arm946es"
-	variant="Core module CM946E-S"
-	echo -n	"#define CONFIG_CM946E_S"		>> tmp.fil
-	echo	" 1 /* CPU core is ARM946E-S */ "	>> tmp.fil
-	;;
-
-	*)
-	echo "$0:: Unknown core module"
-	variant="unknown core module"
-	cpu="arm_intcm"
-	;;
-
-	esac
-fi
-
-if [ "$cpu" = "arm_intcm" ]
-then
-	echo "/* Core module undefined/not ported */"	>> tmp.fil
-	echo "#define CONFIG_ARM_INTCM 1"		>> tmp.fil
-	echo -n	"#undef CONFIG_CM_MULTIPLE_SSRAM"	>> tmp.fil
-	echo -n	"	/* CM may not have "		>> tmp.fil
-	echo	"multiple SSRAM mapping */"		>> tmp.fil
-	echo -n	"#undef CONFIG_CM_SPD_DETECT "		>> tmp.fil
-	echo -n	" /* CM may not support SPD "		>> tmp.fil
-	echo	"query */"				>> tmp.fil
-	echo -n	"#undef CONFIG_CM_REMAP	"		>> tmp.fil
-	echo -n	" /* CM may not support "		>> tmp.fil
-	echo	"remapping */"				>> tmp.fil
-	echo -n	"#undef CONFIG_CM_INIT	"		>> tmp.fil
-	echo -n	" /* CM may not have	"		>> tmp.fil
-	echo	"initialization reg */"			>> tmp.fil
-	echo -n	"#undef CONFIG_CM_TCRAM	"		>> tmp.fil
-	echo	" /* CM may not have TCRAM */"		>> tmp.fil
-fi
-
-mkdir -p ${obj}include
-mkdir -p ${obj}board/integratorap
-mv tmp.fil ${obj}include/config.h
-# ---------------------------------------------------------
-#	Ensure correct core object loaded first in U-Boot image
-# ---------------------------------------------------------
-sed -r 's/CPU_FILE/cpu\/'$cpu'\/start.o/; s/#.*//' ${src}board/integratorap/u-boot.lds.template > ${obj}board/integratorap/u-boot.lds
-# ---------------------------------------------------------
-# Complete the configuration
-# ---------------------------------------------------------
-$MKCONFIG -a integratorap arm $cpu integratorap;
-echo "Variant:: $variant with core $cpu"
-
diff -Naur u-boot-2009.01/board/integratorap/u-boot.lds.template u-boot/board/integratorap/u-boot.lds.template
--- u-boot-2009.01/board/integratorap/u-boot.lds.template	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorap/u-boot.lds.template	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-/*
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-# Template used during configuration to emsure the core module processor code,
-# from CPU_FILE, is placed at the start of the image */
-
-OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
-OUTPUT_ARCH(arm)
-ENTRY(_start)
-SECTIONS
-{
-	. = 0x00000000;
-	. = ALIGN(4);
-	.text	:
-	{
-		CPU_FILE (.text)
-		*(.text)
-	}
-	.rodata : { *(.rodata) }
-	. = ALIGN(4);
-	.data : { *(.data) }
-	. = ALIGN(4);
-	.got : { *(.got) }
-
-	. = .;
-	__u_boot_cmd_start = .;
-	.u_boot_cmd : { *(.u_boot_cmd) }
-	__u_boot_cmd_end = .;
-
-	. = ALIGN(4);
-	__bss_start = .;
-	.bss : { *(.bss) }
-	_end = .;
-}
diff -Naur u-boot-2009.01/board/integratorcp/config.mk u-boot/board/integratorcp/config.mk
--- u-boot-2009.01/board/integratorcp/config.mk	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorcp/config.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-#
-# image should be loaded at 0x01000000
-#
-
-TEXT_BASE = 0x01000000
-
-ifneq ($(OBJTREE),$(SRCTREE))
-# We are building u-boot in a separate directory, use generated
-# .lds script from OBJTREE directory.
-LDSCRIPT := $(OBJTREE)/board/$(BOARDDIR)/u-boot.lds
-endif
diff -Naur u-boot-2009.01/board/integratorcp/flash.c u-boot/board/integratorcp/flash.c
--- u-boot-2009.01/board/integratorcp/flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorcp/flash.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,564 +0,0 @@
-/*
- * (C) Copyright 2004
- * Xiaogeng (Shawn) Jin, Agilent Technologies, xiaogeng_jin@agilent.com
- *
- * (C) Copyright 2001
- * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
- *
- * (C) Copyright 2001-2004
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * (C) Copyright 2003
- * Texas Instruments, <www.ti.com>
- * Kshitij Gupta <Kshitij@ti.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <linux/byteorder/swab.h>
-
-#define DEBUG
-
-#define PHYS_FLASH_SECT_SIZE	0x00040000	/* 256 KB sectors (x2) */
-flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];	/* info for FLASH chips */
-
-/* Board support for 1 or 2 flash devices */
-#define FLASH_PORT_WIDTH32
-#undef FLASH_PORT_WIDTH16
-
-#ifdef FLASH_PORT_WIDTH16
-#define FLASH_PORT_WIDTH	ushort
-#define FLASH_PORT_WIDTHV	vu_short
-#define SWAP(x)			__swab16(x)
-#else
-#define FLASH_PORT_WIDTH	ulong
-#define FLASH_PORT_WIDTHV	vu_long
-#define SWAP(x)			__swab32(x)
-#endif
-
-#define FPW	FLASH_PORT_WIDTH
-#define FPWV	FLASH_PORT_WIDTHV
-
-#define mb() __asm__ __volatile__ ("" : : : "memory")
-
-
-/* Flash Organization Structure */
-typedef struct OrgDef {
-	unsigned int sector_number;
-	unsigned int sector_size;
-} OrgDef;
-
-
-/* Flash Organizations */
-OrgDef OrgIntel_28F256L18T[] = {
-	{4, 32 * 1024},				/* 4 * 32kBytes sectors */
-	{255, 128 * 1024},			/* 255 * 128kBytes sectors */
-};
-
-/* CP control register base address */
-#define CPCR_BASE		0xCB000000
-#define CPCR_EXTRABANK		0x8
-#define CPCR_FLASHSIZE		0x4
-#define CPCR_FLWREN		0x2
-#define CPCR_FLVPPEN		0x1
-
-/*-----------------------------------------------------------------------
- * Functions
- */
-unsigned long flash_init (void);
-static ulong flash_get_size (FPW * addr, flash_info_t * info);
-static int write_data (flash_info_t * info, ulong dest, FPW data);
-static void flash_get_offsets (ulong base, flash_info_t * info);
-void inline spin_wheel (void);
-void flash_print_info (flash_info_t * info);
-void flash_unprotect_sectors (FPWV * addr);
-int flash_erase (flash_info_t * info, int s_first, int s_last);
-int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt);
-
-/*-----------------------------------------------------------------------
- */
-unsigned long flash_init (void)
-{
-	int i, nbanks;
-	ulong size = 0;
-	vu_long *cpcr = (vu_long *)CPCR_BASE;
-
-	/* Check if there is an extra bank of flash */
-	if (cpcr[1] & CPCR_EXTRABANK)
-		nbanks = 2;
-	else
-		nbanks = 1;
-
-	if (nbanks > CONFIG_SYS_MAX_FLASH_BANKS)
-		nbanks = CONFIG_SYS_MAX_FLASH_BANKS;
-
-	/* Enable flash write */
-	cpcr[1] |= 3;
-
-	for (i = 0; i < nbanks; i++) {
-		flash_get_size ((FPW *)(CONFIG_SYS_FLASH_BASE + size), &flash_info[i]);
-		flash_get_offsets (CONFIG_SYS_FLASH_BASE + size, &flash_info[i]);
-		size += flash_info[i].size;
-	}
-
-#if CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE
-	/* monitor protection */
-	flash_protect (FLAG_PROTECT_SET,
-		       CONFIG_SYS_MONITOR_BASE,
-		       CONFIG_SYS_MONITOR_BASE + monitor_flash_len - 1, &flash_info[0]);
-#endif
-
-#ifdef CONFIG_ENV_IS_IN_FLASH
-	/* ENV protection ON */
-	flash_protect(FLAG_PROTECT_SET,
-		      CONFIG_ENV_ADDR,
-		      CONFIG_ENV_ADDR + CONFIG_ENV_SECT_SIZE - 1,
-		      &flash_info[0]);
-#endif
-
-	/* Protect SIB (0x24800000) and bootMonitor (0x24c00000) */
-	flash_protect (FLAG_PROTECT_SET,
-		       flash_info[0].start[62],
-		       flash_info[0].start[63] + PHYS_FLASH_SECT_SIZE - 1,
-		       &flash_info[0]);
-
-	return size;
-}
-
-/*-----------------------------------------------------------------------
- */
-static void flash_get_offsets (ulong base, flash_info_t * info)
-{
-	int i;
-
-	if (info->flash_id == FLASH_UNKNOWN) {
-		return;
-	}
-
-	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL) {
-		for (i = 0; i < info->sector_count; i++) {
-			info->start[i] = base +	(i * PHYS_FLASH_SECT_SIZE);
-			info->protect[i] = 0;
-		}
-	}
-}
-
-/*-----------------------------------------------------------------------
- */
-void flash_print_info (flash_info_t * info)
-{
-	int i;
-
-	if (info->flash_id == FLASH_UNKNOWN) {
-		printf ("missing or unknown FLASH type\n");
-		return;
-	}
-
-	switch (info->flash_id & FLASH_VENDMASK) {
-	case FLASH_MAN_INTEL:
-		printf ("INTEL ");
-		break;
-	default:
-		printf ("Unknown Vendor ");
-		break;
-	}
-
-	/* Integrator CP board uses 28F640J3C or 28F128J3C parts,
-	 * which have the same device id numbers as 28F640J3A or
-	 * 28F128J3A
-	 */
-	switch (info->flash_id & FLASH_TYPEMASK) {
-	case FLASH_28F256L18T:
-		printf ("FLASH 28F256L18T\n");
-		break;
-	case FLASH_28F640J3A:
-		printf ("FLASH 28F640J3C\n");
-		break;
-	case FLASH_28F128J3A:
-		printf ("FLASH 28F128J3C\n");
-		break;
-	default:
-		printf ("Unknown Chip Type\n");
-		break;
-	}
-
-	printf ("  Size: %ld MB in %d Sectors\n",
-			info->size >> 20, info->sector_count);
-
-	printf ("  Sector Start Addresses:");
-	for (i = 0; i < info->sector_count; ++i) {
-		if ((i % 5) == 0)
-			printf ("\n   ");
-		printf (" %08lX%s",
-			info->start[i], info->protect[i] ? " (RO)" : "     ");
-	}
-	printf ("\n");
-	return;
-}
-
-/*
- * The following code cannot be run from FLASH!
- */
-static ulong flash_get_size (FPW * addr, flash_info_t * info)
-{
-	volatile FPW value;
-	vu_long *cpcr = (vu_long *)CPCR_BASE;
-	int nsects;
-
-	/* Check the flash size */
-	if (cpcr[1] & CPCR_FLASHSIZE)
-		nsects = 128;
-	else
-		nsects = 64;
-
-	if (nsects > CONFIG_SYS_MAX_FLASH_SECT)
-		nsects = CONFIG_SYS_MAX_FLASH_SECT;
-
-	/* Write auto select command: read Manufacturer ID */
-	addr[0x5555] = (FPW) 0x00AA00AA;
-	addr[0x2AAA] = (FPW) 0x00550055;
-	addr[0x5555] = (FPW) 0x00900090;
-
-	mb ();
-	value = addr[0];
-
-	switch (value) {
-
-	case (FPW) INTEL_MANUFACT:
-		info->flash_id = FLASH_MAN_INTEL;
-		break;
-
-	default:
-		info->flash_id = FLASH_UNKNOWN;
-		info->sector_count = 0;
-		info->size = 0;
-		addr[0] = (FPW) 0x00FF00FF; /* restore read mode */
-		return (0); /* no or unknown flash */
-	}
-
-	mb ();
-	value = addr[1]; /* device ID */
-	switch (value) {
-
-	case (FPW) (INTEL_ID_28F256L18T):
-		info->flash_id += FLASH_28F256L18T;
-		info->sector_count = 259;
-		info->size = 0x02000000;
-		break;			/* => 32 MB */
-
-	case (FPW) (INTEL_ID_28F640J3A):
-		info->flash_id += FLASH_28F640J3A;
-		info->sector_count = nsects;
-		info->size = nsects * PHYS_FLASH_SECT_SIZE;
-		break;
-
-	case (FPW) (INTEL_ID_28F128J3A):
-		info->flash_id += FLASH_28F128J3A;
-		info->sector_count = nsects;
-		info->size = nsects * PHYS_FLASH_SECT_SIZE;
-		break;
-
-	default:
-		info->flash_id = FLASH_UNKNOWN;
-		break;
-	}
-
-	if (info->sector_count > CONFIG_SYS_MAX_FLASH_SECT) {
-		printf ("** ERROR: sector count %d > max (%d) **\n",
-				info->sector_count, CONFIG_SYS_MAX_FLASH_SECT);
-		info->sector_count = CONFIG_SYS_MAX_FLASH_SECT;
-	}
-
-	addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
-
-	return (info->size);
-}
-
-
-/* unprotects a sector for write and erase
- * on some intel parts, this unprotects the entire chip, but it
- * wont hurt to call this additional times per sector...
- */
-void flash_unprotect_sectors (FPWV * addr)
-{
-	FPW status;
-
-	*addr = (FPW) 0x00500050;	/* clear status register */
-
-	/* this sends the clear lock bit command */
-	*addr = (FPW) 0x00600060;
-	*addr = (FPW) 0x00D000D0;
-
-	reset_timer_masked();
-	while (((status = *addr) & (FPW)0x00800080) != 0x00800080) {
-		if (get_timer_masked() > CONFIG_SYS_FLASH_ERASE_TOUT) {
-			printf("Timeout");
-			break;
-		}
-	}
-
-	*addr = (FPW) 0x00FF00FF;
-}
-
-
-/*-----------------------------------------------------------------------
- */
-int flash_erase (flash_info_t * info, int s_first, int s_last)
-{
-	int flag, prot, sect;
-	ulong type;
-	int rcode = 0;
-
-	if ((s_first < 0) || (s_first > s_last)) {
-		if (info->flash_id == FLASH_UNKNOWN) {
-			printf ("- missing\n");
-		} else {
-			printf ("- no sectors to erase\n");
-		}
-		return 1;
-	}
-
-	type = (info->flash_id & FLASH_VENDMASK);
-	if ((type != FLASH_MAN_INTEL)) {
-		printf ("Can't erase unknown flash type %08lx - aborted\n",
-				info->flash_id);
-		return 1;
-	}
-
-	prot = 0;
-	for (sect = s_first; sect <= s_last; ++sect) {
-		if (info->protect[sect]) {
-			prot++;
-		}
-	}
-
-	if (prot) {
-		printf ("- Warning: %d protected sectors will not be erased!\n",
-				prot);
-	} else {
-		printf ("\n");
-	}
-
-	/* Start erase on unprotected sectors */
-	for (sect = s_first; sect <= s_last; sect++) {
-		if (info->protect[sect] == 0) {	/* not protected */
-			FPWV *addr = (FPWV *) (info->start[sect]);
-			FPW status;
-
-			printf ("Erasing sector %2d ... ", sect);
-
-			/* Disable interrupts which might cause a timeout here */
-			flag = disable_interrupts ();
-
-			/* flash_unprotect_sectors (addr); */
-
-			/* arm simple, non interrupt dependent timer */
-			reset_timer_masked ();
-
-			*addr = (FPW) 0x00500050; /* clear status register */
-			*addr = (FPW) 0x00200020; /* erase setup */
-			*addr = (FPW) 0x00D000D0; /* erase confirm */
-			mb();
-
-			udelay(1000); /* Let's wait 1 ms */
-
-			/* re-enable interrupts if necessary */
-			if (flag)
-				enable_interrupts();
-
-			while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
-				if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
-					*addr = (FPW)0x00700070;
-					status = *addr;
-					if ((status & (FPW) 0x00400040) == (FPW) 0x00400040) {
-						/* erase suspended? Resume it */
-						reset_timer_masked();
-						*addr = (FPW) 0x00D000D0;
-					} else {
-#ifdef DEBUG
-						printf ("Timeout,0x%08lx\n", status);
-#else
-						printf("Timeout\n");
-#endif
-
-						*addr = (FPW) 0x00500050;
-						*addr = (FPW) 0x00FF00FF; /* reset to read mode */
-						rcode = 1;
-						break;
-					}
-				}
-			}
-
-			*addr = (FPW) 0x00FF00FF; /* resest to read mode */
-			printf (" done\n");
-		}
-	}
-
-	return rcode;
-}
-
-/*-----------------------------------------------------------------------
- * Copy memory to flash, returns:
- * 0 - OK
- * 1 - write timeout
- * 2 - Flash not erased
- * 4 - Flash not identified
- */
-int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
-{
-	ulong cp, wp;
-	FPW data;
-	int count, i, l, rc, port_width;
-
-	if (info->flash_id == FLASH_UNKNOWN) {
-		return 4;
-	}
-/* get lower word aligned address */
-#ifdef FLASH_PORT_WIDTH16
-	wp = (addr & ~1);
-	port_width = 2;
-#else
-	wp = (addr & ~3);
-	port_width = 4;
-#endif
-
-	/*
-	 * handle unaligned start bytes
-	 */
-	if ((l = addr - wp) != 0) {
-		data = 0;
-		for (i = 0, cp = wp; i < l; ++i, ++cp) {
-			data = (data << 8) | (*(uchar *) cp);
-		}
-		for (; i < port_width && cnt > 0; ++i) {
-			data = (data << 8) | *src++;
-			--cnt;
-			++cp;
-		}
-		for (; cnt == 0 && i < port_width; ++i, ++cp) {
-			data = (data << 8) | (*(uchar *) cp);
-		}
-
-		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
-			return (rc);
-		}
-		wp += port_width;
-	}
-
-	/*
-	 * handle word aligned part
-	 */
-	count = 0;
-	while (cnt >= port_width) {
-		data = 0;
-		for (i = 0; i < port_width; ++i) {
-			data = (data << 8) | *src++;
-		}
-		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
-			return (rc);
-		}
-		wp += port_width;
-		cnt -= port_width;
-		if (count++ > 0x800) {
-			spin_wheel ();
-			count = 0;
-		}
-	}
-
-	if (cnt == 0) {
-		return (0);
-	}
-
-	/*
-	 * handle unaligned tail bytes
-	 */
-	data = 0;
-	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
-		data = (data << 8) | *src++;
-		--cnt;
-	}
-	for (; i < port_width; ++i, ++cp) {
-		data = (data << 8) | (*(uchar *) cp);
-	}
-
-	return (write_data (info, wp, SWAP (data)));
-}
-
-/*-----------------------------------------------------------------------
- * Write a word or halfword to Flash, returns:
- * 0 - OK
- * 1 - write timeout
- * 2 - Flash not erased
- */
-static int write_data (flash_info_t * info, ulong dest, FPW data)
-{
-	FPWV *addr = (FPWV *) dest;
-	ulong status;
-	int flag;
-
-	/* Check if Flash is (sufficiently) erased */
-	if ((*addr & data) != data) {
-		printf ("not erased at %08lx (%lx)\n", (ulong) addr, *addr);
-		return (2);
-	}
-
-	/* Disable interrupts which might cause a timeout here */
-	flag = disable_interrupts ();
-
-	/* flash_unprotect_sectors (addr); */
-
-	*addr = (FPW) 0x00400040;	/* write setup */
-	*addr = data;
-
-	mb();
-
-	/* re-enable interrupts if necessary */
-	if (flag)
-		enable_interrupts();
-
-	/* arm simple, non interrupt dependent timer */
-	reset_timer_masked ();
-
-	/* wait while polling the status register */
-	while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
-		if (get_timer_masked () > CONFIG_SYS_FLASH_WRITE_TOUT) {
-#ifdef DEBUG
-			*addr = (FPW) 0x00700070;
-			status = *addr;
-			printf("## status=0x%08lx, addr=0x%p\n", status, addr);
-#endif
-			*addr = (FPW) 0x00500050; /* clear status register cmd */
-			*addr = (FPW) 0x00FF00FF; /* restore read mode */
-			return (1);
-		}
-	}
-
-	*addr = (FPW) 0x00FF00FF; /* restore read mode */
-	return (0);
-}
-
-void inline spin_wheel (void)
-{
-	static int p = 0;
-	static char w[] = "\\/-";
-
-	printf ("\010%c", w[p]);
-	(++p == 3) ? (p = 0) : 0;
-}
diff -Naur u-boot-2009.01/board/integratorcp/integratorcp.c u-boot/board/integratorcp/integratorcp.c
--- u-boot-2009.01/board/integratorcp/integratorcp.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorcp/integratorcp.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,279 +0,0 @@
-/*
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Marius Groeger <mgroeger@sysgo.de>
- *
- * (C) Copyright 2002
- * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
- *
- * (C) Copyright 2003
- * Texas Instruments, <www.ti.com>
- * Kshitij Gupta <Kshitij@ti.com>
- *
- * (C) Copyright 2004
- * ARM Ltd.
- * Philippe Robin, <philippe.robin@arm.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <div64.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-void flash__init (void);
-void ether__init (void);
-void peripheral_power_enable (void);
-
-#if defined(CONFIG_SHOW_BOOT_PROGRESS)
-void show_boot_progress(int progress)
-{
-	printf("Boot reached stage %d\n", progress);
-}
-#endif
-
-#define COMP_MODE_ENABLE ((unsigned int)0x0000EAEF)
-
-/*
- * Miscellaneous platform dependent initialisations
- */
-
-int board_init (void)
-{
-	/* arch number of Integrator Board */
-	gd->bd->bi_arch_number = MACH_TYPE_CINTEGRATOR;
-
-	/* adress of boot parameters */
-	gd->bd->bi_boot_params = 0x00000100;
-
-	gd->flags = 0;
-
-#ifdef CONFIG_CM_REMAP
-extern void cm_remap(void);
-	cm_remap();	/* remaps writeable memory to 0x00000000 */
-#endif
-
-	icache_enable ();
-
-	flash__init ();
-	ether__init ();
-	return 0;
-}
-
-
-int misc_init_r (void)
-{
-	setenv("verify", "n");
-	return (0);
-}
-
-/******************************
- Routine:
- Description:
-******************************/
-void flash__init (void)
-{
-}
-/*************************************************************
- Routine:ether__init
- Description: take the Ethernet controller out of reset and wait
-	      for the EEPROM load to complete.
-*************************************************************/
-void ether__init (void)
-{
-}
-
-/******************************
- Routine:
- Description:
-******************************/
-int dram_init (void)
-{
-	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
-	gd->bd->bi_dram[0].size	 = PHYS_SDRAM_1_SIZE;
-
-#ifdef CONFIG_CM_SPD_DETECT
-    {
-extern void dram_query(void);
-	unsigned long cm_reg_sdram;
-	unsigned long sdram_shift;
-
-	dram_query();	/* Assembler accesses to CM registers */
-			/* Queries the SPD values	      */
-
-	/* Obtain the SDRAM size from the CM SDRAM register */
-
-	cm_reg_sdram = *(volatile ulong *)(CM_BASE + OS_SDRAM);
-	/*   Register	      SDRAM size
-	 *
-	 *   0xXXXXXXbbb000bb	 16 MB
-	 *   0xXXXXXXbbb001bb	 32 MB
-	 *   0xXXXXXXbbb010bb	 64 MB
-	 *   0xXXXXXXbbb011bb	128 MB
-	 *   0xXXXXXXbbb100bb	256 MB
-	 *
-	 */
-	sdram_shift		 = ((cm_reg_sdram & 0x0000001C)/4)%4;
-	gd->bd->bi_dram[0].size	 = 0x01000000 << sdram_shift;
-
-    }
-#endif /* CM_SPD_DETECT */
-
-	return 0;
-}
-
-/* The Integrator/CP timer1 is clocked at 1MHz
- * can be divided by 16 or 256
- * and can be set up as a 32-bit timer
- */
-/* U-Boot expects a 32 bit timer, running at CONFIG_SYS_HZ */
-/* Keep total timer count to avoid losing decrements < div_timer */
-static unsigned long long total_count = 0;
-static unsigned long long lastdec;	 /* Timer reading at last call	   */
-static unsigned long long div_clock = 1; /* Divisor applied to timer clock */
-static unsigned long long div_timer = 1; /* Divisor to convert timer reading
-					  * change to U-Boot ticks
-					  */
-/* CONFIG_SYS_HZ = CONFIG_SYS_HZ_CLOCK/(div_clock * div_timer) */
-static ulong timestamp;		/* U-Boot ticks since startup	      */
-
-#define TIMER_LOAD_VAL ((ulong)0xFFFFFFFF)
-#define READ_TIMER (*(volatile ulong *)(CONFIG_SYS_TIMERBASE+4))
-
-/* all function return values in U-Boot ticks i.e. (1/CONFIG_SYS_HZ) sec
- *  - unless otherwise stated
- */
-
-/* starts up a counter
- * - the Integrator/CP timer can be set up to issue an interrupt */
-int interrupt_init (void)
-{
-	/* Load timer with initial value */
-	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 0) = TIMER_LOAD_VAL;
-	/* Set timer to be
-	 *	enabled		  1
-	 *	periodic	  1
-	 *	no interrupts	  0
-	 *	X		  0
-	 *	divider 1	 00 == less rounding error
-	 *	32 bit		  1
-	 *	wrapping	  0
-	 */
-	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 8) = 0x000000C2;
-	/* init the timestamp */
-	total_count = 0ULL;
-	reset_timer_masked();
-
-	div_timer  = (unsigned long long)(CONFIG_SYS_HZ_CLOCK / CONFIG_SYS_HZ);
-	div_timer /= div_clock;
-
-	return (0);
-}
-
-/*
- * timer without interrupts
- */
-void reset_timer (void)
-{
-	reset_timer_masked ();
-}
-
-ulong get_timer (ulong base_ticks)
-{
-	return get_timer_masked () - base_ticks;
-}
-
-void set_timer (ulong ticks)
-{
-	timestamp   = ticks;
-	total_count = (unsigned long long)ticks * div_timer;
-}
-
-/* delay usec useconds */
-void udelay (unsigned long usec)
-{
-	ulong tmo, tmp;
-
-	/* Convert to U-Boot ticks */
-	tmo  = usec * CONFIG_SYS_HZ;
-	tmo /= (1000000L);
-
-	tmp  = get_timer_masked();	/* get current timestamp */
-	tmo += tmp;			/* form target timestamp */
-
-	while (get_timer_masked () < tmo) {/* loop till event */
-		/*NOP*/;
-	}
-}
-
-void reset_timer_masked (void)
-{
-	/* capure current decrementer value    */
-	lastdec	  = (unsigned long long)READ_TIMER;
-	/* start "advancing" time stamp from 0 */
-	timestamp = 0L;
-}
-
-/* converts the timer reading to U-Boot ticks	       */
-/* the timestamp is the number of ticks since reset    */
-ulong get_timer_masked (void)
-{
-	/* get current count */
-	unsigned long long now = (unsigned long long)READ_TIMER;
-
-	if(now > lastdec) {
-		/* Must have wrapped */
-		total_count += lastdec + TIMER_LOAD_VAL + 1 - now;
-	} else {
-		total_count += lastdec - now;
-	}
-	lastdec	  = now;
-
-	/* Reuse "now" */
-	now = total_count;
-	do_div(now, div_timer);
-	timestamp = now;
-
-	return timestamp;
-}
-
-/* waits specified delay value and resets timestamp */
-void udelay_masked (unsigned long usec)
-{
-	udelay(usec);
-}
-
-/*
- * This function is derived from PowerPC code (read timebase as long long).
- * On ARM it just returns the timer value.
- */
-unsigned long long get_ticks(void)
-{
-	return (unsigned long long)get_timer(0);
-}
-
-/*
- * Return the timebase clock frequency
- * i.e. how often the timer decrements
- */
-ulong get_tbclk (void)
-{
-	return (ulong)(((unsigned long long)CONFIG_SYS_HZ_CLOCK)/div_clock);
-}
diff -Naur u-boot-2009.01/board/integratorcp/lowlevel_init.S u-boot/board/integratorcp/lowlevel_init.S
--- u-boot-2009.01/board/integratorcp/lowlevel_init.S	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorcp/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,214 +0,0 @@
-/*
- * Board specific setup info
- *
- * (C) Copyright 2003, ARM Ltd.
- * Philippe Robin, <philippe.robin@arm.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <version.h>
-
-/* Reset using CM control register */
-.global reset_cpu
-reset_cpu:
-	mov	r0, #CM_BASE
-	ldr	r1,[r0,#OS_CTRL]
-	orr	r1,r1,#CMMASK_RESET
-	str	r1,[r0,#OS_CTRL]
-
-reset_failed:
-	b	reset_failed
-
-/* Set up the platform, once the cpu has been initialized */
-.globl lowlevel_init
-lowlevel_init:
-	/* If U-Boot has been run after the ARM boot monitor
-	 * then all the necessary actions have been done
-	 * otherwise we are running from user flash mapped to 0x00000000
-	 * --- DO NOT REMAP BEFORE THE CODE HAS BEEN RELOCATED --
-	 * Changes to the (possibly soft) reset defaults of the processor
-	 * itself should be performed in cpu/arm<>/start.S
-	 * This function affects only the core module or board settings
-	 */
-
-#ifdef CONFIG_CM_INIT
-	/* CM has an initialization register
-	 * - bits in it are wired into test-chip pins to force
-	 *   reset defaults
-	 * - may need to change its contents for U-Boot
-	 */
-
-	/* set the desired CM specific value */
-	mov	r2,#CMMASK_LOWVEC	/* Vectors at 0x00000000 for all */
-
-#if defined (CONFIG_CM10200E) || defined (CONFIG_CM10220E)
-	orr	r2,r2,#CMMASK_INIT_102
-#else
-
-#if	!defined (CONFIG_CM920T) && !defined (CONFIG_CM920T_ETM) && \
-	!defined (CONFIG_CM940T)
-	/* CMxx6 code	*/
-
-#ifdef	CONFIG_CM_MULTIPLE_SSRAM
-	/* set simple mapping			*/
-	and	r2,r2,#CMMASK_MAP_SIMPLE
-#endif /* #ifdef CONFIG_CM_MULTIPLE_SSRAM	*/
-
-#ifdef	CONFIG_CM_TCRAM
-	/* disable TCRAM			*/
-	and	r2,r2,#CMMASK_TCRAM_DISABLE
-#endif /* #ifdef CONFIG_CM_TCRAM		*/
-
-#if defined (CONFIG_CM926EJ_S) || defined (CONFIG_CM1026EJ_S) || \
-			defined (CONFIG_CM1136JF_S)
-
-	and	r2,r2,#CMMASK_LE
-
-#endif /* cpu with little endian initialization */
-
-	orr	r2,r2,#CMMASK_CMxx6_COMMON
-
-#endif /* CMxx6 code */
-
-#endif /* ARM102xxE value */
-
-	/* read CM_INIT		 */
-	mov	r0, #CM_BASE
-	ldr	r1, [r0, #OS_INIT]
-	/* check against desired bit setting */
-	and	r3,r1,r2
-	cmp	r3,r2
-	beq	init_reg_OK
-
-	/* lock for change */
-	mov	r3, #CMVAL_LOCK1
-	and	r3, r3, #CMVAL_LOCK2
-	str	r3, [r0, #OS_LOCK]
-	/* set desired value */
-	orr	r1,r1,r2
-	/* write & relock CM_INIT */
-	str	r1, [r0, #OS_INIT]
-	mov	r1, #CMVAL_UNLOCK
-	str	r1, [r0, #OS_LOCK]
-
-	/* soft reset so new values used */
-	b	reset_cpu
-
-init_reg_OK:
-
-#endif /* CONFIG_CM_INIT */
-
-	mov	pc, lr
-
-#ifdef	CONFIG_CM_SPD_DETECT
-	/* Fast memory is available for the DRAM data
-	 * - ensure it has been transferred, then summarize the data
-	 *	 into a CM register
-	 */
-.globl dram_query
-dram_query:
-	stmfd	r13!,{r4-r6,lr}
-	/* set up SDRAM info					*/
-	/* - based on example code from the CM User Guide */
-	mov	r0, #CM_BASE
-
-readspdbit:
-	ldr	r1, [r0, #OS_SDRAM]	/* read the SDRAM register */
-	and	r1, r1, #0x20		/* mask SPD bit (5)		 */
-	cmp	r1, #0x20		/* test if set			 */
-	bne	readspdbit
-
-setupsdram:
-	add	r0, r0, #OS_SPD		/* address the copy of the SDP data	*/
-	ldrb	r1, [r0, #3]		/* number of row address lines		*/
-	ldrb	r2, [r0, #4]		/* number of column address lines	*/
-	ldrb	r3, [r0, #5]		/* number of banks			*/
-	ldrb	r4, [r0, #31]		/* module bank density			*/
-	mul	r5, r4, r3		/* size of SDRAM (MB divided by 4)	*/
-	mov	r5, r5, ASL#2		/* size in MB				*/
-	mov	r0, #CM_BASE		/* reload for later code		*/
-	cmp	r5, #0x10		/* is it 16MB?				*/
-	bne	not16
-	mov	r6, #0x2		/* store size and CAS latency of 2	*/
-	b	writesize
-
-not16:
-	cmp	r5, #0x20		/* is it  32MB? */
-	bne	not32
-	mov	r6, #0x6
-	b	writesize
-
-not32:
-	cmp	r5, #0x40		/* is it  64MB? */
-	bne	not64
-	mov	r6, #0xa
-	b	writesize
-
-not64:
-	cmp	r5, #0x80		/* is it 128MB? */
-	bne	not128
-	mov	r6, #0xe
-	b	writesize
-
-not128:
-	/* if it is none of these sizes then it is either 256MB, or
-	 * there is no SDRAM fitted so default to 256MB
-	 */
-	mov	r6, #0x12
-
-writesize:
-	mov	r1, r1, ASL#8		/* row addr lines from SDRAM reg */
-	orr	r2, r1, r2, ASL#12	/* OR in column address lines	 */
-	orr	r3, r2, r3, ASL#16	/* OR in number of banks	 */
-	orr	r6, r6, r3		/* OR in size and CAS latency	 */
-	str	r6, [r0, #OS_SDRAM]	/* store SDRAM parameters	 */
-
-#endif /* #ifdef CONFIG_CM_SPD_DETECT */
-
-	ldmfd	r13!,{r4-r6,pc}			/* back to caller */
-
-#ifdef	CONFIG_CM_REMAP
-	/* CM remap bit is operational
-	 * - use it to map writeable memory at 0x00000000, in place of flash
-	 */
-.globl cm_remap
-cm_remap:
-	stmfd	r13!,{r4-r10,lr}
-
-	mov	r0, #CM_BASE
-	ldr	r1, [r0, #OS_CTRL]
-	orr	r1, r1, #CMMASK_REMAP	/* set remap and led bits */
-	str	r1, [r0, #OS_CTRL]
-
-	/* Now 0x00000000 is writeable, replace the vectors	*/
-	ldr	r0, =_start	/* r0 <- start of vectors	*/
-	ldr	r2, =_armboot_start	/* r2 <- past vectors	*/
-	sub	r1,r1,r1		/* destination 0x00000000	*/
-
-copy_vec:
-	ldmia	r0!, {r3-r10}		/* copy from source address [r0]	*/
-	stmia	r1!, {r3-r10}		/* copy to	 target address [r1]	*/
-	cmp	r0, r2			/* until source end address [r2]	*/
-	ble	copy_vec
-
-	ldmfd	r13!,{r4-r10,pc}	/* back to caller			*/
-
-#endif /* #ifdef CONFIG_CM_REMAP */
diff -Naur u-boot-2009.01/board/integratorcp/Makefile u-boot/board/integratorcp/Makefile
--- u-boot-2009.01/board/integratorcp/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorcp/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-#
-# (C) Copyright 2000-2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= $(obj)lib$(BOARD).a
-
-COBJS	:= integratorcp.o flash.o
-SOBJS	:= lowlevel_init.o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
-
-$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
-	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
-
-clean:
-	rm -f $(SOBJS) $(OBJS)
-
-distclean:	clean
-	rm -f $(LIB) core *.bak $(obj).depend
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff -Naur u-boot-2009.01/board/integratorcp/split_by_variant.sh u-boot/board/integratorcp/split_by_variant.sh
--- u-boot-2009.01/board/integratorcp/split_by_variant.sh	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorcp/split_by_variant.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,114 +0,0 @@
-#!/bin/sh
-# ---------------------------------------------------------
-# Set the platform defines
-# ---------------------------------------------------------
-echo -n "/* Integrator configuration implied "   > tmp.fil
-echo    " by Makefile target */"		>> tmp.fil
-echo -n "#define CONFIG_INTEGRATOR"		>> tmp.fil
-echo	 " /* Integrator board */"		>> tmp.fil
-echo -n "#define CONFIG_ARCH_CINTEGRATOR"	>> tmp.fil
-echo     " 1 /* Integrator/CP   */"		>> tmp.fil
-
-cpu="arm_intcm"
-variant="unknown core module"
-
-if [ "$1" = "" ]
-then
-	echo "$0:: No parameters - using arm_intcm"
-else
-	case "$1" in
-	ap966)
-	cpu="arm_intcm"
-	variant="unported core module CM966E-S"
-	;;
-
-	ap922_config)
-	cpu="arm_intcm"
-	variant="unported core module CM922T"
-	;;
-
-	integratorcp_config	|	\
-	cp_config)
-	cpu="arm_intcm"
-	variant="unspecified core module"
-	;;
-
-	cp922_XA10_config)
-	cpu="arm_intcm"
-	variant="unported core module CM922T_XA10"
-	echo -n "#define CONFIG_CM922T_XA10"		>> tmp.fil
-	echo    " 1 /* CPU core is ARM922T_XA10 */"	>> tmp.fil
-	;;
-
-	cp920t_config)
-	cpu="arm920t"
-	variant="Core module CM920T"
-	echo -n "#define CONFIG_CM920T"			>> tmp.fil
-	echo    " 1 /* CPU core is ARM920T */"		>> tmp.fil
-	;;
-
-	cp926ejs_config)
-	cpu="arm926ejs"
-	variant="Core module CM926EJ-S"
-	echo -n "#define CONFIG_CM926EJ_S"		>> tmp.fil
-	echo    " 1 /* CPU core is ARM926EJ-S */ "	>> tmp.fil
-	;;
-
-
-	cp946es_config)
-	cpu="arm946es"
-	variant="Core module CM946E-S"
-	echo -n "#define CONFIG_CM946E_S"		>> tmp.fil
-	echo    " 1 /* CPU core is ARM946E-S */ "	>> tmp.fil
-	;;
-
-	cp1136_config)
-	cpu="arm1136"
-	variant="Core module CM1136EJF-S"
-	echo -n "#define CONFIG_CM1136EJF_S"		>> tmp.fil
-	echo    " 1 /* CPU core is ARM1136JF-S */ "	>> tmp.fil
-	;;
-
-	*)
-	echo "$0:: Unknown core module"
-	variant="unknown core module"
-	cpu="arm_intcm"
-	;;
-
-	esac
-
-fi
-
-if [ "$cpu" = "arm_intcm" ]
-then
-	echo "/* Core module undefined/not ported */"	>> tmp.fil
-	echo "#define CONFIG_ARM_INTCM 1"		>> tmp.fil
-	echo -n "#undef CONFIG_CM_MULTIPLE_SSRAM"	>> tmp.fil
-	echo -n "  /* CM may not have "			>> tmp.fil
-	echo    "multiple SSRAM mapping */"		>> tmp.fil
-	echo -n "#undef CONFIG_CM_SPD_DETECT "		>> tmp.fil
-	echo -n " /* CM may not support SPD "		>> tmp.fil
-	echo    "query */"				>> tmp.fil
-	echo -n "#undef CONFIG_CM_REMAP  "		>> tmp.fil
-	echo -n " /* CM may not support "		>> tmp.fil
-	echo    "remapping */"				>> tmp.fil
-	echo -n "#undef CONFIG_CM_INIT  "		>> tmp.fil
-	echo -n " /* CM may not have  "			>> tmp.fil
-	echo    "initialization reg */"			>> tmp.fil
-	echo -n "#undef CONFIG_CM_TCRAM  "		>> tmp.fil
-	echo    " /* CM may not have TCRAM */"		>> tmp.fil
-fi
-
-mkdir -p ${obj}include
-mkdir -p ${obj}board/integratorcp
-mv tmp.fil ${obj}include/config.h
-# ---------------------------------------------------------
-#  Ensure correct core object loaded first in U-Boot image
-# ---------------------------------------------------------
-sed -r 's/CPU_FILE/cpu\/'$cpu'\/start.o/; s/#.*//' ${src}board/integratorcp/u-boot.lds.template > ${obj}board/integratorcp/u-boot.lds
-# ---------------------------------------------------------
-# Complete the configuration
-# ---------------------------------------------------------
-$MKCONFIG -a integratorcp arm $cpu integratorcp;
-echo "Variant:: $variant with core $cpu"
-
diff -Naur u-boot-2009.01/board/integratorcp/u-boot.lds.template u-boot/board/integratorcp/u-boot.lds.template
--- u-boot-2009.01/board/integratorcp/u-boot.lds.template	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/integratorcp/u-boot.lds.template	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-/*
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-# Template used during configuration to emsure the core module processor code,
-# from CPU_FILE, is placed at the start of the image */
-
-OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
-OUTPUT_ARCH(arm)
-ENTRY(_start)
-SECTIONS
-{
-	. = 0x00000000;
-	. = ALIGN(4);
-	.text	:
-	{
-		CPU_FILE (.text)
-		*(.text)
-	}
-	.rodata : { *(.rodata) }
-	. = ALIGN(4);
-	.data : { *(.data) }
-	. = ALIGN(4);
-	.got : { *(.got) }
-
-	. = .;
-	__u_boot_cmd_start = .;
-	.u_boot_cmd : { *(.u_boot_cmd) }
-	__u_boot_cmd_end = .;
-
-	. = ALIGN(4);
-	__bss_start = .;
-	.bss : { *(.bss) }
-	_end = .;
-}
diff -Naur u-boot-2009.01/board/keymile/common/common.c u-boot/board/keymile/common/common.c
--- u-boot-2009.01/board/keymile/common/common.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/keymile/common/common.c	2009-02-26 14:03:58.000000000 +0100
@@ -22,10 +22,14 @@
  */
 
 #include <common.h>
+#if defined(CONFIG_MGCOGE)
 #include <mpc8260.h>
+#endif
 #include <ioports.h>
 #include <malloc.h>
 #include <hush.h>
+#include <net.h>
+#include <asm/io.h>
 
 #if defined(CONFIG_OF_BOARD_SETUP) && defined(CONFIG_OF_LIBFDT)
 #include <libfdt.h>
@@ -33,8 +37,6 @@
 
 #if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
 #include <i2c.h>
-#endif
-#include <asm/io.h>
 
 extern int i2c_soft_read_pin (void);
 
@@ -495,6 +497,7 @@
 #endif
 }
 #endif
+#endif
 
 #if defined(CONFIG_OF_BOARD_SETUP) && defined(CONFIG_OF_LIBFDT)
 int fdt_set_node_and_value (void *blob,
@@ -521,3 +524,19 @@
 	return ret;
 }
 #endif
+
+int ethernet_present (void)
+{
+	return (in_8((u8 *)CONFIG_SYS_PIGGY_BASE + CONFIG_SYS_SLOT_ID_OFF) & 0x80);
+}
+
+int board_eth_init (bd_t *bis)
+{
+#ifdef CONFIG_KEYMILE_HDLC_ENET
+	(void)keymile_hdlc_enet_initialize (bis);
+#endif
+	if (ethernet_present ()) {
+		return -1;
+	}
+	return 0;
+}
diff -Naur u-boot-2009.01/board/keymile/common/common.h u-boot/board/keymile/common/common.h
--- u-boot-2009.01/board/keymile/common/common.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/keymile/common/common.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,20 @@
+/*
+ * (C) Copyright 2008
+ * Heiko Schocher, DENX Software Engineering, hs@denx.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __KEYMILE_COMMON_H
+#define __KEYMILE_COMMON_H
+
+int ethernet_present (void);
+int ivm_read_eeprom (void);
+
+#ifdef CONFIG_KEYMILE_HDLC_ENET
+int keymile_hdlc_enet_initialize (bd_t *bis);
+#endif
+#endif /* __KEYMILE_COMMON_H */
diff -Naur u-boot-2009.01/board/keymile/common/keymile_hdlc_enet.c u-boot/board/keymile/common/keymile_hdlc_enet.c
--- u-boot-2009.01/board/keymile/common/keymile_hdlc_enet.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/keymile/common/keymile_hdlc_enet.c	2009-02-26 14:03:58.000000000 +0100
@@ -590,7 +590,7 @@
 }
 U_BOOT_CMD(
 	stest, 1, 1, hdlc_enet_stest,
-	"stest	- simple send test for hdlc_enet\n",
+	"simple send test for hdlc_enet",
 	"no arguments\n"
 );
 /* simple receive test routine */
@@ -612,7 +612,7 @@
 }
 U_BOOT_CMD(
 	rtest, 1, 1, hdlc_enet_rtest,
-	"rtest	- simple receive test for hdlc_enet\n",
+	"simple receive test for hdlc_enet",
 	"no arguments\n"
 );
 #endif
diff -Naur u-boot-2009.01/board/keymile/kmeter1/config.mk u-boot/board/keymile/kmeter1/config.mk
--- u-boot-2009.01/board/keymile/kmeter1/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/keymile/kmeter1/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# (C) Copyright 2008
+# Heiko Schocher, DENX Software Engineering, hs@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+TEXT_BASE = 0xF0000000
diff -Naur u-boot-2009.01/board/keymile/kmeter1/kmeter1.c u-boot/board/keymile/kmeter1/kmeter1.c
--- u-boot-2009.01/board/keymile/kmeter1/kmeter1.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/keymile/kmeter1/kmeter1.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2006 Freescale Semiconductor, Inc.
+ *                    Dave Liu <daveliu@freescale.com>
+ *
+ * Copyright (C) 2007 Logic Product Development, Inc.
+ *                    Peter Barada <peterb@logicpd.com>
+ *
+ * Copyright (C) 2007 MontaVista Software, Inc.
+ *                    Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * (C) Copyright 2008
+ * Heiko Schocher, DENX Software Engineering, hs@denx.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <common.h>
+#include <ioports.h>
+#include <mpc83xx.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <asm/io.h>
+#include <asm/mmu.h>
+#include <pci.h>
+#include <libfdt.h>
+
+#include "../common/common.h"
+
+const qe_iop_conf_t qe_iop_conf_tab[] = {
+	/* port pin dir open_drain assign */
+
+	/* MDIO */
+	{0,  1, 3, 0, 2}, /* MDIO */
+	{0,  2, 1, 0, 1}, /* MDC */
+
+	/* UCC4 - UEC */
+	{1, 14, 1, 0, 1}, /* TxD0 */
+	{1, 15, 1, 0, 1}, /* TxD1 */
+	{1, 20, 2, 0, 1}, /* RxD0 */
+	{1, 21, 2, 0, 1}, /* RxD1 */
+	{1, 18, 1, 0, 1}, /* TX_EN */
+	{1, 26, 2, 0, 1}, /* RX_DV */
+	{1, 27, 2, 0, 1}, /* RX_ER */
+	{1, 24, 2, 0, 1}, /* COL */
+	{1, 25, 2, 0, 1}, /* CRS */
+	{2, 15, 2, 0, 1}, /* TX_CLK - CLK16 */
+	{2, 16, 2, 0, 1}, /* RX_CLK - CLK17 */
+
+	/* DUART - UART2 */
+	{5,  0, 1, 0, 2}, /* UART2_SOUT */
+	{5,  2, 1, 0, 1}, /* UART2_RTS */
+	{5,  3, 2, 0, 2}, /* UART2_SIN */
+	{5,  1, 2, 0, 3}, /* UART2_CTS */
+
+	/* END of table */
+	{0,  0, 0, 0, QE_IOP_TAB_END},
+};
+
+int board_early_init_r (void)
+{
+	void *reg = (void *)(CONFIG_SYS_IMMR + 0x14a8);
+	u32 val;
+
+	/*
+	 * Because of errata in the UCCs, we have to write to the reserved
+	 * registers to slow the clocks down.
+	 */
+	val = in_be32 (reg);
+	/* UCC1 */
+	val |= 0x00003000;
+	/* UCC2 */
+	val |= 0x0c000000;
+	out_be32 (reg, val);
+	/* enable the PHY on the PIGGY */
+	setbits (8, (void *)(CONFIG_SYS_PIGGY_BASE + 0x10003), 0x01);
+
+	return 0;
+}
+
+int fixed_sdram(void)
+{
+	volatile immap_t *im = (immap_t *)CONFIG_SYS_IMMR;
+	u32 msize = 0;
+	u32 ddr_size;
+	u32 ddr_size_log2;
+
+	msize = CONFIG_SYS_DDR_SIZE;
+	for (ddr_size = msize << 20, ddr_size_log2 = 0;
+	     (ddr_size > 1); ddr_size = ddr_size >> 1, ddr_size_log2++) {
+		if (ddr_size & 1)
+			return -1;
+	}
+
+	im->sysconf.ddrlaw[0].ar =
+	    LAWAR_EN | ((ddr_size_log2 - 1) & LAWAR_SIZE);
+
+	im->ddr.csbnds[0].csbnds = CONFIG_SYS_DDR_CS0_BNDS;
+	im->ddr.cs_config[0] = CONFIG_SYS_DDR_CS0_CONFIG;
+	im->ddr.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0;
+	im->ddr.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1;
+	im->ddr.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2;
+	im->ddr.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3;
+	im->ddr.sdram_cfg = CONFIG_SYS_DDR_SDRAM_CFG;
+	im->ddr.sdram_cfg2 = CONFIG_SYS_DDR_SDRAM_CFG2;
+	im->ddr.sdram_mode = CONFIG_SYS_DDR_MODE;
+	im->ddr.sdram_mode2 = CONFIG_SYS_DDR_MODE2;
+	im->ddr.sdram_interval = CONFIG_SYS_DDR_INTERVAL;
+	im->ddr.sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CNTL;
+	udelay (200);
+	im->ddr.sdram_cfg |= SDRAM_CFG_MEM_EN;
+
+	return msize;
+}
+
+phys_size_t initdram (int board_type)
+{
+#if defined(CONFIG_DDR_ECC) && !defined(CONFIG_ECC_INIT_VIA_DDRC)
+	extern void ddr_enable_ecc (unsigned int dram_size);
+#endif
+	volatile immap_t *im = (immap_t *)CONFIG_SYS_IMMR;
+	u32 msize = 0;
+
+	if ((im->sysconf.immrbar & IMMRBAR_BASE_ADDR) != (u32)im)
+		return -1;
+
+	/* DDR SDRAM - Main SODIMM */
+	im->sysconf.ddrlaw[0].bar = CONFIG_SYS_DDR_BASE & LAWBAR_BAR;
+	msize = fixed_sdram ();
+
+#if defined(CONFIG_DDR_ECC) && !defined(CONFIG_ECC_INIT_VIA_DDRC)
+	/*
+	 * Initialize DDR ECC byte
+	 */
+	ddr_enable_ecc (msize * 1024 * 1024);
+#endif
+
+	/* return total bus SDRAM size(bytes)  -- DDR */
+	return (msize * 1024 * 1024);
+}
+
+int checkboard (void)
+{
+	puts ("Board: Keymile kmeter1");
+	if (ethernet_present ())
+		puts (" with PIGGY.");
+	puts ("\n");
+	return 0;
+}
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+void ft_board_setup (void *blob, bd_t *bd)
+{
+	ft_cpu_setup (blob, bd);
+}
+#endif
diff -Naur u-boot-2009.01/board/keymile/kmeter1/Makefile u-boot/board/keymile/kmeter1/Makefile
--- u-boot-2009.01/board/keymile/kmeter1/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/keymile/kmeter1/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,53 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+ifneq ($(OBJTREE),$(SRCTREE))
+$(shell mkdir -p $(obj)../common)
+endif
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	+= $(BOARD).o ../common/common.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/keymile/mgcoge/mgcoge.c u-boot/board/keymile/mgcoge/mgcoge.c
--- u-boot-2009.01/board/keymile/mgcoge/mgcoge.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/keymile/mgcoge/mgcoge.c	2009-02-26 14:03:58.000000000 +0100
@@ -25,6 +25,7 @@
 #include <mpc8260.h>
 #include <ioports.h>
 #include <malloc.h>
+#include <net.h>
 #include <asm/io.h>
 
 #if defined(CONFIG_OF_BOARD_SETUP) && defined(CONFIG_OF_LIBFDT)
@@ -35,7 +36,8 @@
 #include <i2c.h>
 #endif
 
-extern int ivm_read_eeprom (void);
+#include "../common/common.h"
+
 /*
  * I/O Port configuration table
  *
@@ -285,8 +287,10 @@
 
 int checkboard(void)
 {
-	puts ("Board: mgcoge\n");
-
+	puts ("Board: Keymile mgcoge");
+	if (ethernet_present ())
+		puts (" with PIGGY.");
+	puts ("\n");
 	return 0;
 }
 
@@ -321,6 +325,7 @@
 {
 	ulong memory_data[2] = {0};
 	ulong flash_data[8] = {0};
+	flash_info_t	*info;
 
 	memory_data[0] = cpu_to_be32 (bd->bi_memstart);
 	memory_data[1] = cpu_to_be32 (bd->bi_memsize);
@@ -328,12 +333,14 @@
 				sizeof (memory_data));
 
 	/* update Flash addr, size */
+	info = flash_get_info(CONFIG_SYS_FLASH_BASE);
 	flash_data[2] = cpu_to_be32 (CONFIG_SYS_FLASH_BASE);
-	flash_data[3] = cpu_to_be32 (CONFIG_SYS_FLASH_SIZE);
+	flash_data[3] = cpu_to_be32 (info->size);
 	flash_data[4] = cpu_to_be32 (5);
 	flash_data[5] = cpu_to_be32 (0);
+	info = flash_get_info(CONFIG_SYS_FLASH_BASE_1);
 	flash_data[6] = cpu_to_be32 (CONFIG_SYS_FLASH_BASE_1);
-	flash_data[7] = cpu_to_be32 (CONFIG_SYS_FLASH_SIZE_1);
+	flash_data[7] = cpu_to_be32 (info->size);
 	fdt_set_node_and_value (blob, "/localbus", "ranges", flash_data,
 				sizeof (flash_data));
 	/* MAC addr */
diff -Naur u-boot-2009.01/board/keymile/mgsuvd/mgsuvd.c u-boot/board/keymile/mgsuvd/mgsuvd.c
--- u-boot-2009.01/board/keymile/mgsuvd/mgsuvd.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/keymile/mgsuvd/mgsuvd.c	2009-02-26 14:03:58.000000000 +0100
@@ -22,13 +22,14 @@
  */
 #include <common.h>
 #include <mpc8xx.h>
+#include <net.h>
 #include <asm/io.h>
 
 #if defined(CONFIG_OF_BOARD_SETUP) && defined(CONFIG_OF_LIBFDT)
 #include <libfdt.h>
 #endif
 
-extern int ivm_read_eeprom (void);
+#include "../common/common.h"
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -60,7 +61,10 @@
 
 int checkboard (void)
 {
-	puts ("Board: Keymile mgsuvd\n");
+	puts ("Board: Keymile mgsuvd");
+	if (ethernet_present ())
+		puts (" with PIGGY.");
+	puts ("\n");
 	return (0);
 }
 
@@ -164,6 +168,7 @@
 	ulong brg_data[1] = {0};
 	ulong memory_data[2] = {0};
 	ulong flash_data[4] = {0};
+	ulong flash_reg[3] = {0};
 
 	memory_data[0] = cpu_to_be32 (bd->bi_memstart);
 	memory_data[1] = cpu_to_be32 (bd->bi_memsize);
@@ -175,6 +180,10 @@
 	fdt_set_node_and_value (blob, "/localbus", "ranges", flash_data,
 				sizeof (flash_data));
 
+	flash_reg[2] = cpu_to_be32 (bd->bi_flashsize);
+	fdt_set_node_and_value (blob, "/localbus/flash@0,0", "reg", flash_reg,
+				sizeof (flash_reg));
+
 	/* BRG */
 	brg_data[0] = cpu_to_be32 (bd->bi_busfreq);
 	fdt_set_node_and_value (blob, "/soc/cpm", "brg-frequency", brg_data,
diff -Naur u-boot-2009.01/board/korat/korat.c u-boot/board/korat/korat.c
--- u-boot-2009.01/board/korat/korat.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/korat/korat.c	2009-02-26 14:03:58.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2007-2008
+ * (C) Copyright 2007-2009
  * Larry Johnson, lrj@acm.org
  *
  * (C) Copyright 2006-2007
@@ -351,6 +351,7 @@
 	unsigned long sdr0_pfc1;
 	uint32_t const flash1_size = gd->bd->bi_flashsize - CONFIG_SYS_FLASH0_SIZE;
 	char const *const act = getenv("usbact");
+	char const *const usbcf = getenv("korat_usbcf");
 
 	/*
 	 * Re-do FLASH1 sizing and adjust flash start and offset.
@@ -405,6 +406,26 @@
 	/*
 	 * USB suff...
 	 */
+	/*
+	 * Select the USB controller on the 440EPx ("ppc") or on the PCI bus
+	 * ("pci") for the CompactFlash.
+	 */
+	if (usbcf != NULL && (strcmp(usbcf, "ppc") == 0)) {
+		/*
+		 * If environment variable "usbcf" is defined and set to "ppc",
+		 * then connect the CompactFlash controller to the PowerPC USB
+		 * port.
+		 */
+		printf("Attaching CompactFalsh controller to PPC USB\n");
+		out_8((u8 *) CONFIG_SYS_CPLD_BASE + 0x02,
+		      in_8((u8 *) CONFIG_SYS_CPLD_BASE + 0x02) | 0x10);
+	} else {
+		if (usbcf != NULL && (strcmp(usbcf, "pci") != 0))
+			printf("Warning: \"korat_usbcf\" is not set to a legal "
+			       "value (\"ppc\" or \"pci\")\n");
+
+		printf("Attaching CompactFalsh controller to PCI USB\n");
+	}
 	if (act == NULL || strcmp(act, "hostdev") == 0) {
 		/* SDR Setting */
 		mfsdr(SDR0_PFC1, sdr0_pfc1);
diff -Naur u-boot-2009.01/board/lwmon/lwmon.c u-boot/board/lwmon/lwmon.c
--- u-boot-2009.01/board/lwmon/lwmon.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/lwmon/lwmon.c	2009-02-26 14:03:58.000000000 +0100
@@ -846,12 +846,12 @@
 	default:
 		break;
 	}
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 U_BOOT_CMD(
 	pic,	4,	1,	do_pic,
-	"pic     - read and write PIC registers\n",
+	"read and write PIC registers",
 	"read  reg      - read PIC register `reg'\n"
 	"pic write reg val  - write value `val' to PIC register `reg'\n"
 );
@@ -910,7 +910,7 @@
 
 U_BOOT_CMD(
 	kbd,	1,	1,	do_kbd,
-	"kbd     - read keyboard status\n",
+	"read keyboard status",
 	NULL
 );
 
@@ -976,13 +976,13 @@
 	default:
 		break;
 	}
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
 U_BOOT_CMD(
 	lsb,	2,	1,	do_lsb,
-	"lsb     - check and set LSB switch\n",
+	"check and set LSB switch",
 	"on  - switch LSB on\n"
 	"lsb off - switch LSB off\n"
 	"lsb     - print current setting\n"
diff -Naur u-boot-2009.01/board/lwmon5/kbd.c u-boot/board/lwmon5/kbd.c
--- u-boot-2009.01/board/lwmon5/kbd.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/lwmon5/kbd.c	2009-02-26 14:03:58.000000000 +0100
@@ -432,7 +432,7 @@
 
 U_BOOT_CMD(
 	kbd,	1,	1,	do_kbd,
-	"kbd     - read keyboard status\n",
+	"read keyboard status",
 	NULL
 );
 
diff -Naur u-boot-2009.01/board/lwmon5/lwmon5.c u-boot/board/lwmon5/lwmon5.c
--- u-boot-2009.01/board/lwmon5/lwmon5.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/lwmon5/lwmon5.c	2009-02-26 14:03:58.000000000 +0100
@@ -467,7 +467,7 @@
 int do_eeprom_wp(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc < 2) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -476,7 +476,7 @@
 	} else if ((strcmp(argv[1], "off") == 0)) {
 		gpio_write_bit(CONFIG_SYS_GPIO_EEPROM_EXT_WP, 0);
 	} else {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -486,7 +486,7 @@
 
 U_BOOT_CMD(
 	eepromwp,	2,	0,	do_eeprom_wp,
-	"eepromwp- eeprom write protect off/on\n",
+	"eeprom write protect off/on",
 	"<on|off> - enable (on) or disable (off) I2C EEPROM write protect\n"
 );
 
diff -Naur u-boot-2009.01/board/MAI/AmigaOneG3SE/articiaS_pci.c u-boot/board/MAI/AmigaOneG3SE/articiaS_pci.c
--- u-boot-2009.01/board/MAI/AmigaOneG3SE/articiaS_pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/MAI/AmigaOneG3SE/articiaS_pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -313,7 +313,7 @@
 		   ARTICIAS_SYS_BUS,
 		   ARTICIAS_SYS_PHYS,
 		   ARTICIAS_SYS_MAXSIZE,
-		   PCI_REGION_MEM | PCI_REGION_MEMORY);
+		   PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
     /* PCI memory space */
     pci_set_region(articiaS_hose.regions + 1,
diff -Naur u-boot-2009.01/board/MAI/AmigaOneG3SE/cmd_boota.c u-boot/board/MAI/AmigaOneG3SE/cmd_boota.c
--- u-boot-2009.01/board/MAI/AmigaOneG3SE/cmd_boota.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/MAI/AmigaOneG3SE/cmd_boota.c	2009-02-26 14:03:58.000000000 +0100
@@ -122,7 +122,7 @@
 #if defined(CONFIG_AMIGAONEG3SE) && defined(CONFIG_CMD_BSP)
 U_BOOT_CMD(
 	boota,   3,      1,      do_boota,
-	"boota   - boot an Amiga kernel\n",
+	"boot an Amiga kernel",
 	"address disk"
 );
 #endif /* _CMD_BOOTA_H */
diff -Naur u-boot-2009.01/board/MAI/menu/cmd_menu.c u-boot/board/MAI/menu/cmd_menu.c
--- u-boot-2009.01/board/MAI/menu/cmd_menu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/MAI/menu/cmd_menu.c	2009-02-26 14:03:58.000000000 +0100
@@ -10,7 +10,7 @@
 #if defined(CONFIG_AMIGAONEG3SE) && defined(CONFIG_CMD_BSP)
 U_BOOT_CMD(
 	menu,   1,      1,      do_menu,
-	"menu    - display BIOS setup menu\n",
+	"display BIOS setup menu",
 	""
 );
 #endif
diff -Naur u-boot-2009.01/board/micronas/vct/bcu.h u-boot/board/micronas/vct/bcu.h
--- u-boot-2009.01/board/micronas/vct/bcu.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/bcu.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,170 @@
+/*
+ * (C) Copyright 2009 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _BCU_H
+#define _BCU_H
+
+enum bcu_tags {
+	BCU_VBV1		= 0,
+	BCU_VBV2		= 1,
+	BCU_BSS1		= 2,
+	BCU_BSS2		= 3,
+	BCU_TSD_TXT		= 4,
+	BCU_TSD_SUBTITLES	= 5,
+	BCU_TSD_PES_0		= 6,
+	BCU_TSD_PES_1		= 7,
+	BCU_TSD_PES_2		= 8,
+	BCU_TSD_PES_3		= 9,
+	BCU_TSIO_RECORD_0	= 10,
+	BCU_TSIO_RECORD_1	= 11,
+	BCU_TSIO_PLAYBACK_0	= 12,
+	BCU_TSIO_PLAYBACK_1	= 13,
+	BCU_SECURE_BUFFER	= 14,
+	BCU_PCM1		= 15,
+	BCU_PCM2		= 16,
+	BCU_BSS_COPY		= 17,
+	BCU_BSS_EXT1		= 18,
+	BCU_BSS_EXT2		= 19,
+	BCU_PCM_JINGLE		= 20,
+	BCU_EBI_CPU_BUFFER	= 21,
+	BCU_PCM_DELAY		= 22,
+	BCU_FH_BUFFER_0		= 23,
+	BCU_FH_BUFFER_1		= 24,
+	BCU_TSD_SECTION_0	= 25,
+	BCU_TSD_SECTION_1	= 26,
+	BCU_TSD_SECTION_2	= 27,
+	BCU_TSD_SECTION_3	= 28,
+	BCU_TSD_SECTION_4	= 29,
+	BCU_TSD_SECTION_5	= 30,
+	BCU_TSD_SECTION_6	= 31,
+	BCU_TSD_SECTION_7	= 32,
+	BCU_TSD_SECTION_8	= 33,
+	BCU_TSD_SECTION_9	= 34,
+	BCU_TSD_SECTION_10	= 35,
+	BCU_TSD_SECTION_11	= 36,
+	BCU_TSD_SECTION_12	= 37,
+	BCU_TSD_SECTION_13	= 38,
+	BCU_TSD_SECTION_14	= 39,
+	BCU_TSD_SECTION_15	= 40,
+	BCU_TSD_SECTION_16	= 41,
+	BCU_TSD_SECTION_17	= 42,
+	BCU_TSD_SECTION_18	= 43,
+	BCU_TSD_SECTION_19	= 44,
+	BCU_TSD_SECTION_20	= 45,
+	BCU_TSD_SECTION_21	= 46,
+	BCU_TSD_SECTION_22	= 47,
+	BCU_TSD_SECTION_23	= 48,
+	BCU_TSD_SECTION_24	= 49,
+	BCU_TSD_SECTION_25	= 50,
+	BCU_TSD_SECTION_26	= 51,
+	BCU_TSD_SECTION_27	= 52,
+	BCU_TSD_SECTION_28	= 53,
+	BCU_TSD_SECTION_29	= 54,
+	BCU_TSD_SECTION_30	= 55,
+	BCU_TSD_SECTION_31	= 56,
+	BCU_TSD_SECTION_32	= 57,
+	BCU_TSD_SECTION_33	= 58,
+	BCU_TSD_SECTION_34	= 59,
+	BCU_TSD_SECTION_35	= 60,
+	BCU_TSD_SECTION_36	= 61,
+	BCU_TSD_SECTION_37	= 62,
+	BCU_TSD_SECTION_38	= 63,
+	BCU_TSD_SECTION_39	= 64,
+	BCU_TSD_SECTION_40	= 65,
+	BCU_TSD_SECTION_41	= 66,
+	BCU_TSD_SECTION_42	= 67,
+	BCU_TSD_SECTION_43	= 68,
+	BCU_TSD_SECTION_44	= 69,
+	BCU_TSD_SECTION_45	= 70,
+	BCU_TSD_SECTION_46	= 71,
+	BCU_TSD_SECTION_47	= 72,
+	BCU_TSD_SECTION_48	= 73,
+	BCU_TSD_SECTION_49	= 74,
+	BCU_TSD_SECTION_50	= 75,
+	BCU_TSD_SECTION_51	= 76,
+	BCU_TSD_SECTION_52	= 77,
+	BCU_TSD_SECTION_53	= 78,
+	BCU_TSIO_RECORD_2	= 79,
+	BCU_TSIO_RECORD_3	= 80,
+	BCU_TSIO_RECORD_4	= 81,
+	BCU_TSIO_RECORD_5	= 82,
+	BCU_TSIO_RECORD_6	= 83,
+	BCU_TSIO_RECORD_7	= 84,
+	BCU_TSIO_RECORD_8	= 85,
+	BCU_TSIO_RECORD_9	= 86,
+	BCU_PCM_DELAY_LINEAR	= 87,
+	BCU_VD_MASTER_USER_DATA	= 88,
+	BCU_VD_SLAVE_USER_DATA	= 89,
+	BCU_VD_MASTER_REF0	= 90,
+	BCU_VD_MASTER_REF1	= 91,
+	BCU_VD_SLAVE_REF0	= 92,
+	BCU_VD_SLAVE_REF1	= 93,
+	BCU_VD_MASTER_DISP0_Y	= 94,
+	BCU_VD_MASTER_DISP1_Y	= 95,
+	BCU_VD_MASTER_DISP2_Y	= 96,
+	BCU_VD_MASTER_DISP0_C	= 97,
+	BCU_VD_MASTER_DISP1_C	= 98,
+	BCU_VD_MASTER_DISP2_C	= 99,
+	BCU_VD_SLAVE_DISP0_Y	= 100,
+	BCU_VD_SLAVE_DISP1_Y	= 101,
+	BCU_VD_SLAVE_DISP2_Y	= 102,
+	BCU_VD_SLAVE_DISP0_C	= 103,
+	BCU_VD_SLAVE_DISP1_C	= 104,
+	BCU_VD_SLAVE_DISP2_C	= 105,
+	BCU_CLUT_BUFFER_0	= 106,
+	BCU_CLUT_BUFFER_1	= 107,
+	BCU_OSD_FRAME_BUFFER_0	= 108,
+	BCU_OSD_FRAME_BUFFER_1	= 109,
+	BCU_GRAPHIC_FRAME_BUFFER0 = 110,
+	BCU_GRAPHIC_FRAME_BUFFER1 = 111,
+	BCU_DVP_VBI_REINSERTION	= 112,
+	BCU_DVP_OSD_FRAME_BUFFER0 = 113,
+	BCU_DVP_OSD_FRAME_BUFFER1 = 114,
+	BCU_GAI_BUFFER		= 115,
+	BCU_GA_SRC_BUFFER_0	= 116,
+	BCU_GA_SRC_BUFFER_1	= 117,
+	BCU_USB_BUFFER_0	= 118,
+	BCU_USB_BUFFER_1	= 119,
+	BCU_FE_3DCOMB_0		= 120,
+	BCU_FE_3DCOMB_1		= 121,
+	BCU_FE_3DCOMB_2		= 122,
+	BCU_FE_3DCOMB_3		= 123,
+	BCU_TNR_BUFFER_0	= 124,
+	BCU_TNR_BUFFER_1	= 125,
+	BCU_TNR_BUFFER_2	= 126,
+	BCU_MVAL_BUFFER		= 127,
+	BCU_RC_BUFFER_0		= 128,
+	BCU_RC_BUFFER_1		= 129,
+	BCU_RC_BUFFER_2		= 130,
+	BCU_RC_BUFFER_3		= 131,
+	BCU_PIP_BUFFER_0	= 132,
+	BCU_PIP_BUFFER_1	= 133,
+	BCU_PIP_BUFFER_2	= 134,
+	BCU_PIP_BUFFER_3	= 135,
+	BCU_EWARP_BUFFER	= 136,
+	BCU_OSD_BUFFER_0	= 137,
+	BCU_OSD_BUFFER_1	= 138,
+	BCU_GLOBAL_BUFFER_0	= 139,
+	BCU_GLOBAL_BUFFER_1	= 140,
+	BCU_MAX			= 141
+};
+
+#endif /* _BCU_H */
diff -Naur u-boot-2009.01/board/micronas/vct/config.mk u-boot/board/micronas/vct/config.mk
--- u-boot-2009.01/board/micronas/vct/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,31 @@
+#
+# (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# vct_xxx boards with MIPS 4Kc CPU core
+#
+
+sinclude $(TOPDIR)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+TEXT_BASE = 0x87000000
+endif
diff -Naur u-boot-2009.01/board/micronas/vct/dcgu.c u-boot/board/micronas/vct/dcgu.c
--- u-boot-2009.01/board/micronas/vct/dcgu.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/dcgu.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,258 @@
+/*
+ * (C) Copyright 2009 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Original Author Guenter Gebhardt
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/errno.h>
+
+#include "vct.h"
+
+int dcgu_set_clk_switch(enum dcgu_hw_module module, enum dcgu_switch setup)
+{
+	u32 enable;
+	union dcgu_clk_en1 en1;
+	union dcgu_clk_en2 en2;
+
+	switch (setup) {
+	case DCGU_SWITCH_ON:
+		enable = 1;
+		break;
+	case DCGU_SWITCH_OFF:
+		enable = 0;
+		break;
+	default:
+		printf("%s:%i:Invalid clock switch: %i\n", __FILE__, __LINE__,
+		       setup);
+		return -EINVAL;
+	}
+
+	if (module == DCGU_HW_MODULE_CPU)
+		en2.reg = reg_read(DCGU_CLK_EN2(DCGU_BASE));
+	else
+		en1.reg = reg_read(DCGU_CLK_EN1(DCGU_BASE));
+
+	switch (module) {
+	case DCGU_HW_MODULE_MSMC:
+		en1.bits.en_clkmsmc = enable;
+		break;
+	case DCGU_HW_MODULE_SSI_S:
+		en1.bits.en_clkssi_s = enable;
+		break;
+	case DCGU_HW_MODULE_SSI_M:
+		en1.bits.en_clkssi_m = enable;
+		break;
+	case DCGU_HW_MODULE_SMC:
+		en1.bits.en_clksmc = enable;
+		break;
+	case DCGU_HW_MODULE_EBI:
+		en1.bits.en_clkebi = enable;
+		break;
+	case DCGU_HW_MODULE_USB_PLL:
+		en1.bits.en_usbpll = enable;
+		break;
+	case DCGU_HW_MODULE_USB_60:
+		en1.bits.en_clkusb60 = enable;
+		break;
+	case DCGU_HW_MODULE_USB_24:
+		en1.bits.en_clkusb24 = enable;
+		break;
+	case DCGU_HW_MODULE_UART_2:
+		en1.bits.en_clkuart2 = enable;
+		break;
+	case DCGU_HW_MODULE_UART_1:
+		en1.bits.en_clkuart1 = enable;
+		break;
+	case DCGU_HW_MODULE_PERI:
+		en1.bits.en_clkperi20 = enable;
+		break;
+	case DCGU_HW_MODULE_CPU:
+		en2.bits.en_clkcpu = enable;
+		break;
+	case DCGU_HW_MODULE_I2S:
+		en1.bits.en_clk_i2s_dly = enable;
+		break;
+	case DCGU_HW_MODULE_ABP_SCC:
+		en1.bits.en_clk_scc_abp = enable;
+		break;
+	case DCGU_HW_MODULE_SPDIF:
+		en1.bits.en_clk_dtv_spdo = enable;
+		break;
+	case DCGU_HW_MODULE_AD:
+		en1.bits.en_clkad = enable;
+		break;
+	case DCGU_HW_MODULE_MVD:
+		en1.bits.en_clkmvd = enable;
+		break;
+	case DCGU_HW_MODULE_TSD:
+		en1.bits.en_clktsd = enable;
+		break;
+	case DCGU_HW_MODULE_GA:
+		en1.bits.en_clkga = enable;
+		break;
+	case DCGU_HW_MODULE_DVP:
+		en1.bits.en_clkdvp = enable;
+		break;
+	case DCGU_HW_MODULE_MR2:
+		en1.bits.en_clkmr2 = enable;
+		break;
+	case DCGU_HW_MODULE_MR1:
+		en1.bits.en_clkmr1 = enable;
+		break;
+	default:
+		printf("%s:%i:Invalid hardware module: %i\n", __FILE__,
+		       __LINE__, module);
+		return -EINVAL;
+	}
+
+	/*
+	 * The reg_read() following the reg_write() below forces the write to
+	 * be really done on the bus.
+	 * Otherwise the clock may not be switched on when this API function
+	 * returns, which may cause an bus error if a registers of the hardware
+	 * module connected to the clock is accessed.
+	 */
+	if (module == DCGU_HW_MODULE_CPU) {
+		reg_write(DCGU_CLK_EN2(DCGU_BASE), en2.reg);
+		en2.reg = reg_read(DCGU_CLK_EN2(DCGU_BASE));
+	} else {
+		reg_write(DCGU_CLK_EN1(DCGU_BASE), en1.reg);
+		en1.reg = reg_read(DCGU_CLK_EN1(DCGU_BASE));
+	}
+
+	return 0;
+}
+
+int dcgu_set_reset_switch(enum dcgu_hw_module module, enum dcgu_switch setup)
+{
+	union dcgu_reset_unit1 val;
+	u32 enable;
+
+	switch (setup) {
+	case DCGU_SWITCH_ON:
+		enable = 1;
+		break;
+	case DCGU_SWITCH_OFF:
+		enable = 0;
+		break;
+	default:
+		printf("%s:%i:Invalid reset switch: %i\n", __FILE__, __LINE__,
+		       setup);
+		return -EINVAL;
+	}
+
+	val.reg = reg_read(DCGU_RESET_UNIT1(DCGU_BASE));
+	switch (module) {
+	case DCGU_HW_MODULE_MSMC:
+		val.bits.swreset_clkmsmc = enable;
+		break;
+	case DCGU_HW_MODULE_SSI_S:
+		val.bits.swreset_clkssi_s = enable;
+		break;
+	case DCGU_HW_MODULE_SSI_M:
+		val.bits.swreset_clkssi_m = enable;
+		break;
+	case DCGU_HW_MODULE_SMC:
+		val.bits.swreset_clksmc = enable;
+		break;
+	case DCGU_HW_MODULE_EBI:
+		val.bits.swreset_clkebi = enable;
+		break;
+	case DCGU_HW_MODULE_USB_60:
+		val.bits.swreset_clkusb60 = enable;
+		break;
+	case DCGU_HW_MODULE_USB_24:
+		val.bits.swreset_clkusb24 = enable;
+		break;
+	case DCGU_HW_MODULE_UART_2:
+		val.bits.swreset_clkuart2 = enable;
+		break;
+	case DCGU_HW_MODULE_UART_1:
+		val.bits.swreset_clkuart1 = enable;
+		break;
+	case DCGU_HW_MODULE_PWM:
+		val.bits.swreset_pwm = enable;
+		break;
+	case DCGU_HW_MODULE_GPT:
+		val.bits.swreset_gpt = enable;
+		break;
+	case DCGU_HW_MODULE_I2C2:
+		val.bits.swreset_i2c2 = enable;
+		break;
+	case DCGU_HW_MODULE_I2C1:
+		val.bits.swreset_i2c1 = enable;
+		break;
+	case DCGU_HW_MODULE_GPIO2:
+		val.bits.swreset_gpio2 = enable;
+		break;
+	case DCGU_HW_MODULE_GPIO1:
+		val.bits.swreset_gpio1 = enable;
+		break;
+	case DCGU_HW_MODULE_CPU:
+		val.bits.swreset_clkcpu = enable;
+		break;
+	case DCGU_HW_MODULE_I2S:
+		val.bits.swreset_clk_i2s_dly = enable;
+		break;
+	case DCGU_HW_MODULE_ABP_SCC:
+		val.bits.swreset_clk_scc_abp = enable;
+		break;
+	case DCGU_HW_MODULE_SPDIF:
+		val.bits.swreset_clk_dtv_spdo = enable;
+		break;
+	case DCGU_HW_MODULE_AD:
+		val.bits.swreset_clkad = enable;
+		break;
+	case DCGU_HW_MODULE_MVD:
+		val.bits.swreset_clkmvd = enable;
+		break;
+	case DCGU_HW_MODULE_TSD:
+		val.bits.swreset_clktsd = enable;
+		break;
+	case DCGU_HW_MODULE_TSIO:
+		val.bits.swreset_clktsio = enable;
+		break;
+	case DCGU_HW_MODULE_GA:
+		val.bits.swreset_clkga = enable;
+		break;
+	case DCGU_HW_MODULE_MPC:
+		val.bits.swreset_clkmpc = enable;
+		break;
+	case DCGU_HW_MODULE_CVE:
+		val.bits.swreset_clkcve = enable;
+		break;
+	case DCGU_HW_MODULE_DVP:
+		val.bits.swreset_clkdvp = enable;
+		break;
+	case DCGU_HW_MODULE_MR2:
+		val.bits.swreset_clkmr2 = enable;
+		break;
+	case DCGU_HW_MODULE_MR1:
+		val.bits.swreset_clkmr1 = enable;
+		break;
+	default:
+		printf("%s:%i:Invalid hardware module: %i\n", __FILE__,
+		       __LINE__, module);
+		return -EINVAL;
+	}
+	reg_write(DCGU_RESET_UNIT1(DCGU_BASE), val.reg);
+
+	return 0;
+}
diff -Naur u-boot-2009.01/board/micronas/vct/dcgu.h u-boot/board/micronas/vct/dcgu.h
--- u-boot-2009.01/board/micronas/vct/dcgu.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/dcgu.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,179 @@
+/*
+ * (C) Copyright 2009 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _DCGU_H
+#define _DCGU_H
+
+enum dcgu_switch {
+	DCGU_SWITCH_OFF,	/* Switch off				*/
+	DCGU_SWITCH_ON		/* Switch on				*/
+};
+
+enum dcgu_hw_module {
+	DCGU_HW_MODULE_DCGU,	/* Selects digital clock gen. unit	*/
+
+	DCGU_HW_MODULE_MIC32_SCI, /* Selects MIC32 SoC interface	*/
+	DCGU_HW_MODULE_SCI,	/* Selects SCI target agent port modules*/
+
+	DCGU_HW_MODULE_MR1,	/* Selects first MPEG reader module	*/
+	DCGU_HW_MODULE_MR2,	/* Selects second MPEG reader module	*/
+	DCGU_HW_MODULE_MVD,	/* Selects MPEG video decoder module	*/
+	DCGU_HW_MODULE_DVP,	/* Selects dig video processing module	*/
+	DCGU_HW_MODULE_CVE,	/* Selects color video encoder module	*/
+	DCGU_HW_MODULE_VID_ENC,	/* Selects video encoder module		*/
+
+	DCGU_HW_MODULE_SSI_S,	/* Selects slave sync serial interface	*/
+	DCGU_HW_MODULE_SSI_M,	/* Selects master sync serial interface	*/
+
+	DCGU_HW_MODULE_GA,	/* Selects graphics accelerator module	*/
+	DCGU_HW_MODULE_DGPU,	/* Selects digital graphics processing	*/
+
+	DCGU_HW_MODULE_UART_1,	/* Selects first UART module		*/
+	DCGU_HW_MODULE_UART_2,	/* Selects second UART module		*/
+
+	DCGU_HW_MODULE_AD,	/* Selects audio decoder module		*/
+	DCGU_HW_MODULE_ABP_DTV,	/* Selects audio baseband processing	*/
+	DCGU_HW_MODULE_ABP_SCC,	/* Selects audio base band processor SCC*/
+	DCGU_HW_MODULE_SPDIF,	/* Selects sony philips digital interf.	*/
+
+	DCGU_HW_MODULE_TSIO,	/* Selects trasnport stream input/output*/
+	DCGU_HW_MODULE_TSD,	/* Selects trasnport stream decoder	*/
+	DCGU_HW_MODULE_TSD_KEY,	/* Selects trasnport stream decoder key	*/
+
+	DCGU_HW_MODULE_USBH,	/* Selects USB hub module		*/
+	DCGU_HW_MODULE_USB_PLL,	/* Selects USB phase locked loop module	*/
+	DCGU_HW_MODULE_USB_60,	/* Selects USB 60 module		*/
+	DCGU_HW_MODULE_USB_24,	/* Selects USB 24 module		*/
+
+	DCGU_HW_MODULE_PERI,	/* Selects all mod connected to clkperi20*/
+	DCGU_HW_MODULE_WDT,	/* Selects wtg timer mod con to clkperi20*/
+	DCGU_HW_MODULE_I2C1,	/* Selects first I2C mod con to clkperi20*/
+	DCGU_HW_MODULE_I2C2,	/* Selects 2nd I2C mod con to clkperi20	*/
+	DCGU_HW_MODULE_GPIO1,	/* Selects gpio module 1		*/
+	DCGU_HW_MODULE_GPIO2,	/* Selects gpio module 2		*/
+
+	DCGU_HW_MODULE_GPT,	/* Selects gpt mod connected to clkperi20*/
+	DCGU_HW_MODULE_PWM,	/* Selects pwm mod connected to clkperi20*/
+
+	DCGU_HW_MODULE_MPC,	/* Selects multi purpose cipher module	*/
+	DCGU_HW_MODULE_MPC_KEY,	/* Selects multi purpose cipher key	*/
+
+	DCGU_HW_MODULE_COM,	/* Selects COM unit module		*/
+	DCGU_HW_MODULE_VCTY_CORE, /* Selects VCT-Y core module		*/
+	DCGU_HW_MODULE_FWSRAM,	/* Selects firmware SRAM module		*/
+
+	DCGU_HW_MODULE_EBI,	/* Selects external bus interface module*/
+	DCGU_HW_MODULE_I2S,	/* Selects integrated interchip sound	*/
+	DCGU_HW_MODULE_MSMC,	/* Selects memory stick and mmc module	*/
+	DCGU_HW_MODULE_SMC,	/* Selects smartcard interface module	*/
+
+	DCGU_HW_MODULE_IRQC,	/* Selects interrupt C module		*/
+	DCGU_HW_MODULE_TOP,	/* Selects top level pinmux module	*/
+	DCGU_HW_MODULE_SRAM,	/* Selects SRAM module			*/
+	DCGU_HW_MODULE_EIC,	/* Selects External Interrupt controller*/
+	DCGU_HW_MODULE_CPU,	/* Selects CPU subsystem module		*/
+	DCGU_HW_MODULE_SCC,	/* Selects SCC module			*/
+	DCGU_HW_MODULE_MM,	/* Selects Memory Manager module	*/
+	DCGU_HW_MODULE_BCU,	/* Selects Buffer Configuration Unit	*/
+	DCGU_HW_MODULE_FH,	/* Selects FIFO Handler module		*/
+	DCGU_HW_MODULE_IMU,	/* Selects Interrupt Management Unit	*/
+	DCGU_HW_MODULE_MDU,	/* Selects MCI Debug Unit module	*/
+	DCGU_HW_MODULE_SI2OCP	/* Selects Standard Interface to OCP bridge*/
+};
+
+union dcgu_clk_en1 {
+	u32 reg;
+	struct {
+		u32 res1:8;		/* reserved			*/
+		u32 en_clkmsmc:1;	/* Enable bit for clkmsmc (#)	*/
+		u32 en_clkssi_s:1;	/* Enable bit for clkssi_s (#)	*/
+		u32 en_clkssi_m:1;	/* Enable bit for clkssi_m (#)	*/
+		u32 en_clksmc:1;	/* Enable bit for clksmc (#)	*/
+		u32 en_clkebi:1;	/* Enable bit for clkebi (#)	*/
+		u32 en_usbpll:1;	/* Enable bit for the USB PLL	*/
+		u32 en_clkusb60:1;	/* Enable bit for clkusb60 (#)	*/
+		u32 en_clkusb24:1;	/* Enable bit for clkusb24 (#)	*/
+		u32 en_clkuart2:1;	/* Enable bit for clkuart2 (#)	*/
+		u32 en_clkuart1:1;	/* Enable bit for clkuart1 (#)	*/
+		u32 en_clkperi20:1;	/* Enable bit for clkperi20 (#)	*/
+		u32 res2:3;		/* reserved			*/
+		u32 en_clk_i2s_dly:1;	/* Enable bit for clk_scc_abp	*/
+		u32 en_clk_scc_abp:1;	/* Enable bit for clk_scc_abp	*/
+		u32 en_clk_dtv_spdo:1;	/* Enable bit for clk_dtv_spdo	*/
+		u32 en_clkad:1;		/* Enable bit for clkad (#)	*/
+		u32 en_clkmvd:1;	/* Enable bit for clkmvd (#)	*/
+		u32 en_clktsd:1;	/* Enable bit for clktsd (#)	*/
+		u32 en_clkga:1;		/* Enable bit for clkga (#)	*/
+		u32 en_clkdvp:1;	/* Enable bit for clkdvp (#)	*/
+		u32 en_clkmr2:1;	/* Enable bit for clkmr2 (#)	*/
+		u32 en_clkmr1:1;	/* Enable bit for clkmr1 (#)	*/
+	} bits;
+};
+
+union dcgu_clk_en2 {
+	u32 reg;
+	struct {
+		u32 res1:31;		/* reserved			*/
+		u32 en_clkcpu:1;	/* Enable bit for clkcpu	*/
+	} bits;
+};
+
+union dcgu_reset_unit1 {
+	u32 reg;
+	struct {
+		u32 res1:1;
+		u32 swreset_clkmsmc:1;
+		u32 swreset_clkssi_s:1;
+		u32 swreset_clkssi_m:1;
+		u32 swreset_clksmc:1;
+		u32 swreset_clkebi:1;
+		u32 swreset_clkusb60:1;
+		u32 swreset_clkusb24:1;
+		u32 swreset_clkuart2:1;
+		u32 swreset_clkuart1:1;
+		u32 swreset_pwm:1;
+		u32 swreset_gpt:1;
+		u32 swreset_i2c2:1;
+		u32 swreset_i2c1:1;
+		u32 swreset_gpio2:1;
+		u32 swreset_gpio1:1;
+		u32 swreset_clkcpu:1;
+		u32 res2:2;
+		u32 swreset_clk_i2s_dly:1;
+		u32 swreset_clk_scc_abp:1;
+		u32 swreset_clk_dtv_spdo:1;
+		u32 swreset_clkad:1;
+		u32 swreset_clkmvd:1;
+		u32 swreset_clktsd:1;
+		u32 swreset_clktsio:1;
+		u32 swreset_clkga:1;
+		u32 swreset_clkmpc:1;
+		u32 swreset_clkcve:1;
+		u32 swreset_clkdvp:1;
+		u32 swreset_clkmr2:1;
+		u32 swreset_clkmr1:1;
+	} bits;
+};
+
+int dcgu_set_clk_switch(enum dcgu_hw_module module, enum dcgu_switch setup);
+int dcgu_set_reset_switch(enum dcgu_hw_module module, enum dcgu_switch setup);
+
+#endif /* _DCGU_H */
diff -Naur u-boot-2009.01/board/micronas/vct/ebi.c u-boot/board/micronas/vct/ebi.c
--- u-boot-2009.01/board/micronas/vct/ebi.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/ebi.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,48 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include "vct.h"
+
+int ebi_initialize(void)
+{
+#if defined(CONFIG_VCT_NOR)
+	if (ebi_init_nor_flash())
+		return -1;
+#endif
+
+#if defined(CONFIG_VCT_ONENAND)
+	if (ebi_init_onenand())
+		return -1;
+#endif
+
+#if defined(CONFIG_DRIVER_SMC911X)
+	if (ebi_init_smc911x())
+		return -1;
+#endif
+
+	reg_write(EBI_CTRL_SIG_ACTLV(EBI_BASE), 0x00004100);
+
+	ebi_wait();
+
+	return 0;
+}
diff -Naur u-boot-2009.01/board/micronas/vct/ebi.h u-boot/board/micronas/vct/ebi.h
--- u-boot-2009.01/board/micronas/vct/ebi.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/ebi.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,95 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __EBI__
+#define __EBI__
+
+#include <common.h>
+#include <asm/io.h>
+#include "vct.h"
+
+#define EXT_DEVICE_CHANNEL_3	(0x30000000)
+#define EXT_DEVICE_CHANNEL_2	(0x20000000)
+#define EXT_DEVICE_CHANNEL_1	(0x10000000)
+#define EXT_CPU_ACCESS_ACTIVE	(0x00000001)
+#define EXT_DMA_ACCESS_ACTIVE	(1 << 14)
+#define EXT_CPU_IORDY_SL	(0x00000001)
+
+#define EBI_CPU_WRITE		(1 << 31)
+#define EBI_CPU_ID_SHIFT	(28)
+#define EBI_CPU_ADDR_MASK	~(~0UL << EBI_CPU_ID_SHIFT)
+
+/* position of various bit slices in timing register EBI_DEV[01]_TIM1_RD1 */
+#define ADDR_LATCH_ENABLE	0
+#define ADDR_ACTIVATION		4
+#define CHIP_SELECT_START	8
+#define OUTPUT_ENABLE_START	12
+#define WAIT_TIME		28
+#define READ_DURATION		20
+
+/* position of various bit slices in timing register EBI_DEV[01]_TIM1_RD2 */
+#define OUTPUT_ENABLE_END	0
+#define CHIP_SELECT_END		4
+#define ADDR_DEACTIVATION	8
+#define RECOVER_TIME		12
+#define ACK_TIME		20
+
+/* various bits in configuration register EBI_DEV[01]_CONFIG1 */
+#define EBI_EXTERNAL_DATA_8	(1 <<  8)
+#define EBI_EXT_ADDR_SHIFT	(1 << 22)
+#define EBI_EXTERNAL_DATA_16	EBI_EXT_ADDR_SHIFT
+#define EBI_CHIP_SELECT_1	0x2
+#define EBI_CHIP_SELECT_2	0x4
+#define EBI_BUSY_EN_RD		(1 << 12)
+#define DIR_ACCESS_WRITE	(1 << 20)
+#define DIR_ACCESS_MASK		(1 << 20)
+
+/* various bits in configuration register EBI_DEV[01]_CONFIG2 */
+#define ADDRESS_INCREMENT_ON	0x0
+#define ADDRESS_INCREMENT_OFF	0x100
+#define QUEUE_LENGTH_1		0x40
+#define QUEUE_LENGTH_2		0x80
+#define QUEUE_LENGTH_3		0xC0
+#define QUEUE_LENGTH_4		0
+#define CPU_TRANSFER_SIZE_32	0
+#define CPU_TRANSFER_SIZE_16	0x10
+#define CPU_TRANSFER_SIZE_8	0x20
+#define READ_ENDIANNESS_ABCD	0
+#define READ_ENDIANNESS_DCBA	0x4
+#define READ_ENDIANNESS_BADC	0x8
+#define READ_ENDIANNESS_CDAB	0xC
+#define WRITE_ENDIANNESS_ABCD	0
+#define WRITE_ENDIANNESS_DCBA	0x1
+#define WRITE_ENDIANNESS_BADC	0x2
+#define WRITE_ENDIANNESS_CDAB	0x3
+
+/* various bits in configuration register EBI_CTRL_SIG_ACTLV */
+#define IORDY_ACTIVELEVEL_HIGH	(1 << 14)
+#define ALE_ACTIVELEVEL_HIGH	(1 <<  8)
+
+/* bits in register EBI_SIG_LEVEL */
+#define IORDY_LEVEL_MASK	1
+
+static inline void ebi_wait(void)
+{
+	while (reg_read(EBI_STATUS(EBI_BASE)) & EXT_CPU_ACCESS_ACTIVE)
+		;	/* wait */
+}
+
+#endif
diff -Naur u-boot-2009.01/board/micronas/vct/ebi_nor_flash.c u-boot/board/micronas/vct/ebi_nor_flash.c
--- u-boot-2009.01/board/micronas/vct/ebi_nor_flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/ebi_nor_flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,131 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include "vct.h"
+
+static u32 ebi_read(u32 addr)
+{
+	addr &= ~0xFC000000;
+
+	reg_write(EBI_CPU_IO_ACCS(EBI_BASE), EXT_DEVICE_CHANNEL_2 | addr);
+	ebi_wait();
+
+	return reg_read(EBI_IO_ACCS_DATA(EBI_BASE));
+}
+
+static int ebi_write_u16(u32 addr, u32 data, int fetchIO)
+{
+	u32 val = (data << 16);
+
+	addr &= ~0xFC000000;
+
+	ebi_wait();
+
+	reg_write(EBI_IO_ACCS_DATA(EBI_BASE), val);
+	reg_write(EBI_CPU_IO_ACCS(EBI_BASE),
+		  EXT_DEVICE_CHANNEL_2 | EBI_CPU_WRITE | addr);
+	ebi_wait();
+
+	if (fetchIO) {
+		u32 counter = 0;
+		while (!(reg_read(EBI_SIG_LEVEL(EBI_BASE)) & EXT_CPU_IORDY_SL)) {
+			if (counter++ > 0xFFFFFF)
+				return 1;
+		}
+	}
+
+	return 0;
+}
+
+static u16 ebi_read_u16(u32 addr)
+{
+	return ((ebi_read(addr) >> 16) & 0xFFFF);
+}
+
+static u8 ebi_read_u8(u32 addr)
+{
+	u32 val = ebi_read(addr) >> 16;
+
+	if (addr & 0x1)
+		return val & 0xff;
+	else
+		return (val >> 8) & 0xff;
+}
+
+/*
+ * EBI initialization for NOR FLASH access
+ */
+int ebi_init_nor_flash(void)
+{
+	reg_write(EBI_DEV1_CONFIG1(EBI_BASE), 0x83000);
+
+	reg_write(EBI_DEV2_CONFIG1(EBI_BASE), 0x400002);
+	reg_write(EBI_DEV2_CONFIG2(EBI_BASE), 0x50);
+
+	reg_write(EBI_DEV2_TIM1_RD1(EBI_BASE), 0x409113);
+	reg_write(EBI_DEV2_TIM1_RD2(EBI_BASE), 0xFF01000);
+	reg_write(EBI_DEV2_TIM1_WR1(EBI_BASE), 0x04003113);
+	reg_write(EBI_DEV2_TIM1_WR2(EBI_BASE), 0x3FC12011);
+	reg_write(EBI_DEV2_TIM_EXT(EBI_BASE), 0xFFF00000);
+
+	return 0;
+}
+
+/*
+ * Accessor functions replacing the "weak" functions in
+ * drivers/mtd/cfi_flash.c
+ */
+void flash_write8(u8 value, void *addr)
+{
+	ebi_write_u16((u32)addr, value, 0);
+}
+
+void flash_write16(u16 value, void *addr)
+{
+	ebi_write_u16((u32)addr, value, 0);
+}
+
+u8 flash_read8(void *addr)
+{
+	return ebi_read_u8((u32)addr);
+}
+
+u16 flash_read16(void *addr)
+{
+	return ebi_read_u16((u32)addr);
+}
+
+u32 flash_read32(void *addr)
+{
+	return ((u32)ebi_read_u16((u32)addr) << 16) |
+		ebi_read_u16((u32)addr + 2);
+}
+
+void *board_flash_read_memcpy(void *dest, const void *src, size_t count)
+{
+	u16 *tmp = (u16 *)dest, *s = (u16 *)src;
+	int i;
+
+	for (i = 0; i < count; i += 2)
+		*tmp++ = flash_read16(s++);
+
+	return dest;
+}
diff -Naur u-boot-2009.01/board/micronas/vct/ebi_onenand.c u-boot/board/micronas/vct/ebi_onenand.c
--- u-boot-2009.01/board/micronas/vct/ebi_onenand.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/ebi_onenand.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,198 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/onenand.h>
+#include "vct.h"
+
+#define BURST_SIZE_WORDS		4
+
+static u16 ebi_nand_read_word(void __iomem *addr)
+{
+	reg_write(EBI_CPU_IO_ACCS(EBI_BASE), (EXT_DEVICE_CHANNEL_2 | (u32)addr));
+	ebi_wait();
+
+	return reg_read(EBI_IO_ACCS_DATA(EBI_BASE)) >> 16;
+}
+
+static void ebi_nand_write_word(u16 data, void __iomem * addr)
+{
+	ebi_wait();
+	reg_write(EBI_IO_ACCS_DATA(EBI_BASE), (data << 16));
+	reg_write(EBI_CPU_IO_ACCS(EBI_BASE),
+		  EXT_DEVICE_CHANNEL_2 | EBI_CPU_WRITE | (u32)addr);
+	ebi_wait();
+}
+
+/*
+ * EBI initialization for OneNAND FLASH access
+ */
+int ebi_init_onenand(void)
+{
+	reg_write(EBI_DEV1_CONFIG1(EBI_BASE), 0x83000);
+
+	reg_write(EBI_DEV2_CONFIG1(EBI_BASE), 0x00403002);
+	reg_write(EBI_DEV2_CONFIG2(EBI_BASE), 0x50);
+
+	reg_write(EBI_DEV3_CONFIG1(EBI_BASE), 0x00403002);
+	reg_write(EBI_DEV3_CONFIG2(EBI_BASE), 0x0); /* byte/word ordering */
+
+	reg_write(EBI_DEV2_TIM1_RD1(EBI_BASE), 0x00504000);
+	reg_write(EBI_DEV2_TIM1_RD2(EBI_BASE), 0x00001000);
+	reg_write(EBI_DEV2_TIM1_WR1(EBI_BASE), 0x12002223);
+	reg_write(EBI_DEV2_TIM1_WR2(EBI_BASE), 0x3FC02220);
+	reg_write(EBI_DEV3_TIM1_RD1(EBI_BASE), 0x00504000);
+	reg_write(EBI_DEV3_TIM1_RD2(EBI_BASE), 0x00001000);
+	reg_write(EBI_DEV3_TIM1_WR1(EBI_BASE), 0x05001000);
+	reg_write(EBI_DEV3_TIM1_WR2(EBI_BASE), 0x00010200);
+
+	reg_write(EBI_DEV2_TIM_EXT(EBI_BASE), 0xFFF00000);
+	reg_write(EBI_DEV2_EXT_ACC(EBI_BASE), 0x0FFFFFFF);
+
+	reg_write(EBI_DEV3_TIM_EXT(EBI_BASE), 0xFFF00000);
+	reg_write(EBI_DEV3_EXT_ACC(EBI_BASE), 0x0FFFFFFF);
+
+	/* prepare DMA configuration for EBI */
+	reg_write(EBI_DEV3_FIFO_CONFIG(EBI_BASE), 0x0101ff00);
+
+	/* READ only no byte order change, TAG 1 used */
+	reg_write(EBI_DEV3_DMA_CONFIG2(EBI_BASE), 0x00000004);
+
+	reg_write(EBI_TAG1_SYS_ID(EBI_BASE), 0x0); /* SCC DMA channel 0 */
+	reg_write(EBI_TAG2_SYS_ID(EBI_BASE), 0x1);
+	reg_write(EBI_TAG3_SYS_ID(EBI_BASE), 0x2);
+	reg_write(EBI_TAG4_SYS_ID(EBI_BASE), 0x3);
+
+	return 0;
+}
+
+static void *memcpy_16_from_onenand(void *dst, const void *src, unsigned int len)
+{
+	void *ret = dst;
+	u16 *d = dst;
+	u16 *s = (u16 *)src;
+
+	len >>= 1;
+	while (len-- > 0)
+		*d++ = ebi_nand_read_word(s++);
+
+	return ret;
+}
+
+static void *memcpy_32_from_onenand(void *dst, const void *src, unsigned int len)
+{
+	void *ret = dst;
+	u32 *d = (u32 *)dst;
+	u32 s = (u32)src;
+	u32 bytes_per_block = BURST_SIZE_WORDS * sizeof(int);
+	u32 n_blocks = len / bytes_per_block;
+	u32 block = 0;
+	u32 burst_word;
+
+	for (block = 0; block < n_blocks; block++) {
+		/* Trigger read channel 3 */
+		reg_write(EBI_CPU_IO_ACCS(EBI_BASE),
+			  (EXT_DEVICE_CHANNEL_3 | (s + (block * bytes_per_block))));
+		/* Poll status to see whether read has finished */
+		ebi_wait();
+
+		/* Squirrel the data away in a safe place */
+		for (burst_word = 0; burst_word < BURST_SIZE_WORDS; burst_word++)
+			*d++ = reg_read(EBI_IO_ACCS_DATA(EBI_BASE));
+	}
+
+	return ret;
+}
+
+static void *memcpy_16_to_onenand(void *dst, const void *src, unsigned int len)
+{
+	void *ret = dst;
+	u16 *d = dst;
+	u16 *s = (u16 *)src;
+
+	len >>= 1;
+	while (len-- > 0)
+		ebi_nand_write_word(*s++, d++);
+
+	return ret;
+}
+
+static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
+{
+	struct onenand_chip *this = mtd->priv;
+
+	if (ONENAND_CURRENT_BUFFERRAM(this)) {
+		if (area == ONENAND_DATARAM)
+			return mtd->writesize;
+		if (area == ONENAND_SPARERAM)
+			return mtd->oobsize;
+	}
+
+	return 0;
+}
+
+static int ebi_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
+			      unsigned char *buffer, int offset,
+			      size_t count)
+{
+	struct onenand_chip *this = mtd->priv;
+	void __iomem *bufferram;
+
+	bufferram = this->base + area;
+	bufferram += onenand_bufferram_offset(mtd, area);
+
+	if (count < 4)
+		memcpy_16_from_onenand(buffer, bufferram + offset, count);
+	else
+		memcpy_32_from_onenand(buffer, bufferram + offset, count);
+
+	return 0;
+}
+
+static int ebi_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
+			       const unsigned char *buffer, int offset,
+			       size_t count)
+{
+	struct onenand_chip *this = mtd->priv;
+	void __iomem *bufferram;
+
+	bufferram = this->base + area;
+	bufferram += onenand_bufferram_offset(mtd, area);
+
+	memcpy_16_to_onenand(bufferram + offset, buffer, count);
+
+	return 0;
+}
+
+void onenand_board_init(struct mtd_info *mtd)
+{
+	struct onenand_chip *chip = mtd->priv;
+
+	/*
+	 * Insert board specific OneNAND access functions
+	 */
+	chip->read_word = ebi_nand_read_word;
+	chip->write_word = ebi_nand_write_word;
+
+	chip->read_bufferram = ebi_read_bufferram;
+	chip->read_spareram = ebi_read_bufferram;
+	chip->write_bufferram = ebi_write_bufferram;
+}
diff -Naur u-boot-2009.01/board/micronas/vct/ebi_smc911x.c u-boot/board/micronas/vct/ebi_smc911x.c
--- u-boot-2009.01/board/micronas/vct/ebi_smc911x.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/ebi_smc911x.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,94 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include "vct.h"
+
+/*
+ * EBI initialization for SMC911x access
+ */
+int ebi_init_smc911x(void)
+{
+	reg_write(EBI_DEV1_CONFIG1(EBI_BASE), 0x00003020);
+	reg_write(EBI_DEV1_CONFIG2(EBI_BASE), 0x0000004F);
+
+	reg_write(EBI_DEV1_TIM1_RD1(EBI_BASE), 0x00501100);
+	reg_write(EBI_DEV1_TIM1_RD2(EBI_BASE), 0x0FF02111);
+
+	reg_write(EBI_DEV1_TIM_EXT(EBI_BASE), 0xFFF00000);
+	reg_write(EBI_DEV1_EXT_ACC(EBI_BASE), 0x0FFFFFFF);
+
+	reg_write(EBI_DEV1_TIM1_WR1(EBI_BASE), 0x05001100);
+	reg_write(EBI_DEV1_TIM1_WR2(EBI_BASE), 0x3FC21110);
+
+	return 0;
+}
+
+/*
+ * Accessor functions replacing the "weak" functions in
+ * drivers/net/smc911x.c
+ */
+u32 smc911x_reg_read(u32 addr)
+{
+	volatile u32 data;
+
+	reg_write(EBI_DEV1_CONFIG2(EBI_BASE), 0x0000004F);
+	ebi_wait();
+	reg_write(EBI_CPU_IO_ACCS(EBI_BASE), (EXT_DEVICE_CHANNEL_1 | addr));
+	ebi_wait();
+	data = reg_read(EBI_IO_ACCS_DATA(EBI_BASE));
+
+	return (data);
+}
+
+void smc911x_reg_write(u32 addr, u32 data)
+{
+	reg_write(EBI_DEV1_CONFIG2(EBI_BASE), 0x0000004F);
+	ebi_wait();
+	reg_write(EBI_IO_ACCS_DATA(EBI_BASE), data);
+	reg_write(EBI_CPU_IO_ACCS(EBI_BASE),
+		  EXT_DEVICE_CHANNEL_1 | EBI_CPU_WRITE | addr);
+	ebi_wait();
+}
+
+void pkt_data_push(u32 addr, u32 data)
+{
+	reg_write(EBI_DEV1_CONFIG2(EBI_BASE), 0x0000004A);
+	ebi_wait();
+	reg_write(EBI_IO_ACCS_DATA(EBI_BASE), data);
+	reg_write(EBI_CPU_IO_ACCS(EBI_BASE),
+		  EXT_DEVICE_CHANNEL_1 | EBI_CPU_WRITE | addr);
+	ebi_wait();
+
+	return;
+}
+
+u32 pkt_data_pull(u32 addr)
+{
+	volatile u32 data;
+
+	reg_write(EBI_DEV1_CONFIG2(EBI_BASE), 0x0000004A);
+	ebi_wait();
+	reg_write(EBI_CPU_IO_ACCS(EBI_BASE), (EXT_DEVICE_CHANNEL_1 | addr));
+	ebi_wait();
+	data = reg_read(EBI_IO_ACCS_DATA(EBI_BASE));
+
+	return data;
+}
diff -Naur u-boot-2009.01/board/micronas/vct/ehci.c u-boot/board/micronas/vct/ehci.c
--- u-boot-2009.01/board/micronas/vct/ehci.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/ehci.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,110 @@
+/*
+ * (C) Copyright 2009 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Original Author Guenter Gebhardt
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#include "vct.h"
+
+int vct_ehci_hcd_init(u32 *hccr, u32 *hcor)
+{
+	int retval;
+	u32 val;
+	u32 addr;
+
+	dcgu_set_reset_switch(DCGU_HW_MODULE_USB_24, DCGU_SWITCH_ON);
+	dcgu_set_reset_switch(DCGU_HW_MODULE_USB_60, DCGU_SWITCH_ON);
+	dcgu_set_clk_switch(DCGU_HW_MODULE_USB_24, DCGU_SWITCH_ON);
+	dcgu_set_clk_switch(DCGU_HW_MODULE_USB_PLL, DCGU_SWITCH_ON);
+	dcgu_set_reset_switch(DCGU_HW_MODULE_USB_24, DCGU_SWITCH_OFF);
+
+	/* Wait until (DCGU_USBPHY_STAT == 7) */
+	addr = DCGU_USBPHY_STAT(DCGU_BASE);
+	val = reg_read(addr);
+	while (val != 7)
+		val = reg_read(addr);
+
+	dcgu_set_clk_switch(DCGU_HW_MODULE_USB_60, DCGU_SWITCH_ON);
+	dcgu_set_reset_switch(DCGU_HW_MODULE_USB_60, DCGU_SWITCH_OFF);
+
+	retval = scc_reset(SCC_USB_RW, 0);
+	if (retval) {
+		printf("scc_reset(SCC_USB_RW, 0) returned: 0x%x\n", retval);
+		return retval;
+	} else {
+		retval = scc_reset(SCC_CPU1_SPDMA_RW, 0);
+		if (retval) {
+			printf("scc_reset(SCC_CPU1_SPDMA_RW, 0) returned: 0x%x\n",
+			       retval);
+			return retval;
+		}
+	}
+
+	if (!retval) {
+		/*
+		 * For the AGU bypass, where the  SCC client provides full
+		 * physical address
+		 */
+		scc_set_usb_address_generation_mode(1);
+		scc_setup_dma(SCC_USB_RW, BCU_USB_BUFFER_1, DMA_LINEAR,
+			      USE_NO_FH, DMA_READ, 0);
+		scc_setup_dma(SCC_CPU1_SPDMA_RW, BCU_USB_BUFFER_1, DMA_LINEAR,
+			      USE_NO_FH, DMA_WRITE, 0);
+		scc_setup_dma(SCC_USB_RW, BCU_USB_BUFFER_0, DMA_LINEAR,
+			      USE_NO_FH, DMA_WRITE, 0);
+		scc_setup_dma(SCC_CPU1_SPDMA_RW, BCU_USB_BUFFER_0, DMA_LINEAR,
+			      USE_NO_FH, DMA_READ, 0);
+
+		/* Enable memory interface */
+		scc_enable(SCC_USB_RW, 1);
+
+		/* Start (start_cmd=0) DMAs */
+		scc_dma_cmd(SCC_USB_RW, DMA_START, 0, DMA_READ);
+		scc_dma_cmd(SCC_USB_RW, DMA_START, 0, DMA_WRITE);
+	} else {
+		printf("Cannot configure USB memory channel.\n");
+		printf("USB can not access RAM. SCC configuration failed.\n");
+		return retval;
+	}
+
+	/* Wait a short while */
+	udelay(300000);
+
+	reg_write(USBH_BURSTSIZE(USBH_BASE), 0x00001c1c);
+
+	/* Set EHCI structures and DATA in RAM */
+	reg_write(USBH_USBHMISC(USBH_BASE), 0x00840003);
+	/* Set USBMODE to bigendian and set host mode */
+	reg_write(USBH_USBMODE(USBH_BASE), 0x00000007);
+
+	/*
+	 * USBH_BURSTSIZE MUST EQUAL 0x00001c1c in order for
+	 * 512 byte USB transfers on the bulk pipe to work properly.
+	 * Set USBH_BURSTSIZE to 0x00001c1c
+	 */
+	reg_write(USBH_BURSTSIZE(USBH_BASE), 0x00001c1c);
+
+	/* Insert access register addresses */
+	*hccr = REG_GLOBAL_START_ADDR + USBH_CAPLENGTH(USBH_BASE);
+	*hcor = REG_GLOBAL_START_ADDR + USBH_USBCMD(USBH_BASE);
+
+	return 0;
+}
diff -Naur u-boot-2009.01/board/micronas/vct/gpio.c u-boot/board/micronas/vct/gpio.c
--- u-boot-2009.01/board/micronas/vct/gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/gpio.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,88 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include "vct.h"
+
+/*
+ * Find out to which of the 2 gpio modules the pin specified in the
+ * argument belongs:
+ * GPIO_MODULE yields 0 for pins  0 to 31,
+ *                    1 for pins 32 to 63
+ */
+#define GPIO_MODULE(pin)	((pin) >> 5)
+
+/*
+ * Bit position within a 32-bit peripheral register (where every
+ * bit is one bitslice)
+ */
+#define MASK(pin)		(1 << ((pin) & 0x1F))
+#define BASE_ADDR(mod)		module_base[mod]
+
+/*
+ * Lookup table for transforming gpio module number 0 to 2 to
+ * address offsets
+ */
+static u32 module_base[] = {
+	GPIO1_BASE,
+	GPIO2_BASE
+};
+
+static void clrsetbits(u32 addr, u32 and_mask, u32 or_mask)
+{
+	reg_write(addr, (reg_read(addr) & ~and_mask) | or_mask);
+}
+
+int vct_gpio_dir(int pin, int dir)
+{
+	u32 gpio_base;
+
+	gpio_base = BASE_ADDR(GPIO_MODULE(pin));
+
+	if (dir == 0)
+		clrsetbits(GPIO_SWPORTA_DDR(gpio_base), MASK(pin), 0);
+	else
+		clrsetbits(GPIO_SWPORTA_DDR(gpio_base), 0, MASK(pin));
+
+	return 0;
+}
+
+void vct_gpio_set(int pin, int val)
+{
+	u32 gpio_base;
+
+	gpio_base = BASE_ADDR(GPIO_MODULE(pin));
+
+	if (val == 0)
+		clrsetbits(GPIO_SWPORTA_DR(gpio_base), MASK(pin), 0);
+	else
+		clrsetbits(GPIO_SWPORTA_DR(gpio_base), 0, MASK(pin));
+}
+
+int vct_gpio_get(int pin)
+{
+	u32 gpio_base;
+	u32 value;
+
+	gpio_base = BASE_ADDR(GPIO_MODULE(pin));
+	value = reg_read(GPIO_EXT_PORTA(gpio_base));
+
+	return ((value & MASK(pin)) ? 1 : 0);
+}
diff -Naur u-boot-2009.01/board/micronas/vct/Makefile u-boot/board/micronas/vct/Makefile
--- u-boot-2009.01/board/micronas/vct/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,57 @@
+#
+# (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS-y := $(BOARD).o
+COBJS-y += ebi.o
+COBJS-$(CONFIG_VCT_NOR) += ebi_nor_flash.o
+COBJS-$(CONFIG_VCT_ONENAND) += ebi_onenand.o
+COBJS-$(CONFIG_DRIVER_SMC911X) += ebi_smc911x.o smc_eeprom.o
+COBJS-y += gpio.o
+COBJS-y += top.o
+COBJS-$(CONFIG_USB_EHCI_VCT) += dcgu.o ehci.o scc.o
+
+COBJS	:= $(sort $(COBJS-y))
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/micronas/vct/scc.c u-boot/board/micronas/vct/scc.c
--- u-boot-2009.01/board/micronas/vct/scc.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/scc.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,669 @@
+/*
+ * (C) Copyright 2009 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/errno.h>
+
+#include "vct.h"
+
+/*
+ * List of statically defined buffers per SCC.
+ * The first entry in the table is the number of fixed buffers
+ * followed by the list of buffer IDs
+ */
+static u32 buffer_list_0[] = { 6, 120, 121, 122, 123, 139, 140 };
+static u32 buffer_list_1[] = { 6, 120, 121, 122, 123, 139, 140 };
+static u32 buffer_list_2[] = { 5, 124, 125, 126, 139, 140 };
+static u32 buffer_list_3[] = { 5, 124, 125, 126, 139, 140 };
+static u32 buffer_list_4[] = { 5, 124, 125, 126, 139, 140 };
+static u32 buffer_list_5[] = { 3, 127, 139, 140 };
+static u32 buffer_list_6[] = { 3, 127, 139, 140 };
+static u32 buffer_list_7[] = { 6, 128, 129, 130, 131, 139, 140 };
+static u32 buffer_list_8[] = { 6, 128, 129, 130, 131, 139, 140 };
+static u32 buffer_list_9[] = { 5, 124, 125, 126, 139, 140 };
+static u32 buffer_list_10[] = { 5, 124, 125, 126, 139, 140 };
+static u32 buffer_list_11[] = { 5, 124, 125, 126, 139, 140 };
+static u32 buffer_list_12[] = { 6, 132, 133, 134, 135, 139, 140 };
+static u32 buffer_list_13[] = { 6, 132, 133, 134, 135, 139, 140 };
+static u32 buffer_list_14[] = { 4, 137, 138, 139, 140 };
+static u32 buffer_list_15[] = { 6, 136, 136, 137, 138, 139, 140 };
+
+/** Issue#7674 (new) - DP/DVP buffer assignment */
+static u32 buffer_list_16[] = { 6, 106, 108, 109, 107, 139, 140 };
+static u32 buffer_list_17[] = { 6, 106, 110, 107, 111, 139, 140 };
+static u32 buffer_list_18[] = { 6, 106, 113, 107, 114, 139, 140 };
+static u32 buffer_list_19[] = { 3, 112, 139, 140 };
+static u32 buffer_list_20[] = { 35, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+				13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+				79, 80, 81, 82, 83, 84, 85, 86, 139, 140 };
+static u32 buffer_list_21[] = { 27, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+				13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+				139, 140 };
+static u32 buffer_list_22[] = { 81, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+				13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+				25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
+				37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
+				49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
+				61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
+				73, 74, 75, 76, 77, 78, 139, 140 };
+static u32 buffer_list_23[] = { 29, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+				13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+				88, 89, 139, 140 };
+static u32 buffer_list_24[] = { 6, 90, 91, 92, 93, 139, 140 };
+static u32 buffer_list_25[] = { 18, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
+				100, 101, 102, 103, 104, 105, 139, 140 };
+static u32 buffer_list_26[] = { 5, 94, 95, 96, 139, 140 };
+static u32 buffer_list_27[] = { 5, 97, 98, 99, 139, 140 };
+static u32 buffer_list_28[] = { 5, 100, 101, 102, 139, 140 };
+static u32 buffer_list_29[] = { 5, 103, 104, 105, 139, 140 };
+static u32 buffer_list_30[] = { 10, 108, 109, 110, 111, 113, 114, 116, 117,
+				139, 140 };
+static u32 buffer_list_31[] = { 13, 106, 107, 108, 109, 110, 111, 113, 114,
+				115, 116, 117, 139, 140 };
+static u32 buffer_list_32[] = { 13, 106, 107, 108, 109, 110, 111, 113, 114,
+				115, 116, 117, 139, 140 };
+static u32 buffer_list_33[] = { 27, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+				13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+				139, 140 };
+static u32 buffer_list_34[] = { 27, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+				13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+				139, 140 };
+static u32 buffer_list_35[] = { 28, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+				13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+				87, 139, 140 };
+static u32 buffer_list_36[] = { 28, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+				13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+				87, 139, 140 };
+static u32 buffer_list_37[] = { 27, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+				13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+				139, 140 };
+static u32 buffer_list_38[] = { 29, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+				13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+				118, 119, 139, 140 };
+static u32 buffer_list_39[] = { 91, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
+				13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+				25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
+				37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
+				49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
+				61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
+				73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,
+				85, 86, 118, 119, 139, 140 };
+static u32 buffer_list_40[] = { 0 };
+
+/*
+ * List of statically defined vcid.csize values.
+ * The first entry in the table is the number of possible csize values
+ * followed by the list of data path values in bits.
+ */
+static u32 csize_list_0[] = { 2, 0, 1 };
+static u32 csize_list_1[] = { 2, 0, 1 };
+static u32 csize_list_2[] = { 1, 1 };
+static u32 csize_list_3[] = { 1, 1 };
+static u32 csize_list_4[] = { 1, 1 };
+static u32 csize_list_5[] = { 1, 0 };
+static u32 csize_list_6[] = { 1, 0 };
+static u32 csize_list_7[] = { 1, 1 };
+static u32 csize_list_8[] = { 1, 1 };
+static u32 csize_list_9[] = { 1, 1 };
+static u32 csize_list_10[] = { 1, 1 };
+static u32 csize_list_11[] = { 1, 1 };
+static u32 csize_list_12[] = { 1, 1 };
+static u32 csize_list_13[] = { 1, 1 };
+static u32 csize_list_14[] = { 1, 2 };
+static u32 csize_list_15[] = { 1, 4 };
+static u32 csize_list_16[] = { 3, 0, 1, 2 };
+static u32 csize_list_17[] = { 3, 0, 1, 2 };
+static u32 csize_list_18[] = { 3, 0, 1, 2 };
+static u32 csize_list_19[] = { 1, 2 };
+static u32 csize_list_20[] = { 1, 0 };
+static u32 csize_list_21[] = { 1, 0 };
+static u32 csize_list_22[] = { 1, 2 };
+static u32 csize_list_23[] = { 1, 3 };
+static u32 csize_list_24[] = { 1, 3 };
+static u32 csize_list_25[] = { 1, 3 };
+static u32 csize_list_26[] = { 1, 0 };
+static u32 csize_list_27[] = { 1, 0 };
+static u32 csize_list_28[] = { 1, 0 };
+static u32 csize_list_29[] = { 1, 0 };
+static u32 csize_list_30[] = { 1, 2 };
+static u32 csize_list_31[] = { 1, 2 };
+static u32 csize_list_32[] = { 1, 2 };
+static u32 csize_list_33[] = { 1, 2 };
+static u32 csize_list_34[] = { 1, 2 };
+static u32 csize_list_35[] = { 1, 2 };
+static u32 csize_list_36[] = { 1, 2 };
+static u32 csize_list_37[] = { 2, 0, 1 };
+static u32 csize_list_38[] = { 1, 2 };
+static u32 csize_list_39[] = { 1, 3 };
+static u32 csize_list_40[] = { 1, 3 };
+
+/*
+ * SCC_Configuration table
+ */
+static const struct scc_descriptor scc_descriptor_table[] = {
+/* scn  scc_name  profile  SCC  scc_id  mci_id  rd  wr   m   p fh  si cfg sta */
+	{"fe_", "fe_3dcomb_wr", STRM_P, SCC0_BASE, 0, 0, 0, 4, 1, 1, 0, 0, 0, 1,
+	 buffer_list_0, csize_list_0},
+	{"fe_", "fe_3dcomb_rd", STRM_P, SCC1_BASE, 1, 18, 4, 0, 1, 1, 0, 1, 0,
+	 1, buffer_list_1, csize_list_1},
+	{"di_", "di_tnr_wr", STRM_P, SCC2_BASE, 2, 1, 0, 3, 1, 1, 0, 2, 0, 1,
+	 buffer_list_2, csize_list_2},
+	{"di_", "di_tnr_field_rd", STRM_P, SCC3_BASE, 3, 19, 3, 0, 1, 1, 0, 3,
+	 0, 1, buffer_list_3, csize_list_3},
+	{"di_", "di_tnr_frame_rd", STRM_P, SCC4_BASE, 4, 20, 3, 0, 1, 1, 0, 4,
+	 0, 1, buffer_list_4, csize_list_4},
+	{"di_", "di_mval_wr", STRM_P, SCC5_BASE, 5, 2, 0, 1, 1, 1, 0, 5, 0, 1,
+	 buffer_list_5, csize_list_5},
+	{"di_", "di_mval_rd", STRM_P, SCC6_BASE, 6, 21, 1, 0, 1, 1, 0, 6, 0, 1,
+	 buffer_list_6, csize_list_6},
+	{"rc_", "rc_frame_wr", STRM_P, SCC7_BASE, 7, 3, 0, 4, 1, 1, 0, 7, 0, 1,
+	 buffer_list_7, csize_list_7},
+	{"rc_", "rc_frame0_rd", STRM_P, SCC8_BASE, 8, 22, 4, 0, 1, 1, 0, 8, 0,
+	 1, buffer_list_8, csize_list_8},
+	{"opt", "opt_field0_rd", STRM_P, SCC9_BASE, 9, 23, 3, 0, 1, 1, 0, 9, 0,
+	 1, buffer_list_9, csize_list_9},
+	{"opt", "opt_field1_rd", STRM_P, SCC10_BASE, 10, 24, 3, 0, 1, 1, 0, 10,
+	 0, 1, buffer_list_10, csize_list_10},
+	{"opt", "opt_field2_rd", STRM_P, SCC11_BASE, 11, 25, 3, 0, 1, 1, 0, 11,
+	 0, 1, buffer_list_11, csize_list_11},
+	{"pip", "pip_frame_wr", STRM_P, SCC12_BASE, 12, 4, 0, 4, 1, 1, 0, 12, 0,
+	 1, buffer_list_12, csize_list_12},
+	{"pip", "pip_frame_rd", STRM_P, SCC13_BASE, 13, 26, 4, 0, 1, 1, 0, 13,
+	 0, 1, buffer_list_13, csize_list_13},
+	{"dp_", "dp_agpu_rd", STRM_P, SCC14_BASE, 14, 27, 2, 0, 2, 1, 0, 14, 0,
+	 1, buffer_list_14, csize_list_14},
+	{"ewa", "ewarp_rw", SRMD, SCC15_BASE, 15, 11, 1, 1, 0, 0, 0, -1, 0, 0,
+	 buffer_list_15, csize_list_15},
+	{"dp_", "dp_osd_rd", STRM_P, SCC16_BASE, 16, 28, 3, 0, 2, 1, 0, 15, 0,
+	 1, buffer_list_16, csize_list_16},
+	{"dp_", "dp_graphic_rd", STRM_P, SCC17_BASE, 17, 29, 3, 0, 2, 1, 0, 16,
+	 0, 1, buffer_list_17, csize_list_17},
+	{"dvp", "dvp_osd_rd", STRM_P, SCC18_BASE, 18, 30, 2, 0, 2, 1, 0, 17, 0,
+	 1, buffer_list_18, csize_list_18},
+	{"dvp", "dvp_vbi_rd", STRM_D, SCC19_BASE, 19, 31, 1, 0, 0, 1, 0, -1, 0,
+	 0, buffer_list_19, csize_list_19},
+	{"tsi", "tsio_wr", STRM_P, SCC20_BASE, 20, 5, 0, 8, 2, 1, 1, -1, 0, 0,
+	 buffer_list_20, csize_list_20},
+	{"tsi", "tsio_rd", STRM_P, SCC21_BASE, 21, 32, 4, 0, 2, 1, 1, -1, 0, 0,
+	 buffer_list_21, csize_list_21},
+	{"tsd", "tsd_wr", SRMD, SCC22_BASE, 22, 6, 0, 64, 0, 0, 1, -1, 0, 0,
+	 buffer_list_22, csize_list_22},
+	{"vd_", "vd_ud_st_rw", SRMD, SCC23_BASE, 23, 12, 2, 2, 0, 0, 1, -1, 0,
+	 0, buffer_list_23, csize_list_23},
+	{"vd_", "vd_frr_rd", SRMD, SCC24_BASE, 24, 33, 4, 0, 0, 0, 0, -1, 0, 0,
+	 buffer_list_24, csize_list_24},
+	{"vd_", "vd_frw_disp_wr", SRMD, SCC25_BASE, 25, 7, 0, 16, 0, 0, 0, -1,
+	 0, 0, buffer_list_25, csize_list_25},
+	{"mr_", "mr_vd_m_y_rd", STRM_P, SCC26_BASE, 26, 34, 3, 0, 2, 1, 0, 18,
+	 0, 1, buffer_list_26, csize_list_26},
+	{"mr_", "mr_vd_m_c_rd", STRM_P, SCC27_BASE, 27, 35, 3, 0, 2, 1, 0, 19,
+	 0, 1, buffer_list_27, csize_list_27},
+	{"mr_", "mr_vd_s_y_rd", STRM_P, SCC28_BASE, 28, 36, 3, 0, 2, 1, 0, 20,
+	 0, 1, buffer_list_28, csize_list_28},
+	{"mr_", "mr_vd_s_c_rd", STRM_P, SCC29_BASE, 29, 37, 3, 0, 2, 1, 0, 21,
+	 0, 1, buffer_list_29, csize_list_29},
+	{"ga_", "ga_wr", STRM_P, SCC30_BASE, 30, 8, 0, 1, 1, 1, 0, -1, 1, 1,
+	 buffer_list_30, csize_list_30},
+	{"ga_", "ga_src1_rd", STRM_P, SCC31_BASE, 31, 38, 1, 0, 1, 1, 0, -1, 1,
+	 1, buffer_list_31, csize_list_31},
+	{"ga_", "ga_src2_rd", STRM_P, SCC32_BASE, 32, 39, 1, 0, 1, 1, 0, -1, 1,
+	 1, buffer_list_32, csize_list_32},
+	{"ad_", "ad_rd", STRM_D, SCC33_BASE, 33, 40, 2, 0, 0, 1, 1, -1, 0, 0,
+	 buffer_list_33, csize_list_33},
+	{"ad_", "ad_wr", STRM_D, SCC34_BASE, 34, 9, 0, 3, 0, 1, 1, -1, 0, 0,
+	 buffer_list_34, csize_list_34},
+	{"abp", "abp_rd", STRM_D, SCC35_BASE, 35, 41, 5, 0, 0, 1, 1, -1, 0, 0,
+	 buffer_list_35, csize_list_35},
+	{"abp", "abp_wr", STRM_D, SCC36_BASE, 36, 10, 0, 3, 0, 1, 1, -1, 0, 0,
+	 buffer_list_36, csize_list_36},
+	{"ebi", "ebi_rw", STRM_P, SCC37_BASE, 37, 13, 4, 4, 2, 1, 1, -1, 0, 0,
+	 buffer_list_37, csize_list_37},
+	{"usb", "usb_rw", SRMD, SCC38_BASE, 38, 14, 1, 1, 0, 0, 1, -1, 0, 0,
+	 buffer_list_38, csize_list_38},
+	{"cpu", "cpu1_spdma_rw", SRMD, SCC39_BASE, 39, 15, 1, 1, 0, 0, 1, -1, 0,
+	 0, buffer_list_39, csize_list_39},
+	{"cpu", "cpu1_bridge_rw", SRMD, SCC40_BASE, 40, 16, 0, 0, 0, 0, 0, -1,
+	 0, 0, buffer_list_40, csize_list_40},
+};
+
+/* DMA state structures for read and write channels for each SCC */
+
+static struct scc_dma_state scc_state_rd_0[] = { {-1} };
+static struct scc_dma_state scc_state_wr_0[] = { {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_rd_1[] = { {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_1[] = { {-1} };
+static struct scc_dma_state scc_state_rd_2[] = { {-1} };
+static struct scc_dma_state scc_state_wr_2[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_rd_3[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_3[] = { {-1} };
+static struct scc_dma_state scc_state_rd_4[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_4[] = { {-1} };
+static struct scc_dma_state scc_state_rd_5[] = { {-1} };
+static struct scc_dma_state scc_state_wr_5[] = { {0} };
+static struct scc_dma_state scc_state_rd_6[] = { {0} };
+static struct scc_dma_state scc_state_wr_6[] = { {-1} };
+static struct scc_dma_state scc_state_rd_7[] = { {-1} };
+static struct scc_dma_state scc_state_wr_7[] = { {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_rd_8[] = { {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_8[] = { {-1} };
+static struct scc_dma_state scc_state_rd_9[] = { {0}, {0}, {0}, };
+static struct scc_dma_state scc_state_wr_9[] = { {-1} };
+static struct scc_dma_state scc_state_rd_10[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_10[] = { {-1} };
+static struct scc_dma_state scc_state_rd_11[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_11[] = { {-1} };
+static struct scc_dma_state scc_state_rd_12[] = { {-1} };
+static struct scc_dma_state scc_state_wr_12[] = { {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_rd_13[] = { {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_13[] = { {-1} };
+static struct scc_dma_state scc_state_rd_14[] = { {0}, {0} };
+static struct scc_dma_state scc_state_wr_14[] = { {-1} };
+static struct scc_dma_state scc_state_rd_15[] = { {0} };
+static struct scc_dma_state scc_state_wr_15[] = { {0} };
+static struct scc_dma_state scc_state_rd_16[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_16[] = { {-1} };
+static struct scc_dma_state scc_state_rd_17[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_17[] = { {-1} };
+static struct scc_dma_state scc_state_rd_18[] = { {0}, {0} };
+static struct scc_dma_state scc_state_wr_18[] = { {-1} };
+static struct scc_dma_state scc_state_rd_19[] = { {0} };
+static struct scc_dma_state scc_state_wr_19[] = { {-1} };
+static struct scc_dma_state scc_state_rd_20[] = { {-1} };
+static struct scc_dma_state scc_state_wr_20[] = {
+	{0}, {0}, {0}, {0}, {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_rd_21[] = { {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_21[] = { {-1} };
+static struct scc_dma_state scc_state_rd_22[] = { {-1} };
+static struct scc_dma_state scc_state_wr_22[] = {
+	{0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0},
+	{0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0},
+	{0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0},
+	{0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0},
+	{0}, {0}, {0}, {0}, {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_rd_23[] = { {0}, {0} };
+static struct scc_dma_state scc_state_wr_23[] = { {0}, {0} };
+static struct scc_dma_state scc_state_rd_24[] = { {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_24[] = { {-1} };
+static struct scc_dma_state scc_state_rd_25[] = { {-1} };
+static struct scc_dma_state scc_state_wr_25[] = {
+	{0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0},
+	{0}, {0} };
+static struct scc_dma_state scc_state_rd_26[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_26[] = { {-1} };
+static struct scc_dma_state scc_state_rd_27[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_27[] = { {-1} };
+static struct scc_dma_state scc_state_rd_28[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_28[] = { {-1} };
+static struct scc_dma_state scc_state_rd_29[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_29[] = { {-1} };
+static struct scc_dma_state scc_state_rd_30[] = { {-1} };
+static struct scc_dma_state scc_state_wr_30[] = { {0} };
+static struct scc_dma_state scc_state_rd_31[] = { {0} };
+static struct scc_dma_state scc_state_wr_31[] = { {-1} };
+static struct scc_dma_state scc_state_rd_32[] = { {0} };
+static struct scc_dma_state scc_state_wr_32[] = { {-1} };
+static struct scc_dma_state scc_state_rd_33[] = { {0}, {0} };
+static struct scc_dma_state scc_state_wr_33[] = { {-1} };
+static struct scc_dma_state scc_state_rd_34[] = { {-1} };
+static struct scc_dma_state scc_state_wr_34[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_rd_35[] = { {0}, {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_35[] = { {-1} };
+static struct scc_dma_state scc_state_rd_36[] = { {-1} };
+static struct scc_dma_state scc_state_wr_36[] = { {0}, {0}, {0} };
+static struct scc_dma_state scc_state_rd_37[] = { {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_wr_37[] = { {0}, {0}, {0}, {0} };
+static struct scc_dma_state scc_state_rd_38[] = { {0} };
+static struct scc_dma_state scc_state_wr_38[] = { {0} };
+static struct scc_dma_state scc_state_rd_39[] = { {0} };
+static struct scc_dma_state scc_state_wr_39[] = { {0} };
+static struct scc_dma_state scc_state_rd_40[] = { {-1} };
+static struct scc_dma_state scc_state_wr_40[] = { {-1} };
+
+/* DMA state references to access from the driver */
+static struct scc_dma_state *scc_state_rd[] = {
+	scc_state_rd_0,
+	scc_state_rd_1,
+	scc_state_rd_2,
+	scc_state_rd_3,
+	scc_state_rd_4,
+	scc_state_rd_5,
+	scc_state_rd_6,
+	scc_state_rd_7,
+	scc_state_rd_8,
+	scc_state_rd_9,
+	scc_state_rd_10,
+	scc_state_rd_11,
+	scc_state_rd_12,
+	scc_state_rd_13,
+	scc_state_rd_14,
+	scc_state_rd_15,
+	scc_state_rd_16,
+	scc_state_rd_17,
+	scc_state_rd_18,
+	scc_state_rd_19,
+	scc_state_rd_20,
+	scc_state_rd_21,
+	scc_state_rd_22,
+	scc_state_rd_23,
+	scc_state_rd_24,
+	scc_state_rd_25,
+	scc_state_rd_26,
+	scc_state_rd_27,
+	scc_state_rd_28,
+	scc_state_rd_29,
+	scc_state_rd_30,
+	scc_state_rd_31,
+	scc_state_rd_32,
+	scc_state_rd_33,
+	scc_state_rd_34,
+	scc_state_rd_35,
+	scc_state_rd_36,
+	scc_state_rd_37,
+	scc_state_rd_38,
+	scc_state_rd_39,
+	scc_state_rd_40,
+};
+
+static struct scc_dma_state *scc_state_wr[] = {
+	scc_state_wr_0,
+	scc_state_wr_1,
+	scc_state_wr_2,
+	scc_state_wr_3,
+	scc_state_wr_4,
+	scc_state_wr_5,
+	scc_state_wr_6,
+	scc_state_wr_7,
+	scc_state_wr_8,
+	scc_state_wr_9,
+	scc_state_wr_10,
+	scc_state_wr_11,
+	scc_state_wr_12,
+	scc_state_wr_13,
+	scc_state_wr_14,
+	scc_state_wr_15,
+	scc_state_wr_16,
+	scc_state_wr_17,
+	scc_state_wr_18,
+	scc_state_wr_19,
+	scc_state_wr_20,
+	scc_state_wr_21,
+	scc_state_wr_22,
+	scc_state_wr_23,
+	scc_state_wr_24,
+	scc_state_wr_25,
+	scc_state_wr_26,
+	scc_state_wr_27,
+	scc_state_wr_28,
+	scc_state_wr_29,
+	scc_state_wr_30,
+	scc_state_wr_31,
+	scc_state_wr_32,
+	scc_state_wr_33,
+	scc_state_wr_34,
+	scc_state_wr_35,
+	scc_state_wr_36,
+	scc_state_wr_37,
+	scc_state_wr_38,
+	scc_state_wr_39,
+	scc_state_wr_40,
+};
+
+static u32 scc_takeover_mode = SCC_TO_IMMEDIATE;
+
+/* Change mode of the SPDMA for given direction */
+static u32 scc_agu_mode_sp = AGU_BYPASS;
+
+/* Change mode of the USB for given direction */
+static u32 scc_agu_mode_usb = AGU_BYPASS;
+
+static union scc_softwareconfiguration scc_software_configuration[SCC_MAX];
+
+static u32 dma_fsm[4][4] = {
+	/* DMA_CMD_RESET  DMA_CMD_SETUP    DMA_CMD_START    DMA_CMD_STOP */
+	/* DMA_STATE_RESET */
+	{DMA_STATE_RESET, DMA_STATE_SETUP, DMA_STATE_ERROR, DMA_STATE_ERROR},
+	/* DMA_STATE_SETUP */
+	{DMA_STATE_RESET, DMA_STATE_SETUP, DMA_STATE_START, DMA_STATE_SETUP},
+	/* DMA_STATE_START */
+	{DMA_STATE_RESET, DMA_STATE_ERROR, DMA_STATE_START, DMA_STATE_SETUP},
+	/* DMA_STATE_ERROR */
+	{DMA_STATE_RESET, DMA_STATE_ERROR, DMA_STATE_ERROR, DMA_STATE_ERROR},
+};
+
+static void dma_state_process(struct scc_dma_state *dma_state, u32 cmd)
+{
+	dma_state->dma_status = dma_fsm[dma_state->dma_status][cmd];
+	dma_state->dma_cmd = cmd;
+}
+
+static void dma_state_process_dma_command(struct scc_dma_state *dma_state,
+					  u32 dma_cmd)
+{
+	dma_state->dma_cmd = dma_cmd;
+	switch (dma_cmd) {
+	case DMA_START:
+	case DMA_START_FH_RESET:
+		dma_state_process(dma_state, DMA_CMD_START);
+		break;
+	case DMA_STOP:
+		dma_state_process(dma_state, DMA_CMD_STOP);
+		break;
+	default:
+		break;
+	}
+}
+
+static void scc_takeover_dma(enum scc_id id, u32 dma_id, u32 drs)
+{
+	union scc_cmd dma_cmd;
+
+	dma_cmd.reg = 0;
+
+	/* Prepare the takeover for the DMA channel */
+	dma_cmd.bits.action = DMA_TAKEOVER;
+	dma_cmd.bits.id = dma_id;
+	dma_cmd.bits.rid = TO_DMA_CFG;	/* this is DMA_CFG register takeover */
+	if (drs == DMA_WRITE)
+		dma_cmd.bits.drs = DMA_WRITE;
+
+	reg_write(SCC_CMD(scc_descriptor_table[id].base_address), dma_cmd.reg);
+}
+
+int scc_dma_cmd(enum scc_id id, u32 cmd, u32 dma_id, u32 drs)
+{
+	union scc_cmd dma_cmd;
+	struct scc_dma_state *dma_state;
+
+	if ((id >= SCC_MAX) || (id < 0))
+		return -EINVAL;
+
+	dma_cmd.reg = 0;
+
+	/* Prepare the takeover for the DMA channel */
+	dma_cmd.bits.action = cmd;
+	dma_cmd.bits.id = dma_id;
+	if (drs == DMA_WRITE) {
+		dma_cmd.bits.drs = DMA_WRITE;
+		dma_state = &scc_state_wr[id][dma_id];
+	} else {
+		dma_state = &scc_state_rd[id][dma_id];
+	}
+
+	dma_state->scc_id = id;
+	dma_state->dma_id = dma_id;
+	dma_state_process_dma_command(dma_state, cmd);
+
+	reg_write(SCC_CMD(scc_descriptor_table[id].base_address), dma_cmd.reg);
+
+	return 0;
+}
+
+int scc_set_usb_address_generation_mode(u32 agu_mode)
+{
+	if (AGU_ACTIVE == agu_mode) {
+		/* Ensure both DMAs are stopped */
+		scc_dma_cmd(SCC_USB_RW, DMA_STOP, 0, DMA_WRITE);
+		scc_dma_cmd(SCC_USB_RW, DMA_STOP, 0, DMA_READ);
+	} else {
+		agu_mode = AGU_BYPASS;
+	}
+
+	scc_agu_mode_usb = agu_mode;
+
+	return 0;
+}
+
+int scc_setup_dma(enum scc_id id, u32 buffer_tag,
+		  u32 type, u32 fh_mode, u32 drs, u32 dma_id)
+{
+	struct scc_dma_state *dma_state;
+	int return_value = 0;
+	union scc_dma_cfg dma_cfg;
+	u32 *buffer_tag_list = scc_descriptor_table[id].buffer_tag_list;
+	u32 tag_count, t, t_valid;
+
+	if ((id >= SCC_MAX) || (id < 0))
+		return -EINVAL;
+
+	/* if the register is only configured by hw, cannot write! */
+	if (1 == scc_descriptor_table[id].hw_dma_cfg)
+		return -EACCES;
+
+	if (DMA_WRITE == drs) {
+		if (dma_id >= scc_descriptor_table[id].p_dma_channels_wr)
+			return -EINVAL;
+		dma_state = &scc_state_wr[id][dma_id];
+	} else {
+		if (dma_id >= scc_descriptor_table[id].p_dma_channels_rd)
+			return -EINVAL;
+		dma_state = &scc_state_rd[id][dma_id];
+	}
+
+	/* Compose the DMA configuration register */
+	tag_count = buffer_tag_list[0];
+	t_valid = 0;
+	for (t = 1; t <= tag_count; t++) {
+		if (buffer_tag == buffer_tag_list[t]) {
+			/* Tag found - validate */
+			t_valid = 1;
+			break;
+		}
+	}
+
+	if (!t_valid)
+		return -EACCES;
+
+	/*
+	 * Read the register first -- two functions write into the register
+	 * it does not make sense to read the DMA config back, because there
+	 * are two register configuration sets (drs)
+	 */
+	dma_cfg.reg = 0;
+	dma_cfg.bits.buffer_id = buffer_tag;
+	dma_state_process(dma_state, DMA_CMD_SETUP);
+
+	/*
+	 * This is Packet CFG set select - usable for TSIO, EBI and those SCCs
+	 * which habe 2 packet configs
+	 */
+	dma_cfg.bits.packet_cfg_id =
+		scc_software_configuration[id].bits.packet_select;
+
+	if (type == DMA_CYCLIC)
+		dma_cfg.bits.buffer_type = 1;
+	else
+		dma_cfg.bits.buffer_type = 0;
+
+	if (fh_mode == USE_FH)
+		dma_cfg.bits.fh_mode = 1;
+	else
+		dma_cfg.bits.fh_mode = 0;
+
+	if (id == SCC_CPU1_SPDMA_RW)
+		dma_cfg.bits.agu_mode = scc_agu_mode_sp;
+
+	if (id == SCC_USB_RW)
+		dma_cfg.bits.agu_mode = scc_agu_mode_usb;
+
+	reg_write(SCC_DMA_CFG(scc_descriptor_table[id].base_address),
+		  dma_cfg.reg);
+
+	/* The DMA_CFG needs a takeover! */
+	if (SCC_TO_IMMEDIATE == scc_takeover_mode)
+		scc_takeover_dma(id, dma_id, drs);
+
+	/* if (buffer_tag is not used) */
+	dma_state->buffer_tag = buffer_tag;
+
+	dma_state->scc_id = id;
+	dma_state->dma_id = dma_id;
+
+	return return_value;
+}
+
+int scc_enable(enum scc_id id, u32 value)
+{
+	if ((id >= SCC_MAX) || (id < 0))
+		return -EINVAL;
+
+	if (value == 0) {
+		scc_software_configuration[id].bits.enable_status = 0;
+	} else {
+		value = 1;
+		scc_software_configuration[id].bits.enable_status = 1;
+	}
+	reg_write(SCC_ENABLE(scc_descriptor_table[id].base_address), value);
+
+	return 0;
+}
+
+static inline void ehb(void)
+{
+	__asm__ __volatile__(
+		"	.set	mips32r2	\n"
+		"	ehb			\n"
+		"	.set	mips0		\n");
+}
+
+int scc_reset(enum scc_id id, u32 value)
+{
+	if ((id >= SCC_MAX) || (id < 0))
+		return -EINVAL;
+
+	/* Invert value to the strait logic from the negative hardware logic */
+	if (value == 0)
+		value = 1;
+	else
+		value = 0;
+
+	/* Write the value to the register */
+	reg_write(SCC_RESET(scc_descriptor_table[id].base_address), value);
+
+	/* sync flush */
+	asm("sync");	/* request bus write queue flush */
+	ehb();		/* wait until previous bus commit instr has finished */
+	asm("nop");	/* wait for flush to occur */
+	asm("nop");	/* wait for flush to occur */
+
+	udelay(100);
+
+	return 0;
+}
diff -Naur u-boot-2009.01/board/micronas/vct/scc.h u-boot/board/micronas/vct/scc.h
--- u-boot-2009.01/board/micronas/vct/scc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/scc.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,205 @@
+/*
+ * (C) Copyright 2009 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCC_H
+#define _SCC_H
+
+#define DMA_READ		0	/* SCC read  DMA		*/
+#define DMA_WRITE		1	/* SCC write DMA		*/
+
+#define DMA_LINEAR		0	/* DMA linear buffer access method */
+#define DMA_CYCLIC		1	/* DMA cyclic buffer access method */
+
+#define DMA_START		0	/* DMA command - start DMA	*/
+#define DMA_STOP		1	/* DMA command - stop  DMA	*/
+#define DMA_START_FH_RESET	2	/* DMA command - start DMA reset FH */
+#define DMA_TAKEOVER		15	/* DMA command - commit the DMA conf */
+
+#define AGU_ACTIVE		0	/* enable AGU address calculation */
+#define AGU_BYPASS		1	/* set AGU to bypass mode	*/
+
+#define USE_NO_FH		0	/* order the DMA to not use FH	*/
+#define USE_FH			1	/* order the DMA to work with FH*/
+
+#define SCC_DBG_IDLE		0	/* DEBUG status (idle interfaces) */
+#define SCC_DBG_SYNC_RES	0x0001	/* synchronuous reset		*/
+
+#define SCC_TO_IMMEDIATE	1	/* takeover command issued immediately*/
+#define TO_DMA_CFG		2	/* takeover command for the DMA config*/
+
+#define DMA_CMD_RESET		0
+#define DMA_CMD_SETUP		1
+#define DMA_CMD_START		2
+#define DMA_CMD_STOP		3
+
+#define DMA_STATE_RESET		0
+#define DMA_STATE_SETUP		1
+#define DMA_STATE_START		2
+#define DMA_STATE_ERROR		3
+
+#define SRMD			0
+#define STRM_D			1
+#define STRM_P			2
+
+/*
+ * Slowest Monterey domain is DVP 27 MHz (324/27 = 12; 12*16 = 192 CPU clocks)
+ */
+#define RESET_TIME		2	/* cycle calc see in SCC_Reset	*/
+
+struct scc_descriptor {
+	char *pu_name;		/* PU identifier			*/
+	char *scc_instance;	/* SCC Name				*/
+	u32 profile;		/* SCC VCI_D profile			*/
+
+	u32 base_address;	/* base address of the SCC unit reg shell*/
+
+	/* SCS Interconnect configuration */
+	u32 p_scc_id;		/* instance number of SCC unit		*/
+	u32 p_mci_id;		/* memory channel ID			*/
+
+	/* DMA Registers configuration */
+	u32 p_dma_channels_rd;	/* Number of Read DMA channels		*/
+	u32 p_dma_channels_wr;	/* Number of Write DMA channels		*/
+
+	u32 p_dma_packet_desc;	/* Number of packet descriptors		*/
+	u32 p_dma_mci_desc;	/* Number of MCI_CFG Descriptors	*/
+
+	int use_fh;		/* the flag tells if SCC uses an FH	*/
+
+	int p_si2ocp_id;	/* instance number of SI2OCP unit	*/
+	int hw_dma_cfg;		/* HW or SW DMA config flag		*/
+	int hw_dma_start;	/* HW or SW DMA start/stop flag		*/
+
+	u32 *buffer_tag_list;	/* list of the buffer tags available	*/
+	u32 *csize_list;	/* list of the valid CSIZE values	*/
+};
+
+struct scc_dma_state {
+	u32 scc_id:8;		/* SCC id				*/
+	u32 dma_id:8;		/* DMA id, used for match with array idx*/
+	u32 buffer_tag:8;	/* mem buf tag, assigned to this DMA	*/
+	u32 dma_status:2;	/* state of DMA, of the DMA_STATE_ const*/
+	u32 dma_drs:2;		/* DMA dir, either DMA_READ or DMA_WRITE*/
+	u32 dma_cmd:4;		/* last executed command on this DMA	*/
+};
+
+union scc_cmd {
+	u32 reg;
+	struct {
+		u32 res1:19;	/* reserved				*/
+		u32 drs:1;	/* DMA Register Set			*/
+		u32 rid:2;	/* Register Identifier			*/
+		u32 id:6;	/* DMA Identifier			*/
+		u32 action:4;	/* DMA Command encoding			*/
+	} bits;
+};
+
+union scc_dma_cfg {
+	u32 reg;
+	struct {
+		u32 res1:17;		/* reserved			*/
+		u32 agu_mode:1;		/* AGU Mode			*/
+		u32 res2:1;		/* reserved			*/
+		u32 fh_mode:1;		/* Fifo Handler			*/
+		u32 buffer_type:1;	/* Defines type of mem buffers	*/
+		u32 mci_cfg_id:1;	/* MCI_CFG register selector	*/
+		u32 packet_cfg_id:1;	/* PACKET_CFG register selector	*/
+		u32 buffer_id:8;	/* DMA Buffer Identifier	*/
+	} bits;
+};
+
+union scc_debug {
+	u32 reg;
+	struct {
+		u32 res1:20;	/* reserved				*/
+		u32 arg:8;	/* SCC Debug Command Argument (#)	*/
+		u32 cmd:4;	/* SCC Debug Command Register		*/
+	} bits;
+};
+
+union scc_softwareconfiguration {
+	u32 reg;
+	struct {
+		u32 res1:28;		/* reserved			*/
+		u32 clock_status:1;	/* clock on/off			*/
+		u32 packet_select:1;	/* active SCC packet id		*/
+		u32 enable_status:1;	/* enabled [1/0]		*/
+		u32 active_status:1;	/* 1=active  0=reset		*/
+	} bits;
+};
+
+/*
+ * System on Chip Channel ID
+ */
+enum scc_id {
+	SCC_NULL = -1,		/* illegal SCC identifier		*/
+	SCC_FE_3DCOMB_WR,	/* SCC_FE_3DCOMB Write channel		*/
+	SCC_FE_3DCOMB_RD,	/* SCC_FE_3DCOMB Read channel		*/
+	SCC_DI_TNR_WR,		/* SCC_DI_TNR Write channel		*/
+	SCC_DI_TNR_FIELD_RD,	/* SCC_DI_TNR_FIELD Read channel	*/
+	SCC_DI_TNR_FRAME_RD,	/* SCC_DI_TNR_FRAME Read channel	*/
+	SCC_DI_MVAL_WR,		/* SCC_DI_MVAL Write channel		*/
+	SCC_DI_MVAL_RD,		/* SCC_DI_MVAL Read channel		*/
+	SCC_RC_FRAME_WR,	/* SCC_RC_FRAME Write channel		*/
+	SCC_RC_FRAME0_RD,	/* SCC_RC_FRAME0 Read channel		*/
+	SCC_OPT_FIELD0_RD,	/* SCC_OPT_FIELD0 Read channel		*/
+	SCC_OPT_FIELD1_RD,	/* SCC_OPT_FIELD1 Read channel		*/
+	SCC_OPT_FIELD2_RD,	/* SCC_OPT_FIELD2 Read channel		*/
+	SCC_PIP_FRAME_WR,	/* SCC_PIP_FRAME Write channel		*/
+	SCC_PIP_FRAME_RD,	/* SCC_PIP_FRAME Read channel		*/
+	SCC_DP_AGPU_RD,		/* SCC_DP_AGPU Read channel		*/
+	SCC_EWARP_RW,		/* SCC_EWARP Read/Write channel		*/
+	SCC_DP_OSD_RD,		/* SCC_DP_OSD Read channel		*/
+	SCC_DP_GRAPHIC_RD,	/* SCC_DP_GRAPHIC Read channel		*/
+	SCC_DVP_OSD_RD,		/* SCC_DVP_OSD Read channel		*/
+	SCC_DVP_VBI_RD,		/* SCC_DVP_VBI Read channel		*/
+	SCC_TSIO_WR,		/* SCC_TSIO Write channel		*/
+	SCC_TSIO_RD,		/* SCC_TSIO Read channel		*/
+	SCC_TSD_WR,		/* SCC_TSD Write channel		*/
+	SCC_VD_UD_ST_RW,	/* SCC_VD_UD_ST Read/Write channel	*/
+	SCC_VD_FRR_RD,		/* SCC_VD_FRR Read channel		*/
+	SCC_VD_FRW_DISP_WR,	/* SCC_VD_FRW_DISP Write channel	*/
+	SCC_MR_VD_M_Y_RD,	/* SCC_MR_VD_M_Y Read channel		*/
+	SCC_MR_VD_M_C_RD,	/* SCC_MR_VD_M_C Read channel		*/
+	SCC_MR_VD_S_Y_RD,	/* SCC_MR_VD_S_Y Read channel		*/
+	SCC_MR_VD_S_C_RD,	/* SCC_MR_VD_S_C Read channel		*/
+	SCC_GA_WR,		/* SCC_GA Write channel			*/
+	SCC_GA_SRC1_RD,		/* SCC_GA_SRC1 Read channel		*/
+	SCC_GA_SRC2_RD,		/* SCC_GA_SRC2 Read channel		*/
+	SCC_AD_RD,		/* SCC_AD Read channel			*/
+	SCC_AD_WR,		/* SCC_AD Write channel			*/
+	SCC_ABP_RD,		/* SCC_ABP Read channel			*/
+	SCC_ABP_WR,		/* SCC_ABP Write channel		*/
+	SCC_EBI_RW,		/* SCC_EBI Read/Write channel		*/
+	SCC_USB_RW,		/* SCC_USB Read/Write channel		*/
+	SCC_CPU1_SPDMA_RW,	/* SCC_CPU1_SPDMA Read/Write channel	*/
+	SCC_CPU1_BRIDGE_RW,	/* SCC_CPU1_BRIDGE Read/Write channel	*/
+	SCC_MAX			/* maximum limit on the SCC id		*/
+};
+
+int scc_set_usb_address_generation_mode(u32 agu_mode);
+int scc_dma_cmd(enum scc_id id, u32 cmd, u32 dma_id, u32 drs);
+int scc_setup_dma(enum scc_id id, u32 buffer_tag,
+		  u32 type, u32 fh_mode, u32 drs, u32 dma_id);
+int scc_enable(enum scc_id id, u32 value);
+int scc_reset(enum scc_id id, u32 value);
+
+#endif /* _SCC_H */
diff -Naur u-boot-2009.01/board/micronas/vct/smc_eeprom.c u-boot/board/micronas/vct/smc_eeprom.c
--- u-boot-2009.01/board/micronas/vct/smc_eeprom.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/smc_eeprom.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,394 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright 2005, Seagate Technology LLC
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#undef DEBUG
+
+#include <common.h>
+#include <command.h>
+#include <config.h>
+#include <net.h>
+
+#include "vct.h"
+
+#define SMSC9118_BASE		CONFIG_DRIVER_SMC911X_BASE
+#define BYTE_TEST		(SMSC9118_BASE + 0x64)
+#define GPIO_CFG		(SMSC9118_BASE + 0x88)
+#define MAC_CSR_CMD		(SMSC9118_BASE + 0xA4)
+#define  MAC_CSR_CMD_CSR_BUSY	(0x80000000)
+#define  MAC_CSR_CMD_RNW	(0x40000000)
+#define  MAC_RD_CMD(reg)	((reg & 0x000000FF) |			\
+				 (MAC_CSR_CMD_CSR_BUSY | MAC_CSR_CMD_RNW))
+#define  MAC_WR_CMD(reg)	((reg & 0x000000FF) |		\
+				 (MAC_CSR_CMD_CSR_BUSY))
+#define MAC_CSR_DATA		(SMSC9118_BASE + 0xA8)
+#define E2P_CMD			(SMSC9118_BASE + 0xB0)
+#define  E2P_CMD_EPC_BUSY_	(0x80000000UL)	/* Self Clearing */
+#define  E2P_CMD_EPC_CMD_	(0x70000000UL)	/* R/W */
+#define  E2P_CMD_EPC_CMD_READ_	(0x00000000UL)	/* R/W */
+#define  E2P_CMD_EPC_CMD_EWDS_	(0x10000000UL)	/* R/W */
+#define  E2P_CMD_EPC_CMD_EWEN_	(0x20000000UL)	/* R/W */
+#define  E2P_CMD_EPC_CMD_WRITE_	(0x30000000UL)	/* R/W */
+#define  E2P_CMD_EPC_CMD_WRAL_	(0x40000000UL)	/* R/W */
+#define  E2P_CMD_EPC_CMD_ERASE_	(0x50000000UL)	/* R/W */
+#define  E2P_CMD_EPC_CMD_ERAL_	(0x60000000UL)	/* R/W */
+#define  E2P_CMD_EPC_CMD_RELOAD_ (0x70000000UL)	/* R/W */
+#define  E2P_CMD_EPC_TIMEOUT_	(0x00000200UL)	/* R */
+#define  E2P_CMD_MAC_ADDR_LOADED_ (0x00000100UL) /* RO */
+#define  E2P_CMD_EPC_ADDR_	(0x000000FFUL)	/* R/W */
+#define E2P_DATA		(SMSC9118_BASE + 0xB4)
+
+#define MAC_ADDRH		(0x2)
+#define MAC_ADDRL		(0x3)
+
+#define MAC_TIMEOUT		200
+
+#define HIBYTE(word)		((u8)(((u16)(word)) >> 8))
+#define LOBYTE(word)		((u8)(((u16)(word)) & 0x00FFU))
+#define HIWORD(dword)		((u16)(((u32)(dword)) >> 16))
+#define LOWORD(dword)		((u16)(((u32)(dword)) & 0x0000FFFFUL))
+
+static int mac_busy(int req_to)
+{
+	int timeout = req_to;
+
+	while (timeout--) {
+		if (!(smc911x_reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY))
+			goto done;
+	}
+	return 1;		/* Timeout */
+
+done:
+	return 0;		/* No timeout */
+}
+
+static ulong get_mac_reg(int reg)
+{
+	ulong reg_val = 0xffffffff;
+
+	if (smc911x_reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY) {
+		printf("get_mac_reg: previous command not complete\n");
+		goto done;
+	}
+
+	smc911x_reg_write(MAC_CSR_CMD, MAC_RD_CMD(reg));
+	udelay(10000);
+
+	if (mac_busy(MAC_TIMEOUT) == 1) {
+		printf("get_mac_reg: timeout waiting for response from MAC\n");
+		goto done;
+	}
+
+	reg_val = smc911x_reg_read(MAC_CSR_DATA);
+
+done:
+	return (reg_val);
+}
+
+static ulong eeprom_enable_access(void)
+{
+	ulong gpio;
+
+	gpio = smc911x_reg_read(GPIO_CFG);
+	debug("%s: gpio= 0x%08lx ---> 0x%08lx\n", __func__, gpio,
+	      (gpio & 0xFF0FFFFFUL));
+
+	smc911x_reg_write(GPIO_CFG, (gpio & 0xFF0FFFFFUL));
+	return gpio;
+}
+
+static void eeprom_disable_access(ulong gpio)
+{
+	debug("%s: gpio= 0x%08lx\n", __func__, gpio);
+	smc911x_reg_write(GPIO_CFG, gpio);
+}
+
+static int eeprom_is_mac_address_loaded(void)
+{
+	int ret;
+
+	ret = smc911x_reg_read(MAC_CSR_CMD) & E2P_CMD_MAC_ADDR_LOADED_;
+	debug("%s: ret = %x\n", __func__, ret);
+
+	return ret;
+}
+
+static int eeprom_read_location(unchar address, u8 *data)
+{
+	ulong timeout = 100000;
+	ulong temp = 0;
+
+	if ((temp = smc911x_reg_read(E2P_CMD)) & E2P_CMD_EPC_BUSY_) {
+		printf("%s: Busy at start, E2P_CMD=0x%08lX\n", __func__, temp);
+		return 0;
+	}
+
+	smc911x_reg_write(E2P_CMD,
+			  (E2P_CMD_EPC_BUSY_ | E2P_CMD_EPC_CMD_READ_ |
+			   ((ulong) address)));
+
+	while ((timeout > 0) && (smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY_)) {
+		udelay(10);
+		timeout--;
+	}
+
+	if (timeout == 0) {
+		printf("Timeout\n");
+		return 0;
+	}
+	(*data) = (unchar) (smc911x_reg_read(E2P_DATA));
+	debug("%s: ret = %x\n", __func__, (*data));
+
+	return 1;
+}
+
+static int eeprom_enable_erase_and_write(void)
+{
+	ulong timeout = 100000;
+
+	if (smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY_) {
+		printf("%s: Busy at start\n", __func__);
+		return 0;
+	}
+	smc911x_reg_write(E2P_CMD, (E2P_CMD_EPC_BUSY_ | E2P_CMD_EPC_CMD_EWEN_));
+
+	while ((timeout > 0) && (smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY_)) {
+		udelay(10);
+		timeout--;
+	}
+
+	if (timeout == 0) {
+		printf("Timeout[1]\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static int eeprom_disable_erase_and_write(void)
+{
+	ulong timeout = 100000;
+
+	if (smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY_) {
+		printf("%s: Busy at start\n", __func__);
+		return 0;
+	}
+	smc911x_reg_write(E2P_CMD, (E2P_CMD_EPC_BUSY_ | E2P_CMD_EPC_CMD_EWDS_));
+
+	while ((timeout > 0) && (smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY_)) {
+		udelay(10);
+		timeout--;
+	}
+
+	if (timeout == 0) {
+		printf("Timeout[2]\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static int eeprom_write_location(unchar address, unchar data)
+{
+	ulong timeout = 100000;
+
+	debug("%s: address: %x data = %x\n", __func__, address, data);
+
+	if (smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY_) {
+		printf("%s: Busy at start\n", __func__);
+		return 0;
+	}
+
+	smc911x_reg_write(E2P_DATA, ((ulong) data));
+	smc911x_reg_write(E2P_CMD,
+			  (E2P_CMD_EPC_BUSY_ | E2P_CMD_EPC_CMD_WRITE_ |
+			   ((ulong) address)));
+
+	while ((timeout > 0) && (smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY_)) {
+		udelay(10);
+		timeout--;
+	}
+
+	if (timeout == 0) {
+		printf("Timeout[3]\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static int eeprom_erase_all(void)
+{
+	ulong timeout = 100000;
+
+	if (smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY_) {
+		printf("%s: Busy at start\n", __func__);
+		return 0;
+	}
+
+	smc911x_reg_write(E2P_CMD, (E2P_CMD_EPC_BUSY_ | E2P_CMD_EPC_CMD_ERAL_));
+
+	while ((timeout > 0) && (smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY_)) {
+		udelay(10);
+		timeout--;
+	}
+
+	if (timeout == 0) {
+		printf("Timeout[4]\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static int eeprom_reload(void)
+{
+	ulong timeout = 100000;
+
+	if (smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY_) {
+		printf("%s: Busy at start\n", __func__);
+		return -1;
+	}
+	smc911x_reg_write(E2P_CMD,
+			  (E2P_CMD_EPC_BUSY_ | E2P_CMD_EPC_CMD_RELOAD_));
+
+	while ((timeout > 0) && (smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY_)) {
+		udelay(10);
+		timeout--;
+	}
+
+	if (timeout == 0)
+		return 0;
+
+	return 1;
+}
+
+static int eeprom_save_mac_address(ulong dwHi16, ulong dwLo32)
+{
+	int result = 0;
+
+	debug("%s: dwHI: 0x%08lx dwLO: %08lx, \n", __func__, dwHi16, dwLo32);
+
+	if (!eeprom_enable_erase_and_write())
+		goto DONE;
+	if (!eeprom_erase_all())
+		goto DONE;
+	if (!eeprom_write_location(0, 0xA5))
+		goto DONE;
+	if (!eeprom_write_location(1, LOBYTE(LOWORD(dwLo32))))
+		goto DONE;
+	if (!eeprom_write_location(2, HIBYTE(LOWORD(dwLo32))))
+		goto DONE;
+	if (!eeprom_write_location(3, LOBYTE(HIWORD(dwLo32))))
+		goto DONE;
+	if (!eeprom_write_location(4, HIBYTE(HIWORD(dwLo32))))
+		goto DONE;
+	if (!eeprom_write_location(5, LOBYTE(LOWORD(dwHi16))))
+		goto DONE;
+	if (!eeprom_write_location(6, HIBYTE(LOWORD(dwHi16))))
+		goto DONE;
+	if (!eeprom_disable_erase_and_write())
+		goto DONE;
+
+	result = 1;
+
+DONE:
+	return result;
+}
+
+static int do_eeprom_dump(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	unchar data = 0, index = 0;
+	ulong gpio_old_val;
+
+	gpio_old_val = eeprom_enable_access();
+
+	printf("EEPROM content: \n");
+	for (index = 0; index < 8; index++) {
+		if (eeprom_read_location(index, &data))
+			printf("%02x ", data);
+		else
+			printf("FAILED");
+	}
+
+	eeprom_disable_access(gpio_old_val);
+	printf("\n");
+
+	return 0;
+}
+
+static int do_eeprom_erase_all(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	eeprom_erase_all();
+
+	return 0;
+}
+
+static int do_eeprom_save_mac(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	ulong hi16, lo32;
+	unchar ethaddr[6], i;
+	ulong gpio;
+	char *tmp, *end;
+
+	tmp = argv[1];
+	for (i = 0; i < 6; i++) {
+		ethaddr[i] = tmp ? simple_strtoul(tmp, &end, 16) : 0;
+		if (tmp)
+			tmp = (*end) ? end + 1 : end;
+	}
+
+	hi16 = (ethaddr[5] << 8) | (ethaddr[4]);
+	lo32 = (ethaddr[3] << 24) | (ethaddr[2] << 16) |
+		(ethaddr[1] << 8) | (ethaddr[0]);
+
+	gpio = eeprom_enable_access();
+
+	eeprom_save_mac_address(hi16, lo32);
+
+	eeprom_reload();
+
+	/* Check new values */
+	if (eeprom_is_mac_address_loaded()) {
+		ulong mac_hi16, mac_lo32;
+
+		mac_hi16 = get_mac_reg(MAC_ADDRH);
+		mac_lo32 = get_mac_reg(MAC_ADDRL);
+		printf("New MAC address: %lx, %lx\n", mac_hi16, mac_lo32);
+	} else {
+		printf("Address is not reloaded \n");
+	}
+	eeprom_disable_access(gpio);
+
+	return 0;
+}
+
+U_BOOT_CMD(smcee, 1, 0, do_eeprom_erase_all,
+	   "smcee   - Erase content of SMC EEPROM\n",);
+
+U_BOOT_CMD(smced, 1, 0, do_eeprom_dump,
+	   "smced   - Dump content of SMC EEPROM\n",);
+
+U_BOOT_CMD(smcew, 2, 0, do_eeprom_save_mac,
+	   "smcew   - Write MAC address to SMC EEPROM\n",
+	   "aa:bb:cc:dd:ee:ff  new mac address\n");
diff -Naur u-boot-2009.01/board/micronas/vct/top.c u-boot/board/micronas/vct/top.c
--- u-boot-2009.01/board/micronas/vct/top.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/top.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,289 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include "vct.h"
+
+typedef union _TOP_PINMUX_t
+{
+	u32 reg;
+	struct {
+		u32 res		: 24;   /* reserved		*/
+		u32 drive	:  2;   /* Driver strength	*/
+		u32 slew	:  1;   /* Slew rate		*/
+		u32 strig	:  1;   /* Schmitt trigger input*/
+		u32 pu_pd	:  2;   /* Pull up/ pull down	*/
+		u32 funsel	:  2;   /* Pin function		*/
+	} Bits;
+} TOP_PINMUX_t;
+
+#if defined(CONFIG_VCT_PREMIUM) || defined(CONFIG_VCT_PLATINUM)
+
+static TOP_PINMUX_t top_read_pin(int pin)
+{
+	TOP_PINMUX_t reg;
+
+	switch (pin) {
+	case 2:
+	case 3:
+	case 6:
+	case 9:
+		reg.reg = 0xdeadbeef;
+		break;
+	case 4:
+		reg.reg = reg_read(FWSRAM_TOP_SCL_CFG(FWSRAM_BASE));
+		break;
+	case 5:
+		reg.reg = reg_read(FWSRAM_TOP_SDA_CFG(FWSRAM_BASE));
+		break;
+	case 7:
+		reg.reg = reg_read(FWSRAM_TOP_TDO_CFG(FWSRAM_BASE));
+		break;
+	case 8:
+		reg.reg = reg_read(FWSRAM_TOP_GPIO2_0_CFG(FWSRAM_BASE));
+		break;
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+	case 16:
+		reg.reg = reg_read(FWSRAM_BASE + FWSRAM_TOP_GPIO2_1_CFG_OFFS +
+				   ((pin - 10) * 4));
+		break;
+	default:
+		reg.reg = reg_read(TOP_BASE + (pin * 4));
+		break;
+	}
+
+	return reg;
+}
+
+static void top_write_pin(int pin, TOP_PINMUX_t reg)
+{
+
+	switch (pin) {
+	case 4:
+		reg_write(FWSRAM_TOP_SCL_CFG(FWSRAM_BASE), reg.reg);
+		break;
+	case 5:
+		reg_write(FWSRAM_TOP_SDA_CFG(FWSRAM_BASE), reg.reg);
+		break;
+	case 7:
+		reg_write(FWSRAM_TOP_TDO_CFG(FWSRAM_BASE), reg.reg);
+		break;
+	case 8:
+		reg_write(FWSRAM_TOP_GPIO2_0_CFG(FWSRAM_BASE), reg.reg);
+		break;
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+	case 16:
+		reg_write(FWSRAM_BASE + FWSRAM_TOP_GPIO2_1_CFG_OFFS +
+			  ((pin - 10) * 4), reg.reg);
+		break;
+	default:
+		reg_write(TOP_BASE + (pin * 4), reg.reg);
+		break;
+	}
+}
+
+int top_set_pin(int pin, int func)
+{
+	TOP_PINMUX_t reg;
+
+	/* check global range */
+	if ((pin < 0) || (pin > 170) || (func < 0) || (func > 3))
+		return -1;  /* pin number or function out of valid range */
+
+	/* check undefined values; */
+	if ((pin == 2) || (pin == 3) || (pin == 6) || (pin == 9))
+		return -1;  /* pin number out of valid range */
+
+	reg = top_read_pin(pin);
+	reg.Bits.funsel = func;
+	top_write_pin(pin, reg);
+
+	return 0;
+}
+
+#endif
+
+#if defined(CONFIG_VCT_PLATINUMAVC)
+
+int top_set_pin(int pin, int func)
+{
+	TOP_PINMUX_t reg;
+
+	/* check global range */
+	if ((pin < 0) || (pin > 158))
+		return -1;	/* pin number or function out of valid range */
+
+	reg.reg = reg_read(TOP_BASE + (pin * 4));
+	reg.Bits.funsel = func;
+	reg_write(TOP_BASE + (pin * 4), reg.reg);
+
+	return 0;
+}
+
+#endif
+
+void vct_pin_mux_initialize(void)
+{
+#if defined(CONFIG_VCT_PREMIUM) || defined(CONFIG_VCT_PLATINUM)
+	top_set_pin(34, 01);	/* EBI_CS0	*/
+	top_set_pin(33, 01);	/* EBI_CS1	*/
+	top_set_pin(32, 01);	/* EBI_CS2	*/
+	top_set_pin(100, 02);	/* EBI_CS3	*/
+	top_set_pin(101, 02);	/* EBI_CS4	*/
+	top_set_pin(102, 02);	/* EBI_CS5	*/
+	top_set_pin(103, 02);	/* EBI_CS6	*/
+	top_set_pin(104, 02);	/* EBI_CS7	top_set_pin(104,03); EBI_GENIO3 */
+	top_set_pin(35, 01);	/* EBI_ALE	*/
+	top_set_pin(36, 01);	/* EBI_ADDR15	*/
+	top_set_pin(37, 01);	/* EBI_ADDR14	top_set_pin(78,03); EBI_ADDR14 */
+	top_set_pin(38, 01);	/* EBI_ADDR13	*/
+	top_set_pin(39, 01);	/* EBI_ADDR12	*/
+	top_set_pin(40, 01);	/* EBI_ADDR11	*/
+	top_set_pin(41, 01);	/* EBI_ADDR10	*/
+	top_set_pin(42, 01);	/* EBI_ADDR9	*/
+	top_set_pin(43, 01);	/* EBI_ADDR8	*/
+	top_set_pin(44, 01);	/* EBI_ADDR7	*/
+	top_set_pin(45, 01);	/* EBI_ADDR6	*/
+	top_set_pin(46, 01);	/* EBI_ADDR5	*/
+	top_set_pin(47, 01);	/* EBI_ADDR4	*/
+	top_set_pin(48, 01);	/* EBI_ADDR3	*/
+	top_set_pin(49, 01);	/* EBI_ADDR2	*/
+	top_set_pin(50, 01);	/* EBI_ADDR1	*/
+	top_set_pin(51, 01);	/* EBI_ADDR0	*/
+	top_set_pin(52, 01);	/* EBI_DIR	*/
+	top_set_pin(53, 01);	/* EBI_DAT15	top_set_pin(81,01); EBI_DAT15 */
+	top_set_pin(54, 01);	/* EBI_DAT14	top_set_pin(82,01); EBI_DAT14 */
+	top_set_pin(55, 01);	/* EBI_DAT13	top_set_pin(83,01); EBI_DAT13 */
+	top_set_pin(56, 01);	/* EBI_DAT12	top_set_pin(84,01); EBI_DAT12 */
+	top_set_pin(57, 01);	/* EBI_DAT11	top_set_pin(85,01); EBI_DAT11 */
+	top_set_pin(58, 01);	/* EBI_DAT10	top_set_pin(86,01); EBI_DAT10 */
+	top_set_pin(59, 01);	/* EBI_DAT9	top_set_pin(87,01); EBI_DAT9 */
+	top_set_pin(60, 01);	/* EBI_DAT8	top_set_pin(88,01); EBI_DAT8 */
+	top_set_pin(61, 01);	/* EBI_DAT7	*/
+	top_set_pin(62, 01);	/* EBI_DAT6	*/
+	top_set_pin(63, 01);	/* EBI_DAT5	*/
+	top_set_pin(64, 01);	/* EBI_DAT4	*/
+	top_set_pin(65, 01);	/* EBI_DAT3	*/
+	top_set_pin(66, 01);	/* EBI_DAT2	*/
+	top_set_pin(67, 01);	/* EBI_DAT1	*/
+	top_set_pin(68, 01);	/* EBI_DAT0	*/
+	top_set_pin(69, 01);	/* EBI_IORD	*/
+	top_set_pin(70, 01);	/* EBI_IOWR	*/
+	top_set_pin(71, 01);	/* EBI_WE	*/
+	top_set_pin(72, 01);	/* EBI_OE	*/
+	top_set_pin(73, 01);	/* EBI_IORDY	*/
+	top_set_pin(95, 02);	/* EBI_EBI_DMACK*/
+	top_set_pin(112, 02);	/* EBI_IRQ0	*/
+	top_set_pin(111, 02);	/* EBI_IRQ1	top_set_pin(111,03); EBI_DMARQ */
+	top_set_pin(107, 02);	/* EBI_IRQ2	*/
+	top_set_pin(108, 02);	/* EBI_IRQ3	*/
+	top_set_pin(30, 01);	/* EBI_GENIO1   top_set_pin(99,03); EBI_GENIO1 */
+	top_set_pin(31, 01);	/* EBI_GENIO2   top_set_pin(98,03); EBI_GENIO2 */
+	top_set_pin(105, 02);	/* EBI_GENIO3   top_set_pin(104,03); EBI_GENIO3 */
+	top_set_pin(106, 02);	/* EBI_GENIO4   top_set_pin(144,02); EBI_GENIO4 */
+	top_set_pin(109, 02);	/* EBI_GENIO5   top_set_pin(142,02); EBI_GENIO5 */
+	top_set_pin(110, 02);	/* EBI_BURST_CLK	*/
+#endif
+
+#if defined(CONFIG_VCT_PLATINUMAVC)
+	top_set_pin(19, 01);	/* EBI_CS0	*/
+	top_set_pin(18, 01);	/* EBI_CS1	*/
+	top_set_pin(17, 01);	/* EBI_CS2	*/
+	top_set_pin(92, 02);	/* EBI_CS3	*/
+	top_set_pin(93, 02);	/* EBI_CS4	*/
+	top_set_pin(95, 02);	/* EBI_CS6	*/
+	top_set_pin(96, 02);	/* EBI_CS7	top_set_pin(104,03); EBI_GENIO3 */
+	top_set_pin(20, 01);	/* EBI_ALE	*/
+	top_set_pin(21, 01);	/* EBI_ADDR15	*/
+	top_set_pin(22, 01);	/* EBI_ADDR14	top_set_pin(78,03); EBI_ADDR14 */
+	top_set_pin(23, 01);	/* EBI_ADDR13	*/
+	top_set_pin(24, 01);	/* EBI_ADDR12	*/
+	top_set_pin(25, 01);	/* EBI_ADDR11	*/
+	top_set_pin(26, 01);	/* EBI_ADDR10	*/
+	top_set_pin(27, 01);	/* EBI_ADDR9	*/
+	top_set_pin(28, 01);	/* EBI_ADDR8	*/
+	top_set_pin(29, 01);	/* EBI_ADDR7	*/
+	top_set_pin(30, 01);	/* EBI_ADDR6	*/
+	top_set_pin(31, 01);	/* EBI_ADDR5	*/
+	top_set_pin(32, 01);	/* EBI_ADDR4	*/
+	top_set_pin(33, 01);	/* EBI_ADDR3	*/
+	top_set_pin(34, 01);	/* EBI_ADDR2	*/
+	top_set_pin(35, 01);	/* EBI_ADDR1	*/
+	top_set_pin(36, 01);	/* EBI_ADDR0	*/
+	top_set_pin(37, 01);	/* EBI_DIR	*/
+	top_set_pin(38, 01);	/* EBI_DAT15	top_set_pin(81,01); EBI_DAT15 */
+	top_set_pin(39, 01);	/* EBI_DAT14	top_set_pin(82,01); EBI_DAT14 */
+	top_set_pin(40, 01);	/* EBI_DAT13	top_set_pin(83,01); EBI_DAT13 */
+	top_set_pin(41, 01);	/* EBI_DAT12	top_set_pin(84,01); EBI_DAT12 */
+	top_set_pin(42, 01);	/* EBI_DAT11	top_set_pin(85,01); EBI_DAT11 */
+	top_set_pin(43, 01);	/* EBI_DAT10	top_set_pin(86,01); EBI_DAT10 */
+	top_set_pin(44, 01);	/* EBI_DAT9	top_set_pin(87,01); EBI_DAT9 */
+	top_set_pin(45, 01);	/* EBI_DAT8	top_set_pin(88,01); EBI_DAT8 */
+	top_set_pin(46, 01);	/* EBI_DAT7	*/
+	top_set_pin(47, 01);	/* EBI_DAT6	*/
+	top_set_pin(48, 01);	/* EBI_DAT5	*/
+	top_set_pin(49, 01);	/* EBI_DAT4	*/
+	top_set_pin(50, 01);	/* EBI_DAT3	*/
+	top_set_pin(51, 01);	/* EBI_DAT2	*/
+	top_set_pin(52, 01);	/* EBI_DAT1	*/
+	top_set_pin(53, 01);	/* EBI_DAT0	*/
+	top_set_pin(54, 01);	/* EBI_IORD	*/
+	top_set_pin(55, 01);	/* EBI_IOWR	*/
+	top_set_pin(56, 01);	/* EBI_WE	*/
+	top_set_pin(57, 01);	/* EBI_OE	*/
+	top_set_pin(58, 01);	/* EBI_IORDY	*/
+	top_set_pin(87, 02);	/* EBI_EBI_DMACK*/
+	top_set_pin(106, 02);	/* EBI_IRQ0	*/
+	top_set_pin(105, 02);	/* EBI_IRQ1	top_set_pin(111,03); EBI_DMARQ */
+	top_set_pin(101, 02);	/* EBI_IRQ2	*/
+	top_set_pin(102, 02);	/* EBI_IRQ3	*/
+	top_set_pin(15, 01);	/* EBI_GENIO1   top_set_pin(99,03); EBI_GENIO1 */
+	top_set_pin(16, 01);	/* EBI_GENIO2   top_set_pin(98,03); EBI_GENIO2 */
+	top_set_pin(99, 02);	/* EBI_GENIO3   top_set_pin(104,03); EBI_GENIO3 */
+	top_set_pin(100, 02);	/* EBI_GENIO4   top_set_pin(144,02); EBI_GENIO4 */
+	top_set_pin(103, 02);	/* EBI_GENIO5   top_set_pin(142,02); EBI_GENIO5 */
+	top_set_pin(104, 02);	/* EBI_BURST_CLK	*/
+#endif
+
+	/* I2C: Configure I2C-2 as GPIO to enable soft-i2c */
+	top_set_pin(0, 2);	/* SCL2 on GPIO 11 */
+	top_set_pin(1, 2);	/* SDA2 on GPIO 10 */
+
+	/* UART pins */
+#if defined(CONFIG_VCT_PREMIUM) || defined(CONFIG_VCT_PLATINUM)
+	top_set_pin(141, 1);
+	top_set_pin(143, 1);
+#endif
+#if defined(CONFIG_VCT_PLATINUMAVC)
+	top_set_pin(107, 1);
+	top_set_pin(109, 1);
+#endif
+}
diff -Naur u-boot-2009.01/board/micronas/vct/u-boot.lds u-boot/board/micronas/vct/u-boot.lds
--- u-boot-2009.01/board/micronas/vct/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,71 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradlittlemips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = .;
+	_gp = ALIGN(16) + 0x7ff0;
+
+	.got : {
+	  __got_start = .;
+	  *(.got)
+	  __got_end = .;
+	}
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(4);
+	.u_boot_cmd : {
+	  __u_boot_cmd_start = .;
+	  *(.u_boot_cmd)
+	  __u_boot_cmd_end = .;
+	}
+
+	. = ALIGN(4);
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss (NOLOAD)  : { *(.sbss) }
+	. = ALIGN(4);
+	.bss (NOLOAD)  : { *(.bss) }
+	uboot_end = .;
+}
diff -Naur u-boot-2009.01/board/micronas/vct/vct.c u-boot/board/micronas/vct/vct.c
--- u-boot-2009.01/board/micronas/vct/vct.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vct.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,117 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include "vct.h"
+
+#if defined(CONFIG_VCT_PREMIUM)
+#define BOARD_NAME	"PremiumD"
+#elif defined(CONFIG_VCT_PLATINUM)
+#define BOARD_NAME	"PlatinumD"
+#elif defined(CONFIG_VCT_PLATINUMAVC)
+#define BOARD_NAME	"PlatinumAVC"
+#else
+#error "vct: No board variant defined!"
+#endif
+
+#if defined(CONFIG_VCT_ONENAND)
+#define BOARD_NAME_ADD	" OneNAND"
+#else
+#define BOARD_NAME_ADD	" NOR"
+#endif
+
+int board_early_init_f(void)
+{
+	/*
+	 * First initialize the PIN mulitplexing
+	 */
+	vct_pin_mux_initialize();
+
+	/*
+	 * Init the EBI very early so that FLASH can be accessed
+	 */
+	ebi_initialize();
+
+	return 0;
+}
+
+void _machine_restart(void)
+{
+	reg_write(DCGU_EN_WDT_RESET(DCGU_BASE), DCGU_MAGIC_WDT);
+	reg_write(WDT_TORR(WDT_BASE), 0x00);
+	reg_write(WDT_CR(WDT_BASE), 0x1D);
+
+	/*
+	 * Now wait for the watchdog to trigger the reset
+	 */
+	udelay(1000000);
+}
+
+/*
+ * SDRAM is already configured by the bootstrap code, only return the
+ * auto-detected size here
+ */
+phys_size_t initdram(int board_type)
+{
+	return get_ram_size((long *)CONFIG_SYS_SDRAM_BASE,
+			    CONFIG_SYS_MBYTES_SDRAM << 20);
+}
+
+int checkboard(void)
+{
+	u32 config0 = read_c0_prid();
+	char *s = getenv("serial#");
+
+	if ((config0 & 0xff0000) == PRID_COMP_LEGACY
+	    && (config0 & 0xff00) == PRID_IMP_LX4280) {
+		puts("Board: MDED \n");
+		printf("CPU:   LX4280 id: 0x%02x, rev: 0x%02x\n",
+		       (config0 >> 8) & 0xFF, config0 & 0xFF);
+	} else if ((config0 & 0xff0000) == PRID_COMP_MIPS
+		   && (config0 & 0xff00) == PRID_IMP_VGC) {
+		u32 jedec_id = *((u32 *) 0xBEBC71A0);
+		if ((((jedec_id) >> 12) & 0xFF) == 0x40) {
+			puts("Board: VGCA \n");
+		} else if ((((jedec_id) >> 12) & 0xFF) == 0x48
+			   || (((jedec_id) >> 12) & 0xFF) == 0x49) {
+			puts("Board: VGCB \n");
+		}
+		printf("CPU:   MIPS 4K id: 0x%02x, rev: 0x%02x\n",
+		       (config0 >> 8) & 0xFF, config0 & 0xFF);
+	} else if (config0 == 0x19378) {
+		printf("CPU:   MIPS 24K id: 0x%02x, rev: 0x%02x\n",
+		       (config0 >> 8) & 0xFF, config0 & 0xFF);
+	} else {
+		printf("Unsupported cpu %d, proc_id=0x%x\n", config0 >> 24,
+		       config0);
+	}
+
+	printf("Board: Micronas VCT " BOARD_NAME BOARD_NAME_ADD);
+	if (s != NULL) {
+		puts(", serial# ");
+		puts(s);
+	}
+	putc('\n');
+
+	return 0;
+}
diff -Naur u-boot-2009.01/board/micronas/vct/vcth/reg_dcgu.h u-boot/board/micronas/vct/vcth/reg_dcgu.h
--- u-boot-2009.01/board/micronas/vct/vcth/reg_dcgu.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vcth/reg_dcgu.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+ * (C) Copyright 2008-2009 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define DCGU_BASE		0x00084000
+
+/* Relative offsets of the register adresses */
+
+#define DCGU_CLK_EN1_OFFS	0x00000010
+#define DCGU_CLK_EN1(base)	((base) + DCGU_CLK_EN1_OFFS)
+#define DCGU_CLK_EN2_OFFS	0x00000014
+#define DCGU_CLK_EN2(base)	((base) + DCGU_CLK_EN2_OFFS)
+#define DCGU_RESET_UNIT1_OFFS	0x00000018
+#define DCGU_RESET_UNIT1(base)	((base) + DCGU_RESET_UNIT1_OFFS)
+#define DCGU_USBPHY_STAT_OFFS	0x00000054
+#define DCGU_USBPHY_STAT(base)	((base) + DCGU_USBPHY_STAT_OFFS)
+#define DCGU_EN_WDT_RESET_OFFS	0x00000064
+#define DCGU_EN_WDT_RESET(base)	((base) + DCGU_EN_WDT_RESET_OFFS)
+
+/* The magic value to write in order to activate the WDT */
+#define DCGU_MAGIC_WDT		0x1909
diff -Naur u-boot-2009.01/board/micronas/vct/vcth/reg_ebi.h u-boot/board/micronas/vct/vcth/reg_ebi.h
--- u-boot-2009.01/board/micronas/vct/vcth/reg_ebi.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vcth/reg_ebi.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,242 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _REG_EBI_PREMIUM_H_
+#define _REG_EBI_PREMIUM_H_
+
+#define EBI_BASE			0x00000000
+
+/*  Relative offsets of the register adresses */
+
+#define EBI_CPU_IO_ACCS_OFFS		0x00000000
+#define EBI_CPU_IO_ACCS(base)		((base) + EBI_CPU_IO_ACCS_OFFS)
+#define EBI_IO_ACCS_DATA_OFFS		0x00000004
+#define EBI_IO_ACCS_DATA(base)		((base) + EBI_IO_ACCS_DATA_OFFS)
+#define EBI_CTRL_OFFS			0x00000008
+#define EBI_CTRL(base)			((base) + EBI_CTRL_OFFS)
+#define EBI_IRQ_MASK_OFFS		0x00000010
+#define EBI_IRQ_MASK(base)		((base) + EBI_IRQ_MASK_OFFS)
+#define EBI_TAG1_SYS_ID_OFFS		0x00000030
+#define EBI_TAG1_SYS_ID(base)		((base) + EBI_TAG1_SYS_ID_OFFS)
+#define EBI_TAG2_SYS_ID_OFFS		0x00000040
+#define EBI_TAG2_SYS_ID(base)		((base) + EBI_TAG2_SYS_ID_OFFS)
+#define EBI_TAG3_SYS_ID_OFFS		0x00000050
+#define EBI_TAG3_SYS_ID(base)		((base) + EBI_TAG3_SYS_ID_OFFS)
+#define EBI_TAG4_SYS_ID_OFFS		0x00000060
+#define EBI_TAG4_SYS_ID(base)		((base) + EBI_TAG4_SYS_ID_OFFS)
+#define EBI_GEN_DMA_CTRL_OFFS		0x00000070
+#define EBI_GEN_DMA_CTRL(base)		((base) + EBI_GEN_DMA_CTRL_OFFS)
+#define EBI_STATUS_OFFS			0x00000080
+#define EBI_STATUS(base)		((base) + EBI_STATUS_OFFS)
+#define EBI_STATUS_DMA_CNT_OFFS		0x00000084
+#define EBI_STATUS_DMA_CNT(base)	((base) + EBI_STATUS_DMA_CNT_OFFS)
+#define EBI_SIG_LEVEL_OFFS		0x00000088
+#define EBI_SIG_LEVEL(base)		((base) + EBI_SIG_LEVEL_OFFS)
+#define EBI_CTRL_SIG_ACTLV_OFFS		0x0000008C
+#define EBI_CTRL_SIG_ACTLV(base)	((base) + EBI_CTRL_SIG_ACTLV_OFFS)
+#define EBI_EXT_ADDR_OFFS		0x000000A0
+#define EBI_EXT_ADDR(base)		((base) + EBI_EXT_ADDR_OFFS)
+#define EBI_IRQ_STATUS_OFFS		0x000000B0
+#define EBI_IRQ_STATUS(base)		((base) + EBI_IRQ_STATUS_OFFS)
+#define EBI_DEV1_DMA_EXT_ADDR_OFFS	0x00000100
+#define EBI_DEV1_DMA_EXT_ADDR(base)	((base) + EBI_DEV1_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV1_EXT_ACC_OFFS		0x00000104
+#define EBI_DEV1_EXT_ACC(base)		((base) + EBI_DEV1_EXT_ACC_OFFS)
+#define EBI_DEV1_CONFIG1_OFFS		0x00000108
+#define EBI_DEV1_CONFIG1(base)		((base) + EBI_DEV1_CONFIG1_OFFS)
+#define EBI_DEV1_CONFIG2_OFFS		0x0000010C
+#define EBI_DEV1_CONFIG2(base)		((base) + EBI_DEV1_CONFIG2_OFFS)
+#define EBI_DEV1_FIFO_CONFIG_OFFS	0x00000110
+#define EBI_DEV1_FIFO_CONFIG(base) 	((base) + EBI_DEV1_FIFO_CONFIG_OFFS)
+#define EBI_DEV1_FLASH_CONF_ST_OFFS	0x00000114
+#define EBI_DEV1_FLASH_CONF_ST(base)	((base) + EBI_DEV1_FLASH_CONF_ST_OFFS)
+#define EBI_DEV1_DMA_CONFIG1_OFFS	0x00000118
+#define EBI_DEV1_DMA_CONFIG1(base)	((base) + EBI_DEV1_DMA_CONFIG1_OFFS)
+#define EBI_DEV1_DMA_CONFIG2_OFFS	0x0000011C
+#define EBI_DEV1_DMA_CONFIG2(base)	((base) + EBI_DEV1_DMA_CONFIG2_OFFS)
+#define EBI_DEV1_TIM1_RD1_OFFS		0x00000124
+#define EBI_DEV1_TIM1_RD1(base)		((base) + EBI_DEV1_TIM1_RD1_OFFS)
+#define EBI_DEV1_TIM1_RD2_OFFS		0x00000128
+#define EBI_DEV1_TIM1_RD2(base)		((base) + EBI_DEV1_TIM1_RD2_OFFS)
+#define EBI_DEV1_TIM1_WR1_OFFS		0x0000012C
+#define EBI_DEV1_TIM1_WR1(base)		((base) + EBI_DEV1_TIM1_WR1_OFFS)
+#define EBI_DEV1_TIM1_WR2_OFFS		0x00000130
+#define EBI_DEV1_TIM1_WR2(base)		((base) + EBI_DEV1_TIM1_WR2_OFFS)
+#define EBI_DEV1_TIM_EXT_OFFS		0x00000134
+#define EBI_DEV1_TIM_EXT(base)		((base) + EBI_DEV1_TIM_EXT_OFFS)
+#define EBI_DEV1_TIM2_CFI_RD1_OFFS	0x00000138
+#define EBI_DEV1_TIM2_CFI_RD1(base)	((base) + EBI_DEV1_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV1_TIM2_CFI_RD2_OFFS	0x0000013C
+#define EBI_DEV1_TIM2_CFI_RD2(base)	((base) + EBI_DEV1_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV1_TIM3_DMA1_OFFS		0x00000140
+#define EBI_DEV1_TIM3_DMA1(base)	((base) + EBI_DEV1_TIM3_DMA1_OFFS)
+#define EBI_DEV1_TIM3_DMA2_OFFS		0x00000144
+#define EBI_DEV1_TIM3_DMA2(base)	((base) + EBI_DEV1_TIM3_DMA2_OFFS)
+#define EBI_DEV1_ACK_RM_CNT_OFFS	0x00000150
+#define EBI_DEV1_ACK_RM_CNT(base)	((base) + EBI_DEV1_ACK_RM_CNT_OFFS)
+#define EBI_DEV2_DMA_EXT_ADDR_OFFS	0x00000200
+#define EBI_DEV2_DMA_EXT_ADDR(base)	((base) + EBI_DEV2_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV2_EXT_ACC_OFFS		0x00000204
+#define EBI_DEV2_EXT_ACC(base)		((base) + EBI_DEV2_EXT_ACC_OFFS)
+#define EBI_DEV2_CONFIG1_OFFS		0x00000208
+#define EBI_DEV2_CONFIG1(base)		((base) + EBI_DEV2_CONFIG1_OFFS)
+#define EBI_DEV2_CONFIG2_OFFS		0x0000020C
+#define EBI_DEV2_CONFIG2(base)		((base) + EBI_DEV2_CONFIG2_OFFS)
+#define EBI_DEV2_FIFO_CONFIG_OFFS	0x00000210
+#define EBI_DEV2_FIFO_CONFIG(base)	((base) + EBI_DEV2_FIFO_CONFIG_OFFS)
+#define EBI_DEV2_FLASH_CONF_ST_OFFS	0x00000214
+#define EBI_DEV2_FLASH_CONF_ST(base)	((base) + EBI_DEV2_FLASH_CONF_ST_OFFS)
+#define EBI_DEV2_DMA_CONFIG1_OFFS	0x00000218
+#define EBI_DEV2_DMA_CONFIG1(base)	((base) + EBI_DEV2_DMA_CONFIG1_OFFS)
+#define EBI_DEV2_DMA_CONFIG2_OFFS	0x0000021C
+#define EBI_DEV2_DMA_CONFIG2(base)	((base) + EBI_DEV2_DMA_CONFIG2_OFFS)
+#define EBI_DEV2_TIM1_RD1_OFFS		0x00000224
+#define EBI_DEV2_TIM1_RD1(base)		((base) + EBI_DEV2_TIM1_RD1_OFFS)
+#define EBI_DEV2_TIM1_RD2_OFFS		0x00000228
+#define EBI_DEV2_TIM1_RD2(base)		((base) + EBI_DEV2_TIM1_RD2_OFFS)
+#define EBI_DEV2_TIM1_WR1_OFFS		0x0000022C
+#define EBI_DEV2_TIM1_WR1(base)		((base) + EBI_DEV2_TIM1_WR1_OFFS)
+#define EBI_DEV2_TIM1_WR2_OFFS		0x00000230
+#define EBI_DEV2_TIM1_WR2(base)		((base) + EBI_DEV2_TIM1_WR2_OFFS)
+#define EBI_DEV2_TIM_EXT_OFFS		0x00000234
+#define EBI_DEV2_TIM_EXT(base)		((base) + EBI_DEV2_TIM_EXT_OFFS)
+#define EBI_DEV2_TIM2_CFI_RD1_OFFS	0x00000238
+#define EBI_DEV2_TIM2_CFI_RD1(base)	((base) + EBI_DEV2_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV2_TIM2_CFI_RD2_OFFS	0x0000023C
+#define EBI_DEV2_TIM2_CFI_RD2(base)	((base) + EBI_DEV2_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV2_TIM3_DMA1_OFFS		0x00000240
+#define EBI_DEV2_TIM3_DMA1(base)	((base) + EBI_DEV2_TIM3_DMA1_OFFS)
+#define EBI_DEV2_TIM3_DMA2_OFFS		0x00000244
+#define EBI_DEV2_TIM3_DMA2(base)	((base) + EBI_DEV2_TIM3_DMA2_OFFS)
+#define EBI_DEV2_ACK_RM_CNT_OFFS	0x00000250
+#define EBI_DEV2_ACK_RM_CNT(base)	((base) + EBI_DEV2_ACK_RM_CNT_OFFS)
+#define EBI_DEV3_DMA_EXT_ADDR_OFFS	0x00000300
+#define EBI_DEV3_DMA_EXT_ADDR(base)	((base) + EBI_DEV3_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV3_EXT_ACC_OFFS		0x00000304
+#define EBI_DEV3_EXT_ACC(base)		((base) + EBI_DEV3_EXT_ACC_OFFS)
+#define EBI_DEV3_CONFIG1_OFFS		0x00000308
+#define EBI_DEV3_CONFIG1(base)		((base) + EBI_DEV3_CONFIG1_OFFS)
+#define EBI_DEV3_CONFIG2_OFFS		0x0000030C
+#define EBI_DEV3_CONFIG2(base)		((base) + EBI_DEV3_CONFIG2_OFFS)
+#define EBI_DEV3_FIFO_CONFIG_OFFS	0x00000310
+#define EBI_DEV3_FIFO_CONFIG(base)	((base) + EBI_DEV3_FIFO_CONFIG_OFFS)
+#define EBI_DEV3_FLASH_CONF_ST_OFFS	0x00000314
+#define EBI_DEV3_FLASH_CONF_ST(base)	((base) + EBI_DEV3_FLASH_CONF_ST_OFFS)
+#define EBI_DEV3_DMA_CONFIG1_OFFS	0x00000318
+#define EBI_DEV3_DMA_CONFIG1(base)	((base) + EBI_DEV3_DMA_CONFIG1_OFFS)
+#define EBI_DEV3_DMA_CONFIG2_OFFS	0x0000031C
+#define EBI_DEV3_DMA_CONFIG2(base)	((base) + EBI_DEV3_DMA_CONFIG2_OFFS)
+#define EBI_DEV3_TIM1_RD1_OFFS		0x00000324
+#define EBI_DEV3_TIM1_RD1(base)		((base) + EBI_DEV3_TIM1_RD1_OFFS)
+#define EBI_DEV3_TIM1_RD2_OFFS		0x00000328
+#define EBI_DEV3_TIM1_RD2(base)		((base) + EBI_DEV3_TIM1_RD2_OFFS)
+#define EBI_DEV3_TIM1_WR1_OFFS		0x0000032C
+#define EBI_DEV3_TIM1_WR1(base)		((base) + EBI_DEV3_TIM1_WR1_OFFS)
+#define EBI_DEV3_TIM1_WR2_OFFS		0x00000330
+#define EBI_DEV3_TIM1_WR2(base)		((base) + EBI_DEV3_TIM1_WR2_OFFS)
+#define EBI_DEV3_TIM_EXT_OFFS		0x00000334
+#define EBI_DEV3_TIM_EXT(base)		((base) + EBI_DEV3_TIM_EXT_OFFS)
+#define EBI_DEV3_TIM2_CFI_RD1_OFFS	0x00000338
+#define EBI_DEV3_TIM2_CFI_RD1(base)	((base) + EBI_DEV3_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV3_TIM2_CFI_RD2_OFFS	0x0000033C
+#define EBI_DEV3_TIM2_CFI_RD2(base)	((base) + EBI_DEV3_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV3_TIM3_DMA1_OFFS		0x00000340
+#define EBI_DEV3_TIM3_DMA1(base)	((base) + EBI_DEV3_TIM3_DMA1_OFFS)
+#define EBI_DEV3_TIM3_DMA2_OFFS		0x00000344
+#define EBI_DEV3_TIM3_DMA2(base)	((base) + EBI_DEV3_TIM3_DMA2_OFFS)
+#define EBI_DEV3_ACK_RM_CNT_OFFS	0x00000350
+#define EBI_DEV3_ACK_RM_CNT(base)	((base) + EBI_DEV3_ACK_RM_CNT_OFFS)
+#define EBI_DEV4_DMA_EXT_ADDR_OFFS	0x00000400
+#define EBI_DEV4_DMA_EXT_ADDR(base)	((base) + EBI_DEV4_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV4_EXT_ACC_OFFS		0x00000404
+#define EBI_DEV4_EXT_ACC(base)		((base) + EBI_DEV4_EXT_ACC_OFFS)
+#define EBI_DEV4_CONFIG1_OFFS		0x00000408
+#define EBI_DEV4_CONFIG1(base)		((base) + EBI_DEV4_CONFIG1_OFFS)
+#define EBI_DEV4_CONFIG2_OFFS		0x0000040C
+#define EBI_DEV4_CONFIG2(base)		((base) + EBI_DEV4_CONFIG2_OFFS)
+#define EBI_DEV4_FIFO_CONFIG_OFFS	0x00000410
+#define EBI_DEV4_FIFO_CONFIG(base)	((base) + EBI_DEV4_FIFO_CONFIG_OFFS)
+#define EBI_DEV4_FLASH_CONF_ST_OFFS	0x00000414
+#define EBI_DEV4_FLASH_CONF_ST(base)	((base) + EBI_DEV4_FLASH_CONF_ST_OFFS)
+#define EBI_DEV4_DMA_CONFIG1_OFFS	0x00000418
+#define EBI_DEV4_DMA_CONFIG1(base)	((base) + EBI_DEV4_DMA_CONFIG1_OFFS)
+#define EBI_DEV4_DMA_CONFIG2_OFFS	0x0000041C
+#define EBI_DEV4_DMA_CONFIG2(base)	((base) + EBI_DEV4_DMA_CONFIG2_OFFS)
+#define EBI_DEV4_TIM1_RD1_OFFS		0x00000424
+#define EBI_DEV4_TIM1_RD1(base)		((base) + EBI_DEV4_TIM1_RD1_OFFS)
+#define EBI_DEV4_TIM1_RD2_OFFS		0x00000428
+#define EBI_DEV4_TIM1_RD2(base)		((base) + EBI_DEV4_TIM1_RD2_OFFS)
+#define EBI_DEV4_TIM1_WR1_OFFS		0x0000042C
+#define EBI_DEV4_TIM1_WR1(base)		((base) + EBI_DEV4_TIM1_WR1_OFFS)
+#define EBI_DEV4_TIM1_WR2_OFFS		0x00000430
+#define EBI_DEV4_TIM1_WR2(base)		((base) + EBI_DEV4_TIM1_WR2_OFFS)
+#define EBI_DEV4_TIM_EXT_OFFS		0x00000434
+#define EBI_DEV4_TIM_EXT(base)		((base) + EBI_DEV4_TIM_EXT_OFFS)
+#define EBI_DEV4_TIM2_CFI_RD1_OFFS	0x00000438
+#define EBI_DEV4_TIM2_CFI_RD1(base)	((base) + EBI_DEV4_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV4_TIM2_CFI_RD2_OFFS	0x0000043C
+#define EBI_DEV4_TIM2_CFI_RD2(base)	((base) + EBI_DEV4_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV4_TIM3_DMA1_OFFS		0x00000440
+#define EBI_DEV4_TIM3_DMA1(base)	((base) + EBI_DEV4_TIM3_DMA1_OFFS)
+#define EBI_DEV4_TIM3_DMA2_OFFS		0x00000444
+#define EBI_DEV4_TIM3_DMA2(base)	((base) + EBI_DEV4_TIM3_DMA2_OFFS)
+#define EBI_DEV4_ACK_RM_CNT_OFFS	0x00000450
+#define EBI_DEV4_ACK_RM_CNT(base)	((base) + EBI_DEV4_ACK_RM_CNT_OFFS)
+#define EBI_CNT_FL_PROGR_OFFS		0x00000904
+#define EBI_CNT_FL_PROGR(base)		((base) + EBI_CNT_FL_PROGR_OFFS)
+#define EBI_CNT_EXT_PAGE_SZ_OFFS	0x0000090C
+#define EBI_CNT_EXT_PAGE_SZ(base)	((base) + EBI_CNT_EXT_PAGE_SZ_OFFS)
+#define EBI_CNT_WAIT_RDY_OFFS		0x00000914
+#define EBI_CNT_WAIT_RDY(base)		((base) + EBI_CNT_WAIT_RDY_OFFS)
+#define EBI_CNT_ACK_OFFS		0x00000918
+#define EBI_CNT_ACK(base)		((base) + EBI_CNT_ACK_OFFS)
+#define EBI_GENIO1_CONFIG1_OFFS		0x00000A00
+#define EBI_GENIO1_CONFIG1(base)	((base) + EBI_GENIO1_CONFIG1_OFFS)
+#define EBI_GENIO1_CONFIG2_OFFS		0x00000A04
+#define EBI_GENIO1_CONFIG2(base)	((base) + EBI_GENIO1_CONFIG2_OFFS)
+#define EBI_GENIO1_CONFIG3_OFFS		0x00000A08
+#define EBI_GENIO1_CONFIG3(base)	((base) + EBI_GENIO1_CONFIG3_OFFS)
+#define EBI_GENIO2_CONFIG1_OFFS		0x00000A10
+#define EBI_GENIO2_CONFIG1(base)	((base) + EBI_GENIO2_CONFIG1_OFFS)
+#define EBI_GENIO2_CONFIG2_OFFS		0x00000A14
+#define EBI_GENIO2_CONFIG2(base)	((base) + EBI_GENIO2_CONFIG2_OFFS)
+#define EBI_GENIO2_CONFIG3_OFFS		0x00000A18
+#define EBI_GENIO2_CONFIG3(base)	((base) + EBI_GENIO2_CONFIG3_OFFS)
+#define EBI_GENIO3_CONFIG1_OFFS		0x00000A20
+#define EBI_GENIO3_CONFIG1(base)	((base) + EBI_GENIO3_CONFIG1_OFFS)
+#define EBI_GENIO3_CONFIG2_OFFS		0x00000A24
+#define EBI_GENIO3_CONFIG2(base)	((base) + EBI_GENIO3_CONFIG2_OFFS)
+#define EBI_GENIO3_CONFIG3_OFFS		0x00000A28
+#define EBI_GENIO3_CONFIG3(base)	((base) + EBI_GENIO3_CONFIG3_OFFS)
+#define EBI_GENIO4_CONFIG1_OFFS		0x00000A30
+#define EBI_GENIO4_CONFIG1(base)	((base) + EBI_GENIO4_CONFIG1_OFFS)
+#define EBI_GENIO4_CONFIG2_OFFS		0x00000A34
+#define EBI_GENIO4_CONFIG2(base)	((base) + EBI_GENIO4_CONFIG2_OFFS)
+#define EBI_GENIO4_CONFIG3_OFFS		0x00000A38
+#define EBI_GENIO4_CONFIG3(base)	((base) + EBI_GENIO4_CONFIG3_OFFS)
+#define EBI_GENIO5_CONFIG1_OFFS		0x00000A40
+#define EBI_GENIO5_CONFIG1(base)	((base) + EBI_GENIO5_CONFIG1_OFFS)
+#define EBI_GENIO5_CONFIG2_OFFS		0x00000A44
+#define EBI_GENIO5_CONFIG2(base)	((base) + EBI_GENIO5_CONFIG2_OFFS)
+#define EBI_GENIO5_CONFIG3_OFFS		0x00000A48
+#define EBI_GENIO5_CONFIG3(base)	((base) + EBI_GENIO5_CONFIG3_OFFS)
+
+#endif
diff -Naur u-boot-2009.01/board/micronas/vct/vcth/reg_fwsram.h u-boot/board/micronas/vct/vcth/reg_fwsram.h
--- u-boot-2009.01/board/micronas/vct/vcth/reg_fwsram.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vcth/reg_fwsram.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,73 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Premium & Platinum register addresses/definitions seem to be
+ * identical, so we only need to use one file for both platforms.
+ */
+
+#ifndef _REG_FWSRAM_H_
+#define _REG_FWSRAM_H_
+
+#define FWSRAM_BASE			0x00030000
+
+/*  Relative offsets of the register adresses */
+
+#define FWSRAM_SR_ADDR_OFFSET_OFFS	0x00002000
+#define FWSRAM_SR_ADDR_OFFSET(base)	((base) + FWSRAM_SR_ADDR_OFFSET_OFFS)
+#define FWSRAM_TOP_BOOT_LOG_OFFS	0x00002004
+#define FWSRAM_TOP_BOOT_LOG(base)	((base) + FWSRAM_TOP_BOOT_LOG_OFFS)
+#define FWSRAM_TOP_ROM_KBIST_OFFS	0x00002008
+#define FWSRAM_TOP_ROM_KBIST(base)	((base) + FWSRAM_TOP_ROM_KBIST_OFFS)
+#define FWSRAM_TOP_CID1_H_OFFS		0x0000200C
+#define FWSRAM_TOP_CID1_H(base)		((base) + FWSRAM_TOP_CID1_H_OFFS)
+#define FWSRAM_TOP_CID1_L_OFFS		0x00002010
+#define FWSRAM_TOP_CID1_L(base)		((base) + FWSRAM_TOP_CID1_L_OFFS)
+#define FWSRAM_TOP_CID2_H_OFFS		0x00002014
+#define FWSRAM_TOP_CID2_H(base)		((base) + FWSRAM_TOP_CID2_H_OFFS)
+#define FWSRAM_TOP_CID2_L_OFFS		0x00002018
+#define FWSRAM_TOP_CID2_L(base)		((base) + FWSRAM_TOP_CID2_L_OFFS)
+#define FWSRAM_TOP_TDO_CFG_OFFS		0x0000203C
+#define FWSRAM_TOP_TDO_CFG(base)	((base) + FWSRAM_TOP_TDO_CFG_OFFS)
+#define FWSRAM_TOP_GPIO2_0_CFG_OFFS	0x00002040
+#define FWSRAM_TOP_GPIO2_0_CFG(base)	((base) + FWSRAM_TOP_GPIO2_0_CFG_OFFS)
+#define FWSRAM_TOP_GPIO2_1_CFG_OFFS	0x00002044
+#define FWSRAM_TOP_GPIO2_1_CFG(base)	((base) + FWSRAM_TOP_GPIO2_1_CFG_OFFS)
+#define FWSRAM_TOP_GPIO2_2_CFG_OFFS	0x00002048
+#define FWSRAM_TOP_GPIO2_2_CFG(base)	((base) + FWSRAM_TOP_GPIO2_2_CFG_OFFS)
+#define FWSRAM_TOP_GPIO2_3_CFG_OFFS	0x0000204C
+#define FWSRAM_TOP_GPIO2_3_CFG(base)	((base) + FWSRAM_TOP_GPIO2_3_CFG_OFFS)
+#define FWSRAM_TOP_GPIO2_4_CFG_OFFS	0x00002050
+#define FWSRAM_TOP_GPIO2_4_CFG(base)	((base) + FWSRAM_TOP_GPIO2_4_CFG_OFFS)
+#define FWSRAM_TOP_GPIO2_5_CFG_OFFS	0x00002054
+#define FWSRAM_TOP_GPIO2_5_CFG(base)	((base) + FWSRAM_TOP_GPIO2_5_CFG_OFFS)
+#define FWSRAM_TOP_GPIO2_6_CFG_OFFS	0x00002058
+#define FWSRAM_TOP_GPIO2_6_CFG(base)	((base) + FWSRAM_TOP_GPIO2_6_CFG_OFFS)
+#define FWSRAM_TOP_GPIO2_7_CFG_OFFS	0x0000205C
+#define FWSRAM_TOP_GPIO2_7_CFG(base)	((base) + FWSRAM_TOP_GPIO2_7_CFG_OFFS)
+#define FWSRAM_TOP_SCL_CFG_OFFS		0x00002060
+#define FWSRAM_TOP_SCL_CFG(base)	((base) + FWSRAM_TOP_SCL_CFG_OFFS)
+#define FWSRAM_TOP_SDA_CFG_OFFS		0x00002064
+#define FWSRAM_TOP_SDA_CFG(base)	((base) + FWSRAM_TOP_SDA_CFG_OFFS)
+#define FWSRAM_NO_MCM_FLASH_OFFS	0x00002068
+#define FWSRAM_NO_MCM_FLASH(base)	((base) + FWSRAM_NO_MCM_FLASH_OFFS)
+
+#endif
diff -Naur u-boot-2009.01/board/micronas/vct/vcth/reg_gpio.h u-boot/board/micronas/vct/vcth/reg_gpio.h
--- u-boot-2009.01/board/micronas/vct/vcth/reg_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vcth/reg_gpio.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define GPIO1_BASE		0x00088000
+#define GPIO2_BASE		0x0008c000
+
+/* Instances */
+#define GPIO_INSTANCES		2
+
+/*  Relative offsets of the register adresses */
+#define GPIO_SWPORTA_DR_OFFS	0x00000000
+#define GPIO_SWPORTA_DR(base)	((base) + GPIO_SWPORTA_DR_OFFS)
+#define GPIO_SWPORTA_DDR_OFFS	0x00000004
+#define GPIO_SWPORTA_DDR(base)	((base) + GPIO_SWPORTA_DDR_OFFS)
+#define GPIO_EXT_PORTA_OFFS	0x00000050
+#define GPIO_EXT_PORTA(base)	((base) + GPIO_EXT_PORTA_OFFS)
diff -Naur u-boot-2009.01/board/micronas/vct/vcth/reg_scc.h u-boot/board/micronas/vct/vcth/reg_scc.h
--- u-boot-2009.01/board/micronas/vct/vcth/reg_scc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vcth/reg_scc.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,102 @@
+/*
+ * (C) Copyright 2009 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _REG_SCC_PREMIUM_H_
+#define _REG_SCC_PREMIUM_H_
+
+#define SCC0_BASE		0x00110000
+#define SCC1_BASE		0x00110080
+#define SCC2_BASE		0x00110100
+#define SCC3_BASE		0x00110180
+#define SCC4_BASE		0x00110200
+#define SCC5_BASE		0x00110280
+#define SCC6_BASE		0x00110300
+#define SCC7_BASE		0x00110380
+#define SCC8_BASE		0x00110400
+#define SCC9_BASE		0x00110480
+#define SCC10_BASE		0x00110500
+#define SCC11_BASE		0x00110580
+#define SCC12_BASE		0x00110600
+#define SCC13_BASE		0x00110680
+#define SCC14_BASE		0x00110700
+#define SCC15_BASE		0x00110780
+#define SCC16_BASE		0x00110800
+#define SCC17_BASE		0x00110880
+#define SCC18_BASE		0x00110900
+#define SCC19_BASE		0x00110980
+#define SCC20_BASE		0x00110a00
+#define SCC21_BASE		0x00110a80
+#define SCC22_BASE		0x00110b00
+#define SCC23_BASE		0x00110b80
+#define SCC24_BASE		0x00110c00
+#define SCC25_BASE		0x00110c80
+#define SCC26_BASE		0x00110d00
+#define SCC27_BASE		0x00110d80
+#define SCC28_BASE		0x00110e00
+#define SCC29_BASE		0x00110e80
+#define SCC30_BASE		0x00110f00
+#define SCC31_BASE		0x00110f80
+#define SCC32_BASE		0x00111000
+#define SCC33_BASE		0x00111080
+#define SCC34_BASE		0x00111100
+#define SCC35_BASE		0x00111180
+#define SCC36_BASE		0x00111200
+#define SCC37_BASE		0x00111280
+#define SCC38_BASE		0x00111300
+#define SCC39_BASE		0x00111380
+#define SCC40_BASE		0x00111400
+
+/*  Relative offsets of the register adresses */
+
+#define SCC_ENABLE_OFFS		0x00000000
+#define SCC_ENABLE(base)	((base) + SCC_ENABLE_OFFS)
+#define SCC_RESET_OFFS		0x00000004
+#define SCC_RESET(base)		((base) + SCC_RESET_OFFS)
+#define SCC_VCID_OFFS		0x00000008
+#define SCC_VCID(base)		((base) + SCC_VCID_OFFS)
+#define SCC_MCI_CFG_OFFS	0x0000000C
+#define SCC_MCI_CFG(base)	((base) + SCC_MCI_CFG_OFFS)
+#define SCC_PACKET_CFG1_OFFS	0x00000010
+#define SCC_PACKET_CFG1(base)	((base) + SCC_PACKET_CFG1_OFFS)
+#define SCC_PACKET_CFG2_OFFS	0x00000014
+#define SCC_PACKET_CFG2(base)	((base) + SCC_PACKET_CFG2_OFFS)
+#define SCC_PACKET_CFG3_OFFS	0x00000018
+#define SCC_PACKET_CFG3(base)	((base) + SCC_PACKET_CFG3_OFFS)
+#define SCC_DMA_CFG_OFFS	0x0000001C
+#define SCC_DMA_CFG(base)	((base) + SCC_DMA_CFG_OFFS)
+#define SCC_CMD_OFFS		0x00000020
+#define SCC_CMD(base)		((base) + SCC_CMD_OFFS)
+#define SCC_PRIO_OFFS		0x00000024
+#define SCC_PRIO(base)		((base) + SCC_PRIO_OFFS)
+#define SCC_DEBUG_OFFS		0x00000028
+#define SCC_DEBUG(base)		((base) + SCC_DEBUG_OFFS)
+#define SCC_STATUS_OFFS		0x0000002C
+#define SCC_STATUS(base)	((base) + SCC_STATUS_OFFS)
+#define SCC_IMR_OFFS		0x00000030
+#define SCC_IMR(base)		((base) + SCC_IMR_OFFS)
+#define SCC_ISR_OFFS		0x00000034
+#define SCC_ISR(base)		((base) + SCC_ISR_OFFS)
+#define SCC_DMA_OFFSET_OFFS	0x00000038
+#define SCC_DMA_OFFSET(base)	((base) + SCC_DMA_OFFSET_OFFS)
+#define SCC_RS_CTLSTS_OFFS	0x0000003C
+#define SCC_RS_CTLSTS(base)	((base) + SCC_RS_CTLSTS_OFFS)
+
+#endif
diff -Naur u-boot-2009.01/board/micronas/vct/vcth/reg_usbh.h u-boot/board/micronas/vct/vcth/reg_usbh.h
--- u-boot-2009.01/board/micronas/vct/vcth/reg_usbh.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vcth/reg_usbh.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,33 @@
+/*
+ * (C) Copyright 2009 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define USBH_BASE		0x00080000
+
+/* Relative offsets of the register adresses */
+
+#define USBH_CAPLENGTH_OFFS	0x00000100
+#define USBH_CAPLENGTH(base)	((base) + USBH_CAPLENGTH_OFFS)
+#define USBH_USBCMD_OFFS	0x00000140
+#define USBH_USBCMD(base)	((base) + USBH_USBCMD_OFFS)
+#define USBH_BURSTSIZE_OFFS	0x00000160
+#define USBH_BURSTSIZE(base)	((base) + USBH_BURSTSIZE_OFFS)
+#define USBH_USBMODE_OFFS	0x000001A8
+#define USBH_USBMODE(base)	((base) + USBH_USBMODE_OFFS)
+#define USBH_USBHMISC_OFFS	0x00000200
+#define USBH_USBHMISC(base)	((base) + USBH_USBHMISC_OFFS)
diff -Naur u-boot-2009.01/board/micronas/vct/vcth/reg_wdt.h u-boot/board/micronas/vct/vcth/reg_wdt.h
--- u-boot-2009.01/board/micronas/vct/vcth/reg_wdt.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vcth/reg_wdt.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define WDT_BASE		0x000b0000
+#define WDT_CR_OFFS		0x00000000
+#define WDT_CR(base)		((base) + WDT_CR_OFFS)
+#define WDT_TORR_OFFS		0x00000004
+#define WDT_TORR(base)		((base) + WDT_TORR_OFFS)
diff -Naur u-boot-2009.01/board/micronas/vct/vct.h u-boot/board/micronas/vct/vct.h
--- u-boot-2009.01/board/micronas/vct/vct.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vct.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,104 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/io.h>
+
+#include "bcu.h"
+#include "dcgu.h"
+#include "ebi.h"
+#include "scc.h"
+
+#ifdef CONFIG_VCT_PREMIUM
+/* Global start address of all memory mapped registers */
+#define REG_GLOBAL_START_ADDR	0xbf800000
+#define TOP_BASE		0x000c8000
+
+#include "vcth/reg_ebi.h"
+#include "vcth/reg_dcgu.h"
+#include "vcth/reg_wdt.h"
+#include "vcth/reg_gpio.h"
+#include "vcth/reg_fwsram.h"
+#include "vcth/reg_scc.h"
+#include "vcth/reg_usbh.h"
+#endif
+
+#ifdef CONFIG_VCT_PLATINUM
+/* Global start address of all memory mapped registers */
+#define REG_GLOBAL_START_ADDR	0xbf800000
+#define TOP_BASE		0x000c8000
+
+#include "vcth2/reg_ebi.h"
+#include "vcth/reg_dcgu.h"
+#include "vcth/reg_wdt.h"
+#include "vcth/reg_gpio.h"
+#include "vcth/reg_fwsram.h"
+#include "vcth/reg_scc.h"
+#include "vcth/reg_usbh.h"
+#endif
+
+#ifdef CONFIG_VCT_PLATINUMAVC
+/* Global start address of all memory mapped registers */
+#define REG_GLOBAL_START_ADDR	0xbdc00000
+#define TOP_BASE		0x00050000
+
+#include "vctv/reg_ebi.h"
+#include "vctv/reg_dcgu.h"
+#include "vctv/reg_wdt.h"
+#include "vctv/reg_gpio.h"
+#endif
+
+#ifndef _VCT_H
+#define _VCT_H
+
+/*
+ * Defines
+ */
+#define PRID_COMP_LEGACY	0x000000
+#define PRID_COMP_MIPS		0x010000
+#define PRID_IMP_LX4280		0xc200
+#define PRID_IMP_VGC		0x9000
+
+/*
+ * Prototypes
+ */
+int ebi_initialize(void);
+int ebi_init_nor_flash(void);
+int ebi_init_onenand(void);
+int ebi_init_smc911x(void);
+u32 smc911x_reg_read(u32 addr);
+void smc911x_reg_write(u32 addr, u32 data);
+int top_set_pin(int pin, int func);
+void vct_pin_mux_initialize(void);
+
+/*
+ * static inlines
+ */
+static inline void reg_write(u32 addr, u32 data)
+{
+	__raw_writel(data, addr + REG_GLOBAL_START_ADDR);
+}
+
+static inline u32 reg_read(u32 addr)
+{
+	return __raw_readl(addr + REG_GLOBAL_START_ADDR);
+}
+
+#endif /* _VCT_H */
diff -Naur u-boot-2009.01/board/micronas/vct/vcth2/reg_ebi.h u-boot/board/micronas/vct/vcth2/reg_ebi.h
--- u-boot-2009.01/board/micronas/vct/vcth2/reg_ebi.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vcth2/reg_ebi.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,290 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _REG_EBI_PREMIUM_H_
+#define _REG_EBI_PREMIUM_H_
+
+#define EBI_BASE			0x00000000
+
+/*  Relative offsets of the register adresses */
+
+#define EBI_CPU_IO_ACCS_OFFS		0x00000000
+#define EBI_CPU_IO_ACCS(base)		((base) + EBI_CPU_IO_ACCS_OFFS)
+#define EBI_IO_ACCS_DATA_OFFS		0x00000004
+#define EBI_IO_ACCS_DATA(base)		((base) + EBI_IO_ACCS_DATA_OFFS)
+#define EBI_CPU_IO_ACCS2_OFFS		0x00000008
+#define EBI_CPU_IO_ACCS2(base)		((base) + EBI_CPU_IO_ACCS2_OFFS)
+#define EBI_IO_ACCS2_DATA_OFFS		0x0000000C
+#define EBI_IO_ACCS2_DATA(base)		((base) + EBI_IO_ACCS2_DATA_OFFS)
+#define EBI_CTRL_OFFS			0x00000010
+#define EBI_CTRL(base)			((base) + EBI_CTRL_OFFS)
+#define EBI_IRQ_MASK_OFFS		0x00000018
+#define EBI_IRQ_MASK(base)		((base) + EBI_IRQ_MASK_OFFS)
+#define EBI_IRQ_MASK2_OFFS		0x0000001C
+#define EBI_IRQ_MASK2(base)		((base) + EBI_IRQ_MASK2_OFFS)
+#define EBI_TAG1_SYS_ID_OFFS		0x00000030
+#define EBI_TAG1_SYS_ID(base)		((base) + EBI_TAG1_SYS_ID_OFFS)
+#define EBI_TAG2_SYS_ID_OFFS		0x00000040
+#define EBI_TAG2_SYS_ID(base)		((base) + EBI_TAG2_SYS_ID_OFFS)
+#define EBI_TAG3_SYS_ID_OFFS		0x00000050
+#define EBI_TAG3_SYS_ID(base)		((base) + EBI_TAG3_SYS_ID_OFFS)
+#define EBI_TAG4_SYS_ID_OFFS		0x00000060
+#define EBI_TAG4_SYS_ID(base)		((base) + EBI_TAG4_SYS_ID_OFFS)
+#define EBI_GEN_DMA_CTRL_OFFS		0x00000070
+#define EBI_GEN_DMA_CTRL(base)		((base) + EBI_GEN_DMA_CTRL_OFFS)
+#define EBI_STATUS_OFFS			0x00000080
+#define EBI_STATUS(base)		((base) + EBI_STATUS_OFFS)
+#define EBI_STATUS_DMA_CNT_OFFS		0x00000084
+#define EBI_STATUS_DMA_CNT(base)	((base) + EBI_STATUS_DMA_CNT_OFFS)
+#define EBI_SIG_LEVEL_OFFS		0x00000088
+#define EBI_SIG_LEVEL(base)		((base) + EBI_SIG_LEVEL_OFFS)
+#define EBI_CTRL_SIG_ACTLV_OFFS		0x0000008C
+#define EBI_CTRL_SIG_ACTLV(base)	((base) + EBI_CTRL_SIG_ACTLV_OFFS)
+#define EBI_CRC_GEN_OFFS		0x00000090
+#define EBI_CRC_GEN(base)		((base) + EBI_CRC_GEN_OFFS)
+#define EBI_EXT_ADDR_OFFS		0x000000A0
+#define EBI_EXT_ADDR(base)		((base) + EBI_EXT_ADDR_OFFS)
+#define EBI_IRQ_STATUS_OFFS		0x000000B0
+#define EBI_IRQ_STATUS(base)		((base) + EBI_IRQ_STATUS_OFFS)
+#define EBI_IRQ_STATUS2_OFFS		0x000000B4
+#define EBI_IRQ_STATUS2(base)		((base) + EBI_IRQ_STATUS2_OFFS)
+#define EBI_EXT_MASTER_SRAM_HIGH_OFFS	0x000000C0
+#define EBI_EXT_MASTER_SRAM_HIGH(base)	((base) + EBI_EXT_MASTER_SRAM_HIGH_OFFS)
+#define EBI_EXT_MASTER_SRAM_LOW_OFFS	0x000000C4
+#define EBI_EXT_MASTER_SRAM_LOW(base)	((base) + EBI_EXT_MASTER_SRAM_LOW_OFFS)
+#define EBI_ECC0_OFFS			0x000000D0
+#define EBI_ECC0(base)			((base) + EBI_ECC0_OFFS)
+#define EBI_ECC1_OFFS			0x000000D4
+#define EBI_ECC1(base)			((base) + EBI_ECC1_OFFS)
+#define EBI_ECC2_OFFS			0x000000D8
+#define EBI_ECC2(base)			((base) + EBI_ECC2_OFFS)
+#define EBI_ECC3_OFFS			0x000000DC
+#define EBI_ECC3(base)			((base) + EBI_ECC3_OFFS)
+#define EBI_DEV1_DMA_EXT_ADDR_OFFS	0x00000100
+#define EBI_DEV1_DMA_EXT_ADDR(base)	((base) + EBI_DEV1_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV1_EXT_ACC_OFFS		0x00000104
+#define EBI_DEV1_EXT_ACC(base)		((base) + EBI_DEV1_EXT_ACC_OFFS)
+#define EBI_DEV1_CONFIG1_OFFS		0x00000108
+#define EBI_DEV1_CONFIG1(base)		((base) + EBI_DEV1_CONFIG1_OFFS)
+#define EBI_DEV1_CONFIG2_OFFS		0x0000010C
+#define EBI_DEV1_CONFIG2(base)		((base) + EBI_DEV1_CONFIG2_OFFS)
+#define EBI_DEV1_FIFO_CONFIG_OFFS	0x00000110
+#define EBI_DEV1_FIFO_CONFIG(base)	((base) + EBI_DEV1_FIFO_CONFIG_OFFS)
+#define EBI_DEV1_FLASH_CONF_ST_OFFS	0x00000114
+#define EBI_DEV1_FLASH_CONF_ST(base)	((base) + EBI_DEV1_FLASH_CONF_ST_OFFS)
+#define EBI_DEV1_DMA_CONFIG1_OFFS	0x00000118
+#define EBI_DEV1_DMA_CONFIG1(base)	((base) + EBI_DEV1_DMA_CONFIG1_OFFS)
+#define EBI_DEV1_DMA_CONFIG2_OFFS	0x0000011C
+#define EBI_DEV1_DMA_CONFIG2(base)	((base) + EBI_DEV1_DMA_CONFIG2_OFFS)
+#define EBI_DEV1_DMA_ECC_CTRL_OFFS	0x00000120
+#define EBI_DEV1_DMA_ECC_CTRL(base)	((base) + EBI_DEV1_DMA_ECC_CTRL_OFFS)
+#define EBI_DEV1_TIM1_RD1_OFFS		0x00000124
+#define EBI_DEV1_TIM1_RD1(base)		((base) + EBI_DEV1_TIM1_RD1_OFFS)
+#define EBI_DEV1_TIM1_RD2_OFFS		0x00000128
+#define EBI_DEV1_TIM1_RD2(base)		((base) + EBI_DEV1_TIM1_RD2_OFFS)
+#define EBI_DEV1_TIM1_WR1_OFFS		0x0000012C
+#define EBI_DEV1_TIM1_WR1(base)		((base) + EBI_DEV1_TIM1_WR1_OFFS)
+#define EBI_DEV1_TIM1_WR2_OFFS		0x00000130
+#define EBI_DEV1_TIM1_WR2(base)		((base) + EBI_DEV1_TIM1_WR2_OFFS)
+#define EBI_DEV1_TIM_EXT_OFFS		0x00000134
+#define EBI_DEV1_TIM_EXT(base)		((base) + EBI_DEV1_TIM_EXT_OFFS)
+#define EBI_DEV1_TIM2_CFI_RD1_OFFS	0x00000138
+#define EBI_DEV1_TIM2_CFI_RD1(base)	((base) + EBI_DEV1_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV1_TIM2_CFI_RD2_OFFS	0x0000013C
+#define EBI_DEV1_TIM2_CFI_RD2(base)	((base) + EBI_DEV1_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV1_TIM3_DMA1_OFFS		0x00000140
+#define EBI_DEV1_TIM3_DMA1(base)	((base) + EBI_DEV1_TIM3_DMA1_OFFS)
+#define EBI_DEV1_TIM3_DMA2_OFFS		0x00000144
+#define EBI_DEV1_TIM3_DMA2(base)	((base) + EBI_DEV1_TIM3_DMA2_OFFS)
+#define EBI_DEV1_TIM4_UDMA1_OFFS	0x00000148
+#define EBI_DEV1_TIM4_UDMA1(base)	((base) + EBI_DEV1_TIM4_UDMA1_OFFS)
+#define EBI_DEV1_TIM4_UDMA2_OFFS	0x0000014C
+#define EBI_DEV1_TIM4_UDMA2(base)	((base) + EBI_DEV1_TIM4_UDMA2_OFFS)
+#define EBI_DEV1_ACK_RM_CNT_OFFS	0x00000150
+#define EBI_DEV1_ACK_RM_CNT(base)	((base) + EBI_DEV1_ACK_RM_CNT_OFFS)
+#define EBI_DEV2_DMA_EXT_ADDR_OFFS	0x00000200
+#define EBI_DEV2_DMA_EXT_ADDR(base)	((base) + EBI_DEV2_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV2_EXT_ACC_OFFS		0x00000204
+#define EBI_DEV2_EXT_ACC(base)		((base) + EBI_DEV2_EXT_ACC_OFFS)
+#define EBI_DEV2_CONFIG1_OFFS		0x00000208
+#define EBI_DEV2_CONFIG1(base)		((base) + EBI_DEV2_CONFIG1_OFFS)
+#define EBI_DEV2_CONFIG2_OFFS		0x0000020C
+#define EBI_DEV2_CONFIG2(base)		((base) + EBI_DEV2_CONFIG2_OFFS)
+#define EBI_DEV2_FIFO_CONFIG_OFFS	0x00000210
+#define EBI_DEV2_FIFO_CONFIG(base)	((base) + EBI_DEV2_FIFO_CONFIG_OFFS)
+#define EBI_DEV2_FLASH_CONF_ST_OFFS	0x00000214
+#define EBI_DEV2_FLASH_CONF_ST(base)	((base) + EBI_DEV2_FLASH_CONF_ST_OFFS)
+#define EBI_DEV2_DMA_CONFIG1_OFFS	0x00000218
+#define EBI_DEV2_DMA_CONFIG1(base)	((base) + EBI_DEV2_DMA_CONFIG1_OFFS)
+#define EBI_DEV2_DMA_CONFIG2_OFFS	0x0000021C
+#define EBI_DEV2_DMA_CONFIG2(base)	((base) + EBI_DEV2_DMA_CONFIG2_OFFS)
+#define EBI_DEV2_DMA_ECC_CTRL_OFFS	0x00000220
+#define EBI_DEV2_DMA_ECC_CTRL(base)	((base) + EBI_DEV2_DMA_ECC_CTRL_OFFS)
+#define EBI_DEV2_TIM1_RD1_OFFS		0x00000224
+#define EBI_DEV2_TIM1_RD1(base)		((base) + EBI_DEV2_TIM1_RD1_OFFS)
+#define EBI_DEV2_TIM1_RD2_OFFS		0x00000228
+#define EBI_DEV2_TIM1_RD2(base)		((base) + EBI_DEV2_TIM1_RD2_OFFS)
+#define EBI_DEV2_TIM1_WR1_OFFS		0x0000022C
+#define EBI_DEV2_TIM1_WR1(base)		((base) + EBI_DEV2_TIM1_WR1_OFFS)
+#define EBI_DEV2_TIM1_WR2_OFFS		0x00000230
+#define EBI_DEV2_TIM1_WR2(base)		((base) + EBI_DEV2_TIM1_WR2_OFFS)
+#define EBI_DEV2_TIM_EXT_OFFS		0x00000234
+#define EBI_DEV2_TIM_EXT(base)		((base) + EBI_DEV2_TIM_EXT_OFFS)
+#define EBI_DEV2_TIM2_CFI_RD1_OFFS	0x00000238
+#define EBI_DEV2_TIM2_CFI_RD1(base)	((base) + EBI_DEV2_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV2_TIM2_CFI_RD2_OFFS	0x0000023C
+#define EBI_DEV2_TIM2_CFI_RD2(base)	((base) + EBI_DEV2_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV2_TIM3_DMA1_OFFS		0x00000240
+#define EBI_DEV2_TIM3_DMA1(base)	((base) + EBI_DEV2_TIM3_DMA1_OFFS)
+#define EBI_DEV2_TIM3_DMA2_OFFS		0x00000244
+#define EBI_DEV2_TIM3_DMA2(base)	((base) + EBI_DEV2_TIM3_DMA2_OFFS)
+#define EBI_DEV2_TIM4_UDMA1_OFFS	0x00000248
+#define EBI_DEV2_TIM4_UDMA1(base)	((base) + EBI_DEV2_TIM4_UDMA1_OFFS)
+#define EBI_DEV2_TIM4_UDMA2_OFFS	0x0000024C
+#define EBI_DEV2_TIM4_UDMA2(base)	((base) + EBI_DEV2_TIM4_UDMA2_OFFS)
+#define EBI_DEV2_ACK_RM_CNT_OFFS	0x00000250
+#define EBI_DEV2_ACK_RM_CNT(base)	((base) + EBI_DEV2_ACK_RM_CNT_OFFS)
+#define EBI_DEV3_DMA_EXT_ADDR_OFFS	0x00000300
+#define EBI_DEV3_DMA_EXT_ADDR(base)	((base) + EBI_DEV3_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV3_EXT_ACC_OFFS		0x00000304
+#define EBI_DEV3_EXT_ACC(base)		((base) + EBI_DEV3_EXT_ACC_OFFS)
+#define EBI_DEV3_CONFIG1_OFFS		0x00000308
+#define EBI_DEV3_CONFIG1(base)		((base) + EBI_DEV3_CONFIG1_OFFS)
+#define EBI_DEV3_CONFIG2_OFFS		0x0000030C
+#define EBI_DEV3_CONFIG2(base)		((base) + EBI_DEV3_CONFIG2_OFFS)
+#define EBI_DEV3_FIFO_CONFIG_OFFS	0x00000310
+#define EBI_DEV3_FIFO_CONFIG(base)	((base) + EBI_DEV3_FIFO_CONFIG_OFFS)
+#define EBI_DEV3_FLASH_CONF_ST_OFFS	0x00000314
+#define EBI_DEV3_FLASH_CONF_ST(base)	((base) + EBI_DEV3_FLASH_CONF_ST_OFFS)
+#define EBI_DEV3_DMA_CONFIG1_OFFS	0x00000318
+#define EBI_DEV3_DMA_CONFIG1(base)	((base) + EBI_DEV3_DMA_CONFIG1_OFFS)
+#define EBI_DEV3_DMA_CONFIG2_OFFS	0x0000031C
+#define EBI_DEV3_DMA_CONFIG2(base)	((base) + EBI_DEV3_DMA_CONFIG2_OFFS)
+#define EBI_DEV3_DMA_ECC_CTRL_OFFS	0x00000320
+#define EBI_DEV3_DMA_ECC_CTRL(base)	((base) + EBI_DEV3_DMA_ECC_CTRL_OFFS)
+#define EBI_DEV3_TIM1_RD1_OFFS		0x00000324
+#define EBI_DEV3_TIM1_RD1(base)		((base) + EBI_DEV3_TIM1_RD1_OFFS)
+#define EBI_DEV3_TIM1_RD2_OFFS		0x00000328
+#define EBI_DEV3_TIM1_RD2(base)		((base) + EBI_DEV3_TIM1_RD2_OFFS)
+#define EBI_DEV3_TIM1_WR1_OFFS		0x0000032C
+#define EBI_DEV3_TIM1_WR1(base)		((base) + EBI_DEV3_TIM1_WR1_OFFS)
+#define EBI_DEV3_TIM1_WR2_OFFS		0x00000330
+#define EBI_DEV3_TIM1_WR2(base)		((base) + EBI_DEV3_TIM1_WR2_OFFS)
+#define EBI_DEV3_TIM_EXT_OFFS		0x00000334
+#define EBI_DEV3_TIM_EXT(base)		((base) + EBI_DEV3_TIM_EXT_OFFS)
+#define EBI_DEV3_TIM2_CFI_RD1_OFFS	0x00000338
+#define EBI_DEV3_TIM2_CFI_RD1(base)	((base) + EBI_DEV3_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV3_TIM2_CFI_RD2_OFFS	0x0000033C
+#define EBI_DEV3_TIM2_CFI_RD2(base)	((base) + EBI_DEV3_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV3_TIM3_DMA1_OFFS		0x00000340
+#define EBI_DEV3_TIM3_DMA1(base)	((base) + EBI_DEV3_TIM3_DMA1_OFFS)
+#define EBI_DEV3_TIM3_DMA2_OFFS		0x00000344
+#define EBI_DEV3_TIM3_DMA2(base)	((base) + EBI_DEV3_TIM3_DMA2_OFFS)
+#define EBI_DEV3_TIM4_UDMA1_OFFS	0x00000348
+#define EBI_DEV3_TIM4_UDMA1(base)	((base) + EBI_DEV3_TIM4_UDMA1_OFFS)
+#define EBI_DEV3_TIM4_UDMA2_OFFS	0x0000034C
+#define EBI_DEV3_TIM4_UDMA2(base)	((base) + EBI_DEV3_TIM4_UDMA2_OFFS)
+#define EBI_DEV3_ACK_RM_CNT_OFFS	0x00000350
+#define EBI_DEV3_ACK_RM_CNT(base)	((base) + EBI_DEV3_ACK_RM_CNT_OFFS)
+#define EBI_DEV4_DMA_EXT_ADDR_OFFS	0x00000400
+#define EBI_DEV4_DMA_EXT_ADDR(base)	((base) + EBI_DEV4_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV4_EXT_ACC_OFFS		0x00000404
+#define EBI_DEV4_EXT_ACC(base)		((base) + EBI_DEV4_EXT_ACC_OFFS)
+#define EBI_DEV4_CONFIG1_OFFS		0x00000408
+#define EBI_DEV4_CONFIG1(base)		((base) + EBI_DEV4_CONFIG1_OFFS)
+#define EBI_DEV4_CONFIG2_OFFS		0x0000040C
+#define EBI_DEV4_CONFIG2(base)		((base) + EBI_DEV4_CONFIG2_OFFS)
+#define EBI_DEV4_FIFO_CONFIG_OFFS	0x00000410
+#define EBI_DEV4_FIFO_CONFIG(base)	((base) + EBI_DEV4_FIFO_CONFIG_OFFS)
+#define EBI_DEV4_FLASH_CONF_ST_OFFS	0x00000414
+#define EBI_DEV4_FLASH_CONF_ST(base)	((base) + EBI_DEV4_FLASH_CONF_ST_OFFS)
+#define EBI_DEV4_DMA_CONFIG1_OFFS	0x00000418
+#define EBI_DEV4_DMA_CONFIG1(base)	((base) + EBI_DEV4_DMA_CONFIG1_OFFS)
+#define EBI_DEV4_DMA_CONFIG2_OFFS	0x0000041C
+#define EBI_DEV4_DMA_CONFIG2(base)	((base) + EBI_DEV4_DMA_CONFIG2_OFFS)
+#define EBI_DEV4_DMA_ECC_CTRL_OFFS	0x00000420
+#define EBI_DEV4_DMA_ECC_CTRL(base)	((base) + EBI_DEV4_DMA_ECC_CTRL_OFFS)
+#define EBI_DEV4_TIM1_RD1_OFFS		0x00000424
+#define EBI_DEV4_TIM1_RD1(base)		((base) + EBI_DEV4_TIM1_RD1_OFFS)
+#define EBI_DEV4_TIM1_RD2_OFFS		0x00000428
+#define EBI_DEV4_TIM1_RD2(base)		((base) + EBI_DEV4_TIM1_RD2_OFFS)
+#define EBI_DEV4_TIM1_WR1_OFFS		0x0000042C
+#define EBI_DEV4_TIM1_WR1(base)		((base) + EBI_DEV4_TIM1_WR1_OFFS)
+#define EBI_DEV4_TIM1_WR2_OFFS		0x00000430
+#define EBI_DEV4_TIM1_WR2(base)		((base) + EBI_DEV4_TIM1_WR2_OFFS)
+#define EBI_DEV4_TIM_EXT_OFFS		0x00000434
+#define EBI_DEV4_TIM_EXT(base)		((base) + EBI_DEV4_TIM_EXT_OFFS)
+#define EBI_DEV4_TIM2_CFI_RD1_OFFS	0x00000438
+#define EBI_DEV4_TIM2_CFI_RD1(base)	((base) + EBI_DEV4_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV4_TIM2_CFI_RD2_OFFS	0x0000043C
+#define EBI_DEV4_TIM2_CFI_RD2(base)	((base) + EBI_DEV4_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV4_TIM3_DMA1_OFFS		0x00000440
+#define EBI_DEV4_TIM3_DMA1(base)	((base) + EBI_DEV4_TIM3_DMA1_OFFS)
+#define EBI_DEV4_TIM3_DMA2_OFFS		0x00000444
+#define EBI_DEV4_TIM3_DMA2(base)	((base) + EBI_DEV4_TIM3_DMA2_OFFS)
+#define EBI_DEV4_TIM4_UDMA1_OFFS	0x00000448
+#define EBI_DEV4_TIM4_UDMA1(base)	((base) + EBI_DEV4_TIM4_UDMA1_OFFS)
+#define EBI_DEV4_TIM4_UDMA2_OFFS	0x0000044C
+#define EBI_DEV4_TIM4_UDMA2(base)	((base) + EBI_DEV4_TIM4_UDMA2_OFFS)
+#define EBI_DEV4_ACK_RM_CNT_OFFS	0x00000450
+#define EBI_DEV4_ACK_RM_CNT(base)	((base) + EBI_DEV4_ACK_RM_CNT_OFFS)
+#define EBI_INTERLEAVE_CNT_OFFS		0x00000900
+#define EBI_INTERLEAVE_CNT(base)	((base) + EBI_INTERLEAVE_CNT_OFFS)
+#define EBI_CNT_FL_PROGR_OFFS		0x00000904
+#define EBI_CNT_FL_PROGR(base)		((base) + EBI_CNT_FL_PROGR_OFFS)
+#define EBI_CNT_EXT_PAGE_SZ_OFFS	0x0000090C
+#define EBI_CNT_EXT_PAGE_SZ(base)	((base) + EBI_CNT_EXT_PAGE_SZ_OFFS)
+#define EBI_CNT_WAIT_RDY_OFFS		0x00000914
+#define EBI_CNT_WAIT_RDY(base)		((base) + EBI_CNT_WAIT_RDY_OFFS)
+#define EBI_CNT_ACK_OFFS		0x00000918
+#define EBI_CNT_ACK(base)		((base) + EBI_CNT_ACK_OFFS)
+#define EBI_GENIO1_CONFIG1_OFFS		0x00000A00
+#define EBI_GENIO1_CONFIG1(base)	((base) + EBI_GENIO1_CONFIG1_OFFS)
+#define EBI_GENIO1_CONFIG2_OFFS		0x00000A04
+#define EBI_GENIO1_CONFIG2(base)	((base) + EBI_GENIO1_CONFIG2_OFFS)
+#define EBI_GENIO1_CONFIG3_OFFS		0x00000A08
+#define EBI_GENIO1_CONFIG3(base)	((base) + EBI_GENIO1_CONFIG3_OFFS)
+#define EBI_GENIO2_CONFIG1_OFFS		0x00000A10
+#define EBI_GENIO2_CONFIG1(base)	((base) + EBI_GENIO2_CONFIG1_OFFS)
+#define EBI_GENIO2_CONFIG2_OFFS		0x00000A14
+#define EBI_GENIO2_CONFIG2(base)	((base) + EBI_GENIO2_CONFIG2_OFFS)
+#define EBI_GENIO2_CONFIG3_OFFS		0x00000A18
+#define EBI_GENIO2_CONFIG3(base)	((base) + EBI_GENIO2_CONFIG3_OFFS)
+#define EBI_GENIO3_CONFIG1_OFFS		0x00000A20
+#define EBI_GENIO3_CONFIG1(base)	((base) + EBI_GENIO3_CONFIG1_OFFS)
+#define EBI_GENIO3_CONFIG2_OFFS		0x00000A24
+#define EBI_GENIO3_CONFIG2(base)	((base) + EBI_GENIO3_CONFIG2_OFFS)
+#define EBI_GENIO3_CONFIG3_OFFS		0x00000A28
+#define EBI_GENIO3_CONFIG3(base)	((base) + EBI_GENIO3_CONFIG3_OFFS)
+#define EBI_GENIO4_CONFIG1_OFFS		0x00000A30
+#define EBI_GENIO4_CONFIG1(base)	((base) + EBI_GENIO4_CONFIG1_OFFS)
+#define EBI_GENIO4_CONFIG2_OFFS		0x00000A34
+#define EBI_GENIO4_CONFIG2(base)	((base) + EBI_GENIO4_CONFIG2_OFFS)
+#define EBI_GENIO4_CONFIG3_OFFS		0x00000A38
+#define EBI_GENIO4_CONFIG3(base)	((base) + EBI_GENIO4_CONFIG3_OFFS)
+#define EBI_GENIO5_CONFIG1_OFFS		0x00000A40
+#define EBI_GENIO5_CONFIG1(base)	((base) + EBI_GENIO5_CONFIG1_OFFS)
+#define EBI_GENIO5_CONFIG2_OFFS		0x00000A44
+#define EBI_GENIO5_CONFIG2(base)	((base) + EBI_GENIO5_CONFIG2_OFFS)
+#define EBI_GENIO5_CONFIG3_OFFS		0x00000A48
+#define EBI_GENIO5_CONFIG3(base)	((base) + EBI_GENIO5_CONFIG3_OFFS)
+
+#endif
diff -Naur u-boot-2009.01/board/micronas/vct/vctv/reg_dcgu.h u-boot/board/micronas/vct/vctv/reg_dcgu.h
--- u-boot-2009.01/board/micronas/vct/vctv/reg_dcgu.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vctv/reg_dcgu.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,25 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define DCGU_BASE		0x0004c000
+#define DCGU_EN_WDT_RESET_OFFS	0x000000FC
+#define DCGU_EN_WDT_RESET(base)	((base) + DCGU_EN_WDT_RESET_OFFS)
+
+/* The magic value to write in order to activate the WDT */
+#define DCGU_MAGIC_WDT		0x1909
diff -Naur u-boot-2009.01/board/micronas/vct/vctv/reg_ebi.h u-boot/board/micronas/vct/vctv/reg_ebi.h
--- u-boot-2009.01/board/micronas/vct/vctv/reg_ebi.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vctv/reg_ebi.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,290 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Copyright (C) 2006 Micronas GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _REG_EBI_PLATINUMAVC_H_
+#define _REG_EBI_PLATINUMAVC_H_
+
+#define EBI_BASE			0x00014000
+
+/*  Relative offsets of the register adresses */
+
+#define EBI_CPU_IO_ACCS_OFFS		0x00000000
+#define EBI_CPU_IO_ACCS(base)		((base) + EBI_CPU_IO_ACCS_OFFS)
+#define EBI_IO_ACCS_DATA_OFFS		0x00000004
+#define EBI_IO_ACCS_DATA(base)		((base) + EBI_IO_ACCS_DATA_OFFS)
+#define EBI_CPU_IO_ACCS2_OFFS		0x00000008
+#define EBI_CPU_IO_ACCS2(base)		((base) + EBI_CPU_IO_ACCS2_OFFS)
+#define EBI_IO_ACCS2_DATA_OFFS		0x0000000C
+#define EBI_IO_ACCS2_DATA(base)		((base) + EBI_IO_ACCS2_DATA_OFFS)
+#define EBI_CTRL_OFFS			0x00000010
+#define EBI_CTRL(base)			((base) + EBI_CTRL_OFFS)
+#define EBI_IRQ_MASK_OFFS		0x00000018
+#define EBI_IRQ_MASK(base)		((base) + EBI_IRQ_MASK_OFFS)
+#define EBI_IRQ_MASK2_OFFS		0x0000001C
+#define EBI_IRQ_MASK2(base)		((base) + EBI_IRQ_MASK2_OFFS)
+#define EBI_TAG1_SYS_ID_OFFS		0x00000030
+#define EBI_TAG1_SYS_ID(base)		((base) + EBI_TAG1_SYS_ID_OFFS)
+#define EBI_TAG2_SYS_ID_OFFS		0x00000040
+#define EBI_TAG2_SYS_ID(base)		((base) + EBI_TAG2_SYS_ID_OFFS)
+#define EBI_TAG3_SYS_ID_OFFS		0x00000050
+#define EBI_TAG3_SYS_ID(base)		((base) + EBI_TAG3_SYS_ID_OFFS)
+#define EBI_TAG4_SYS_ID_OFFS		0x00000060
+#define EBI_TAG4_SYS_ID(base)		((base) + EBI_TAG4_SYS_ID_OFFS)
+#define EBI_GEN_DMA_CTRL_OFFS		0x00000070
+#define EBI_GEN_DMA_CTRL(base)		((base) + EBI_GEN_DMA_CTRL_OFFS)
+#define EBI_STATUS_OFFS			0x00000080
+#define EBI_STATUS(base)		((base) + EBI_STATUS_OFFS)
+#define EBI_STATUS_DMA_CNT_OFFS		0x00000084
+#define EBI_STATUS_DMA_CNT(base)	((base) + EBI_STATUS_DMA_CNT_OFFS)
+#define EBI_SIG_LEVEL_OFFS		0x00000088
+#define EBI_SIG_LEVEL(base)		((base) + EBI_SIG_LEVEL_OFFS)
+#define EBI_CTRL_SIG_ACTLV_OFFS		0x0000008C
+#define EBI_CTRL_SIG_ACTLV(base)	((base) + EBI_CTRL_SIG_ACTLV_OFFS)
+#define EBI_CRC_GEN_OFFS		0x00000090
+#define EBI_CRC_GEN(base)		((base) + EBI_CRC_GEN_OFFS)
+#define EBI_EXT_ADDR_OFFS		0x000000A0
+#define EBI_EXT_ADDR(base)		((base) + EBI_EXT_ADDR_OFFS)
+#define EBI_IRQ_STATUS_OFFS		0x000000B0
+#define EBI_IRQ_STATUS(base)		((base) + EBI_IRQ_STATUS_OFFS)
+#define EBI_IRQ_STATUS2_OFFS		0x000000B4
+#define EBI_IRQ_STATUS2(base)		((base) + EBI_IRQ_STATUS2_OFFS)
+#define EBI_EXT_MASTER_SRAM_HIGH_OFFS	0x000000C0
+#define EBI_EXT_MASTER_SRAM_HIGH(base)	((base) + EBI_EXT_MASTER_SRAM_HIGH_OFFS)
+#define EBI_EXT_MASTER_SRAM_LOW_OFFS	0x000000C4
+#define EBI_EXT_MASTER_SRAM_LOW(base)	((base) + EBI_EXT_MASTER_SRAM_LOW_OFFS)
+#define EBI_ECC0_OFFS			0x000000D0
+#define EBI_ECC0(base)			((base) + EBI_ECC0_OFFS)
+#define EBI_ECC1_OFFS			0x000000D4
+#define EBI_ECC1(base)			((base) + EBI_ECC1_OFFS)
+#define EBI_ECC2_OFFS			0x000000D8
+#define EBI_ECC2(base)			((base) + EBI_ECC2_OFFS)
+#define EBI_ECC3_OFFS			0x000000DC
+#define EBI_ECC3(base)			((base) + EBI_ECC3_OFFS)
+#define EBI_DEV1_DMA_EXT_ADDR_OFFS	0x00000100
+#define EBI_DEV1_DMA_EXT_ADDR(base)	((base) + EBI_DEV1_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV1_EXT_ACC_OFFS		0x00000104
+#define EBI_DEV1_EXT_ACC(base)		((base) + EBI_DEV1_EXT_ACC_OFFS)
+#define EBI_DEV1_CONFIG1_OFFS		0x00000108
+#define EBI_DEV1_CONFIG1(base)		((base) + EBI_DEV1_CONFIG1_OFFS)
+#define EBI_DEV1_CONFIG2_OFFS		0x0000010C
+#define EBI_DEV1_CONFIG2(base)		((base) + EBI_DEV1_CONFIG2_OFFS)
+#define EBI_DEV1_FIFO_CONFIG_OFFS	0x00000110
+#define EBI_DEV1_FIFO_CONFIG(base)	((base) + EBI_DEV1_FIFO_CONFIG_OFFS)
+#define EBI_DEV1_FLASH_CONF_ST_OFFS	0x00000114
+#define EBI_DEV1_FLASH_CONF_ST(base)	((base) + EBI_DEV1_FLASH_CONF_ST_OFFS)
+#define EBI_DEV1_DMA_CONFIG1_OFFS	0x00000118
+#define EBI_DEV1_DMA_CONFIG1(base)	((base) + EBI_DEV1_DMA_CONFIG1_OFFS)
+#define EBI_DEV1_DMA_CONFIG2_OFFS	0x0000011C
+#define EBI_DEV1_DMA_CONFIG2(base)	((base) + EBI_DEV1_DMA_CONFIG2_OFFS)
+#define EBI_DEV1_DMA_ECC_CTRL_OFFS	0x00000120
+#define EBI_DEV1_DMA_ECC_CTRL(base)	((base) + EBI_DEV1_DMA_ECC_CTRL_OFFS)
+#define EBI_DEV1_TIM1_RD1_OFFS		0x00000124
+#define EBI_DEV1_TIM1_RD1(base)		((base) + EBI_DEV1_TIM1_RD1_OFFS)
+#define EBI_DEV1_TIM1_RD2_OFFS		0x00000128
+#define EBI_DEV1_TIM1_RD2(base)		((base) + EBI_DEV1_TIM1_RD2_OFFS)
+#define EBI_DEV1_TIM1_WR1_OFFS		0x0000012C
+#define EBI_DEV1_TIM1_WR1(base)		((base) + EBI_DEV1_TIM1_WR1_OFFS)
+#define EBI_DEV1_TIM1_WR2_OFFS		0x00000130
+#define EBI_DEV1_TIM1_WR2(base)		((base) + EBI_DEV1_TIM1_WR2_OFFS)
+#define EBI_DEV1_TIM_EXT_OFFS		0x00000134
+#define EBI_DEV1_TIM_EXT(base)		((base) + EBI_DEV1_TIM_EXT_OFFS)
+#define EBI_DEV1_TIM2_CFI_RD1_OFFS	0x00000138
+#define EBI_DEV1_TIM2_CFI_RD1(base)	((base) + EBI_DEV1_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV1_TIM2_CFI_RD2_OFFS	0x0000013C
+#define EBI_DEV1_TIM2_CFI_RD2(base)	((base) + EBI_DEV1_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV1_TIM3_DMA1_OFFS		0x00000140
+#define EBI_DEV1_TIM3_DMA1(base)	((base) + EBI_DEV1_TIM3_DMA1_OFFS)
+#define EBI_DEV1_TIM3_DMA2_OFFS		0x00000144
+#define EBI_DEV1_TIM3_DMA2(base)	((base) + EBI_DEV1_TIM3_DMA2_OFFS)
+#define EBI_DEV1_TIM4_UDMA1_OFFS	0x00000148
+#define EBI_DEV1_TIM4_UDMA1(base)	((base) + EBI_DEV1_TIM4_UDMA1_OFFS)
+#define EBI_DEV1_TIM4_UDMA2_OFFS	0x0000014C
+#define EBI_DEV1_TIM4_UDMA2(base)	((base) + EBI_DEV1_TIM4_UDMA2_OFFS)
+#define EBI_DEV1_ACK_RM_CNT_OFFS	0x00000150
+#define EBI_DEV1_ACK_RM_CNT(base)	((base) + EBI_DEV1_ACK_RM_CNT_OFFS)
+#define EBI_DEV2_DMA_EXT_ADDR_OFFS	0x00000200
+#define EBI_DEV2_DMA_EXT_ADDR(base)	((base) + EBI_DEV2_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV2_EXT_ACC_OFFS		0x00000204
+#define EBI_DEV2_EXT_ACC(base)		((base) + EBI_DEV2_EXT_ACC_OFFS)
+#define EBI_DEV2_CONFIG1_OFFS		0x00000208
+#define EBI_DEV2_CONFIG1(base)		((base) + EBI_DEV2_CONFIG1_OFFS)
+#define EBI_DEV2_CONFIG2_OFFS		0x0000020C
+#define EBI_DEV2_CONFIG2(base)		((base) + EBI_DEV2_CONFIG2_OFFS)
+#define EBI_DEV2_FIFO_CONFIG_OFFS	0x00000210
+#define EBI_DEV2_FIFO_CONFIG(base)	((base) + EBI_DEV2_FIFO_CONFIG_OFFS)
+#define EBI_DEV2_FLASH_CONF_ST_OFFS	0x00000214
+#define EBI_DEV2_FLASH_CONF_ST(base)	((base) + EBI_DEV2_FLASH_CONF_ST_OFFS)
+#define EBI_DEV2_DMA_CONFIG1_OFFS	0x00000218
+#define EBI_DEV2_DMA_CONFIG1(base)	((base) + EBI_DEV2_DMA_CONFIG1_OFFS)
+#define EBI_DEV2_DMA_CONFIG2_OFFS	0x0000021C
+#define EBI_DEV2_DMA_CONFIG2(base)	((base) + EBI_DEV2_DMA_CONFIG2_OFFS)
+#define EBI_DEV2_DMA_ECC_CTRL_OFFS	0x00000220
+#define EBI_DEV2_DMA_ECC_CTRL(base)	((base) + EBI_DEV2_DMA_ECC_CTRL_OFFS)
+#define EBI_DEV2_TIM1_RD1_OFFS		0x00000224
+#define EBI_DEV2_TIM1_RD1(base)		((base) + EBI_DEV2_TIM1_RD1_OFFS)
+#define EBI_DEV2_TIM1_RD2_OFFS		0x00000228
+#define EBI_DEV2_TIM1_RD2(base)		((base) + EBI_DEV2_TIM1_RD2_OFFS)
+#define EBI_DEV2_TIM1_WR1_OFFS		0x0000022C
+#define EBI_DEV2_TIM1_WR1(base)		((base) + EBI_DEV2_TIM1_WR1_OFFS)
+#define EBI_DEV2_TIM1_WR2_OFFS		0x00000230
+#define EBI_DEV2_TIM1_WR2(base)		((base) + EBI_DEV2_TIM1_WR2_OFFS)
+#define EBI_DEV2_TIM_EXT_OFFS		0x00000234
+#define EBI_DEV2_TIM_EXT(base)		((base) + EBI_DEV2_TIM_EXT_OFFS)
+#define EBI_DEV2_TIM2_CFI_RD1_OFFS	0x00000238
+#define EBI_DEV2_TIM2_CFI_RD1(base)	((base) + EBI_DEV2_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV2_TIM2_CFI_RD2_OFFS	0x0000023C
+#define EBI_DEV2_TIM2_CFI_RD2(base)	((base) + EBI_DEV2_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV2_TIM3_DMA1_OFFS		0x00000240
+#define EBI_DEV2_TIM3_DMA1(base)	((base) + EBI_DEV2_TIM3_DMA1_OFFS)
+#define EBI_DEV2_TIM3_DMA2_OFFS		0x00000244
+#define EBI_DEV2_TIM3_DMA2(base)	((base) + EBI_DEV2_TIM3_DMA2_OFFS)
+#define EBI_DEV2_TIM4_UDMA1_OFFS	0x00000248
+#define EBI_DEV2_TIM4_UDMA1(base)	((base) + EBI_DEV2_TIM4_UDMA1_OFFS)
+#define EBI_DEV2_TIM4_UDMA2_OFFS	0x0000024C
+#define EBI_DEV2_TIM4_UDMA2(base)	((base) + EBI_DEV2_TIM4_UDMA2_OFFS)
+#define EBI_DEV2_ACK_RM_CNT_OFFS	0x00000250
+#define EBI_DEV2_ACK_RM_CNT(base)	((base) + EBI_DEV2_ACK_RM_CNT_OFFS)
+#define EBI_DEV3_DMA_EXT_ADDR_OFFS	0x00000300
+#define EBI_DEV3_DMA_EXT_ADDR(base)	((base) + EBI_DEV3_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV3_EXT_ACC_OFFS		0x00000304
+#define EBI_DEV3_EXT_ACC(base)		((base) + EBI_DEV3_EXT_ACC_OFFS)
+#define EBI_DEV3_CONFIG1_OFFS		0x00000308
+#define EBI_DEV3_CONFIG1(base)		((base) + EBI_DEV3_CONFIG1_OFFS)
+#define EBI_DEV3_CONFIG2_OFFS		0x0000030C
+#define EBI_DEV3_CONFIG2(base)		((base) + EBI_DEV3_CONFIG2_OFFS)
+#define EBI_DEV3_FIFO_CONFIG_OFFS	0x00000310
+#define EBI_DEV3_FIFO_CONFIG(base)	((base) + EBI_DEV3_FIFO_CONFIG_OFFS)
+#define EBI_DEV3_FLASH_CONF_ST_OFFS	0x00000314
+#define EBI_DEV3_FLASH_CONF_ST(base)	((base) + EBI_DEV3_FLASH_CONF_ST_OFFS)
+#define EBI_DEV3_DMA_CONFIG1_OFFS	0x00000318
+#define EBI_DEV3_DMA_CONFIG1(base)	((base) + EBI_DEV3_DMA_CONFIG1_OFFS)
+#define EBI_DEV3_DMA_CONFIG2_OFFS	0x0000031C
+#define EBI_DEV3_DMA_CONFIG2(base)	((base) + EBI_DEV3_DMA_CONFIG2_OFFS)
+#define EBI_DEV3_DMA_ECC_CTRL_OFFS	0x00000320
+#define EBI_DEV3_DMA_ECC_CTRL(base)	((base) + EBI_DEV3_DMA_ECC_CTRL_OFFS)
+#define EBI_DEV3_TIM1_RD1_OFFS		0x00000324
+#define EBI_DEV3_TIM1_RD1(base)		((base) + EBI_DEV3_TIM1_RD1_OFFS)
+#define EBI_DEV3_TIM1_RD2_OFFS		0x00000328
+#define EBI_DEV3_TIM1_RD2(base)		((base) + EBI_DEV3_TIM1_RD2_OFFS)
+#define EBI_DEV3_TIM1_WR1_OFFS		0x0000032C
+#define EBI_DEV3_TIM1_WR1(base)		((base) + EBI_DEV3_TIM1_WR1_OFFS)
+#define EBI_DEV3_TIM1_WR2_OFFS		0x00000330
+#define EBI_DEV3_TIM1_WR2(base)		((base) + EBI_DEV3_TIM1_WR2_OFFS)
+#define EBI_DEV3_TIM_EXT_OFFS		0x00000334
+#define EBI_DEV3_TIM_EXT(base)		((base) + EBI_DEV3_TIM_EXT_OFFS)
+#define EBI_DEV3_TIM2_CFI_RD1_OFFS	0x00000338
+#define EBI_DEV3_TIM2_CFI_RD1(base)	((base) + EBI_DEV3_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV3_TIM2_CFI_RD2_OFFS	0x0000033C
+#define EBI_DEV3_TIM2_CFI_RD2(base)	((base) + EBI_DEV3_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV3_TIM3_DMA1_OFFS		0x00000340
+#define EBI_DEV3_TIM3_DMA1(base)	((base) + EBI_DEV3_TIM3_DMA1_OFFS)
+#define EBI_DEV3_TIM3_DMA2_OFFS		0x00000344
+#define EBI_DEV3_TIM3_DMA2(base)	((base) + EBI_DEV3_TIM3_DMA2_OFFS)
+#define EBI_DEV3_TIM4_UDMA1_OFFS	0x00000348
+#define EBI_DEV3_TIM4_UDMA1(base)	((base) + EBI_DEV3_TIM4_UDMA1_OFFS)
+#define EBI_DEV3_TIM4_UDMA2_OFFS	0x0000034C
+#define EBI_DEV3_TIM4_UDMA2(base)	((base) + EBI_DEV3_TIM4_UDMA2_OFFS)
+#define EBI_DEV3_ACK_RM_CNT_OFFS	0x00000350
+#define EBI_DEV3_ACK_RM_CNT(base)	((base) + EBI_DEV3_ACK_RM_CNT_OFFS)
+#define EBI_DEV4_DMA_EXT_ADDR_OFFS	0x00000400
+#define EBI_DEV4_DMA_EXT_ADDR(base)	((base) + EBI_DEV4_DMA_EXT_ADDR_OFFS)
+#define EBI_DEV4_EXT_ACC_OFFS		0x00000404
+#define EBI_DEV4_EXT_ACC(base)		((base) + EBI_DEV4_EXT_ACC_OFFS)
+#define EBI_DEV4_CONFIG1_OFFS		0x00000408
+#define EBI_DEV4_CONFIG1(base)		((base) + EBI_DEV4_CONFIG1_OFFS)
+#define EBI_DEV4_CONFIG2_OFFS		0x0000040C
+#define EBI_DEV4_CONFIG2(base)		((base) + EBI_DEV4_CONFIG2_OFFS)
+#define EBI_DEV4_FIFO_CONFIG_OFFS	0x00000410
+#define EBI_DEV4_FIFO_CONFIG(base)	((base) + EBI_DEV4_FIFO_CONFIG_OFFS)
+#define EBI_DEV4_FLASH_CONF_ST_OFFS	0x00000414
+#define EBI_DEV4_FLASH_CONF_ST(base)	((base) + EBI_DEV4_FLASH_CONF_ST_OFFS)
+#define EBI_DEV4_DMA_CONFIG1_OFFS	0x00000418
+#define EBI_DEV4_DMA_CONFIG1(base)	((base) + EBI_DEV4_DMA_CONFIG1_OFFS)
+#define EBI_DEV4_DMA_CONFIG2_OFFS	0x0000041C
+#define EBI_DEV4_DMA_CONFIG2(base)	((base) + EBI_DEV4_DMA_CONFIG2_OFFS)
+#define EBI_DEV4_DMA_ECC_CTRL_OFFS	0x00000420
+#define EBI_DEV4_DMA_ECC_CTRL(base)	((base) + EBI_DEV4_DMA_ECC_CTRL_OFFS)
+#define EBI_DEV4_TIM1_RD1_OFFS		0x00000424
+#define EBI_DEV4_TIM1_RD1(base)		((base) + EBI_DEV4_TIM1_RD1_OFFS)
+#define EBI_DEV4_TIM1_RD2_OFFS		0x00000428
+#define EBI_DEV4_TIM1_RD2(base)		((base) + EBI_DEV4_TIM1_RD2_OFFS)
+#define EBI_DEV4_TIM1_WR1_OFFS		0x0000042C
+#define EBI_DEV4_TIM1_WR1(base)		((base) + EBI_DEV4_TIM1_WR1_OFFS)
+#define EBI_DEV4_TIM1_WR2_OFFS		0x00000430
+#define EBI_DEV4_TIM1_WR2(base)		((base) + EBI_DEV4_TIM1_WR2_OFFS)
+#define EBI_DEV4_TIM_EXT_OFFS		0x00000434
+#define EBI_DEV4_TIM_EXT(base)		((base) + EBI_DEV4_TIM_EXT_OFFS)
+#define EBI_DEV4_TIM2_CFI_RD1_OFFS	0x00000438
+#define EBI_DEV4_TIM2_CFI_RD1(base)	((base) + EBI_DEV4_TIM2_CFI_RD1_OFFS)
+#define EBI_DEV4_TIM2_CFI_RD2_OFFS	0x0000043C
+#define EBI_DEV4_TIM2_CFI_RD2(base)	((base) + EBI_DEV4_TIM2_CFI_RD2_OFFS)
+#define EBI_DEV4_TIM3_DMA1_OFFS		0x00000440
+#define EBI_DEV4_TIM3_DMA1(base)	((base) + EBI_DEV4_TIM3_DMA1_OFFS)
+#define EBI_DEV4_TIM3_DMA2_OFFS		0x00000444
+#define EBI_DEV4_TIM3_DMA2(base)	((base) + EBI_DEV4_TIM3_DMA2_OFFS)
+#define EBI_DEV4_TIM4_UDMA1_OFFS	0x00000448
+#define EBI_DEV4_TIM4_UDMA1(base)	((base) + EBI_DEV4_TIM4_UDMA1_OFFS)
+#define EBI_DEV4_TIM4_UDMA2_OFFS	0x0000044C
+#define EBI_DEV4_TIM4_UDMA2(base)	((base) + EBI_DEV4_TIM4_UDMA2_OFFS)
+#define EBI_DEV4_ACK_RM_CNT_OFFS	0x00000450
+#define EBI_DEV4_ACK_RM_CNT(base)	((base) + EBI_DEV4_ACK_RM_CNT_OFFS)
+#define EBI_INTERLEAVE_CNT_OFFS		0x00000900
+#define EBI_INTERLEAVE_CNT(base)	((base) + EBI_INTERLEAVE_CNT_OFFS)
+#define EBI_CNT_FL_PROGR_OFFS		0x00000904
+#define EBI_CNT_FL_PROGR(base)		((base) + EBI_CNT_FL_PROGR_OFFS)
+#define EBI_CNT_EXT_PAGE_SZ_OFFS	0x0000090C
+#define EBI_CNT_EXT_PAGE_SZ(base)	((base) + EBI_CNT_EXT_PAGE_SZ_OFFS)
+#define EBI_CNT_WAIT_RDY_OFFS		0x00000914
+#define EBI_CNT_WAIT_RDY(base)		((base) + EBI_CNT_WAIT_RDY_OFFS)
+#define EBI_CNT_ACK_OFFS		0x00000918
+#define EBI_CNT_ACK(base)		((base) + EBI_CNT_ACK_OFFS)
+#define EBI_GENIO1_CONFIG1_OFFS		0x00000A00
+#define EBI_GENIO1_CONFIG1(base)	((base) + EBI_GENIO1_CONFIG1_OFFS)
+#define EBI_GENIO1_CONFIG2_OFFS		0x00000A04
+#define EBI_GENIO1_CONFIG2(base)	((base) + EBI_GENIO1_CONFIG2_OFFS)
+#define EBI_GENIO1_CONFIG3_OFFS		0x00000A08
+#define EBI_GENIO1_CONFIG3(base)	((base) + EBI_GENIO1_CONFIG3_OFFS)
+#define EBI_GENIO2_CONFIG1_OFFS		0x00000A10
+#define EBI_GENIO2_CONFIG1(base)	((base) + EBI_GENIO2_CONFIG1_OFFS)
+#define EBI_GENIO2_CONFIG2_OFFS		0x00000A14
+#define EBI_GENIO2_CONFIG2(base)	((base) + EBI_GENIO2_CONFIG2_OFFS)
+#define EBI_GENIO2_CONFIG3_OFFS		0x00000A18
+#define EBI_GENIO2_CONFIG3(base)	((base) + EBI_GENIO2_CONFIG3_OFFS)
+#define EBI_GENIO3_CONFIG1_OFFS		0x00000A20
+#define EBI_GENIO3_CONFIG1(base)	((base) + EBI_GENIO3_CONFIG1_OFFS)
+#define EBI_GENIO3_CONFIG2_OFFS		0x00000A24
+#define EBI_GENIO3_CONFIG2(base)	((base) + EBI_GENIO3_CONFIG2_OFFS)
+#define EBI_GENIO3_CONFIG3_OFFS		0x00000A28
+#define EBI_GENIO3_CONFIG3(base)	((base) + EBI_GENIO3_CONFIG3_OFFS)
+#define EBI_GENIO4_CONFIG1_OFFS		0x00000A30
+#define EBI_GENIO4_CONFIG1(base)	((base) + EBI_GENIO4_CONFIG1_OFFS)
+#define EBI_GENIO4_CONFIG2_OFFS		0x00000A34
+#define EBI_GENIO4_CONFIG2(base)	((base) + EBI_GENIO4_CONFIG2_OFFS)
+#define EBI_GENIO4_CONFIG3_OFFS		0x00000A38
+#define EBI_GENIO4_CONFIG3(base)	((base) + EBI_GENIO4_CONFIG3_OFFS)
+#define EBI_GENIO5_CONFIG1_OFFS		0x00000A40
+#define EBI_GENIO5_CONFIG1(base)	((base) + EBI_GENIO5_CONFIG1_OFFS)
+#define EBI_GENIO5_CONFIG2_OFFS		0x00000A44
+#define EBI_GENIO5_CONFIG2(base)	((base) + EBI_GENIO5_CONFIG2_OFFS)
+#define EBI_GENIO5_CONFIG3_OFFS		0x00000A48
+#define EBI_GENIO5_CONFIG3(base)	((base) + EBI_GENIO5_CONFIG3_OFFS)
+
+#endif
diff -Naur u-boot-2009.01/board/micronas/vct/vctv/reg_gpio.h u-boot/board/micronas/vct/vctv/reg_gpio.h
--- u-boot-2009.01/board/micronas/vct/vctv/reg_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vctv/reg_gpio.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define GPIO1_BASE		0x00044000
+#define GPIO2_BASE		0x00048000
+
+/* Instances */
+#define GPIO_INSTANCES		2
+
+/*  Relative offsets of the register adresses */
+#define GPIO_SWPORTA_DR_OFFS	0x00000000
+#define GPIO_SWPORTA_DR(base)	((base) + GPIO_SWPORTA_DR_OFFS)
+#define GPIO_SWPORTA_DDR_OFFS	0x00000004
+#define GPIO_SWPORTA_DDR(base)	((base) + GPIO_SWPORTA_DDR_OFFS)
+#define GPIO_EXT_PORTA_OFFS	0x00000050
+#define GPIO_EXT_PORTA(base)	((base) + GPIO_EXT_PORTA_OFFS)
diff -Naur u-boot-2009.01/board/micronas/vct/vctv/reg_wdt.h u-boot/board/micronas/vct/vctv/reg_wdt.h
--- u-boot-2009.01/board/micronas/vct/vctv/reg_wdt.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/micronas/vct/vctv/reg_wdt.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define WDT_BASE		0x00040000
+#define WDT_CR_OFFS		0x00000000
+#define WDT_CR(base)		((base) + WDT_CR_OFFS)
+#define WDT_TORR_OFFS		0x00000004
+#define WDT_TORR(base)		((base) + WDT_TORR_OFFS)
diff -Naur u-boot-2009.01/board/mpc8540eval/mpc8540eval.c u-boot/board/mpc8540eval/mpc8540eval.c
--- u-boot-2009.01/board/mpc8540eval/mpc8540eval.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/mpc8540eval/mpc8540eval.c	2009-02-26 14:03:58.000000000 +0100
@@ -50,7 +50,7 @@
 	get_sys_info (&sysinfo);
 
 	printf ("Board: Freescale MPC8540EVAL Board\n");
-	printf ("\tCPU: %lu MHz\n", sysinfo.freqProcessor / 1000000);
+	printf ("\tCPU: %lu MHz\n", sysinfo.freqProcessor[0] / 1000000);
 	printf ("\tCCB: %lu MHz\n", sysinfo.freqSystemBus / 1000000);
 	printf ("\tDDR: %lu MHz\n", sysinfo.freqSystemBus / 2000000);
 	if((CONFIG_SYS_LBC_LCRR & 0x0f) == 2 || (CONFIG_SYS_LBC_LCRR & 0x0f) == 4 \
diff -Naur u-boot-2009.01/board/mpl/common/common_util.c u-boot/board/mpl/common/common_util.c
--- u-boot-2009.01/board/mpl/common/common_util.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/mpl/common/common_util.c	2009-02-26 14:03:58.000000000 +0100
@@ -559,7 +559,7 @@
 		return 0;
 	}
 #endif
-	printf("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
diff -Naur u-boot-2009.01/board/mpl/mip405/cmd_mip405.c u-boot/board/mpl/mip405/cmd_mip405.c
--- u-boot-2009.01/board/mpl/mip405/cmd_mip405.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/mpl/mip405/cmd_mip405.c	2009-02-26 14:03:58.000000000 +0100
@@ -55,7 +55,7 @@
 }
 U_BOOT_CMD(
 	mip405,	8,	1,	do_mip405,
-	"mip405  - MIP405 specific Cmds\n",
+	"MIP405 specific Cmds",
 	"flash mem [SrcAddr] - updates U-Boot with image in memory\n"
 	"mip405 flash mps - updates U-Boot with image from MPS\n"
 	"mip405 info      - displays board information\n"
diff -Naur u-boot-2009.01/board/mpl/pati/cmd_pati.c u-boot/board/mpl/pati/cmd_pati.c
--- u-boot-2009.01/board/mpl/pati/cmd_pati.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/mpl/pati/cmd_pati.c	2009-02-26 14:03:58.000000000 +0100
@@ -427,7 +427,7 @@
 
 U_BOOT_CMD(
 	pati,	8,	1,	do_pati,
-	"pati    - PATI specific Cmds\n",
+	"PATI specific Cmds",
 	"info - displays board information\n"
 	"pati pci  - displays PCI registers\n"
 	"pati led <nr> <on> \n"
diff -Naur u-boot-2009.01/board/mpl/pip405/cmd_pip405.c u-boot/board/mpl/pip405/cmd_pip405.c
--- u-boot-2009.01/board/mpl/pip405/cmd_pip405.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/mpl/pip405/cmd_pip405.c	2009-02-26 14:03:58.000000000 +0100
@@ -60,7 +60,7 @@
 }
 U_BOOT_CMD(
 	pip405,	6,	1,	do_pip405,
-	"pip405  - PIP405 specific Cmds\n",
+	"PIP405 specific Cmds",
 	"flash mem [SrcAddr] - updates U-Boot with image in memory\n"
 	"pip405 flash floppy [SrcAddr] - updates U-Boot with image from floppy\n"
 	"pip405 flash mps - updates U-Boot with image from MPS\n"
diff -Naur u-boot-2009.01/board/mpl/vcma9/cmd_vcma9.c u-boot/board/mpl/vcma9/cmd_vcma9.c
--- u-boot-2009.01/board/mpl/vcma9/cmd_vcma9.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/mpl/vcma9/cmd_vcma9.c	2009-02-26 14:03:58.000000000 +0100
@@ -175,6 +175,6 @@
 
 U_BOOT_CMD(
 	vcma9, 6, 1, do_vcma9,
-	"vcma9   - VCMA9 specific commands\n",
+	"VCMA9 specific commands",
 	"flash mem [SrcAddr]\n    - updates U-Boot with image in memory\n"
 );
diff -Naur u-boot-2009.01/board/omap3/beagle/beagle.c u-boot/board/omap3/beagle/beagle.c
--- u-boot-2009.01/board/omap3/beagle/beagle.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/beagle/beagle.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,131 @@
+/*
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Author :
+ *	Sunil Kumar <sunilsaini05@gmail.com>
+ *	Shashi Ranjan <shashiranjanmca05@gmail.com>
+ *
+ * Derived from Beagle Board and 3430 SDP code by
+ *	Richard Woodruff <r-woodruff2@ti.com>
+ *	Syed Mohammed Khasim <khasim@ti.com>
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-types.h>
+#include "beagle.h"
+
+static int beagle_revision_c;
+
+/******************************************************************************
+ * Routine: board_init
+ * Description: Early hardware init.
+ *****************************************************************************/
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gpmc_init(); /* in SRAM or SDRAM, finish GPMC */
+	/* board id for Linux */
+	gd->bd->bi_arch_number = MACH_TYPE_OMAP3_BEAGLE;
+	/* boot param addr */
+	gd->bd->bi_boot_params = (OMAP34XX_SDRC_CS0 + 0x100);
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: beagle_get_revision
+ * Description: Return revision of the BeagleBoard this code is running on.
+ *              If it is a revision Ax/Bx board, this function returns 0,
+ *              on a revision C board you will get a 1.
+ *****************************************************************************/
+int beagle_get_revision(void)
+{
+	return beagle_revision_c;
+}
+
+/******************************************************************************
+ * Routine: beagle_identify
+ * Description: Detect if we are running on a Beagle revision Ax/Bx or
+ *              Cx. This can be done by GPIO_171. If this is low, we are
+ *              running on a revision C board.
+ *****************************************************************************/
+void beagle_identify(void)
+{
+	gpio_t *gpio6_base = (gpio_t *)OMAP34XX_GPIO6_BASE;
+
+	/* Configure GPIO 171 as input */
+	writel(readl(&gpio6_base->oe) | GPIO11, &gpio6_base->oe);
+
+	/* Get value of GPIO 171 */
+	beagle_revision_c = readl(&gpio6_base->datain) & BOARD_REVISION_MASK;
+
+	printf("Board revision ");
+	if (beagle_revision_c) {
+		printf("Ax/Bx\n");
+		beagle_revision_c = 0;
+	} else {
+		printf("C\n");
+		beagle_revision_c = 1;
+	}
+}
+
+/******************************************************************************
+ * Routine: misc_init_r
+ * Description: Configure board specific parts
+ *****************************************************************************/
+int misc_init_r(void)
+{
+	gpio_t *gpio5_base = (gpio_t *)OMAP34XX_GPIO5_BASE;
+	gpio_t *gpio6_base = (gpio_t *)OMAP34XX_GPIO6_BASE;
+
+	power_init_r();
+
+	/* Configure GPIOs to output */
+	writel(~(GPIO23 | GPIO10 | GPIO8 | GPIO2 | GPIO1), &gpio6_base->oe);
+	writel(~(GPIO31 | GPIO30 | GPIO29 | GPIO28 | GPIO22 | GPIO21 |
+		GPIO15 | GPIO14 | GPIO13 | GPIO12), &gpio5_base->oe);
+
+	/* Set GPIOs */
+	writel(GPIO23 | GPIO10 | GPIO8 | GPIO2 | GPIO1,
+		&gpio6_base->setdataout);
+	writel(GPIO31 | GPIO30 | GPIO29 | GPIO28 | GPIO22 | GPIO21 |
+		GPIO15 | GPIO14 | GPIO13 | GPIO12, &gpio5_base->setdataout);
+
+	beagle_identify();
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: set_muxconf_regs
+ * Description: Setting up the configuration Mux registers specific to the
+ *		hardware. Many pins need to be moved from protect to primary
+ *		mode.
+ *****************************************************************************/
+void set_muxconf_regs(void)
+{
+	MUX_BEAGLE();
+}
diff -Naur u-boot-2009.01/board/omap3/beagle/beagle.h u-boot/board/omap3/beagle/beagle.h
--- u-boot-2009.01/board/omap3/beagle/beagle.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/beagle/beagle.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,377 @@
+/*
+ * (C) Copyright 2008
+ * Dirk Behme <dirk.behme@gmail.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _BEAGLE_H_
+#define _BEAGLE_H_
+
+const omap3_sysinfo sysinfo = {
+	SDP_3430_V1,
+	SDP_3430_V2,
+	DDR_STACKED,
+	"OMAP3 Beagle board",
+#if defined(CONFIG_ENV_IS_IN_ONENAND)
+	"OneNAND",
+#else
+	"NAND",
+#endif
+};
+
+#define BOARD_REVISION_MASK	(0x1 << 11)
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+#define MUX_BEAGLE() \
+ /*SDRC*/\
+ MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) /*SDRC_D0*/\
+ MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) /*SDRC_D1*/\
+ MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) /*SDRC_D2*/\
+ MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) /*SDRC_D3*/\
+ MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) /*SDRC_D4*/\
+ MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) /*SDRC_D5*/\
+ MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) /*SDRC_D6*/\
+ MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) /*SDRC_D7*/\
+ MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) /*SDRC_D8*/\
+ MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) /*SDRC_D9*/\
+ MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) /*SDRC_D10*/\
+ MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) /*SDRC_D11*/\
+ MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) /*SDRC_D12*/\
+ MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) /*SDRC_D13*/\
+ MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) /*SDRC_D14*/\
+ MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) /*SDRC_D15*/\
+ MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) /*SDRC_D16*/\
+ MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) /*SDRC_D17*/\
+ MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) /*SDRC_D18*/\
+ MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) /*SDRC_D19*/\
+ MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) /*SDRC_D20*/\
+ MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) /*SDRC_D21*/\
+ MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) /*SDRC_D22*/\
+ MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) /*SDRC_D23*/\
+ MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) /*SDRC_D24*/\
+ MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) /*SDRC_D25*/\
+ MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) /*SDRC_D26*/\
+ MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) /*SDRC_D27*/\
+ MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) /*SDRC_D28*/\
+ MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) /*SDRC_D29*/\
+ MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) /*SDRC_D30*/\
+ MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) /*SDRC_D31*/\
+ MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) /*SDRC_CLK*/\
+ MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS0*/\
+ MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS1*/\
+ MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS2*/\
+ MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS3*/\
+ /*GPMC*/\
+ MUX_VAL(CP(GPMC_A1),		(IDIS | PTD | DIS | M0)) /*GPMC_A1*/\
+ MUX_VAL(CP(GPMC_A2),		(IDIS | PTD | DIS | M0)) /*GPMC_A2*/\
+ MUX_VAL(CP(GPMC_A3),		(IDIS | PTD | DIS | M0)) /*GPMC_A3*/\
+ MUX_VAL(CP(GPMC_A4),		(IDIS | PTD | DIS | M0)) /*GPMC_A4*/\
+ MUX_VAL(CP(GPMC_A5),		(IDIS | PTD | DIS | M0)) /*GPMC_A5*/\
+ MUX_VAL(CP(GPMC_A6),		(IDIS | PTD | DIS | M0)) /*GPMC_A6*/\
+ MUX_VAL(CP(GPMC_A7),		(IDIS | PTD | DIS | M0)) /*GPMC_A7*/\
+ MUX_VAL(CP(GPMC_A8),		(IDIS | PTD | DIS | M0)) /*GPMC_A8*/\
+ MUX_VAL(CP(GPMC_A9),		(IDIS | PTD | DIS | M0)) /*GPMC_A9*/\
+ MUX_VAL(CP(GPMC_A10),		(IDIS | PTD | DIS | M0)) /*GPMC_A10*/\
+ MUX_VAL(CP(GPMC_D0),		(IEN  | PTD | DIS | M0)) /*GPMC_D0*/\
+ MUX_VAL(CP(GPMC_D1),		(IEN  | PTD | DIS | M0)) /*GPMC_D1*/\
+ MUX_VAL(CP(GPMC_D2),		(IEN  | PTD | DIS | M0)) /*GPMC_D2*/\
+ MUX_VAL(CP(GPMC_D3),		(IEN  | PTD | DIS | M0)) /*GPMC_D3*/\
+ MUX_VAL(CP(GPMC_D4),		(IEN  | PTD | DIS | M0)) /*GPMC_D4*/\
+ MUX_VAL(CP(GPMC_D5),		(IEN  | PTD | DIS | M0)) /*GPMC_D5*/\
+ MUX_VAL(CP(GPMC_D6),		(IEN  | PTD | DIS | M0)) /*GPMC_D6*/\
+ MUX_VAL(CP(GPMC_D7),		(IEN  | PTD | DIS | M0)) /*GPMC_D7*/\
+ MUX_VAL(CP(GPMC_D8),		(IEN  | PTD | DIS | M0)) /*GPMC_D8*/\
+ MUX_VAL(CP(GPMC_D9),		(IEN  | PTD | DIS | M0)) /*GPMC_D9*/\
+ MUX_VAL(CP(GPMC_D10),		(IEN  | PTD | DIS | M0)) /*GPMC_D10*/\
+ MUX_VAL(CP(GPMC_D11),		(IEN  | PTD | DIS | M0)) /*GPMC_D11*/\
+ MUX_VAL(CP(GPMC_D12),		(IEN  | PTD | DIS | M0)) /*GPMC_D12*/\
+ MUX_VAL(CP(GPMC_D13),		(IEN  | PTD | DIS | M0)) /*GPMC_D13*/\
+ MUX_VAL(CP(GPMC_D14),		(IEN  | PTD | DIS | M0)) /*GPMC_D14*/\
+ MUX_VAL(CP(GPMC_D15),		(IEN  | PTD | DIS | M0)) /*GPMC_D15*/\
+ MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS0*/\
+ MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS1*/\
+ MUX_VAL(CP(GPMC_NCS2),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS2*/\
+ MUX_VAL(CP(GPMC_NCS3),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS3*/\
+ MUX_VAL(CP(GPMC_NCS4),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS4*/\
+ MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTD | DIS | M0)) /*GPMC_nCS5*/\
+ MUX_VAL(CP(GPMC_NCS6),		(IEN  | PTD | DIS | M1)) /*SYS_nDMA_REQ2*/\
+ MUX_VAL(CP(GPMC_NCS7),		(IEN  | PTU | EN  | M1)) /*SYS_nDMA_REQ3*/\
+ MUX_VAL(CP(GPMC_NBE1),		(IEN  | PTD | DIS | M0)) /*GPMC_nBE1*/\
+ MUX_VAL(CP(GPMC_WAIT2),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT2*/\
+ MUX_VAL(CP(GPMC_WAIT3),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT3*/\
+ MUX_VAL(CP(GPMC_CLK),		(IDIS | PTD | DIS | M0)) /*GPMC_CLK*/\
+ MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0)) /*GPMC_nADV_ALE*/\
+ MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0)) /*GPMC_nOE*/\
+ MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0)) /*GPMC_nWE*/\
+ MUX_VAL(CP(GPMC_NBE0_CLE),	(IDIS | PTD | DIS | M0)) /*GPMC_nBE0_CLE*/\
+ MUX_VAL(CP(GPMC_NWP),		(IEN  | PTD | DIS | M0)) /*GPMC_nWP*/\
+ MUX_VAL(CP(GPMC_WAIT0),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT0*/\
+ MUX_VAL(CP(GPMC_WAIT1),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT1*/\
+ /*DSS*/\
+ MUX_VAL(CP(DSS_PCLK),		(IDIS | PTD | DIS | M0)) /*DSS_PCLK*/\
+ MUX_VAL(CP(DSS_HSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_HSYNC*/\
+ MUX_VAL(CP(DSS_VSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_VSYNC*/\
+ MUX_VAL(CP(DSS_ACBIAS),	(IDIS | PTD | DIS | M0)) /*DSS_ACBIAS*/\
+ MUX_VAL(CP(DSS_DATA0),		(IDIS | PTD | DIS | M0)) /*DSS_DATA0*/\
+ MUX_VAL(CP(DSS_DATA1),		(IDIS | PTD | DIS | M0)) /*DSS_DATA1*/\
+ MUX_VAL(CP(DSS_DATA2),		(IDIS | PTD | DIS | M0)) /*DSS_DATA2*/\
+ MUX_VAL(CP(DSS_DATA3),		(IDIS | PTD | DIS | M0)) /*DSS_DATA3*/\
+ MUX_VAL(CP(DSS_DATA4),		(IDIS | PTD | DIS | M0)) /*DSS_DATA4*/\
+ MUX_VAL(CP(DSS_DATA5),		(IDIS | PTD | DIS | M0)) /*DSS_DATA5*/\
+ MUX_VAL(CP(DSS_DATA6),		(IDIS | PTD | DIS | M0)) /*DSS_DATA6*/\
+ MUX_VAL(CP(DSS_DATA7),		(IDIS | PTD | DIS | M0)) /*DSS_DATA7*/\
+ MUX_VAL(CP(DSS_DATA8),		(IDIS | PTD | DIS | M0)) /*DSS_DATA8*/\
+ MUX_VAL(CP(DSS_DATA9),		(IDIS | PTD | DIS | M0)) /*DSS_DATA9*/\
+ MUX_VAL(CP(DSS_DATA10),	(IDIS | PTD | DIS | M0)) /*DSS_DATA10*/\
+ MUX_VAL(CP(DSS_DATA11),	(IDIS | PTD | DIS | M0)) /*DSS_DATA11*/\
+ MUX_VAL(CP(DSS_DATA12),	(IDIS | PTD | DIS | M0)) /*DSS_DATA12*/\
+ MUX_VAL(CP(DSS_DATA13),	(IDIS | PTD | DIS | M0)) /*DSS_DATA13*/\
+ MUX_VAL(CP(DSS_DATA14),	(IDIS | PTD | DIS | M0)) /*DSS_DATA14*/\
+ MUX_VAL(CP(DSS_DATA15),	(IDIS | PTD | DIS | M0)) /*DSS_DATA15*/\
+ MUX_VAL(CP(DSS_DATA16),	(IDIS | PTD | DIS | M0)) /*DSS_DATA16*/\
+ MUX_VAL(CP(DSS_DATA17),	(IDIS | PTD | DIS | M0)) /*DSS_DATA17*/\
+ MUX_VAL(CP(DSS_DATA18),	(IDIS | PTD | DIS | M0)) /*DSS_DATA18*/\
+ MUX_VAL(CP(DSS_DATA19),	(IDIS | PTD | DIS | M0)) /*DSS_DATA19*/\
+ MUX_VAL(CP(DSS_DATA20),	(IDIS | PTD | DIS | M0)) /*DSS_DATA20*/\
+ MUX_VAL(CP(DSS_DATA21),	(IDIS | PTD | DIS | M0)) /*DSS_DATA21*/\
+ MUX_VAL(CP(DSS_DATA22),	(IDIS | PTD | DIS | M0)) /*DSS_DATA22*/\
+ MUX_VAL(CP(DSS_DATA23),	(IDIS | PTD | DIS | M0)) /*DSS_DATA23*/\
+ /*CAMERA*/\
+ MUX_VAL(CP(CAM_HS),		(IEN  | PTU | EN  | M0)) /*CAM_HS */\
+ MUX_VAL(CP(CAM_VS),		(IEN  | PTU | EN  | M0)) /*CAM_VS */\
+ MUX_VAL(CP(CAM_XCLKA),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKA*/\
+ MUX_VAL(CP(CAM_PCLK),		(IEN  | PTU | EN  | M0)) /*CAM_PCLK*/\
+ MUX_VAL(CP(CAM_FLD),		(IDIS | PTD | DIS | M4)) /*GPIO_98*/\
+ MUX_VAL(CP(CAM_D0),		(IEN  | PTD | DIS | M0)) /*CAM_D0*/\
+ MUX_VAL(CP(CAM_D1),		(IEN  | PTD | DIS | M0)) /*CAM_D1*/\
+ MUX_VAL(CP(CAM_D2),		(IEN  | PTD | DIS | M0)) /*CAM_D2*/\
+ MUX_VAL(CP(CAM_D3),		(IEN  | PTD | DIS | M0)) /*CAM_D3*/\
+ MUX_VAL(CP(CAM_D4),		(IEN  | PTD | DIS | M0)) /*CAM_D4*/\
+ MUX_VAL(CP(CAM_D5),		(IEN  | PTD | DIS | M0)) /*CAM_D5*/\
+ MUX_VAL(CP(CAM_D6),		(IEN  | PTD | DIS | M0)) /*CAM_D6*/\
+ MUX_VAL(CP(CAM_D7),		(IEN  | PTD | DIS | M0)) /*CAM_D7*/\
+ MUX_VAL(CP(CAM_D8),		(IEN  | PTD | DIS | M0)) /*CAM_D8*/\
+ MUX_VAL(CP(CAM_D9),		(IEN  | PTD | DIS | M0)) /*CAM_D9*/\
+ MUX_VAL(CP(CAM_D10),		(IEN  | PTD | DIS | M0)) /*CAM_D10*/\
+ MUX_VAL(CP(CAM_D11),		(IEN  | PTD | DIS | M0)) /*CAM_D11*/\
+ MUX_VAL(CP(CAM_XCLKB),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKB*/\
+ MUX_VAL(CP(CAM_WEN),		(IEN  | PTD | DIS | M4)) /*GPIO_167*/\
+ MUX_VAL(CP(CAM_STROBE),	(IDIS | PTD | DIS | M0)) /*CAM_STROBE*/\
+ MUX_VAL(CP(CSI2_DX0),		(IEN  | PTD | DIS | M0)) /*CSI2_DX0*/\
+ MUX_VAL(CP(CSI2_DY0),		(IEN  | PTD | DIS | M0)) /*CSI2_DY0*/\
+ MUX_VAL(CP(CSI2_DX1),		(IEN  | PTD | DIS | M0)) /*CSI2_DX1*/\
+ MUX_VAL(CP(CSI2_DY1),		(IEN  | PTD | DIS | M0)) /*CSI2_DY1*/\
+ /*Audio Interface */\
+ MUX_VAL(CP(MCBSP2_FSX),	(IEN  | PTD | DIS | M0)) /*McBSP2_FSX*/\
+ MUX_VAL(CP(MCBSP2_CLKX),	(IEN  | PTD | DIS | M0)) /*McBSP2_CLKX*/\
+ MUX_VAL(CP(MCBSP2_DR),		(IEN  | PTD | DIS | M0)) /*McBSP2_DR*/\
+ MUX_VAL(CP(MCBSP2_DX),		(IDIS | PTD | DIS | M0)) /*McBSP2_DX*/\
+ /*Expansion card */\
+ MUX_VAL(CP(MMC1_CLK),		(IDIS | PTU | EN  | M0)) /*MMC1_CLK*/\
+ MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | EN  | M0)) /*MMC1_CMD*/\
+ MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT0*/\
+ MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT1*/\
+ MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT2*/\
+ MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT3*/\
+ MUX_VAL(CP(MMC1_DAT4),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT4*/\
+ MUX_VAL(CP(MMC1_DAT5),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT5*/\
+ MUX_VAL(CP(MMC1_DAT6),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT6*/\
+ MUX_VAL(CP(MMC1_DAT7),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT7*/\
+ /*Wireless LAN */\
+ MUX_VAL(CP(MMC2_CLK),		(IEN  | PTU | EN  | M4)) /*GPIO_130*/\
+ MUX_VAL(CP(MMC2_CMD),		(IEN  | PTU | EN  | M4)) /*GPIO_131*/\
+ MUX_VAL(CP(MMC2_DAT0),		(IEN  | PTU | EN  | M4)) /*GPIO_132*/\
+ MUX_VAL(CP(MMC2_DAT1),		(IEN  | PTU | EN  | M4)) /*GPIO_133*/\
+ MUX_VAL(CP(MMC2_DAT2),		(IEN  | PTU | EN  | M4)) /*GPIO_134*/\
+ MUX_VAL(CP(MMC2_DAT3),		(IEN  | PTU | EN  | M4)) /*GPIO_135*/\
+ MUX_VAL(CP(MMC2_DAT4),		(IEN  | PTU | EN  | M4)) /*GPIO_136*/\
+ MUX_VAL(CP(MMC2_DAT5),		(IEN  | PTU | EN  | M4)) /*GPIO_137*/\
+ MUX_VAL(CP(MMC2_DAT6),		(IEN  | PTU | EN  | M4)) /*GPIO_138*/\
+ MUX_VAL(CP(MMC2_DAT7),		(IEN  | PTU | EN  | M4)) /*GPIO_139*/\
+ /*Bluetooth*/\
+ MUX_VAL(CP(MCBSP3_DX),		(IDIS | PTD | DIS | M4)) /*GPIO_140*/\
+ MUX_VAL(CP(MCBSP3_DR),		(IDIS | PTD | DIS | M4)) /*GPIO_142*/\
+ MUX_VAL(CP(MCBSP3_CLKX),	(IDIS | PTD | DIS | M4)) /*GPIO_141*/\
+ MUX_VAL(CP(MCBSP3_FSX),	(IDIS | PTD | DIS | M4)) /*GPIO_143*/\
+ MUX_VAL(CP(UART2_CTS),		(IEN  | PTU | EN  | M0)) /*UART2_CTS*/\
+ MUX_VAL(CP(UART2_RTS),		(IDIS | PTD | DIS | M0)) /*UART2_RTS*/\
+ MUX_VAL(CP(UART2_TX),		(IDIS | PTD | DIS | M0)) /*UART2_TX*/\
+ MUX_VAL(CP(UART2_RX),		(IDIS | PTD | DIS | M4)) /*GPIO_147*/\
+ /*Modem Interface */\
+ MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0)) /*UART1_TX*/\
+ MUX_VAL(CP(UART1_RTS),		(IDIS | PTD | DIS | M4)) /*GPIO_149*/ \
+ MUX_VAL(CP(UART1_CTS),		(IDIS | PTD | DIS | M4)) /*GPIO_150*/ \
+ MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0)) /*UART1_RX*/\
+ MUX_VAL(CP(MCBSP4_CLKX),	(IEN  | PTD | DIS | M1)) /*SSI1_DAT_RX*/\
+ MUX_VAL(CP(MCBSP4_DR),		(IEN  | PTD | DIS | M1)) /*SSI1_FLAG_RX*/\
+ MUX_VAL(CP(MCBSP4_DX),		(IEN  | PTD | DIS | M1)) /*SSI1_RDY_RX*/\
+ MUX_VAL(CP(MCBSP4_FSX),	(IEN  | PTD | DIS | M1)) /*SSI1_WAKE*/\
+ MUX_VAL(CP(MCBSP1_CLKR),	(IDIS | PTD | DIS | M4)) /*GPIO_156*/\
+ MUX_VAL(CP(MCBSP1_FSR),	(IDIS | PTU | EN  | M4)) /*GPIO_157*/\
+ MUX_VAL(CP(MCBSP1_DX),		(IDIS | PTD | DIS | M4)) /*GPIO_158*/\
+ MUX_VAL(CP(MCBSP1_DR),		(IDIS | PTD | DIS | M4)) /*GPIO_159*/\
+ MUX_VAL(CP(MCBSP_CLKS),	(IEN  | PTU | DIS | M0)) /*McBSP_CLKS*/\
+ MUX_VAL(CP(MCBSP1_FSX),	(IDIS | PTD | DIS | M4)) /*GPIO_161*/\
+ MUX_VAL(CP(MCBSP1_CLKX),	(IDIS | PTD | DIS | M4)) /*GPIO_162*/\
+ /*Serial Interface*/\
+ MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTD | EN  | M0)) /*UART3_CTS_RCTX*/\
+ MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M0)) /*UART3_RTS_SD */\
+ MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0)) /*UART3_RX_IRRX*/\
+ MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0)) /*UART3_TX_IRTX*/\
+ MUX_VAL(CP(HSUSB0_CLK),	(IEN  | PTD | DIS | M0)) /*HSUSB0_CLK*/\
+ MUX_VAL(CP(HSUSB0_STP),	(IDIS | PTU | EN  | M0)) /*HSUSB0_STP*/\
+ MUX_VAL(CP(HSUSB0_DIR),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DIR*/\
+ MUX_VAL(CP(HSUSB0_NXT),	(IEN  | PTD | DIS | M0)) /*HSUSB0_NXT*/\
+ MUX_VAL(CP(HSUSB0_DATA0),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA0*/\
+ MUX_VAL(CP(HSUSB0_DATA1),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA1*/\
+ MUX_VAL(CP(HSUSB0_DATA2),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA2*/\
+ MUX_VAL(CP(HSUSB0_DATA3),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA3*/\
+ MUX_VAL(CP(HSUSB0_DATA4),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA4*/\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA5*/\
+ MUX_VAL(CP(HSUSB0_DATA6),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA6*/\
+ MUX_VAL(CP(HSUSB0_DATA7),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA7*/\
+ MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0)) /*I2C1_SCL*/\
+ MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0)) /*I2C1_SDA*/\
+ MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M4)) /*GPIO_168*/\
+ MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M4)) /*GPIO_183*/\
+ MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)) /*I2C3_SCL*/\
+ MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)) /*I2C3_SDA*/\
+ MUX_VAL(CP(I2C4_SCL),		(IEN  | PTU | EN  | M0)) /*I2C4_SCL*/\
+ MUX_VAL(CP(I2C4_SDA),		(IEN  | PTU | EN  | M0)) /*I2C4_SDA*/\
+ MUX_VAL(CP(HDQ_SIO),		(IDIS | PTU | EN  | M4)) /*GPIO_170*/\
+ MUX_VAL(CP(MCSPI1_CLK),	(IEN  | PTU | EN  | M4)) /*GPIO_171*/\
+ MUX_VAL(CP(MCSPI1_SIMO),	(IEN  | PTU | EN  | M4)) /*GPIO_172*/\
+ MUX_VAL(CP(MCSPI1_SOMI),	(IEN  | PTD | DIS | M0)) /*McSPI1_SOMI*/\
+ MUX_VAL(CP(MCSPI1_CS0),	(IEN  | PTD | EN  | M0)) /*McSPI1_CS0*/\
+ MUX_VAL(CP(MCSPI1_CS1),	(IDIS | PTD | EN  | M0)) /*McSPI1_CS1*/\
+ MUX_VAL(CP(MCSPI1_CS2),	(IDIS | PTD | DIS | M4)) /*GPIO_176*/\
+ /* USB EHCI (port 2) */\
+ MUX_VAL(CP(MCSPI1_CS3),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA2*/\
+ MUX_VAL(CP(MCSPI2_CLK),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA7*/\
+ MUX_VAL(CP(MCSPI2_SIMO),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA4*/\
+ MUX_VAL(CP(MCSPI2_SOMI),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA5*/\
+ MUX_VAL(CP(MCSPI2_CS0),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA6*/\
+ MUX_VAL(CP(MCSPI2_CS1),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA3*/\
+ MUX_VAL(CP(ETK_D10_ES2),	(IDIS | PTU | DIS | M3)) /*HSUSB2_CLK*/\
+ MUX_VAL(CP(ETK_D11_ES2),	(IDIS | PTU | DIS | M3)) /*HSUSB2_STP*/\
+ MUX_VAL(CP(ETK_D12_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DIR*/\
+ MUX_VAL(CP(ETK_D13_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_NXT*/\
+ MUX_VAL(CP(ETK_D14_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA0*/\
+ MUX_VAL(CP(ETK_D15_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA1*/\
+ /*Control and debug */\
+ MUX_VAL(CP(SYS_32K),		(IEN  | PTD | DIS | M0)) /*SYS_32K*/\
+ MUX_VAL(CP(SYS_CLKREQ),	(IEN  | PTD | DIS | M0)) /*SYS_CLKREQ*/\
+ MUX_VAL(CP(SYS_NIRQ),		(IEN  | PTU | EN  | M0)) /*SYS_nIRQ*/\
+ MUX_VAL(CP(SYS_BOOT0),		(IEN  | PTD | DIS | M4)) /*GPIO_2*/\
+ MUX_VAL(CP(SYS_BOOT1),		(IEN  | PTD | DIS | M4)) /*GPIO_3*/\
+ MUX_VAL(CP(SYS_BOOT2),		(IEN  | PTD | DIS | M4)) /*GPIO_4 - MMC1_WP*/\
+ MUX_VAL(CP(SYS_BOOT3),		(IEN  | PTD | DIS | M4)) /*GPIO_5*/\
+ MUX_VAL(CP(SYS_BOOT4),		(IEN  | PTD | DIS | M4)) /*GPIO_6*/\
+ MUX_VAL(CP(SYS_BOOT5),		(IEN  | PTD | DIS | M4)) /*GPIO_7*/\
+ MUX_VAL(CP(SYS_BOOT6),		(IDIS | PTD | DIS | M4)) /*GPIO_8*/ \
+ MUX_VAL(CP(SYS_OFF_MODE),	(IEN  | PTD | DIS | M0)) /*SYS_OFF_MODE*/\
+ MUX_VAL(CP(SYS_CLKOUT1),	(IEN  | PTD | DIS | M0)) /*SYS_CLKOUT1*/\
+ MUX_VAL(CP(SYS_CLKOUT2),	(IEN  | PTU | EN  | M4)) /*GPIO_186*/\
+ MUX_VAL(CP(ETK_CLK_ES2),	(IDIS | PTU | EN  | M3)) /*HSUSB1_STP*/\
+ MUX_VAL(CP(ETK_CTL_ES2),	(IDIS | PTU | DIS | M3)) /*HSUSB1_CLK*/\
+ MUX_VAL(CP(ETK_D0_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA0*/\
+ MUX_VAL(CP(ETK_D1_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA1*/\
+ MUX_VAL(CP(ETK_D2_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA2*/\
+ MUX_VAL(CP(ETK_D3_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA7*/\
+ MUX_VAL(CP(ETK_D4_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA4*/\
+ MUX_VAL(CP(ETK_D5_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA5*/\
+ MUX_VAL(CP(ETK_D6_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA6*/\
+ MUX_VAL(CP(ETK_D7_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA3*/\
+ MUX_VAL(CP(ETK_D8_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DIR*/\
+ MUX_VAL(CP(ETK_D9_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_NXT*/\
+ MUX_VAL(CP(D2D_MCAD1),		(IEN  | PTD | EN  | M0)) /*d2d_mcad1*/\
+ MUX_VAL(CP(D2D_MCAD2),		(IEN  | PTD | EN  | M0)) /*d2d_mcad2*/\
+ MUX_VAL(CP(D2D_MCAD3),		(IEN  | PTD | EN  | M0)) /*d2d_mcad3*/\
+ MUX_VAL(CP(D2D_MCAD4),		(IEN  | PTD | EN  | M0)) /*d2d_mcad4*/\
+ MUX_VAL(CP(D2D_MCAD5),		(IEN  | PTD | EN  | M0)) /*d2d_mcad5*/\
+ MUX_VAL(CP(D2D_MCAD6),		(IEN  | PTD | EN  | M0)) /*d2d_mcad6*/\
+ MUX_VAL(CP(D2D_MCAD7),		(IEN  | PTD | EN  | M0)) /*d2d_mcad7*/\
+ MUX_VAL(CP(D2D_MCAD8),		(IEN  | PTD | EN  | M0)) /*d2d_mcad8*/\
+ MUX_VAL(CP(D2D_MCAD9),		(IEN  | PTD | EN  | M0)) /*d2d_mcad9*/\
+ MUX_VAL(CP(D2D_MCAD10),	(IEN  | PTD | EN  | M0)) /*d2d_mcad10*/\
+ MUX_VAL(CP(D2D_MCAD11),	(IEN  | PTD | EN  | M0)) /*d2d_mcad11*/\
+ MUX_VAL(CP(D2D_MCAD12),	(IEN  | PTD | EN  | M0)) /*d2d_mcad12*/\
+ MUX_VAL(CP(D2D_MCAD13),	(IEN  | PTD | EN  | M0)) /*d2d_mcad13*/\
+ MUX_VAL(CP(D2D_MCAD14),	(IEN  | PTD | EN  | M0)) /*d2d_mcad14*/\
+ MUX_VAL(CP(D2D_MCAD15),	(IEN  | PTD | EN  | M0)) /*d2d_mcad15*/\
+ MUX_VAL(CP(D2D_MCAD16),	(IEN  | PTD | EN  | M0)) /*d2d_mcad16*/\
+ MUX_VAL(CP(D2D_MCAD17),	(IEN  | PTD | EN  | M0)) /*d2d_mcad17*/\
+ MUX_VAL(CP(D2D_MCAD18),	(IEN  | PTD | EN  | M0)) /*d2d_mcad18*/\
+ MUX_VAL(CP(D2D_MCAD19),	(IEN  | PTD | EN  | M0)) /*d2d_mcad19*/\
+ MUX_VAL(CP(D2D_MCAD20),	(IEN  | PTD | EN  | M0)) /*d2d_mcad20*/\
+ MUX_VAL(CP(D2D_MCAD21),	(IEN  | PTD | EN  | M0)) /*d2d_mcad21*/\
+ MUX_VAL(CP(D2D_MCAD22),	(IEN  | PTD | EN  | M0)) /*d2d_mcad22*/\
+ MUX_VAL(CP(D2D_MCAD23),	(IEN  | PTD | EN  | M0)) /*d2d_mcad23*/\
+ MUX_VAL(CP(D2D_MCAD24),	(IEN  | PTD | EN  | M0)) /*d2d_mcad24*/\
+ MUX_VAL(CP(D2D_MCAD25),	(IEN  | PTD | EN  | M0)) /*d2d_mcad25*/\
+ MUX_VAL(CP(D2D_MCAD26),	(IEN  | PTD | EN  | M0)) /*d2d_mcad26*/\
+ MUX_VAL(CP(D2D_MCAD27),	(IEN  | PTD | EN  | M0)) /*d2d_mcad27*/\
+ MUX_VAL(CP(D2D_MCAD28),	(IEN  | PTD | EN  | M0)) /*d2d_mcad28*/\
+ MUX_VAL(CP(D2D_MCAD29),	(IEN  | PTD | EN  | M0)) /*d2d_mcad29*/\
+ MUX_VAL(CP(D2D_MCAD30),	(IEN  | PTD | EN  | M0)) /*d2d_mcad30*/\
+ MUX_VAL(CP(D2D_MCAD31),	(IEN  | PTD | EN  | M0)) /*d2d_mcad31*/\
+ MUX_VAL(CP(D2D_MCAD32),	(IEN  | PTD | EN  | M0)) /*d2d_mcad32*/\
+ MUX_VAL(CP(D2D_MCAD33),	(IEN  | PTD | EN  | M0)) /*d2d_mcad33*/\
+ MUX_VAL(CP(D2D_MCAD34),	(IEN  | PTD | EN  | M0)) /*d2d_mcad34*/\
+ MUX_VAL(CP(D2D_MCAD35),	(IEN  | PTD | EN  | M0)) /*d2d_mcad35*/\
+ MUX_VAL(CP(D2D_MCAD36),	(IEN  | PTD | EN  | M0)) /*d2d_mcad36*/\
+ MUX_VAL(CP(D2D_CLK26MI),	(IEN  | PTD | DIS | M0)) /*d2d_clk26mi*/\
+ MUX_VAL(CP(D2D_NRESPWRON),	(IEN  | PTD | EN  | M0)) /*d2d_nrespwron*/\
+ MUX_VAL(CP(D2D_NRESWARM),	(IEN  | PTU | EN  | M0)) /*d2d_nreswarm */\
+ MUX_VAL(CP(D2D_ARM9NIRQ),	(IEN  | PTD | DIS | M0)) /*d2d_arm9nirq */\
+ MUX_VAL(CP(D2D_UMA2P6FIQ),	(IEN  | PTD | DIS | M0)) /*d2d_uma2p6fiq*/\
+ MUX_VAL(CP(D2D_SPINT),		(IEN  | PTD | EN  | M0)) /*d2d_spint*/\
+ MUX_VAL(CP(D2D_FRINT),		(IEN  | PTD | EN  | M0)) /*d2d_frint*/\
+ MUX_VAL(CP(D2D_DMAREQ0),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq0*/\
+ MUX_VAL(CP(D2D_DMAREQ1),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq1*/\
+ MUX_VAL(CP(D2D_DMAREQ2),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq2*/\
+ MUX_VAL(CP(D2D_DMAREQ3),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq3*/\
+ MUX_VAL(CP(D2D_N3GTRST),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtrst*/\
+ MUX_VAL(CP(D2D_N3GTDI),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdi*/\
+ MUX_VAL(CP(D2D_N3GTDO),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdo*/\
+ MUX_VAL(CP(D2D_N3GTMS),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtms*/\
+ MUX_VAL(CP(D2D_N3GTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtck*/\
+ MUX_VAL(CP(D2D_N3GRTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3grtck*/\
+ MUX_VAL(CP(D2D_MSTDBY),	(IEN  | PTU | EN  | M0)) /*d2d_mstdby*/\
+ MUX_VAL(CP(D2D_SWAKEUP),	(IEN  | PTD | EN  | M0)) /*d2d_swakeup*/\
+ MUX_VAL(CP(D2D_IDLEREQ),	(IEN  | PTD | DIS | M0)) /*d2d_idlereq*/\
+ MUX_VAL(CP(D2D_IDLEACK),	(IEN  | PTU | EN  | M0)) /*d2d_idleack*/\
+ MUX_VAL(CP(D2D_MWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_mwrite*/\
+ MUX_VAL(CP(D2D_SWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_swrite*/\
+ MUX_VAL(CP(D2D_MREAD),		(IEN  | PTD | DIS | M0)) /*d2d_mread*/\
+ MUX_VAL(CP(D2D_SREAD),		(IEN  | PTD | DIS | M0)) /*d2d_sread*/\
+ MUX_VAL(CP(D2D_MBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_mbusflag*/\
+ MUX_VAL(CP(D2D_SBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_sbusflag*/\
+ MUX_VAL(CP(SDRC_CKE0),		(IDIS | PTU | EN  | M0)) /*sdrc_cke0*/\
+ MUX_VAL(CP(SDRC_CKE1),		(IDIS | PTD | DIS | M7)) /*sdrc_cke1*/
+#endif
diff -Naur u-boot-2009.01/board/omap3/beagle/config.mk u-boot/board/omap3/beagle/config.mk
--- u-boot-2009.01/board/omap3/beagle/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/beagle/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2006
+# Texas Instruments, <www.ti.com>
+#
+# Beagle Board uses OMAP3 (ARM-CortexA8) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+# Physical Address:
+# 8000'0000 (bank0)
+# A000/0000 (bank1)
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+
+# For use with external or internal boots.
+TEXT_BASE = 0x80e80000
diff -Naur u-boot-2009.01/board/omap3/beagle/Makefile u-boot/board/omap3/beagle/Makefile
--- u-boot-2009.01/board/omap3/beagle/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/beagle/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,49 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= beagle.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/omap3/beagle/u-boot.lds u-boot/board/omap3/beagle/u-boot.lds
--- u-boot-2009.01/board/omap3/beagle/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/beagle/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,63 @@
+/*
+ * January 2004 - Changed to support H4 device
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm_cortexa8/start.o	(.text)
+		*(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	.ARM.extab	: { *(.ARM.extab* .gnu.linkonce.armextab.*) }
+	__exidx_start = .;
+	.ARM.exidx	: { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
+	__exidx_end = .;
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/omap3/common/Makefile u-boot/board/omap3/common/Makefile
--- u-boot-2009.01/board/omap3/common/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/common/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,53 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+ifneq ($(OBJTREE),$(SRCTREE))
+$(shell mkdir -p $(obj)board/$(VENDOR)/common)
+endif
+
+LIB	= $(obj)lib$(VENDOR).a
+
+COBJS-$(CONFIG_OMAP3_BEAGLE) += power.o
+COBJS-$(CONFIG_OMAP3_OVERO) += power.o
+COBJS-$(CONFIG_OMAP3_PANDORA) += power.o
+COBJS-$(CONFIG_OMAP3_ZOOM1) += power.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/omap3/common/power.c u-boot/board/omap3/common/power.c
--- u-boot-2009.01/board/omap3/common/power.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/common/power.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,74 @@
+/*
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Author :
+ *	Sunil Kumar <sunilsaini05@gmail.com>
+ *	Shashi Ranjan <shashiranjanmca05@gmail.com>
+ *
+ * Derived from Beagle Board and 3430 SDP code by
+ *	Richard Woodruff <r-woodruff2@ti.com>
+ *	Syed Mohammed Khasim <khasim@ti.com>
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+
+/******************************************************************************
+ * Routine: power_init_r
+ * Description: Configure power supply
+ *****************************************************************************/
+void power_init_r(void)
+{
+	unsigned char byte;
+
+#ifdef CONFIG_DRIVER_OMAP34XX_I2C
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+#endif
+
+	/*
+	 * Configure OMAP3 supply voltages in power management
+	 * companion chip.
+	 */
+
+	/* set VAUX3 to 2.8V */
+	byte = DEV_GRP_P1;
+	i2c_write(PWRMGT_ADDR_ID4, VAUX3_DEV_GRP, 1, &byte, 1);
+	byte = VAUX3_VSEL_28;
+	i2c_write(PWRMGT_ADDR_ID4, VAUX3_DEDICATED, 1, &byte, 1);
+
+	/* set VPLL2 to 1.8V */
+	byte = DEV_GRP_ALL;
+	i2c_write(PWRMGT_ADDR_ID4, VPLL2_DEV_GRP, 1, &byte, 1);
+	byte = VPLL2_VSEL_18;
+	i2c_write(PWRMGT_ADDR_ID4, VPLL2_DEDICATED, 1, &byte, 1);
+
+	/* set VDAC to 1.8V */
+	byte = DEV_GRP_P1;
+	i2c_write(PWRMGT_ADDR_ID4, VDAC_DEV_GRP, 1, &byte, 1);
+	byte = VDAC_VSEL_18;
+	i2c_write(PWRMGT_ADDR_ID4, VDAC_DEDICATED, 1, &byte, 1);
+
+	/* enable LED */
+	byte = LEDBPWM | LEDAPWM | LEDBON | LEDAON;
+	i2c_write(PWRMGT_ADDR_ID3, LEDEN, 1, &byte, 1);
+}
diff -Naur u-boot-2009.01/board/omap3/evm/config.mk u-boot/board/omap3/evm/config.mk
--- u-boot-2009.01/board/omap3/evm/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/evm/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2006 - 2008
+# Texas Instruments, <www.ti.com>
+#
+# EVM uses OMAP3 (ARM-CortexA8) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+# Physical Address:
+# 8000'0000 (bank0)
+# A000/0000 (bank1)
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+
+# For use with external or internal boots.
+TEXT_BASE = 0x80e80000
diff -Naur u-boot-2009.01/board/omap3/evm/evm.c u-boot/board/omap3/evm/evm.c
--- u-boot-2009.01/board/omap3/evm/evm.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/evm/evm.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,122 @@
+/*
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Author :
+ *	Manikandan Pillai <mani.pillai@ti.com>
+ *
+ * Derived from Beagle Board and 3430 SDP code by
+ *	Richard Woodruff <r-woodruff2@ti.com>
+ *	Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+#include <asm/mach-types.h>
+#include "evm.h"
+
+/******************************************************************************
+ * Routine: board_init
+ * Description: Early hardware init.
+ *****************************************************************************/
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gpmc_init(); /* in SRAM or SDRAM, finish GPMC */
+	/* board id for Linux */
+	gd->bd->bi_arch_number = MACH_TYPE_OMAP3EVM;
+	/* boot param addr */
+	gd->bd->bi_boot_params = (OMAP34XX_SDRC_CS0 + 0x100);
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: misc_init_r
+ * Description: Init ethernet (done here so udelay works)
+ *****************************************************************************/
+int misc_init_r(void)
+{
+
+#ifdef CONFIG_DRIVER_OMAP34XX_I2C
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+#endif
+
+#if defined(CONFIG_CMD_NET)
+	setup_net_chip();
+#endif
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: set_muxconf_regs
+ * Description: Setting up the configuration Mux registers specific to the
+ *		hardware. Many pins need to be moved from protect to primary
+ *		mode.
+ *****************************************************************************/
+void set_muxconf_regs(void)
+{
+	MUX_EVM();
+}
+
+/******************************************************************************
+ * Routine: setup_net_chip
+ * Description: Setting up the configuration GPMC registers specific to the
+ *		Ethernet hardware.
+ *****************************************************************************/
+static void setup_net_chip(void)
+{
+	gpio_t *gpio3_base = (gpio_t *)OMAP34XX_GPIO3_BASE;
+	gpmc_csx_t *gpmc_cs6_base = (gpmc_csx_t *)GPMC_CONFIG_CS6_BASE;
+	ctrl_t *ctrl_base = (ctrl_t *)OMAP34XX_CTRL_BASE;
+
+	/* Configure GPMC registers */
+	writel(NET_GPMC_CONFIG1, &gpmc_cs6_base->config1);
+	writel(NET_GPMC_CONFIG2, &gpmc_cs6_base->config2);
+	writel(NET_GPMC_CONFIG3, &gpmc_cs6_base->config3);
+	writel(NET_GPMC_CONFIG4, &gpmc_cs6_base->config4);
+	writel(NET_GPMC_CONFIG5, &gpmc_cs6_base->config5);
+	writel(NET_GPMC_CONFIG6, &gpmc_cs6_base->config6);
+	writel(NET_GPMC_CONFIG7, &gpmc_cs6_base->config7);
+
+	/* Enable off mode for NWE in PADCONF_GPMC_NWE register */
+	writew(readw(&ctrl_base ->gpmc_nwe) | 0x0E00, &ctrl_base->gpmc_nwe);
+	/* Enable off mode for NOE in PADCONF_GPMC_NADV_ALE register */
+	writew(readw(&ctrl_base->gpmc_noe) | 0x0E00, &ctrl_base->gpmc_noe);
+	/* Enable off mode for ALE in PADCONF_GPMC_NADV_ALE register */
+	writew(readw(&ctrl_base->gpmc_nadv_ale) | 0x0E00,
+		&ctrl_base->gpmc_nadv_ale);
+
+	/* Make GPIO 64 as output pin */
+	writel(readl(&gpio3_base->oe) & ~(GPIO0), &gpio3_base->oe);
+
+	/* Now send a pulse on the GPIO pin */
+	writel(GPIO0, &gpio3_base->setdataout);
+	udelay(1);
+	writel(GPIO0, &gpio3_base->cleardataout);
+	udelay(1);
+	writel(GPIO0, &gpio3_base->setdataout);
+}
diff -Naur u-boot-2009.01/board/omap3/evm/evm.h u-boot/board/omap3/evm/evm.h
--- u-boot-2009.01/board/omap3/evm/evm.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/evm/evm.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,395 @@
+/*
+ * (C) Copyright 2008
+ * Nishanth Menon <menon.nishanth@gmail.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _EVM_H_
+#define _EVM_H_
+
+const omap3_sysinfo sysinfo = {
+	OMAP3EVM_V1,
+	OMAP3EVM_V2,
+	DDR_DISCRETE,
+	"OMAP3 EVM board",
+#if defined(CONFIG_ENV_IS_IN_ONENAND)
+	"OneNAND",
+#else
+	"NAND",
+#endif
+};
+
+static void setup_net_chip(void);
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+#define MUX_EVM() \
+ /*SDRC*/\
+ MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) /*SDRC_D0*/\
+ MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) /*SDRC_D1*/\
+ MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) /*SDRC_D2*/\
+ MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) /*SDRC_D3*/\
+ MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) /*SDRC_D4*/\
+ MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) /*SDRC_D5*/\
+ MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) /*SDRC_D6*/\
+ MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) /*SDRC_D7*/\
+ MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) /*SDRC_D8*/\
+ MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) /*SDRC_D9*/\
+ MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) /*SDRC_D10*/\
+ MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) /*SDRC_D11*/\
+ MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) /*SDRC_D12*/\
+ MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) /*SDRC_D13*/\
+ MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) /*SDRC_D14*/\
+ MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) /*SDRC_D15*/\
+ MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) /*SDRC_D16*/\
+ MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) /*SDRC_D17*/\
+ MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) /*SDRC_D18*/\
+ MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) /*SDRC_D19*/\
+ MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) /*SDRC_D20*/\
+ MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) /*SDRC_D21*/\
+ MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) /*SDRC_D22*/\
+ MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) /*SDRC_D23*/\
+ MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) /*SDRC_D24*/\
+ MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) /*SDRC_D25*/\
+ MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) /*SDRC_D26*/\
+ MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) /*SDRC_D27*/\
+ MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) /*SDRC_D28*/\
+ MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) /*SDRC_D29*/\
+ MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) /*SDRC_D30*/\
+ MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) /*SDRC_D31*/\
+ MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) /*SDRC_CLK*/\
+ MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS0*/\
+ MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS1*/\
+ MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS2*/\
+ MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS3*/\
+ /*GPMC*/\
+ MUX_VAL(CP(GPMC_A1),		(IDIS | PTU | EN  | M0)) /*GPMC_A1*/\
+ MUX_VAL(CP(GPMC_A2),		(IDIS | PTU | EN  | M0)) /*GPMC_A2*/\
+ MUX_VAL(CP(GPMC_A3),		(IDIS | PTU | EN  | M0)) /*GPMC_A3*/\
+ MUX_VAL(CP(GPMC_A4),		(IDIS | PTU | EN  | M0)) /*GPMC_A4*/\
+ MUX_VAL(CP(GPMC_A5),		(IDIS | PTU | EN  | M0)) /*GPMC_A5*/\
+ MUX_VAL(CP(GPMC_A6),		(IDIS | PTU | EN  | M0)) /*GPMC_A6*/\
+ MUX_VAL(CP(GPMC_A7),		(IDIS | PTU | EN  | M0)) /*GPMC_A7*/\
+ MUX_VAL(CP(GPMC_A8),		(IDIS | PTU | EN  | M0)) /*GPMC_A8*/\
+ MUX_VAL(CP(GPMC_A9),		(IDIS | PTU | EN  | M0)) /*GPMC_A9*/\
+ MUX_VAL(CP(GPMC_A10),		(IDIS | PTU | EN  | M0)) /*GPMC_A10*/\
+ MUX_VAL(CP(GPMC_D0),		(IEN  | PTU | EN  | M0)) /*GPMC_D0*/\
+ MUX_VAL(CP(GPMC_D1),		(IEN  | PTU | EN  | M0)) /*GPMC_D1*/\
+ MUX_VAL(CP(GPMC_D2),		(IEN  | PTU | EN  | M0)) /*GPMC_D2*/\
+ MUX_VAL(CP(GPMC_D3),		(IEN  | PTU | EN  | M0)) /*GPMC_D3*/\
+ MUX_VAL(CP(GPMC_D4),		(IEN  | PTU | EN  | M0)) /*GPMC_D4*/\
+ MUX_VAL(CP(GPMC_D5),		(IEN  | PTU | EN  | M0)) /*GPMC_D5*/\
+ MUX_VAL(CP(GPMC_D6),		(IEN  | PTU | EN  | M0)) /*GPMC_D6*/\
+ MUX_VAL(CP(GPMC_D7),		(IEN  | PTU | EN  | M0)) /*GPMC_D7*/\
+ MUX_VAL(CP(GPMC_D8),		(IEN  | PTU | EN  | M0)) /*GPMC_D8*/\
+ MUX_VAL(CP(GPMC_D9),		(IEN  | PTU | EN  | M0)) /*GPMC_D9*/\
+ MUX_VAL(CP(GPMC_D10),		(IEN  | PTU | EN  | M0)) /*GPMC_D10*/\
+ MUX_VAL(CP(GPMC_D11),		(IEN  | PTU | EN  | M0)) /*GPMC_D11*/\
+ MUX_VAL(CP(GPMC_D12),		(IEN  | PTU | EN  | M0)) /*GPMC_D12*/\
+ MUX_VAL(CP(GPMC_D13),		(IEN  | PTU | EN  | M0)) /*GPMC_D13*/\
+ MUX_VAL(CP(GPMC_D14),		(IEN  | PTU | EN  | M0)) /*GPMC_D14*/\
+ MUX_VAL(CP(GPMC_D15),		(IEN  | PTU | EN  | M0)) /*GPMC_D15*/\
+ MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS0*/\
+ MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS1*/\
+ MUX_VAL(CP(GPMC_NCS2),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS2*/\
+ MUX_VAL(CP(GPMC_NCS3),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS3*/\
+ MUX_VAL(CP(GPMC_NCS4),		(IEN  | PTU | EN  | M0)) /*GPMC_nCS4*/\
+ MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS5*/\
+ MUX_VAL(CP(GPMC_NCS6),		(IEN  | PTD | DIS | M0)) /*GPMC_nCS6*/\
+ MUX_VAL(CP(GPMC_NCS7),		(IEN  | PTU | EN  | M0)) /*GPMC_nCS7*/\
+ MUX_VAL(CP(GPMC_CLK),		(IDIS | PTU | EN  | M0)) /*GPMC_CLK*/\
+ MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0)) /*GPMC_nADV_ALE*/\
+ MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0)) /*GPMC_nOE*/\
+ MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0)) /*GPMC_nWE*/\
+ MUX_VAL(CP(GPMC_NBE0_CLE),	(IDIS | PTU | EN  | M0)) /*GPMC_nBE0_CLE*/\
+ MUX_VAL(CP(GPMC_NBE1),		(IEN  | PTU | EN  | M0)) /*GPMC_nBE1*/\
+ MUX_VAL(CP(GPMC_NWP),		(IEN  | PTD | DIS | M0)) /*GPMC_nWP*/\
+ MUX_VAL(CP(GPMC_WAIT0),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT0*/\
+ MUX_VAL(CP(GPMC_WAIT1),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT1*/\
+ MUX_VAL(CP(GPMC_WAIT2),	(IEN  | PTU | EN  | M4)) /*GPIO_64*/\
+							 /* - ETH_nRESET*/\
+ MUX_VAL(CP(GPMC_WAIT3),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT3*/\
+ /*DSS*/\
+ MUX_VAL(CP(DSS_PCLK),		(IDIS | PTD | DIS | M0)) /*DSS_PCLK*/\
+ MUX_VAL(CP(DSS_HSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_HSYNC*/\
+ MUX_VAL(CP(DSS_VSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_VSYNC*/\
+ MUX_VAL(CP(DSS_ACBIAS),		(IDIS | PTD | DIS | M0)) /*DSS_ACBIAS*/\
+ MUX_VAL(CP(DSS_DATA0),		(IDIS | PTD | DIS | M0)) /*DSS_DATA0*/\
+ MUX_VAL(CP(DSS_DATA1),		(IDIS | PTD | DIS | M0)) /*DSS_DATA1*/\
+ MUX_VAL(CP(DSS_DATA2),		(IDIS | PTD | DIS | M0)) /*DSS_DATA2*/\
+ MUX_VAL(CP(DSS_DATA3),		(IDIS | PTD | DIS | M0)) /*DSS_DATA3*/\
+ MUX_VAL(CP(DSS_DATA4),		(IDIS | PTD | DIS | M0)) /*DSS_DATA4*/\
+ MUX_VAL(CP(DSS_DATA5),		(IDIS | PTD | DIS | M0)) /*DSS_DATA5*/\
+ MUX_VAL(CP(DSS_DATA6),		(IDIS | PTD | DIS | M0)) /*DSS_DATA6*/\
+ MUX_VAL(CP(DSS_DATA7),		(IDIS | PTD | DIS | M0)) /*DSS_DATA7*/\
+ MUX_VAL(CP(DSS_DATA8),		(IDIS | PTD | DIS | M0)) /*DSS_DATA8*/\
+ MUX_VAL(CP(DSS_DATA9),		(IDIS | PTD | DIS | M0)) /*DSS_DATA9*/\
+ MUX_VAL(CP(DSS_DATA10),	(IDIS | PTD | DIS | M0)) /*DSS_DATA10*/\
+ MUX_VAL(CP(DSS_DATA11),	(IDIS | PTD | DIS | M0)) /*DSS_DATA11*/\
+ MUX_VAL(CP(DSS_DATA12),	(IDIS | PTD | DIS | M0)) /*DSS_DATA12*/\
+ MUX_VAL(CP(DSS_DATA13),	(IDIS | PTD | DIS | M0)) /*DSS_DATA13*/\
+ MUX_VAL(CP(DSS_DATA14),	(IDIS | PTD | DIS | M0)) /*DSS_DATA14*/\
+ MUX_VAL(CP(DSS_DATA15),	(IDIS | PTD | DIS | M0)) /*DSS_DATA15*/\
+ MUX_VAL(CP(DSS_DATA16),	(IDIS | PTD | DIS | M0)) /*DSS_DATA16*/\
+ MUX_VAL(CP(DSS_DATA17),	(IDIS | PTD | DIS | M0)) /*DSS_DATA17*/\
+ MUX_VAL(CP(DSS_DATA18),	(IDIS | PTD | DIS | M0)) /*DSS_DATA18*/\
+ MUX_VAL(CP(DSS_DATA19),	(IDIS | PTD | DIS | M0)) /*DSS_DATA19*/\
+ MUX_VAL(CP(DSS_DATA20),	(IDIS | PTD | DIS | M0)) /*DSS_DATA20*/\
+ MUX_VAL(CP(DSS_DATA21),	(IDIS | PTD | DIS | M0)) /*DSS_DATA21*/\
+ MUX_VAL(CP(DSS_DATA22),	(IDIS | PTD | DIS | M0)) /*DSS_DATA22*/\
+ MUX_VAL(CP(DSS_DATA23),	(IDIS | PTD | DIS | M0)) /*DSS_DATA23*/\
+ /*CAMERA*/\
+ MUX_VAL(CP(CAM_HS),		(IEN  | PTU | EN  | M0)) /*CAM_HS */\
+ MUX_VAL(CP(CAM_VS),		(IEN  | PTU | EN  | M0)) /*CAM_VS */\
+ MUX_VAL(CP(CAM_XCLKA),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKA*/\
+ MUX_VAL(CP(CAM_PCLK),		(IEN  | PTU | EN  | M0)) /*CAM_PCLK*/\
+ MUX_VAL(CP(CAM_FLD),		(IDIS | PTD | DIS | M4)) /*GPIO_98*/\
+							 /* - CAM_RESET*/\
+ MUX_VAL(CP(CAM_D0),		(IEN  | PTD | DIS | M0)) /*CAM_D0*/\
+ MUX_VAL(CP(CAM_D1),		(IEN  | PTD | DIS | M0)) /*CAM_D1*/\
+ MUX_VAL(CP(CAM_D2),		(IEN  | PTD | DIS | M0)) /*CAM_D2*/\
+ MUX_VAL(CP(CAM_D3),		(IEN  | PTD | DIS | M0)) /*CAM_D3*/\
+ MUX_VAL(CP(CAM_D4),		(IEN  | PTD | DIS | M0)) /*CAM_D4*/\
+ MUX_VAL(CP(CAM_D5),		(IEN  | PTD | DIS | M0)) /*CAM_D5*/\
+ MUX_VAL(CP(CAM_D6),		(IEN  | PTD | DIS | M0)) /*CAM_D6*/\
+ MUX_VAL(CP(CAM_D7),		(IEN  | PTD | DIS | M0)) /*CAM_D7*/\
+ MUX_VAL(CP(CAM_D8),		(IEN  | PTD | DIS | M0)) /*CAM_D8*/\
+ MUX_VAL(CP(CAM_D9),		(IEN  | PTD | DIS | M0)) /*CAM_D9*/\
+ MUX_VAL(CP(CAM_D10),		(IEN  | PTD | DIS | M0)) /*CAM_D10*/\
+ MUX_VAL(CP(CAM_D11),		(IEN  | PTD | DIS | M0)) /*CAM_D11*/\
+ MUX_VAL(CP(CAM_XCLKB),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKB*/\
+ MUX_VAL(CP(CAM_WEN),		(IEN  | PTD | DIS | M4)) /*GPIO_167*/\
+ MUX_VAL(CP(CAM_STROBE),	(IDIS | PTD | DIS | M0)) /*CAM_STROBE*/\
+ MUX_VAL(CP(CSI2_DX0),		(IEN  | PTD | DIS | M0)) /*CSI2_DX0*/\
+ MUX_VAL(CP(CSI2_DY0),		(IEN  | PTD | DIS | M0)) /*CSI2_DY0*/\
+ MUX_VAL(CP(CSI2_DX1),		(IEN  | PTD | DIS | M0)) /*CSI2_DX1*/\
+ MUX_VAL(CP(CSI2_DY1),		(IEN  | PTD | DIS | M0)) /*CSI2_DY1*/\
+ /*Audio Interface */\
+ MUX_VAL(CP(MCBSP2_FSX),	(IEN  | PTD | DIS | M0)) /*McBSP2_FSX*/\
+ MUX_VAL(CP(MCBSP2_CLKX),	(IEN  | PTD | DIS | M0)) /*McBSP2_CLKX*/\
+ MUX_VAL(CP(MCBSP2_DR),		(IEN  | PTD | DIS | M0)) /*McBSP2_DR*/\
+ MUX_VAL(CP(MCBSP2_DX),		(IDIS | PTD | DIS | M0)) /*McBSP2_DX*/\
+ /*Expansion card  */\
+ MUX_VAL(CP(MMC1_CLK),		(IDIS | PTU | EN  | M0)) /*MMC1_CLK*/\
+ MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | EN  | M0)) /*MMC1_CMD*/\
+ MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT0*/\
+ MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT1*/\
+ MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT2*/\
+ MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT3*/\
+ MUX_VAL(CP(MMC1_DAT4),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT4*/\
+ MUX_VAL(CP(MMC1_DAT5),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT5*/\
+ MUX_VAL(CP(MMC1_DAT6),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT6*/\
+ MUX_VAL(CP(MMC1_DAT7),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT7*/\
+ /*Wireless LAN */\
+ MUX_VAL(CP(MMC2_CLK),		(IEN  | PTD | DIS | M0)) /*MMC2_CLK*/\
+ MUX_VAL(CP(MMC2_CMD),		(IEN  | PTU | EN  | M0)) /*MMC2_CMD*/\
+ MUX_VAL(CP(MMC2_DAT0),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT0*/\
+ MUX_VAL(CP(MMC2_DAT1),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT1*/\
+ MUX_VAL(CP(MMC2_DAT2),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT2*/\
+ MUX_VAL(CP(MMC2_DAT3),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT3*/\
+ MUX_VAL(CP(MMC2_DAT4),		(IDIS | PTD | DIS | M0)) /*MMC2_DAT4*/\
+ MUX_VAL(CP(MMC2_DAT5),		(IDIS | PTD | DIS | M0)) /*MMC2_DAT5*/\
+ MUX_VAL(CP(MMC2_DAT6),		(IDIS | PTD | DIS | M0)) /*MMC2_DAT6 */\
+ MUX_VAL(CP(MMC2_DAT7),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT7*/\
+ /*Bluetooth*/\
+ MUX_VAL(CP(MCBSP3_DX),		(IDIS | PTD | DIS | M0)) /*McBSP3_DX*/\
+ MUX_VAL(CP(MCBSP3_DR),		(IEN  | PTD | DIS | M0)) /*McBSP3_DR*/\
+ MUX_VAL(CP(MCBSP3_CLKX),	(IEN  | PTD | DIS | M0)) /*McBSP3_CLKX  */\
+ MUX_VAL(CP(MCBSP3_FSX),	(IEN  | PTD | DIS | M0)) /*McBSP3_FSX*/\
+ MUX_VAL(CP(UART2_CTS),		(IEN  | PTU | EN  | M0)) /*UART2_CTS*/\
+ MUX_VAL(CP(UART2_RTS),		(IDIS | PTD | DIS | M0)) /*UART2_RTS*/\
+ MUX_VAL(CP(UART2_TX),		(IDIS | PTD | DIS | M0)) /*UART2_TX*/\
+ MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M0)) /*UART2_RX*/\
+ /*Modem Interface */\
+ MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0)) /*UART1_TX*/\
+ MUX_VAL(CP(UART1_RTS),		(IDIS | PTD | DIS | M0)) /*UART1_RTS*/\
+ MUX_VAL(CP(UART1_CTS),		(IEN  | PTU | DIS | M0)) /*UART1_CTS*/\
+ MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0)) /*UART1_RX*/\
+ MUX_VAL(CP(MCBSP4_CLKX),	(IDIS | PTD | DIS | M4)) /*GPIO_152*/\
+							 /* - LCD_INI*/\
+ MUX_VAL(CP(MCBSP4_DR),		(IDIS | PTD | DIS | M4)) /*GPIO_153*/\
+							 /* - LCD_ENVDD */\
+ MUX_VAL(CP(MCBSP4_DX),		(IDIS | PTD | DIS | M4)) /*GPIO_154*/\
+							 /* - LCD_QVGA/nVGA */\
+ MUX_VAL(CP(MCBSP4_FSX),	(IDIS | PTD | DIS | M4)) /*GPIO_155*/\
+							 /* - LCD_RESB */\
+ MUX_VAL(CP(MCBSP1_CLKR),	(IEN  | PTD | DIS | M0)) /*MCBSP1_CLKR  */\
+ MUX_VAL(CP(MCBSP1_FSR),	(IDIS | PTU | EN  | M0)) /*MCBSP1_FSR*/\
+ MUX_VAL(CP(MCBSP1_DX),		(IDIS | PTD | DIS | M0)) /*MCBSP1_DX*/\
+ MUX_VAL(CP(MCBSP1_DR),		(IEN  | PTD | DIS | M0)) /*MCBSP1_DR*/\
+ MUX_VAL(CP(MCBSP_CLKS),	(IEN  | PTU | DIS | M0)) /*MCBSP_CLKS  */\
+ MUX_VAL(CP(MCBSP1_FSX),	(IEN  | PTD | DIS | M0)) /*MCBSP1_FSX*/\
+ MUX_VAL(CP(MCBSP1_CLKX),	(IEN  | PTD | DIS | M0)) /*MCBSP1_CLKX  */\
+ /*Serial Interface*/\
+ MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTD | EN  | M0)) /*UART3_CTS_*/\
+							 /* RCTX*/\
+ MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M0)) /*UART3_RTS_SD */\
+ MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0)) /*UART3_RX_IRRX*/\
+ MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0)) /*UART3_TX_IRTX*/\
+ MUX_VAL(CP(HSUSB0_CLK),	(IEN  | PTD | DIS | M0)) /*HSUSB0_CLK*/\
+ MUX_VAL(CP(HSUSB0_STP),	(IDIS | PTU | EN  | M0)) /*HSUSB0_STP*/\
+ MUX_VAL(CP(HSUSB0_DIR),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DIR*/\
+ MUX_VAL(CP(HSUSB0_NXT),	(IEN  | PTD | DIS | M0)) /*HSUSB0_NXT*/\
+ MUX_VAL(CP(HSUSB0_DATA0),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA0*/\
+ MUX_VAL(CP(HSUSB0_DATA1),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA1*/\
+ MUX_VAL(CP(HSUSB0_DATA2),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA2*/\
+ MUX_VAL(CP(HSUSB0_DATA3),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA3*/\
+ MUX_VAL(CP(HSUSB0_DATA4),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA4*/\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA5*/\
+ MUX_VAL(CP(HSUSB0_DATA6),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA6*/\
+ MUX_VAL(CP(HSUSB0_DATA7),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA7*/\
+ MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0)) /*I2C1_SCL*/\
+ MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0)) /*I2C1_SDA*/\
+ MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M0)) /*I2C2_SCL*/\
+ MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M0)) /*I2C2_SDA*/\
+ MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)) /*I2C3_SCL*/\
+ MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)) /*I2C3_SDA*/\
+ MUX_VAL(CP(I2C4_SCL),		(IEN  | PTU | EN  | M0)) /*I2C4_SCL*/\
+ MUX_VAL(CP(I2C4_SDA),		(IEN  | PTU | EN  | M0)) /*I2C4_SDA*/\
+ MUX_VAL(CP(HDQ_SIO),		(IEN  | PTU | EN  | M0)) /*HDQ_SIO*/\
+ MUX_VAL(CP(MCSPI1_CLK),	(IEN  | PTD | DIS | M0)) /*McSPI1_CLK*/\
+ MUX_VAL(CP(MCSPI1_SIMO),	(IEN  | PTD | DIS | M0)) /*McSPI1_SIMO  */\
+ MUX_VAL(CP(MCSPI1_SOMI),	(IEN  | PTD | DIS | M0)) /*McSPI1_SOMI  */\
+ MUX_VAL(CP(MCSPI1_CS0),	(IEN  | PTD | EN  | M0)) /*McSPI1_CS0*/\
+ MUX_VAL(CP(MCSPI1_CS1),	(IEN  | PTD | EN  | M4)) /*GPIO_175*/\
+							 /* TS_PEN_IRQ */\
+ MUX_VAL(CP(MCSPI1_CS2),	(IEN  | PTU | DIS | M4)) /*GPIO_176*/\
+							 /* - LAN_INTR*/\
+ MUX_VAL(CP(MCSPI1_CS3),	(IEN  | PTD | EN  | M0)) /*McSPI1_CS3*/\
+ MUX_VAL(CP(MCSPI2_CLK),	(IEN  | PTD | DIS | M0)) /*McSPI2_CLK*/\
+ MUX_VAL(CP(MCSPI2_SIMO),	(IEN  | PTD | DIS | M0)) /*McSPI2_SIMO*/\
+ MUX_VAL(CP(MCSPI2_SOMI),	(IEN  | PTD | DIS | M0)) /*McSPI2_SOMI*/\
+ MUX_VAL(CP(MCSPI2_CS0),	(IEN  | PTD | EN  | M0)) /*McSPI2_CS0*/\
+ MUX_VAL(CP(MCSPI2_CS1),	(IEN  | PTD | EN  | M0)) /*McSPI2_CS1*/\
+ /*Control and debug */\
+ MUX_VAL(CP(SYS_32K),		(IEN  | PTD | DIS | M0)) /*SYS_32K*/\
+ MUX_VAL(CP(SYS_CLKREQ),	(IEN  | PTD | DIS | M0)) /*SYS_CLKREQ*/\
+ MUX_VAL(CP(SYS_NIRQ),		(IEN  | PTU | EN  | M0)) /*SYS_nIRQ*/\
+ MUX_VAL(CP(SYS_BOOT0),		(IEN  | PTD | DIS | M4)) /*GPIO_2*/\
+							 /* - PEN_IRQ */\
+ MUX_VAL(CP(SYS_BOOT1),		(IEN  | PTD | DIS | M4)) /*GPIO_3 */\
+ MUX_VAL(CP(SYS_BOOT2),		(IEN  | PTD | DIS | M4)) /*GPIO_4*/\
+ MUX_VAL(CP(SYS_BOOT3),		(IEN  | PTD | DIS | M4)) /*GPIO_5*/\
+ MUX_VAL(CP(SYS_BOOT4),		(IEN  | PTD | DIS | M4)) /*GPIO_6*/\
+ MUX_VAL(CP(SYS_BOOT5),		(IEN  | PTD | DIS | M4)) /*GPIO_7*/\
+ MUX_VAL(CP(SYS_BOOT6),		(IDIS | PTD | DIS | M4)) /*GPIO_8*/\
+							 /* - VIO_1V8*/\
+ MUX_VAL(CP(SYS_OFF_MODE),	(IEN  | PTD | DIS | M0)) /*SYS_OFF_MODE*/\
+ MUX_VAL(CP(SYS_CLKOUT1),	(IEN  | PTD | DIS | M0)) /*SYS_CLKOUT1*/\
+ MUX_VAL(CP(SYS_CLKOUT2),	(IEN  | PTU | EN  | M0)) /*SYS_CLKOUT2*/\
+ MUX_VAL(CP(JTAG_nTRST),	(IEN  | PTD | DIS | M0)) /*JTAG_nTRST*/\
+ MUX_VAL(CP(JTAG_TCK),		(IEN  | PTD | DIS | M0)) /*JTAG_TCK*/\
+ MUX_VAL(CP(JTAG_TMS),		(IEN  | PTD | DIS | M0)) /*JTAG_TMS*/\
+ MUX_VAL(CP(JTAG_TDI),		(IEN  | PTD | DIS | M0)) /*JTAG_TDI*/\
+ MUX_VAL(CP(JTAG_EMU0),		(IEN  | PTD | DIS | M0)) /*JTAG_EMU0*/\
+ MUX_VAL(CP(JTAG_EMU1),		(IEN  | PTD | DIS | M0)) /*JTAG_EMU1*/\
+ MUX_VAL(CP(ETK_CLK_ES2),	(IDIS | PTU | EN  | M0)) /*ETK_CLK*/\
+ MUX_VAL(CP(ETK_CTL_ES2),	(IDIS | PTD | DIS | M0)) /*ETK_CTL*/\
+ MUX_VAL(CP(ETK_D0_ES2 ),	(IEN  | PTD | DIS | M0)) /*ETK_D0*/\
+ MUX_VAL(CP(ETK_D1_ES2 ),	(IEN  | PTD | DIS | M0)) /*ETK_D1*/\
+ MUX_VAL(CP(ETK_D2_ES2 ),	(IEN  | PTD | EN  | M0)) /*ETK_D2*/\
+ MUX_VAL(CP(ETK_D3_ES2 ),	(IEN  | PTD | DIS | M0)) /*ETK_D3*/\
+ MUX_VAL(CP(ETK_D4_ES2 ),	(IEN  | PTD | DIS | M0)) /*ETK_D4*/\
+ MUX_VAL(CP(ETK_D5_ES2 ),	(IEN  | PTD | DIS | M0)) /*ETK_D5*/\
+ MUX_VAL(CP(ETK_D6_ES2 ),	(IEN  | PTD | DIS | M0)) /*ETK_D6*/\
+ MUX_VAL(CP(ETK_D7_ES2 ),	(IEN  | PTD | DIS | M0)) /*ETK_D7*/\
+ MUX_VAL(CP(ETK_D8_ES2 ),	(IEN  | PTD | DIS | M0)) /*ETK_D8*/\
+ MUX_VAL(CP(ETK_D9_ES2 ),	(IEN  | PTD | DIS | M0)) /*ETK_D9*/\
+ MUX_VAL(CP(ETK_D10_ES2),	(IEN  | PTD | DIS | M0)) /*ETK_D10*/\
+ MUX_VAL(CP(ETK_D11_ES2),	(IEN  | PTD | DIS | M0)) /*ETK_D11*/\
+ MUX_VAL(CP(ETK_D12_ES2),	(IEN  | PTD | DIS | M0)) /*ETK_D12*/\
+ MUX_VAL(CP(ETK_D13_ES2),	(IEN  | PTD | DIS | M0)) /*ETK_D13*/\
+ MUX_VAL(CP(ETK_D14_ES2),	(IEN  | PTD | DIS | M0)) /*ETK_D14*/\
+ MUX_VAL(CP(ETK_D15_ES2),	(IEN  | PTD | DIS | M0)) /*ETK_D15*/\
+ /*Die to Die */\
+ MUX_VAL(CP(D2D_MCAD1),		(IEN  | PTD | EN  | M0)) /*d2d_mcad1*/\
+ MUX_VAL(CP(D2D_MCAD2),		(IEN  | PTD | EN  | M0)) /*d2d_mcad2*/\
+ MUX_VAL(CP(D2D_MCAD3),		(IEN  | PTD | EN  | M0)) /*d2d_mcad3*/\
+ MUX_VAL(CP(D2D_MCAD4),		(IEN  | PTD | EN  | M0)) /*d2d_mcad4*/\
+ MUX_VAL(CP(D2D_MCAD5),		(IEN  | PTD | EN  | M0)) /*d2d_mcad5*/\
+ MUX_VAL(CP(D2D_MCAD6),		(IEN  | PTD | EN  | M0)) /*d2d_mcad6*/\
+ MUX_VAL(CP(D2D_MCAD7),		(IEN  | PTD | EN  | M0)) /*d2d_mcad7*/\
+ MUX_VAL(CP(D2D_MCAD8),		(IEN  | PTD | EN  | M0)) /*d2d_mcad8*/\
+ MUX_VAL(CP(D2D_MCAD9),		(IEN  | PTD | EN  | M0)) /*d2d_mcad9*/\
+ MUX_VAL(CP(D2D_MCAD10),	(IEN  | PTD | EN  | M0)) /*d2d_mcad10*/\
+ MUX_VAL(CP(D2D_MCAD11),	(IEN  | PTD | EN  | M0)) /*d2d_mcad11*/\
+ MUX_VAL(CP(D2D_MCAD12),	(IEN  | PTD | EN  | M0)) /*d2d_mcad12*/\
+ MUX_VAL(CP(D2D_MCAD13),	(IEN  | PTD | EN  | M0)) /*d2d_mcad13*/\
+ MUX_VAL(CP(D2D_MCAD14),	(IEN  | PTD | EN  | M0)) /*d2d_mcad14*/\
+ MUX_VAL(CP(D2D_MCAD15),	(IEN  | PTD | EN  | M0)) /*d2d_mcad15*/\
+ MUX_VAL(CP(D2D_MCAD16),	(IEN  | PTD | EN  | M0)) /*d2d_mcad16*/\
+ MUX_VAL(CP(D2D_MCAD17),	(IEN  | PTD | EN  | M0)) /*d2d_mcad17*/\
+ MUX_VAL(CP(D2D_MCAD18),	(IEN  | PTD | EN  | M0)) /*d2d_mcad18*/\
+ MUX_VAL(CP(D2D_MCAD19),	(IEN  | PTD | EN  | M0)) /*d2d_mcad19*/\
+ MUX_VAL(CP(D2D_MCAD20),	(IEN  | PTD | EN  | M0)) /*d2d_mcad20*/\
+ MUX_VAL(CP(D2D_MCAD21),	(IEN  | PTD | EN  | M0)) /*d2d_mcad21*/\
+ MUX_VAL(CP(D2D_MCAD22),	(IEN  | PTD | EN  | M0)) /*d2d_mcad22*/\
+ MUX_VAL(CP(D2D_MCAD23),	(IEN  | PTD | EN  | M0)) /*d2d_mcad23*/\
+ MUX_VAL(CP(D2D_MCAD24),	(IEN  | PTD | EN  | M0)) /*d2d_mcad24*/\
+ MUX_VAL(CP(D2D_MCAD25),	(IEN  | PTD | EN  | M0)) /*d2d_mcad25*/\
+ MUX_VAL(CP(D2D_MCAD26),	(IEN  | PTD | EN  | M0)) /*d2d_mcad26*/\
+ MUX_VAL(CP(D2D_MCAD27),	(IEN  | PTD | EN  | M0)) /*d2d_mcad27*/\
+ MUX_VAL(CP(D2D_MCAD28),	(IEN  | PTD | EN  | M0)) /*d2d_mcad28*/\
+ MUX_VAL(CP(D2D_MCAD29),	(IEN  | PTD | EN  | M0)) /*d2d_mcad29*/\
+ MUX_VAL(CP(D2D_MCAD30),	(IEN  | PTD | EN  | M0)) /*d2d_mcad30*/\
+ MUX_VAL(CP(D2D_MCAD31),	(IEN  | PTD | EN  | M0)) /*d2d_mcad31*/\
+ MUX_VAL(CP(D2D_MCAD32),	(IEN  | PTD | EN  | M0)) /*d2d_mcad32*/\
+ MUX_VAL(CP(D2D_MCAD33),	(IEN  | PTD | EN  | M0)) /*d2d_mcad33*/\
+ MUX_VAL(CP(D2D_MCAD34),	(IEN  | PTD | EN  | M0)) /*d2d_mcad34*/\
+ MUX_VAL(CP(D2D_MCAD35),	(IEN  | PTD | EN  | M0)) /*d2d_mcad35*/\
+ MUX_VAL(CP(D2D_MCAD36),	(IEN  | PTD | EN  | M0)) /*d2d_mcad36*/\
+ MUX_VAL(CP(D2D_CLK26MI),	(IEN  | PTD | DIS | M0)) /*d2d_clk26mi*/\
+ MUX_VAL(CP(D2D_NRESPWRON),	(IEN  | PTD | EN  | M0)) /*d2d_nrespwron*/\
+ MUX_VAL(CP(D2D_NRESWARM),	(IEN  | PTU | EN  | M0)) /*d2d_nreswarm */\
+ MUX_VAL(CP(D2D_ARM9NIRQ),	(IEN  | PTD | DIS | M0)) /*d2d_arm9nirq */\
+ MUX_VAL(CP(D2D_UMA2P6FIQ),	(IEN  | PTD | DIS | M0)) /*d2d_uma2p6fiq*/\
+ MUX_VAL(CP(D2D_SPINT),		(IEN  | PTD | EN  | M0)) /*d2d_spint*/\
+ MUX_VAL(CP(D2D_FRINT),		(IEN  | PTD | EN  | M0)) /*d2d_frint*/\
+ MUX_VAL(CP(D2D_DMAREQ0),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq0*/\
+ MUX_VAL(CP(D2D_DMAREQ1),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq1*/\
+ MUX_VAL(CP(D2D_DMAREQ2),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq2*/\
+ MUX_VAL(CP(D2D_DMAREQ3),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq3*/\
+ MUX_VAL(CP(D2D_N3GTRST),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtrst*/\
+ MUX_VAL(CP(D2D_N3GTDI),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdi*/\
+ MUX_VAL(CP(D2D_N3GTDO),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdo*/\
+ MUX_VAL(CP(D2D_N3GTMS),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtms*/\
+ MUX_VAL(CP(D2D_N3GTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtck*/\
+ MUX_VAL(CP(D2D_N3GRTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3grtck*/\
+ MUX_VAL(CP(D2D_MSTDBY),	(IEN  | PTU | EN  | M0)) /*d2d_mstdby*/\
+ MUX_VAL(CP(D2D_SWAKEUP),	(IEN  | PTD | EN  | M0)) /*d2d_swakeup*/\
+ MUX_VAL(CP(D2D_IDLEREQ),	(IEN  | PTD | DIS | M0)) /*d2d_idlereq*/\
+ MUX_VAL(CP(D2D_IDLEACK),	(IEN  | PTU | EN  | M0)) /*d2d_idleack*/\
+ MUX_VAL(CP(D2D_MWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_mwrite*/\
+ MUX_VAL(CP(D2D_SWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_swrite*/\
+ MUX_VAL(CP(D2D_MREAD),		(IEN  | PTD | DIS | M0)) /*d2d_mread*/\
+ MUX_VAL(CP(D2D_SREAD),		(IEN  | PTD | DIS | M0)) /*d2d_sread*/\
+ MUX_VAL(CP(D2D_MBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_mbusflag*/\
+ MUX_VAL(CP(D2D_SBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_sbusflag*/\
+ MUX_VAL(CP(SDRC_CKE0),		(IDIS | PTU | EN  | M0)) /*sdrc_cke0*/\
+ MUX_VAL(CP(SDRC_CKE1),		(IDIS | PTD | DIS | M7)) /*sdrc_cke1*/\
+
+#endif
diff -Naur u-boot-2009.01/board/omap3/evm/Makefile u-boot/board/omap3/evm/Makefile
--- u-boot-2009.01/board/omap3/evm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/evm/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= evm.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
diff -Naur u-boot-2009.01/board/omap3/evm/u-boot.lds u-boot/board/omap3/evm/u-boot.lds
--- u-boot-2009.01/board/omap3/evm/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/evm/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,63 @@
+/*
+ * January 2004 - Changed to support H4 device
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm_cortexa8/start.o	(.text)
+		*(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	.ARM.extab	: { *(.ARM.extab* .gnu.linkonce.armextab.*) }
+	__exidx_start = .;
+	.ARM.exidx	: { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
+	__exidx_end = .;
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/omap3/overo/config.mk u-boot/board/omap3/overo/config.mk
--- u-boot-2009.01/board/omap3/overo/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/overo/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,29 @@
+#
+# Overo uses OMAP3 (ARM-CortexA8) cpu
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+# Physical Address:
+# 8000'0000 (bank0)
+# A000/0000 (bank1)
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+
+# For use with external or internal boots.
+TEXT_BASE = 0x80e80000
diff -Naur u-boot-2009.01/board/omap3/overo/Makefile u-boot/board/omap3/overo/Makefile
--- u-boot-2009.01/board/omap3/overo/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/overo/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,48 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= overo.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+#########################################################################
+sinclude $(obj).depend
diff -Naur u-boot-2009.01/board/omap3/overo/overo.c u-boot/board/omap3/overo/overo.c
--- u-boot-2009.01/board/omap3/overo/overo.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/overo/overo.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+ * Maintainer : Steve Sakoman <steve@sakoman.com>
+ *
+ * Derived from Beagle Board, 3430 SDP, and OMAP3EVM code by
+ *	Richard Woodruff <r-woodruff2@ti.com>
+ *	Syed Mohammed Khasim <khasim@ti.com>
+ *	Sunil Kumar <sunilsaini05@gmail.com>
+ *	Shashi Ranjan <shashiranjanmca05@gmail.com>
+ *
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-types.h>
+#include "overo.h"
+
+/******************************************************************************
+ * Routine: board_init
+ * Description: Early hardware init.
+ *****************************************************************************/
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gpmc_init(); /* in SRAM or SDRAM, finish GPMC */
+	/* board id for Linux */
+	gd->bd->bi_arch_number = MACH_TYPE_OVERO;
+	/* boot param addr */
+	gd->bd->bi_boot_params = (OMAP34XX_SDRC_CS0 + 0x100);
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: misc_init_r
+ * Description: Configure board specific parts
+ *****************************************************************************/
+int misc_init_r(void)
+{
+	power_init_r();
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: set_muxconf_regs
+ * Description: Setting up the configuration Mux registers specific to the
+ *		hardware. Many pins need to be moved from protect to primary
+ *		mode.
+ *****************************************************************************/
+void set_muxconf_regs(void)
+{
+	MUX_OVERO();
+}
diff -Naur u-boot-2009.01/board/omap3/overo/overo.h u-boot/board/omap3/overo/overo.h
--- u-boot-2009.01/board/omap3/overo/overo.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/overo/overo.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,382 @@
+/*
+ * (C) Copyright 2008
+ * Steve Sakoman <steve@sakoman.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _OVERO_H_
+#define _OVERO_H_
+
+const omap3_sysinfo sysinfo = {
+	SDP_3430_V1,
+	SDP_3430_V2,
+	DDR_STACKED,
+	"Gumstix Overo board",
+#if defined(CONFIG_ENV_IS_IN_ONENAND)
+	"OneNAND",
+#else
+	"NAND",
+#endif
+};
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+#define MUX_OVERO() \
+ /*SDRC*/\
+ MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) /*SDRC_D0*/\
+ MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) /*SDRC_D1*/\
+ MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) /*SDRC_D2*/\
+ MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) /*SDRC_D3*/\
+ MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) /*SDRC_D4*/\
+ MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) /*SDRC_D5*/\
+ MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) /*SDRC_D6*/\
+ MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) /*SDRC_D7*/\
+ MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) /*SDRC_D8*/\
+ MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) /*SDRC_D9*/\
+ MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) /*SDRC_D10*/\
+ MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) /*SDRC_D11*/\
+ MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) /*SDRC_D12*/\
+ MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) /*SDRC_D13*/\
+ MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) /*SDRC_D14*/\
+ MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) /*SDRC_D15*/\
+ MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) /*SDRC_D16*/\
+ MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) /*SDRC_D17*/\
+ MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) /*SDRC_D18*/\
+ MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) /*SDRC_D19*/\
+ MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) /*SDRC_D20*/\
+ MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) /*SDRC_D21*/\
+ MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) /*SDRC_D22*/\
+ MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) /*SDRC_D23*/\
+ MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) /*SDRC_D24*/\
+ MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) /*SDRC_D25*/\
+ MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) /*SDRC_D26*/\
+ MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) /*SDRC_D27*/\
+ MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) /*SDRC_D28*/\
+ MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) /*SDRC_D29*/\
+ MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) /*SDRC_D30*/\
+ MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) /*SDRC_D31*/\
+ MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) /*SDRC_CLK*/\
+ MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS0*/\
+ MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS1*/\
+ MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS2*/\
+ MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS3*/\
+ /*GPMC*/\
+ MUX_VAL(CP(GPMC_A1),		(IDIS | PTD | DIS | M0)) /*GPMC_A1*/\
+ MUX_VAL(CP(GPMC_A2),		(IDIS | PTD | DIS | M0)) /*GPMC_A2*/\
+ MUX_VAL(CP(GPMC_A3),		(IDIS | PTD | DIS | M0)) /*GPMC_A3*/\
+ MUX_VAL(CP(GPMC_A4),		(IDIS | PTD | DIS | M0)) /*GPMC_A4*/\
+ MUX_VAL(CP(GPMC_A5),		(IDIS | PTD | DIS | M0)) /*GPMC_A5*/\
+ MUX_VAL(CP(GPMC_A6),		(IDIS | PTD | DIS | M0)) /*GPMC_A6*/\
+ MUX_VAL(CP(GPMC_A7),		(IDIS | PTD | DIS | M0)) /*GPMC_A7*/\
+ MUX_VAL(CP(GPMC_A8),		(IDIS | PTD | DIS | M0)) /*GPMC_A8*/\
+ MUX_VAL(CP(GPMC_A9),		(IDIS | PTD | DIS | M0)) /*GPMC_A9*/\
+ MUX_VAL(CP(GPMC_A10),		(IDIS | PTD | DIS | M0)) /*GPMC_A10*/\
+ MUX_VAL(CP(GPMC_D0),		(IEN  | PTD | DIS | M0)) /*GPMC_D0*/\
+ MUX_VAL(CP(GPMC_D1),		(IEN  | PTD | DIS | M0)) /*GPMC_D1*/\
+ MUX_VAL(CP(GPMC_D2),		(IEN  | PTD | DIS | M0)) /*GPMC_D2*/\
+ MUX_VAL(CP(GPMC_D3),		(IEN  | PTD | DIS | M0)) /*GPMC_D3*/\
+ MUX_VAL(CP(GPMC_D4),		(IEN  | PTD | DIS | M0)) /*GPMC_D4*/\
+ MUX_VAL(CP(GPMC_D5),		(IEN  | PTD | DIS | M0)) /*GPMC_D5*/\
+ MUX_VAL(CP(GPMC_D6),		(IEN  | PTD | DIS | M0)) /*GPMC_D6*/\
+ MUX_VAL(CP(GPMC_D7),		(IEN  | PTD | DIS | M0)) /*GPMC_D7*/\
+ MUX_VAL(CP(GPMC_D8),		(IEN  | PTD | DIS | M0)) /*GPMC_D8*/\
+ MUX_VAL(CP(GPMC_D9),		(IEN  | PTD | DIS | M0)) /*GPMC_D9*/\
+ MUX_VAL(CP(GPMC_D10),		(IEN  | PTD | DIS | M0)) /*GPMC_D10*/\
+ MUX_VAL(CP(GPMC_D11),		(IEN  | PTD | DIS | M0)) /*GPMC_D11*/\
+ MUX_VAL(CP(GPMC_D12),		(IEN  | PTD | DIS | M0)) /*GPMC_D12*/\
+ MUX_VAL(CP(GPMC_D13),		(IEN  | PTD | DIS | M0)) /*GPMC_D13*/\
+ MUX_VAL(CP(GPMC_D14),		(IEN  | PTD | DIS | M0)) /*GPMC_D14*/\
+ MUX_VAL(CP(GPMC_D15),		(IEN  | PTD | DIS | M0)) /*GPMC_D15*/\
+ MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS0*/\
+ MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS1*/\
+ MUX_VAL(CP(GPMC_NCS2),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS2*/\
+ MUX_VAL(CP(GPMC_NCS3),		(IEN  | PTU | EN  | M4)) /*GPIO_54*/\
+							 /* - MMC1_WP*/\
+ MUX_VAL(CP(GPMC_NCS4),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS4*/\
+ MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTD | DIS | M0)) /*GPMC_nCS5*/\
+ MUX_VAL(CP(GPMC_NCS6),		(IEN  | PTD | DIS | M0)) /*GPMC_nCS6*/\
+ MUX_VAL(CP(GPMC_NCS7),		(IEN  | PTU | EN  | M0)) /*GPMC_nCS7*/\
+ MUX_VAL(CP(GPMC_NBE1),		(IEN  | PTD | DIS | M0)) /*GPMC_nCS3*/\
+ MUX_VAL(CP(GPMC_CLK),		(IDIS | PTD | DIS | M0)) /*GPMC_CLK*/\
+ MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0)) /*GPMC_nADV_ALE*/\
+ MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0)) /*GPMC_nOE*/\
+ MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0)) /*GPMC_nWE*/\
+ MUX_VAL(CP(GPMC_NBE0_CLE),	(IDIS | PTD | DIS | M0)) /*GPMC_nBE0_CLE*/\
+ MUX_VAL(CP(GPMC_NWP),		(IEN  | PTD | DIS | M0)) /*GPMC_nWP*/\
+ MUX_VAL(CP(GPMC_WAIT0),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT0*/\
+ MUX_VAL(CP(GPMC_WAIT1),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT1*/\
+ MUX_VAL(CP(GPMC_WAIT2),	(IEN  | PTU | DIS | M4)) /*GPIO_64*/\
+							/* - SMSC911X_NRES*/\
+ MUX_VAL(CP(GPMC_WAIT3),	(IEN  | PTU | EN  | M0)) /*GPMC_nCS3*/\
+ /*DSS*/\
+ MUX_VAL(CP(DSS_PCLK),		(IDIS | PTD | DIS | M0)) /*DSS_PCLK*/\
+ MUX_VAL(CP(DSS_HSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_HSYNC*/\
+ MUX_VAL(CP(DSS_VSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_VSYNC*/\
+ MUX_VAL(CP(DSS_ACBIAS),	(IDIS | PTD | DIS | M0)) /*DSS_ACBIAS*/\
+ MUX_VAL(CP(DSS_DATA0),		(IDIS | PTD | DIS | M0)) /*DSS_DATA0*/\
+ MUX_VAL(CP(DSS_DATA1),		(IDIS | PTD | DIS | M0)) /*DSS_DATA1*/\
+ MUX_VAL(CP(DSS_DATA2),		(IDIS | PTD | DIS | M0)) /*DSS_DATA2*/\
+ MUX_VAL(CP(DSS_DATA3),		(IDIS | PTD | DIS | M0)) /*DSS_DATA3*/\
+ MUX_VAL(CP(DSS_DATA4),		(IDIS | PTD | DIS | M0)) /*DSS_DATA4*/\
+ MUX_VAL(CP(DSS_DATA5),		(IDIS | PTD | DIS | M0)) /*DSS_DATA5*/\
+ MUX_VAL(CP(DSS_DATA6),		(IDIS | PTD | DIS | M0)) /*DSS_DATA6*/\
+ MUX_VAL(CP(DSS_DATA7),		(IDIS | PTD | DIS | M0)) /*DSS_DATA7*/\
+ MUX_VAL(CP(DSS_DATA8),		(IDIS | PTD | DIS | M0)) /*DSS_DATA8*/\
+ MUX_VAL(CP(DSS_DATA9),		(IDIS | PTD | DIS | M0)) /*DSS_DATA9*/\
+ MUX_VAL(CP(DSS_DATA10),	(IDIS | PTD | DIS | M0)) /*DSS_DATA10*/\
+ MUX_VAL(CP(DSS_DATA11),	(IDIS | PTD | DIS | M0)) /*DSS_DATA11*/\
+ MUX_VAL(CP(DSS_DATA12),	(IDIS | PTD | DIS | M0)) /*DSS_DATA12*/\
+ MUX_VAL(CP(DSS_DATA13),	(IDIS | PTD | DIS | M0)) /*DSS_DATA13*/\
+ MUX_VAL(CP(DSS_DATA14),	(IDIS | PTD | DIS | M0)) /*DSS_DATA14*/\
+ MUX_VAL(CP(DSS_DATA15),	(IDIS | PTD | DIS | M0)) /*DSS_DATA15*/\
+ MUX_VAL(CP(DSS_DATA16),	(IDIS | PTD | DIS | M0)) /*DSS_DATA16*/\
+ MUX_VAL(CP(DSS_DATA17),	(IDIS | PTD | DIS | M0)) /*DSS_DATA17*/\
+ MUX_VAL(CP(DSS_DATA18),	(IDIS | PTD | DIS | M0)) /*DSS_DATA18*/\
+ MUX_VAL(CP(DSS_DATA19),	(IDIS | PTD | DIS | M0)) /*DSS_DATA19*/\
+ MUX_VAL(CP(DSS_DATA20),	(IDIS | PTD | DIS | M0)) /*DSS_DATA20*/\
+ MUX_VAL(CP(DSS_DATA21),	(IDIS | PTD | DIS | M0)) /*DSS_DATA21*/\
+ MUX_VAL(CP(DSS_DATA22),	(IDIS | PTD | DIS | M0)) /*DSS_DATA22*/\
+ MUX_VAL(CP(DSS_DATA23),	(IDIS | PTD | DIS | M0)) /*DSS_DATA23*/\
+ /*CAMERA*/\
+ MUX_VAL(CP(CAM_HS),		(IEN  | PTU | EN  | M0)) /*CAM_HS */\
+ MUX_VAL(CP(CAM_VS),		(IEN  | PTU | EN  | M0)) /*CAM_VS */\
+ MUX_VAL(CP(CAM_XCLKA),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKA*/\
+ MUX_VAL(CP(CAM_PCLK),		(IEN  | PTU | EN  | M0)) /*CAM_PCLK*/\
+ MUX_VAL(CP(CAM_FLD),		(IDIS | PTD | DIS | M4)) /*CAM_FLD*/\
+ MUX_VAL(CP(CAM_D0),		(IEN  | PTD | DIS | M0)) /*CAM_D0*/\
+ MUX_VAL(CP(CAM_D1),		(IEN  | PTD | DIS | M0)) /*CAM_D1*/\
+ MUX_VAL(CP(CAM_D2),		(IEN  | PTD | DIS | M0)) /*CAM_D2*/\
+ MUX_VAL(CP(CAM_D3),		(IEN  | PTD | DIS | M0)) /*CAM_D3*/\
+ MUX_VAL(CP(CAM_D4),		(IEN  | PTD | DIS | M0)) /*CAM_D4*/\
+ MUX_VAL(CP(CAM_D5),		(IEN  | PTD | DIS | M0)) /*CAM_D5*/\
+ MUX_VAL(CP(CAM_D6),		(IEN  | PTD | DIS | M0)) /*CAM_D6*/\
+ MUX_VAL(CP(CAM_D7),		(IEN  | PTD | DIS | M0)) /*CAM_D7*/\
+ MUX_VAL(CP(CAM_D8),		(IEN  | PTD | DIS | M0)) /*CAM_D8*/\
+ MUX_VAL(CP(CAM_D9),		(IEN  | PTD | DIS | M0)) /*CAM_D9*/\
+ MUX_VAL(CP(CAM_D10),		(IEN  | PTD | DIS | M0)) /*CAM_D10*/\
+ MUX_VAL(CP(CAM_D11),		(IEN  | PTD | DIS | M0)) /*CAM_D11*/\
+ MUX_VAL(CP(CAM_XCLKB),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKB*/\
+ MUX_VAL(CP(CAM_WEN),		(IEN  | PTD | DIS | M0)) /*CAM_WEN*/\
+ MUX_VAL(CP(CAM_STROBE),	(IDIS | PTD | DIS | M0)) /*CAM_STROBE*/\
+ MUX_VAL(CP(CSI2_DX0),		(IEN  | PTD | DIS | M0)) /*CSI2_DX0*/\
+ MUX_VAL(CP(CSI2_DY0),		(IEN  | PTD | DIS | M0)) /*CSI2_DY0*/\
+ MUX_VAL(CP(CSI2_DX1),		(IEN  | PTD | EN  | M4)) /*GPIO_114*/\
+ MUX_VAL(CP(CSI2_DY1),		(IEN  | PTU | EN  | M4)) /*GPIO_115*/\
+ /*Audio Interface */\
+ MUX_VAL(CP(MCBSP2_FSX),	(IEN  | PTD | DIS | M0)) /*McBSP2_FSX*/\
+ MUX_VAL(CP(MCBSP2_CLKX),	(IEN  | PTD | DIS | M0)) /*McBSP2_CLKX*/\
+ MUX_VAL(CP(MCBSP2_DR),		(IEN  | PTD | DIS | M0)) /*McBSP2_DR*/\
+ MUX_VAL(CP(MCBSP2_DX),		(IDIS | PTD | DIS | M0)) /*McBSP2_DX*/\
+ /*Expansion card */\
+ MUX_VAL(CP(MMC1_CLK),		(IDIS | PTU | EN  | M0)) /*MMC1_CLK*/\
+ MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | EN  | M0)) /*MMC1_CMD*/\
+ MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT0*/\
+ MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT1*/\
+ MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT2*/\
+ MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT3*/\
+ MUX_VAL(CP(MMC1_DAT4),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT4*/\
+ MUX_VAL(CP(MMC1_DAT5),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT5*/\
+ MUX_VAL(CP(MMC1_DAT6),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT6*/\
+ MUX_VAL(CP(MMC1_DAT7),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT7*/\
+ /*Wireless LAN */\
+ MUX_VAL(CP(MMC2_CLK),		(IEN  | PTU | EN  | M0)) /*MMC2_CLK*/\
+ MUX_VAL(CP(MMC2_CMD),		(IEN  | PTU | EN  | M0)) /*MMC2_CMD*/\
+ MUX_VAL(CP(MMC2_DAT0),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT0*/\
+ MUX_VAL(CP(MMC2_DAT1),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT1*/\
+ MUX_VAL(CP(MMC2_DAT2),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT2*/\
+ MUX_VAL(CP(MMC2_DAT3),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT3*/\
+ MUX_VAL(CP(MMC2_DAT4),		(IEN  | PTU | EN  | M1)) /*MMC2_DIR_DAT0*/\
+ MUX_VAL(CP(MMC2_DAT5),		(IEN  | PTU | EN  | M1)) /*MMC2_DIR_DAT1*/\
+ MUX_VAL(CP(MMC2_DAT6),		(IEN  | PTU | EN  | M1)) /*MMC2_DIR_CMD*/\
+ MUX_VAL(CP(MMC2_DAT7),		(IEN  | PTU | EN  | M1)) /*MMC2_CLKIN*/\
+ /*Bluetooth*/\
+ MUX_VAL(CP(MCBSP3_DX),		(IEN  | PTD | DIS | M1)) /*UART2_CTS*/\
+ MUX_VAL(CP(MCBSP3_DR),		(IDIS | PTD | DIS | M1)) /*UART2_RTS*/\
+ MUX_VAL(CP(MCBSP3_CLKX),	(IDIS | PTD | DIS | M1)) /*UART2_TX*/\
+ MUX_VAL(CP(MCBSP3_FSX),	(IEN  | PTD | DIS | M1)) /*UART2_RX*/\
+ MUX_VAL(CP(UART2_CTS),		(IEN  | PTD | DIS | M4)) /*GPIO_144 - LCD_EN*/\
+ MUX_VAL(CP(UART2_RTS),		(IEN  | PTD | DIS | M4)) /*GPIO_145*/\
+ MUX_VAL(CP(UART2_TX),		(IEN  | PTD | DIS | M4)) /*GPIO_146*/\
+ MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M4)) /*GPIO_147*/\
+ MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0)) /*UART1_TX*/\
+ MUX_VAL(CP(UART1_RTS),		(IEN  | PTU | DIS | M4)) /*GPIO_149*/ \
+ MUX_VAL(CP(UART1_CTS),		(IEN  | PTU | DIS | M4)) /*GPIO_150-MMC3_WP*/\
+ MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0)) /*UART1_RX*/\
+ MUX_VAL(CP(MCBSP4_CLKX),	(IEN  | PTD | DIS | M0)) /*McBSP4_CLKX*/\
+ MUX_VAL(CP(MCBSP4_DR),		(IEN  | PTD | DIS | M0)) /*McBSP4_DR*/\
+ MUX_VAL(CP(MCBSP4_DX),		(IEN  | PTD | DIS | M0)) /*McBSP4_DX*/\
+ MUX_VAL(CP(MCBSP4_FSX),	(IEN  | PTD | DIS | M0)) /*McBSP4_FSX*/\
+ MUX_VAL(CP(MCBSP1_CLKR),	(IEN  | PTD | DIS | M0)) /*McBSP1_CLKR*/\
+ MUX_VAL(CP(MCBSP1_FSR),	(IEN  | PTD | DIS | M0)) /*McBSP1_FSR*/\
+ MUX_VAL(CP(MCBSP1_DX),		(IEN  | PTD | DIS | M0)) /*McBSP1_DX*/\
+ MUX_VAL(CP(MCBSP1_DR),		(IEN  | PTD | DIS | M0)) /*McBSP1_DR*/\
+ MUX_VAL(CP(MCBSP_CLKS),	(IEN  | PTU | DIS | M0)) /*McBSP_CLKS*/\
+ MUX_VAL(CP(MCBSP1_FSX),	(IEN  | PTD | DIS | M0)) /*McBSP1_FSX*/\
+ MUX_VAL(CP(MCBSP1_CLKX),	(IEN  | PTD | DIS | M0)) /*McBSP1_CLKX*/\
+ /*Serial Interface*/\
+ MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTD | EN  | M0)) /*UART3_CTS_RCTX*/\
+ MUX_VAL(CP(UART3_RTS_SD),	(IEN  | PTU | EN  | M4)) /*GPIO_164 W2W_*/\
+							 /* BT_NRESET*/\
+ MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTU | EN  | M0)) /*UART3_RX_IRRX*/\
+ MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0)) /*UART3_TX_IRTX*/\
+ MUX_VAL(CP(HSUSB0_CLK),	(IEN  | PTD | DIS | M0)) /*HSUSB0_CLK*/\
+ MUX_VAL(CP(HSUSB0_STP),	(IDIS | PTU | EN  | M0)) /*HSUSB0_STP*/\
+ MUX_VAL(CP(HSUSB0_DIR),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DIR*/\
+ MUX_VAL(CP(HSUSB0_NXT),	(IEN  | PTD | DIS | M0)) /*HSUSB0_NXT*/\
+ MUX_VAL(CP(HSUSB0_DATA0),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA0*/\
+ MUX_VAL(CP(HSUSB0_DATA1),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA1*/\
+ MUX_VAL(CP(HSUSB0_DATA2),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA2*/\
+ MUX_VAL(CP(HSUSB0_DATA3),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA3*/\
+ MUX_VAL(CP(HSUSB0_DATA4),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA4*/\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA5*/\
+ MUX_VAL(CP(HSUSB0_DATA6),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA6*/\
+ MUX_VAL(CP(HSUSB0_DATA7),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA7*/\
+ MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0)) /*I2C1_SCL*/\
+ MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0)) /*I2C1_SDA*/\
+ MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M4)) /*GPIO_168*/\
+							 /* - USBH_CPEN*/\
+ MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M4)) /*GPIO_183*/\
+							 /* - USBH_RESET*/\
+ MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)) /*I2C3_SCL*/\
+ MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)) /*I2C3_SDA*/\
+ MUX_VAL(CP(I2C4_SCL),		(IEN  | PTU | EN  | M0)) /*I2C4_SCL*/\
+ MUX_VAL(CP(I2C4_SDA),		(IEN  | PTU | EN  | M0)) /*I2C4_SDA*/\
+ MUX_VAL(CP(HDQ_SIO),		(IDIS | PTU | EN  | M4)) /*HDQ_SIO*/\
+ MUX_VAL(CP(MCSPI1_CLK),	(IEN  | PTD | DIS | M0)) /*McSPI1_CLK*/\
+ MUX_VAL(CP(MCSPI1_SIMO),	(IEN  | PTD | DIS | M0)) /*McSPI1_SIMO */\
+ MUX_VAL(CP(MCSPI1_SOMI),	(IEN  | PTD | DIS | M0)) /*McSPI1_SOMI */\
+ MUX_VAL(CP(MCSPI1_CS0),	(IEN  | PTD | EN  | M0)) /*McSPI1_CS0*/\
+ MUX_VAL(CP(MCSPI1_CS1),	(IDIS | PTD | EN  | M0)) /*McSPI1_CS1*/\
+ MUX_VAL(CP(MCSPI1_CS2),	(IEN  | PTD | DIS | M4)) /*GPIO_176*/\
+							/* - SMSC911X_IRQ*/\
+ MUX_VAL(CP(MCSPI1_CS3),	(IEN  | PTD | DIS | M3)) /*HSUSB2_DATA2*/\
+ MUX_VAL(CP(MCSPI2_CLK),	(IEN  | PTD | DIS | M3)) /*HSUSB2_DATA7*/\
+ MUX_VAL(CP(MCSPI2_SIMO),	(IEN  | PTD | DIS | M3)) /*HSUSB2_DATA4*/\
+ MUX_VAL(CP(MCSPI2_SOMI),	(IEN  | PTD | DIS | M3)) /*HSUSB2_DATA5*/\
+ MUX_VAL(CP(MCSPI2_CS0),	(IEN  | PTD | DIS | M3)) /*HSUSB2_DATA6*/\
+ MUX_VAL(CP(MCSPI2_CS1),	(IEN  | PTD | DIS | M3)) /*HSUSB2_DATA3*/\
+ /*Control and debug */\
+ MUX_VAL(CP(SYS_32K),		(IEN  | PTD | DIS | M0)) /*SYS_32K*/\
+ MUX_VAL(CP(SYS_CLKREQ),	(IEN  | PTD | DIS | M0)) /*SYS_CLKREQ*/\
+ MUX_VAL(CP(SYS_NIRQ),		(IEN  | PTU | EN  | M0)) /*SYS_nIRQ*/\
+ MUX_VAL(CP(SYS_BOOT0),		(IEN  | PTD | DIS | M4)) /*GPIO_2*/\
+ MUX_VAL(CP(SYS_BOOT1),		(IEN  | PTD | DIS | M4)) /*GPIO_3 */\
+ MUX_VAL(CP(SYS_BOOT2),		(IEN  | PTD | DIS | M4)) /*GPIO_4 - MMC1_WP*/\
+ MUX_VAL(CP(SYS_BOOT3),		(IEN  | PTD | DIS | M4)) /*GPIO_5*/\
+ MUX_VAL(CP(SYS_BOOT4),		(IEN  | PTD | DIS | M4)) /*GPIO_6*/\
+ MUX_VAL(CP(SYS_BOOT5),		(IEN  | PTD | DIS | M4)) /*GPIO_7*/\
+ MUX_VAL(CP(SYS_BOOT6),		(IDIS | PTD | DIS | M4)) /*GPIO_8*/\
+ MUX_VAL(CP(SYS_OFF_MODE),	(IEN  | PTD | DIS | M0)) /*SYS_OFF_MODE*/\
+ MUX_VAL(CP(SYS_CLKOUT1),	(IEN  | PTD | DIS | M0)) /*SYS_CLKOUT1*/\
+ MUX_VAL(CP(SYS_CLKOUT2),	(IEN  | PTU | EN  | M4)) /*GPIO_186*/\
+ MUX_VAL(CP(ETK_CLK_ES2),	(IDIS | PTU | EN  | M2)) /*MMC3_CLK*/\
+ MUX_VAL(CP(ETK_CTL_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_CMD*/\
+ MUX_VAL(CP(ETK_D0_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT4*/\
+ MUX_VAL(CP(ETK_D1_ES2),	(IEN  | PTD | EN  | M4)) /*GPIO_15 - X_GATE*/\
+ MUX_VAL(CP(ETK_D2_ES2),	(IEN  | PTU | EN  | M4)) /*GPIO_16*/\
+							 /* - W2W_NRESET*/\
+ MUX_VAL(CP(ETK_D3_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT3*/\
+ MUX_VAL(CP(ETK_D4_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT0*/\
+ MUX_VAL(CP(ETK_D5_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT1*/\
+ MUX_VAL(CP(ETK_D6_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT2*/\
+ MUX_VAL(CP(ETK_D7_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT7*/\
+ MUX_VAL(CP(ETK_D8_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT6*/\
+ MUX_VAL(CP(ETK_D9_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT5*/\
+ MUX_VAL(CP(ETK_D10_ES2),	(IDIS | PTD | DIS | M3)) /*HSUSB2_CLK*/\
+ MUX_VAL(CP(ETK_D11_ES2),	(IDIS | PTD | DIS | M3)) /*HSUSB2_STP*/\
+ MUX_VAL(CP(ETK_D12_ES2),	(IEN  | PTD | DIS | M3)) /*HSUSB2_DIR*/\
+ MUX_VAL(CP(ETK_D13_ES2),	(IEN  | PTD | DIS | M3)) /*HSUSB2_NXT*/\
+ MUX_VAL(CP(ETK_D14_ES2),	(IEN  | PTD | DIS | M3)) /*HSUSB2_DATA0*/\
+ MUX_VAL(CP(ETK_D15_ES2),	(IEN  | PTD | DIS | M3)) /*HSUSB2_DATA1*/\
+ /* die to die */\
+ MUX_VAL(CP(D2D_MCAD1),		(IEN  | PTD | EN  | M0)) /*d2d_mcad1*/\
+ MUX_VAL(CP(D2D_MCAD2),		(IEN  | PTD | EN  | M0)) /*d2d_mcad2*/\
+ MUX_VAL(CP(D2D_MCAD3),		(IEN  | PTD | EN  | M0)) /*d2d_mcad3*/\
+ MUX_VAL(CP(D2D_MCAD4),		(IEN  | PTD | EN  | M0)) /*d2d_mcad4*/\
+ MUX_VAL(CP(D2D_MCAD5),		(IEN  | PTD | EN  | M0)) /*d2d_mcad5*/\
+ MUX_VAL(CP(D2D_MCAD6),		(IEN  | PTD | EN  | M0)) /*d2d_mcad6*/\
+ MUX_VAL(CP(D2D_MCAD7),		(IEN  | PTD | EN  | M0)) /*d2d_mcad7*/\
+ MUX_VAL(CP(D2D_MCAD8),		(IEN  | PTD | EN  | M0)) /*d2d_mcad8*/\
+ MUX_VAL(CP(D2D_MCAD9),		(IEN  | PTD | EN  | M0)) /*d2d_mcad9*/\
+ MUX_VAL(CP(D2D_MCAD10),	(IEN  | PTD | EN  | M0)) /*d2d_mcad10*/\
+ MUX_VAL(CP(D2D_MCAD11),	(IEN  | PTD | EN  | M0)) /*d2d_mcad11*/\
+ MUX_VAL(CP(D2D_MCAD12),	(IEN  | PTD | EN  | M0)) /*d2d_mcad12*/\
+ MUX_VAL(CP(D2D_MCAD13),	(IEN  | PTD | EN  | M0)) /*d2d_mcad13*/\
+ MUX_VAL(CP(D2D_MCAD14),	(IEN  | PTD | EN  | M0)) /*d2d_mcad14*/\
+ MUX_VAL(CP(D2D_MCAD15),	(IEN  | PTD | EN  | M0)) /*d2d_mcad15*/\
+ MUX_VAL(CP(D2D_MCAD16),	(IEN  | PTD | EN  | M0)) /*d2d_mcad16*/\
+ MUX_VAL(CP(D2D_MCAD17),	(IEN  | PTD | EN  | M0)) /*d2d_mcad17*/\
+ MUX_VAL(CP(D2D_MCAD18),	(IEN  | PTD | EN  | M0)) /*d2d_mcad18*/\
+ MUX_VAL(CP(D2D_MCAD19),	(IEN  | PTD | EN  | M0)) /*d2d_mcad19*/\
+ MUX_VAL(CP(D2D_MCAD20),	(IEN  | PTD | EN  | M0)) /*d2d_mcad20*/\
+ MUX_VAL(CP(D2D_MCAD21),	(IEN  | PTD | EN  | M0)) /*d2d_mcad21*/\
+ MUX_VAL(CP(D2D_MCAD22),	(IEN  | PTD | EN  | M0)) /*d2d_mcad22*/\
+ MUX_VAL(CP(D2D_MCAD23),	(IEN  | PTD | EN  | M0)) /*d2d_mcad23*/\
+ MUX_VAL(CP(D2D_MCAD24),	(IEN  | PTD | EN  | M0)) /*d2d_mcad24*/\
+ MUX_VAL(CP(D2D_MCAD25),	(IEN  | PTD | EN  | M0)) /*d2d_mcad25*/\
+ MUX_VAL(CP(D2D_MCAD26),	(IEN  | PTD | EN  | M0)) /*d2d_mcad26*/\
+ MUX_VAL(CP(D2D_MCAD27),	(IEN  | PTD | EN  | M0)) /*d2d_mcad27*/\
+ MUX_VAL(CP(D2D_MCAD28),	(IEN  | PTD | EN  | M0)) /*d2d_mcad28*/\
+ MUX_VAL(CP(D2D_MCAD29),	(IEN  | PTD | EN  | M0)) /*d2d_mcad29*/\
+ MUX_VAL(CP(D2D_MCAD30),	(IEN  | PTD | EN  | M0)) /*d2d_mcad30*/\
+ MUX_VAL(CP(D2D_MCAD31),	(IEN  | PTD | EN  | M0)) /*d2d_mcad31*/\
+ MUX_VAL(CP(D2D_MCAD32),	(IEN  | PTD | EN  | M0)) /*d2d_mcad32*/\
+ MUX_VAL(CP(D2D_MCAD33),	(IEN  | PTD | EN  | M0)) /*d2d_mcad33*/\
+ MUX_VAL(CP(D2D_MCAD34),	(IEN  | PTD | EN  | M0)) /*d2d_mcad34*/\
+ MUX_VAL(CP(D2D_MCAD35),	(IEN  | PTD | EN  | M0)) /*d2d_mcad35*/\
+ MUX_VAL(CP(D2D_MCAD36),	(IEN  | PTD | EN  | M0)) /*d2d_mcad36*/\
+ MUX_VAL(CP(D2D_CLK26MI),	(IEN  | PTD | DIS | M0)) /*d2d_clk26mi*/\
+ MUX_VAL(CP(D2D_NRESPWRON),	(IEN  | PTD | EN  | M0)) /*d2d_nrespwron*/\
+ MUX_VAL(CP(D2D_NRESWARM),	(IEN  | PTU | EN  | M0)) /*d2d_nreswarm */\
+ MUX_VAL(CP(D2D_ARM9NIRQ),	(IEN  | PTD | DIS | M0)) /*d2d_arm9nirq */\
+ MUX_VAL(CP(D2D_UMA2P6FIQ),	(IEN  | PTD | DIS | M0)) /*d2d_uma2p6fiq*/\
+ MUX_VAL(CP(D2D_SPINT),		(IEN  | PTD | EN  | M0)) /*d2d_spint*/\
+ MUX_VAL(CP(D2D_FRINT),		(IEN  | PTD | EN  | M0)) /*d2d_frint*/\
+ MUX_VAL(CP(D2D_DMAREQ0),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq0*/\
+ MUX_VAL(CP(D2D_DMAREQ1),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq1*/\
+ MUX_VAL(CP(D2D_DMAREQ2),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq2*/\
+ MUX_VAL(CP(D2D_DMAREQ3),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq3*/\
+ MUX_VAL(CP(D2D_N3GTRST),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtrst*/\
+ MUX_VAL(CP(D2D_N3GTDI),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdi*/\
+ MUX_VAL(CP(D2D_N3GTDO),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdo*/\
+ MUX_VAL(CP(D2D_N3GTMS),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtms*/\
+ MUX_VAL(CP(D2D_N3GTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtck*/\
+ MUX_VAL(CP(D2D_N3GRTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3grtck*/\
+ MUX_VAL(CP(D2D_MSTDBY),	(IEN  | PTU | EN  | M0)) /*d2d_mstdby*/\
+ MUX_VAL(CP(D2D_SWAKEUP),	(IEN  | PTD | EN  | M0)) /*d2d_swakeup*/\
+ MUX_VAL(CP(D2D_IDLEREQ),	(IEN  | PTD | DIS | M0)) /*d2d_idlereq*/\
+ MUX_VAL(CP(D2D_IDLEACK),	(IEN  | PTU | EN  | M0)) /*d2d_idleack*/\
+ MUX_VAL(CP(D2D_MWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_mwrite*/\
+ MUX_VAL(CP(D2D_SWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_swrite*/\
+ MUX_VAL(CP(D2D_MREAD),		(IEN  | PTD | DIS | M0)) /*d2d_mread*/\
+ MUX_VAL(CP(D2D_SREAD),		(IEN  | PTD | DIS | M0)) /*d2d_sread*/\
+ MUX_VAL(CP(D2D_MBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_mbusflag*/\
+ MUX_VAL(CP(D2D_SBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_sbusflag*/\
+ MUX_VAL(CP(SDRC_CKE0),		(IDIS | PTU | EN  | M0)) /*sdrc_cke0*/\
+ MUX_VAL(CP(SDRC_CKE1),		(IDIS | PTD | DIS | M7)) /*sdrc_cke1*/
+
+#endif
diff -Naur u-boot-2009.01/board/omap3/overo/u-boot.lds u-boot/board/omap3/overo/u-boot.lds
--- u-boot-2009.01/board/omap3/overo/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/overo/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,63 @@
+/*
+ * January 2004 - Changed to support H4 device
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm_cortexa8/start.o	(.text)
+		*(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	.ARM.extab	: { *(.ARM.extab* .gnu.linkonce.armextab.*) }
+	__exidx_start = .;
+	.ARM.exidx	: { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
+	__exidx_end = .;
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/omap3/pandora/config.mk u-boot/board/omap3/pandora/config.mk
--- u-boot-2009.01/board/omap3/pandora/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/pandora/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2006
+# Texas Instruments, <www.ti.com>
+#
+# Pandora uses OMAP3 (ARM-CortexA8) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+# Physical Address:
+# 8000'0000 (bank0)
+# A000/0000 (bank1)
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+
+# For use with external or internal boots.
+TEXT_BASE = 0x80e80000
diff -Naur u-boot-2009.01/board/omap3/pandora/Makefile u-boot/board/omap3/pandora/Makefile
--- u-boot-2009.01/board/omap3/pandora/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/pandora/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,49 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= pandora.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/omap3/pandora/pandora.c u-boot/board/omap3/pandora/pandora.c
--- u-boot-2009.01/board/omap3/pandora/pandora.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/pandora/pandora.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,92 @@
+/*
+ * (C) Copyright 2008
+ * Grazvydas Ignotas <notasas@gmail.com>
+ *
+ * Derived from Beagle Board, 3430 SDP, and OMAP3EVM code by
+ *	Richard Woodruff <r-woodruff2@ti.com>
+ *	Syed Mohammed Khasim <khasim@ti.com>
+ *	Sunil Kumar <sunilsaini05@gmail.com>
+ *	Shashi Ranjan <shashiranjanmca05@gmail.com>
+ *
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-types.h>
+#include "pandora.h"
+
+/******************************************************************************
+ * Routine: board_init
+ * Description: Early hardware init.
+ *****************************************************************************/
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gpmc_init(); /* in SRAM or SDRAM, finish GPMC */
+	/* board id for Linux */
+	gd->bd->bi_arch_number = MACH_TYPE_OMAP3_PANDORA;
+	/* boot param addr */
+	gd->bd->bi_boot_params = (OMAP34XX_SDRC_CS0 + 0x100);
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: misc_init_r
+ * Description: Configure board specific parts
+ *****************************************************************************/
+int misc_init_r(void)
+{
+	gpio_t *gpio1_base = (gpio_t *)OMAP34XX_GPIO1_BASE;
+	gpio_t *gpio4_base = (gpio_t *)OMAP34XX_GPIO4_BASE;
+	gpio_t *gpio5_base = (gpio_t *)OMAP34XX_GPIO5_BASE;
+	gpio_t *gpio6_base = (gpio_t *)OMAP34XX_GPIO6_BASE;
+
+	power_init_r();
+
+	/* Configure GPIOs to output */
+	writel(~(GPIO14 | GPIO15 | GPIO16 | GPIO23), &gpio1_base->oe);
+	writel(~GPIO22, &gpio4_base->oe);	/* 118 */
+	writel(~(GPIO0 | GPIO1 | GPIO28 | GPIO29 | GPIO30 | GPIO31),
+		&gpio5_base->oe);	/* 128, 129, 156-159 */
+	writel(~GPIO4, &gpio6_base->oe);	/* 164 */
+
+	/* Set GPIOs */
+	writel(GPIO28, &gpio5_base->setdataout);
+	writel(GPIO4, &gpio6_base->setdataout);
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: set_muxconf_regs
+ * Description: Setting up the configuration Mux registers specific to the
+ *		hardware. Many pins need to be moved from protect to primary
+ *		mode.
+ *****************************************************************************/
+void set_muxconf_regs(void)
+{
+	MUX_PANDORA();
+}
diff -Naur u-boot-2009.01/board/omap3/pandora/pandora.h u-boot/board/omap3/pandora/pandora.h
--- u-boot-2009.01/board/omap3/pandora/pandora.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/pandora/pandora.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,419 @@
+/*
+ * (C) Copyright 2008
+ * Grazvydas Ignotas <notasas@gmail.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _PANDORA_H_
+#define _PANDORA_H_
+
+const omap3_sysinfo sysinfo = {
+	SDP_3430_V1,
+	SDP_3430_V2,
+	DDR_STACKED,
+	"OMAP3 Pandora",
+	"NAND",
+};
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN	- Pull type selection is active
+ * M0	- Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+#define MUX_PANDORA() \
+ /*SDRC*/\
+ MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) /*SDRC_D0*/\
+ MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) /*SDRC_D1*/\
+ MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) /*SDRC_D2*/\
+ MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) /*SDRC_D3*/\
+ MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) /*SDRC_D4*/\
+ MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) /*SDRC_D5*/\
+ MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) /*SDRC_D6*/\
+ MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) /*SDRC_D7*/\
+ MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) /*SDRC_D8*/\
+ MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) /*SDRC_D9*/\
+ MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) /*SDRC_D10*/\
+ MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) /*SDRC_D11*/\
+ MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) /*SDRC_D12*/\
+ MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) /*SDRC_D13*/\
+ MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) /*SDRC_D14*/\
+ MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) /*SDRC_D15*/\
+ MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) /*SDRC_D16*/\
+ MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) /*SDRC_D17*/\
+ MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) /*SDRC_D18*/\
+ MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) /*SDRC_D19*/\
+ MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) /*SDRC_D20*/\
+ MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) /*SDRC_D21*/\
+ MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) /*SDRC_D22*/\
+ MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) /*SDRC_D23*/\
+ MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) /*SDRC_D24*/\
+ MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) /*SDRC_D25*/\
+ MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) /*SDRC_D26*/\
+ MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) /*SDRC_D27*/\
+ MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) /*SDRC_D28*/\
+ MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) /*SDRC_D29*/\
+ MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) /*SDRC_D30*/\
+ MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) /*SDRC_D31*/\
+ MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) /*SDRC_CLK*/\
+ MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS0*/\
+ MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS1*/\
+ MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS2*/\
+ MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS3*/\
+ /*GPMC*/\
+ MUX_VAL(CP(GPMC_A1),		(IDIS | PTD | DIS | M0)) /*GPMC_A1*/\
+ MUX_VAL(CP(GPMC_A2),		(IDIS | PTD | DIS | M0)) /*GPMC_A2*/\
+ MUX_VAL(CP(GPMC_A3),		(IDIS | PTD | DIS | M0)) /*GPMC_A3*/\
+ MUX_VAL(CP(GPMC_A4),		(IDIS | PTD | DIS | M0)) /*GPMC_A4*/\
+ MUX_VAL(CP(GPMC_A5),		(IDIS | PTD | DIS | M0)) /*GPMC_A5*/\
+ MUX_VAL(CP(GPMC_A6),		(IDIS | PTD | DIS | M0)) /*GPMC_A6*/\
+ MUX_VAL(CP(GPMC_A7),		(IDIS | PTD | DIS | M0)) /*GPMC_A7*/\
+ MUX_VAL(CP(GPMC_A8),		(IDIS | PTD | DIS | M0)) /*GPMC_A8*/\
+ MUX_VAL(CP(GPMC_A9),		(IDIS | PTD | DIS | M0)) /*GPMC_A9*/\
+ MUX_VAL(CP(GPMC_A10),		(IDIS | PTD | DIS | M0)) /*GPMC_A10*/\
+ MUX_VAL(CP(GPMC_D0),		(IEN  | PTD | DIS | M0)) /*GPMC_D0*/\
+ MUX_VAL(CP(GPMC_D1),		(IEN  | PTD | DIS | M0)) /*GPMC_D1*/\
+ MUX_VAL(CP(GPMC_D2),		(IEN  | PTD | DIS | M0)) /*GPMC_D2*/\
+ MUX_VAL(CP(GPMC_D3),		(IEN  | PTD | DIS | M0)) /*GPMC_D3*/\
+ MUX_VAL(CP(GPMC_D4),		(IEN  | PTD | DIS | M0)) /*GPMC_D4*/\
+ MUX_VAL(CP(GPMC_D5),		(IEN  | PTD | DIS | M0)) /*GPMC_D5*/\
+ MUX_VAL(CP(GPMC_D6),		(IEN  | PTD | DIS | M0)) /*GPMC_D6*/\
+ MUX_VAL(CP(GPMC_D7),		(IEN  | PTD | DIS | M0)) /*GPMC_D7*/\
+ MUX_VAL(CP(GPMC_D8),		(IEN  | PTD | DIS | M0)) /*GPMC_D8*/\
+ MUX_VAL(CP(GPMC_D9),		(IEN  | PTD | DIS | M0)) /*GPMC_D9*/\
+ MUX_VAL(CP(GPMC_D10),		(IEN  | PTD | DIS | M0)) /*GPMC_D10*/\
+ MUX_VAL(CP(GPMC_D11),		(IEN  | PTD | DIS | M0)) /*GPMC_D11*/\
+ MUX_VAL(CP(GPMC_D12),		(IEN  | PTD | DIS | M0)) /*GPMC_D12*/\
+ MUX_VAL(CP(GPMC_D13),		(IEN  | PTD | DIS | M0)) /*GPMC_D13*/\
+ MUX_VAL(CP(GPMC_D14),		(IEN  | PTD | DIS | M0)) /*GPMC_D14*/\
+ MUX_VAL(CP(GPMC_D15),		(IEN  | PTD | DIS | M0)) /*GPMC_D15*/\
+ MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS0*/\
+ MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS1*/\
+ MUX_VAL(CP(GPMC_NCS2),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS2*/\
+ MUX_VAL(CP(GPMC_NCS3),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS3*/\
+ MUX_VAL(CP(GPMC_NCS4),		(IDIS | PTU | EN  | M0))\
+ MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTD | DIS | M0))\
+ MUX_VAL(CP(GPMC_NCS6),		(IEN  | PTD | DIS | M1))\
+ MUX_VAL(CP(GPMC_NCS7),		(IEN  | PTU | EN  | M1))\
+ MUX_VAL(CP(GPMC_NBE1),		(IEN  | PTD | DIS | M0))\
+ MUX_VAL(CP(GPMC_WAIT2),	(IEN  | PTU | EN  | M0))\
+ MUX_VAL(CP(GPMC_WAIT3),	(IEN  | PTU | EN  | M0))\
+ MUX_VAL(CP(GPMC_CLK),		(IDIS | PTD | DIS | M0)) /*GPMC_CLK*/\
+ MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0)) /*GPMC_nADV_ALE*/\
+ MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0)) /*GPMC_nOE*/\
+ MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0)) /*GPMC_nWE*/\
+ MUX_VAL(CP(GPMC_NBE0_CLE),	(IDIS | PTD | DIS | M0)) /*GPMC_nBE0_CLE*/\
+ MUX_VAL(CP(GPMC_NWP),		(IEN  | PTD | DIS | M0)) /*GPMC_nWP*/\
+ MUX_VAL(CP(GPMC_WAIT0),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT0*/\
+ MUX_VAL(CP(GPMC_WAIT1),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT1*/\
+ /*DSS*/\
+ MUX_VAL(CP(DSS_PCLK),		(IDIS | PTD | DIS | M0)) /*DSS_PCLK*/\
+ MUX_VAL(CP(DSS_HSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_HSYNC*/\
+ MUX_VAL(CP(DSS_VSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_VSYNC*/\
+ MUX_VAL(CP(DSS_ACBIAS),	(IDIS | PTD | DIS | M0)) /*DSS_ACBIAS*/\
+ MUX_VAL(CP(DSS_DATA0),		(IDIS | PTD | DIS | M0)) /*DSS_DATA0*/\
+ MUX_VAL(CP(DSS_DATA1),		(IDIS | PTD | DIS | M0)) /*DSS_DATA1*/\
+ MUX_VAL(CP(DSS_DATA2),		(IDIS | PTD | DIS | M0)) /*DSS_DATA2*/\
+ MUX_VAL(CP(DSS_DATA3),		(IDIS | PTD | DIS | M0)) /*DSS_DATA3*/\
+ MUX_VAL(CP(DSS_DATA4),		(IDIS | PTD | DIS | M0)) /*DSS_DATA4*/\
+ MUX_VAL(CP(DSS_DATA5),		(IDIS | PTD | DIS | M0)) /*DSS_DATA5*/\
+ MUX_VAL(CP(DSS_DATA6),		(IDIS | PTD | DIS | M0)) /*DSS_DATA6*/\
+ MUX_VAL(CP(DSS_DATA7),		(IDIS | PTD | DIS | M0)) /*DSS_DATA7*/\
+ MUX_VAL(CP(DSS_DATA8),		(IDIS | PTD | DIS | M0)) /*DSS_DATA8*/\
+ MUX_VAL(CP(DSS_DATA9),		(IDIS | PTD | DIS | M0)) /*DSS_DATA9*/\
+ MUX_VAL(CP(DSS_DATA10),	(IDIS | PTD | DIS | M0)) /*DSS_DATA10*/\
+ MUX_VAL(CP(DSS_DATA11),	(IDIS | PTD | DIS | M0)) /*DSS_DATA11*/\
+ MUX_VAL(CP(DSS_DATA12),	(IDIS | PTD | DIS | M0)) /*DSS_DATA12*/\
+ MUX_VAL(CP(DSS_DATA13),	(IDIS | PTD | DIS | M0)) /*DSS_DATA13*/\
+ MUX_VAL(CP(DSS_DATA14),	(IDIS | PTD | DIS | M0)) /*DSS_DATA14*/\
+ MUX_VAL(CP(DSS_DATA15),	(IDIS | PTD | DIS | M0)) /*DSS_DATA15*/\
+ MUX_VAL(CP(DSS_DATA16),	(IDIS | PTD | DIS | M0)) /*DSS_DATA16*/\
+ MUX_VAL(CP(DSS_DATA17),	(IDIS | PTD | DIS | M0)) /*DSS_DATA17*/\
+ MUX_VAL(CP(DSS_DATA18),	(IDIS | PTD | DIS | M0)) /*DSS_DATA18*/\
+ MUX_VAL(CP(DSS_DATA19),	(IDIS | PTD | DIS | M0)) /*DSS_DATA19*/\
+ MUX_VAL(CP(DSS_DATA20),	(IDIS | PTD | DIS | M0)) /*DSS_DATA20*/\
+ MUX_VAL(CP(DSS_DATA21),	(IDIS | PTD | DIS | M0)) /*DSS_DATA21*/\
+ MUX_VAL(CP(DSS_DATA22),	(IDIS | PTD | DIS | M0)) /*DSS_DATA22*/\
+ MUX_VAL(CP(DSS_DATA23),	(IDIS | PTD | DIS | M0)) /*DSS_DATA23*/\
+ /*GPIO based game buttons*/\
+ MUX_VAL(CP(CAM_XCLKA),		(IEN  | PTU | DIS | M4)) /*GPIO_96 - LEFT*/\
+ MUX_VAL(CP(CAM_PCLK),		(IEN  | PTU | DIS | M4)) /*GPIO_97 - L2*/\
+ MUX_VAL(CP(CAM_FLD),		(IEN  | PTU | DIS | M4)) /*GPIO_98 - RIGHT*/\
+ MUX_VAL(CP(CAM_D0),		(IEN  | PTU | DIS | M4)) /*GPIO_99 - MENU*/\
+ MUX_VAL(CP(CAM_D1),		(IEN  | PTU | DIS | M4)) /*GPIO_100 - START*/\
+ MUX_VAL(CP(CAM_D2),		(IEN  | PTU | DIS | M4)) /*GPIO_101 - Y*/\
+ MUX_VAL(CP(CAM_D3),		(IEN  | PTU | DIS | M4)) /*GPIO_102 - L1*/\
+ MUX_VAL(CP(CAM_D4),		(IEN  | PTU | DIS | M4)) /*GPIO_103 - DOWN*/\
+ MUX_VAL(CP(CAM_D5),		(IEN  | PTU | DIS | M4)) /*GPIO_104 - SELECT*/\
+ MUX_VAL(CP(CAM_D6),		(IEN  | PTU | DIS | M4)) /*GPIO_105 - R1*/\
+ MUX_VAL(CP(CAM_D7),		(IEN  | PTU | DIS | M4)) /*GPIO_106 - B*/\
+ MUX_VAL(CP(CAM_D8),		(IEN  | PTU | DIS | M4)) /*GPIO_107 - R2*/\
+ MUX_VAL(CP(CAM_D10),		(IEN  | PTU | DIS | M4)) /*GPIO_109 - X*/\
+ MUX_VAL(CP(CAM_D11),		(IEN  | PTU | DIS | M4)) /*GPIO_110 - UP*/\
+ MUX_VAL(CP(CAM_XCLKB),		(IEN  | PTU | DIS | M4)) /*GPIO_111 - A*/\
+ /*Audio Interface To External DAC (Headphone, Speakers)*/\
+ MUX_VAL(CP(MCBSP2_FSX),	(IDIS | PTD | DIS | M0)) /*McBSP2_FSX*/\
+ MUX_VAL(CP(MCBSP2_CLKX),	(IDIS | PTD | DIS | M0)) /*McBSP2_CLKX*/\
+ MUX_VAL(CP(MCBSP2_DX),		(IDIS | PTD | DIS | M0)) /*McBSP2_DX*/\
+ MUX_VAL(CP(MCBSP_CLKS),	(IEN  | PTU | DIS | M0)) /*McBSP_CLKS*/\
+ MUX_VAL(CP(MCBSP2_DR),		(IDIS | PTD | DIS | M4)) /*GPIO_118*/\
+							 /* - nPOWERDOWN_DAC*/\
+ /*Expansion card 1*/\
+ MUX_VAL(CP(MMC1_CLK),		(IDIS | PTU | EN  | M0)) /*MMC1_CLK*/\
+ MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | EN  | M0)) /*MMC1_CMD*/\
+ MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT0*/\
+ MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT1*/\
+ MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT2*/\
+ MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT3*/\
+ MUX_VAL(CP(MMC1_DAT4),		(IEN  | PTD | DIS | M4)) /*GPIO_126 - MMC1_WP*/\
+ /*Expansion card 2*/\
+ MUX_VAL(CP(MMC2_CLK),		(IDIS | PTD | DIS | M0)) /*MMC2_CLK*/\
+ MUX_VAL(CP(MMC2_CMD),		(IEN  | PTU | EN  | M0)) /*MMC2_CMD*/\
+ MUX_VAL(CP(MMC2_DAT0),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT0*/\
+ MUX_VAL(CP(MMC2_DAT1),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT1*/\
+ MUX_VAL(CP(MMC2_DAT2),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT2*/\
+ MUX_VAL(CP(MMC2_DAT3),		(IEN  | PTU | EN  | M0)) /*MMC2_DAT3*/\
+ MUX_VAL(CP(MMC2_DAT4),		(IDIS | PTD | DIS | M1)) /*MMC2_DIR_DAT0*/\
+ MUX_VAL(CP(MMC2_DAT5),		(IDIS | PTD | DIS | M1)) /*MMC2_DIR_DAT1*/\
+ MUX_VAL(CP(MMC2_DAT6),		(IDIS | PTD | DIS | M1)) /*MMC2_DIR_CMD */\
+ MUX_VAL(CP(MMC2_DAT7),		(IEN  | PTU | EN  | M1)) /*MMC2_CLKIN*/\
+ MUX_VAL(CP(MMC1_DAT5),		(IEN  | PTD | DIS | M4)) /*GPIO_127 - MMC2_WP*/\
+ /*SDIO Interface to WIFI Module*/\
+ MUX_VAL(CP(ETK_CLK_ES2),	(IEN  | PTD | DIS | M2)) /*MMC3_CLK*/\
+ MUX_VAL(CP(ETK_CTL_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_CMD*/\
+ MUX_VAL(CP(ETK_D4_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT0*/\
+ MUX_VAL(CP(ETK_D5_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT1*/\
+ MUX_VAL(CP(ETK_D6_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT2*/\
+ MUX_VAL(CP(ETK_D3_ES2),	(IEN  | PTU | EN  | M2)) /*MMC3_DAT3*/\
+ /*Audio Interface To Bluetooth chip*/\
+ MUX_VAL(CP(MCBSP3_DX),		(IDIS | PTD | DIS | M0)) /*McBSP3_DX*/\
+ MUX_VAL(CP(MCBSP3_DR),		(IEN  | PTD | DIS | M0)) /*McBSP3_DR*/\
+ MUX_VAL(CP(MCBSP3_CLKX),	(IEN  | PTD | DIS | M0)) /*McBSP3_CLKX*/\
+ MUX_VAL(CP(MCBSP3_FSX),	(IEN  | PTD | DIS | M0)) /*McBSP3_FSX*/\
+ /*Digital Interface to Bluetooth (UART)*/\
+ MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0)) /*UART1_TX*/\
+ MUX_VAL(CP(UART1_RTS),		(IDIS | PTD | DIS | M0)) /*UART1_RTS*/\
+ MUX_VAL(CP(UART1_CTS),		(IEN  | PTU | EN  | M0)) /*UART1_CTS*/\
+ MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0)) /*UART1_RX*/\
+ /*Audio Interface to Triton2 chip (TPS65950)*/\
+ MUX_VAL(CP(MCBSP4_CLKX),	(IEN  | PTD | DIS | M0)) /*McBSP4_CLKX*/\
+ MUX_VAL(CP(MCBSP4_DR),		(IEN  | PTD | DIS | M0)) /*McBSP4_DR*/\
+ MUX_VAL(CP(MCBSP4_DX),		(IDIS | PTD | DIS | M0)) /*McBSP4_DX*/\
+ MUX_VAL(CP(MCBSP4_FSX),	(IEN  | PTD | DIS | M0)) /*McBSP4_FSX*/\
+ /*GPIO definitions for muxed pins on AV connector*/\
+ MUX_VAL(CP(UART2_CTS),		(IEN  | PTU | EN  | M4)) /*GPIO_144,*/\
+							 /*UART2_CTS*/\
+ MUX_VAL(CP(UART2_RTS),		(IEN  | PTU | DIS | M4)) /*GPIO_145,*/\
+							 /*UART2_RTS*/\
+ MUX_VAL(CP(UART2_TX),		(IEN  | PTU | EN  | M4)) /*GPIO_146,*/\
+							 /*UART2_TX*/\
+ MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M4)) /*GPIO_147,*/\
+							 /*UART2_RX*/\
+ /*Serial Interface (Peripheral boot, Linux console, on AV connector)*/\
+ MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0)) /*UART3_RX*/\
+ MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0)) /*UART3_TX*/\
+ /*LEDs (Controlled by OMAP)*/\
+ MUX_VAL(CP(MMC1_DAT6),		(IDIS | PTD | DIS | M4)) /*GPIO_128*/\
+							 /* - LED_MMC1*/\
+ MUX_VAL(CP(MMC1_DAT7),		(IDIS | PTD | DIS | M4)) /*GPIO_129*/\
+							 /* - LED_MMC2*/\
+ MUX_VAL(CP(MCBSP1_DX),		(IDIS | PTD | DIS | M4)) /*GPIO_158*/\
+							 /* - LED_BT*/\
+ MUX_VAL(CP(MCBSP1_DR),		(IDIS | PTD | DIS | M4)) /*GPIO_159*/\
+							 /* - LED_WIFI*/\
+ /*Switches*/\
+ MUX_VAL(CP(MCSPI1_CS2),	(IEN  | PTU | DIS | M4)) /*GPIO_176*/\
+							 /* - nHOLD_SWITCH*/\
+ MUX_VAL(CP(CAM_D9),		(IEN  | PTU | DIS | M4)) /*GPIO_108*/\
+							 /* - nLID_SWITCH*/\
+ /*External IRQs*/\
+ MUX_VAL(CP(CAM_HS),		(IEN  | PTU | DIS | M4)) /*GPIO_94*/\
+							 /* - nTOUCH_IRQ*/\
+ MUX_VAL(CP(ETK_D7_ES2),	(IEN  | PTD | DIS | M4)) /*GPIO_21*/\
+							 /* - WIFI_IRQ*/\
+ MUX_VAL(CP(MCBSP1_FSX),	(IEN  | PTD | DIS | M4)) /*GPIO_161*/\
+							 /* - nIRQ_NUB1*/\
+ MUX_VAL(CP(CAM_WEN),		(IEN  | PTU | DIS | M4)) /*GPIO_167*/\
+							 /* - nIRQ_NUB2*/\
+ /*Various other stuff*/\
+ MUX_VAL(CP(CAM_VS),		(IEN  | PTU | DIS | M4)) /*GPIO_95*/\
+							 /* - nTOUCH_BUSY*/\
+ MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTD | DIS | M4)) /*GPIO_163*/\
+							 /* - nOC_USB5*/\
+ MUX_VAL(CP(MCBSP1_CLKX),	(IDIS | PTD | DIS | M4)) /*GPIO_162*/\
+							 /* - START_ADC*/\
+ MUX_VAL(CP(ETK_D8_ES2),	(IEN  | PTD | DIS | M4)) /*GPIO_22*/\
+							 /* - MSECURE*/\
+ MUX_VAL(CP(CAM_STROBE),	(IEN  | PTU | DIS | M4)) /*GPIO_126*/\
+							 /* - HP_DETECT*/\
+ /*External Resets and Enables*/\
+ MUX_VAL(CP(ETK_D0_ES2),	(IDIS | PTD | DIS | M4)) /*GPIO_14*/\
+							 /* - nHDPHN_SHUTDOWN*/\
+ MUX_VAL(CP(ETK_D1_ES2),	(IDIS | PTD | DIS | M4)) /*GPIO_15*/\
+							 /* - nBT_SHUTDOWN*/\
+ MUX_VAL(CP(ETK_D9_ES2),	(IDIS | PTD | DIS | M4)) /*GPIO_23*/\
+							 /* - nWIFI_RESET*/\
+ MUX_VAL(CP(MCBSP1_FSR),	(IDIS | PTU | DIS | M4)) /*GPIO_157*/\
+							 /* - nLCD_RESET*/\
+ MUX_VAL(CP(MCBSP1_CLKR),	(IDIS | PTD | DIS | M4)) /*GPIO_156*/\
+							 /* - RESET_NUBS*/\
+ MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTU | EN  | M4)) /*GPIO_164*/\
+							 /* - EN_USB_5V*/\
+ /*Unused*/\
+ MUX_VAL(CP(HDQ_SIO),		(IEN  | PTU | EN  | M0)) /*HDQ_SIO - NC*/\
+ MUX_VAL(CP(CSI2_DX0),		(IEN  | PTD | DIS | M0)) /*CSI2_DX0 - NC*/\
+ MUX_VAL(CP(CSI2_DY0),		(IEN  | PTD | DIS | M0)) /*CSI2_DY0 - NC*/\
+ MUX_VAL(CP(CSI2_DX1),		(IEN  | PTD | DIS | M0)) /*CSI2_DX1 - NC*/\
+ MUX_VAL(CP(CSI2_DY1),		(IEN  | PTD | DIS | M0)) /*CSI2_DY1 - NC*/\
+ MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M0)) /*I2C2_SCL - NC*/\
+ MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M0)) /*I2C2_SDA - NC*/\
+ /*HS USB OTG Port (connects to HSUSB0)*/\
+ MUX_VAL(CP(HSUSB0_CLK),	(IEN  | PTD | DIS | M0)) /*HSUSB0_CLK*/\
+ MUX_VAL(CP(HSUSB0_STP),	(IDIS | PTU | EN  | M0)) /*HSUSB0_STP*/\
+ MUX_VAL(CP(HSUSB0_DIR),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DIR*/\
+ MUX_VAL(CP(HSUSB0_NXT),	(IEN  | PTD | DIS | M0)) /*HSUSB0_NXT*/\
+ MUX_VAL(CP(HSUSB0_DATA0),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA0*/\
+ MUX_VAL(CP(HSUSB0_DATA1),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA1*/\
+ MUX_VAL(CP(HSUSB0_DATA2),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA2*/\
+ MUX_VAL(CP(HSUSB0_DATA3),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA3*/\
+ MUX_VAL(CP(HSUSB0_DATA4),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA4*/\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA5*/\
+ MUX_VAL(CP(HSUSB0_DATA6),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA6*/\
+ MUX_VAL(CP(HSUSB0_DATA7),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA7*/\
+ /*I2C Ports*/\
+ MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0)) /*I2C1_SCL - T2_CTRL*/\
+ MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0)) /*I2C1_SDA - T2_CTRL*/\
+ MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)) /*I2C3_SCL - NUBS*/\
+ MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)) /*I2C3_SDA - NUBS*/\
+ MUX_VAL(CP(I2C4_SCL),		(IEN  | PTU | EN  | M0)) /*I2C4_SCL - T2_SR*/\
+ MUX_VAL(CP(I2C4_SDA),		(IEN  | PTU | EN  | M0)) /*I2C4_SDA - T2_SR*/\
+ /*Serial Interface (Touch, LCD control)*/\
+ MUX_VAL(CP(MCSPI1_CLK),	(IEN  | PTD | DIS | M0)) /*McSPI1_CLK*/\
+ MUX_VAL(CP(MCSPI1_SIMO),	(IEN  | PTD | DIS | M0)) /*McSPI1_SIMO*/\
+ MUX_VAL(CP(MCSPI1_SOMI),	(IEN  | PTD | DIS | M0)) /*McSPI1_SOMI*/\
+ MUX_VAL(CP(MCSPI1_CS0),	(IDIS | PTU | EN  | M0)) /*McSPI1_CS0 - TOUCH*/\
+ MUX_VAL(CP(MCSPI1_CS1),	(IDIS | PTU | EN  | M0)) /*McSPI1_CS1 - LCD*/\
+ /*HS USB HOST Port (connects to HSUSB2)*/\
+ MUX_VAL(CP(ETK_D10_ES2),	(IDIS | PTD | DIS | M3)) /*USB_HOST_CLK*/\
+ MUX_VAL(CP(ETK_D11_ES2),	(IDIS | PTU | EN  | M3)) /*USB_HOST_STP*/\
+ MUX_VAL(CP(ETK_D12_ES2),	(IEN  | PTD | DIS | M3)) /*USB_HOST_DIR*/\
+ MUX_VAL(CP(ETK_D13_ES2),	(IEN  | PTD | DIS | M3)) /*USB_HOST_NXT*/\
+ MUX_VAL(CP(ETK_D14_ES2),	(IEN  | PTD | DIS | M3)) /*USB_HOST_D0*/\
+ MUX_VAL(CP(ETK_D15_ES2),	(IEN  | PTD | DIS | M3)) /*USB_HOST_D1*/\
+ MUX_VAL(CP(MCSPI1_CS3),	(IEN  | PTD | DIS | M3)) /*USB_HOST_D2*/\
+ MUX_VAL(CP(MCSPI2_CS1),	(IEN  | PTD | DIS | M3)) /*USB_HOST_D3*/\
+ MUX_VAL(CP(MCSPI2_SIMO),	(IEN  | PTD | DIS | M3)) /*USB_HOST_D4*/\
+ MUX_VAL(CP(MCSPI2_SOMI),	(IEN  | PTD | DIS | M3)) /*USB_HOST_D5*/\
+ MUX_VAL(CP(MCSPI2_CS0),	(IEN  | PTD | DIS | M3)) /*USB_HOST_D6*/\
+ MUX_VAL(CP(MCSPI2_CLK),	(IEN  | PTD | DIS | M3)) /*USB_HOST_D7*/\
+ MUX_VAL(CP(ETK_D2_ES2),	(IDIS | PTD | DIS | M4)) /*GPIO_16*/\
+							 /* - nRESET_USB_HOST*/\
+ /*Control and debug */\
+ MUX_VAL(CP(SYS_32K),		(IEN  | PTD | DIS | M0)) /*SYS_32K*/\
+ MUX_VAL(CP(SYS_CLKREQ),	(IEN  | PTD | DIS | M0)) /*SYS_CLKREQ*/\
+ MUX_VAL(CP(SYS_NIRQ),		(IEN  | PTU | EN  | M0)) /*SYS_nIRQ*/\
+ MUX_VAL(CP(SYS_BOOT0),		(IEN  | PTD | DIS | M4)) /*GPIO_2*/\
+ MUX_VAL(CP(SYS_BOOT1),		(IEN  | PTD | DIS | M4)) /*GPIO_3*/\
+ MUX_VAL(CP(SYS_BOOT2),		(IEN  | PTD | DIS | M4)) /*GPIO_4*/\
+ MUX_VAL(CP(SYS_BOOT3),		(IEN  | PTD | DIS | M4)) /*GPIO_5*/\
+ MUX_VAL(CP(SYS_BOOT4),		(IEN  | PTD | DIS | M4)) /*GPIO_6*/\
+ MUX_VAL(CP(SYS_BOOT5),		(IEN  | PTD | DIS | M4)) /*GPIO_7*/\
+ MUX_VAL(CP(SYS_BOOT6),		(IEN  | PTD | DIS | M4)) /*GPIO_8*/\
+ MUX_VAL(CP(SYS_OFF_MODE),	(IEN  | PTD | DIS | M0)) /*SYS_OFF_MODE*/\
+ MUX_VAL(CP(SYS_CLKOUT1),	(IEN  | PTD | DIS | M4)) /*SYS_CLKOUT1 - NC*/\
+ MUX_VAL(CP(SYS_CLKOUT2),	(IEN  | PTD | DIS | M4)) /*SYS_CLKOUT2 - NC*/\
+ /*JTAG*/\
+ MUX_VAL(CP(JTAG_nTRST),	(IEN  | PTD | DIS | M0)) /*JTAG_nTRST*/\
+ MUX_VAL(CP(JTAG_TCK),		(IEN  | PTD | DIS | M0)) /*JTAG_TCK*/\
+ MUX_VAL(CP(JTAG_TMS),		(IEN  | PTD | DIS | M0)) /*JTAG_TMS*/\
+ MUX_VAL(CP(JTAG_TDI),		(IEN  | PTD | DIS | M0)) /*JTAG_TDI*/\
+ MUX_VAL(CP(JTAG_EMU0),		(IEN  | PTD | DIS | M0)) /*JTAG_EMU0*/\
+ MUX_VAL(CP(JTAG_EMU1),		(IEN  | PTD | DIS | M0)) /*JTAG_EMU1*/\
+ /*Die to Die stuff*/\
+ MUX_VAL(CP(D2D_MCAD1),		(IEN  | PTD | EN  | M0)) /*d2d_mcad1*/\
+ MUX_VAL(CP(D2D_MCAD2),		(IEN  | PTD | EN  | M0)) /*d2d_mcad2*/\
+ MUX_VAL(CP(D2D_MCAD3),		(IEN  | PTD | EN  | M0)) /*d2d_mcad3*/\
+ MUX_VAL(CP(D2D_MCAD4),		(IEN  | PTD | EN  | M0)) /*d2d_mcad4*/\
+ MUX_VAL(CP(D2D_MCAD5),		(IEN  | PTD | EN  | M0)) /*d2d_mcad5*/\
+ MUX_VAL(CP(D2D_MCAD6),		(IEN  | PTD | EN  | M0)) /*d2d_mcad6*/\
+ MUX_VAL(CP(D2D_MCAD7),		(IEN  | PTD | EN  | M0)) /*d2d_mcad7*/\
+ MUX_VAL(CP(D2D_MCAD8),		(IEN  | PTD | EN  | M0)) /*d2d_mcad8*/\
+ MUX_VAL(CP(D2D_MCAD9),		(IEN  | PTD | EN  | M0)) /*d2d_mcad9*/\
+ MUX_VAL(CP(D2D_MCAD10),	(IEN  | PTD | EN  | M0)) /*d2d_mcad10*/\
+ MUX_VAL(CP(D2D_MCAD11),	(IEN  | PTD | EN  | M0)) /*d2d_mcad11*/\
+ MUX_VAL(CP(D2D_MCAD12),	(IEN  | PTD | EN  | M0)) /*d2d_mcad12*/\
+ MUX_VAL(CP(D2D_MCAD13),	(IEN  | PTD | EN  | M0)) /*d2d_mcad13*/\
+ MUX_VAL(CP(D2D_MCAD14),	(IEN  | PTD | EN  | M0)) /*d2d_mcad14*/\
+ MUX_VAL(CP(D2D_MCAD15),	(IEN  | PTD | EN  | M0)) /*d2d_mcad15*/\
+ MUX_VAL(CP(D2D_MCAD16),	(IEN  | PTD | EN  | M0)) /*d2d_mcad16*/\
+ MUX_VAL(CP(D2D_MCAD17),	(IEN  | PTD | EN  | M0)) /*d2d_mcad17*/\
+ MUX_VAL(CP(D2D_MCAD18),	(IEN  | PTD | EN  | M0)) /*d2d_mcad18*/\
+ MUX_VAL(CP(D2D_MCAD19),	(IEN  | PTD | EN  | M0)) /*d2d_mcad19*/\
+ MUX_VAL(CP(D2D_MCAD20),	(IEN  | PTD | EN  | M0)) /*d2d_mcad20*/\
+ MUX_VAL(CP(D2D_MCAD21),	(IEN  | PTD | EN  | M0)) /*d2d_mcad21*/\
+ MUX_VAL(CP(D2D_MCAD22),	(IEN  | PTD | EN  | M0)) /*d2d_mcad22*/\
+ MUX_VAL(CP(D2D_MCAD23),	(IEN  | PTD | EN  | M0)) /*d2d_mcad23*/\
+ MUX_VAL(CP(D2D_MCAD24),	(IEN  | PTD | EN  | M0)) /*d2d_mcad24*/\
+ MUX_VAL(CP(D2D_MCAD25),	(IEN  | PTD | EN  | M0)) /*d2d_mcad25*/\
+ MUX_VAL(CP(D2D_MCAD26),	(IEN  | PTD | EN  | M0)) /*d2d_mcad26*/\
+ MUX_VAL(CP(D2D_MCAD27),	(IEN  | PTD | EN  | M0)) /*d2d_mcad27*/\
+ MUX_VAL(CP(D2D_MCAD28),	(IEN  | PTD | EN  | M0)) /*d2d_mcad28*/\
+ MUX_VAL(CP(D2D_MCAD29),	(IEN  | PTD | EN  | M0)) /*d2d_mcad29*/\
+ MUX_VAL(CP(D2D_MCAD30),	(IEN  | PTD | EN  | M0)) /*d2d_mcad30*/\
+ MUX_VAL(CP(D2D_MCAD31),	(IEN  | PTD | EN  | M0)) /*d2d_mcad31*/\
+ MUX_VAL(CP(D2D_MCAD32),	(IEN  | PTD | EN  | M0)) /*d2d_mcad32*/\
+ MUX_VAL(CP(D2D_MCAD33),	(IEN  | PTD | EN  | M0)) /*d2d_mcad33*/\
+ MUX_VAL(CP(D2D_MCAD34),	(IEN  | PTD | EN  | M0)) /*d2d_mcad34*/\
+ MUX_VAL(CP(D2D_MCAD35),	(IEN  | PTD | EN  | M0)) /*d2d_mcad35*/\
+ MUX_VAL(CP(D2D_MCAD36),	(IEN  | PTD | EN  | M0)) /*d2d_mcad36*/\
+ MUX_VAL(CP(D2D_CLK26MI),	(IEN  | PTD | DIS | M0)) /*d2d_clk26mi*/\
+ MUX_VAL(CP(D2D_NRESPWRON),	(IEN  | PTD | EN  | M0)) /*d2d_nrespwron*/\
+ MUX_VAL(CP(D2D_NRESWARM),	(IEN  | PTU | EN  | M0)) /*d2d_nreswarm*/\
+ MUX_VAL(CP(D2D_ARM9NIRQ),	(IEN  | PTD | DIS | M0)) /*d2d_arm9nirq*/\
+ MUX_VAL(CP(D2D_UMA2P6FIQ),	(IEN  | PTD | DIS | M0)) /*d2d_uma2p6fiq*/\
+ MUX_VAL(CP(D2D_SPINT),		(IEN  | PTD | EN  | M0)) /*d2d_spint*/\
+ MUX_VAL(CP(D2D_FRINT),		(IEN  | PTD | EN  | M0)) /*d2d_frint*/\
+ MUX_VAL(CP(D2D_DMAREQ0),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq0*/\
+ MUX_VAL(CP(D2D_DMAREQ1),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq1*/\
+ MUX_VAL(CP(D2D_DMAREQ2),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq2*/\
+ MUX_VAL(CP(D2D_DMAREQ3),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq3*/\
+ MUX_VAL(CP(D2D_N3GTRST),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtrst*/\
+ MUX_VAL(CP(D2D_N3GTDI),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdi*/\
+ MUX_VAL(CP(D2D_N3GTDO),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdo*/\
+ MUX_VAL(CP(D2D_N3GTMS),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtms*/\
+ MUX_VAL(CP(D2D_N3GTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtck*/\
+ MUX_VAL(CP(D2D_N3GRTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3grtck*/\
+ MUX_VAL(CP(D2D_MSTDBY),	(IEN  | PTU | EN  | M0)) /*d2d_mstdby*/\
+ MUX_VAL(CP(D2D_SWAKEUP),	(IEN  | PTD | EN  | M0)) /*d2d_swakeup*/\
+ MUX_VAL(CP(D2D_IDLEREQ),	(IEN  | PTD | DIS | M0)) /*d2d_idlereq*/\
+ MUX_VAL(CP(D2D_IDLEACK),	(IEN  | PTU | EN  | M0)) /*d2d_idleack*/\
+ MUX_VAL(CP(D2D_MWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_mwrite*/\
+ MUX_VAL(CP(D2D_SWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_swrite*/\
+ MUX_VAL(CP(D2D_MREAD),		(IEN  | PTD | DIS | M0)) /*d2d_mread*/\
+ MUX_VAL(CP(D2D_SREAD),		(IEN  | PTD | DIS | M0)) /*d2d_sread*/\
+ MUX_VAL(CP(D2D_MBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_mbusflag*/\
+ MUX_VAL(CP(D2D_SBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_sbusflag*/\
+ MUX_VAL(CP(SDRC_CKE0),		(IDIS | PTU | EN  | M0)) /*sdrc_cke0*/\
+ MUX_VAL(CP(SDRC_CKE1),		(IDIS | PTD | DIS | M7)) /*sdrc_cke1*/
+
+#endif
diff -Naur u-boot-2009.01/board/omap3/pandora/u-boot.lds u-boot/board/omap3/pandora/u-boot.lds
--- u-boot-2009.01/board/omap3/pandora/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/pandora/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,63 @@
+/*
+ * January 2004 - Changed to support H4 device
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm_cortexa8/start.o	(.text)
+		*(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	.ARM.extab	: { *(.ARM.extab* .gnu.linkonce.armextab.*) }
+	__exidx_start = .;
+	.ARM.exidx	: { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
+	__exidx_end = .;
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/omap3/zoom1/config.mk u-boot/board/omap3/zoom1/config.mk
--- u-boot-2009.01/board/omap3/zoom1/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/zoom1/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2006-2008
+# Texas Instruments, <www.ti.com>
+#
+# Zoom MDK uses OMAP3 (ARM-CortexA8) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+# Physical Address:
+# 8000'0000 (bank0)
+# A000/0000 (bank1)
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+
+# For use with external or internal boots.
+TEXT_BASE = 0x80e80000
diff -Naur u-boot-2009.01/board/omap3/zoom1/Makefile u-boot/board/omap3/zoom1/Makefile
--- u-boot-2009.01/board/omap3/zoom1/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/zoom1/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,49 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= zoom1.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/omap3/zoom1/u-boot.lds u-boot/board/omap3/zoom1/u-boot.lds
--- u-boot-2009.01/board/omap3/zoom1/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/zoom1/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,63 @@
+/*
+ * January 2004 - Changed to support H4 device
+ * Copyright (c) 2004-2008 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm_cortexa8/start.o	(.text)
+		*(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	.ARM.extab	: { *(.ARM.extab* .gnu.linkonce.armextab.*) }
+	__exidx_start = .;
+	.ARM.exidx	: { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
+	__exidx_end = .;
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/omap3/zoom1/zoom1.c u-boot/board/omap3/zoom1/zoom1.c
--- u-boot-2009.01/board/omap3/zoom1/zoom1.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/zoom1/zoom1.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,77 @@
+/*
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Author :
+ *	Nishanth Menon <nm@ti.com>
+ *
+ * Derived from Beagle Board and 3430 SDP code by
+ *	Sunil Kumar <sunilsaini05@gmail.com>
+ *	Shashi Ranjan <shashiranjanmca05@gmail.com>
+ *	Richard Woodruff <r-woodruff2@ti.com>
+ *	Syed Mohammed Khasim <khasim@ti.com>
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-types.h>
+#include "zoom1.h"
+
+/******************************************************************************
+ * Routine: board_init
+ * Description: Early hardware init.
+ *****************************************************************************/
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gpmc_init(); /* in SRAM or SDRAM, finish GPMC */
+	/* board id for Linux */
+	gd->bd->bi_arch_number = MACH_TYPE_OMAP_LDP;
+	/* boot param addr */
+	gd->bd->bi_boot_params = (OMAP34XX_SDRC_CS0 + 0x100);
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: misc_init_r
+ * Description: Configure zoom board specific configurations
+ *****************************************************************************/
+int misc_init_r(void)
+{
+	power_init_r();
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: set_muxconf_regs
+ * Description: Setting up the configuration Mux registers specific to the
+ *		hardware. Many pins need to be moved from protect to primary
+ *		mode.
+ *****************************************************************************/
+void set_muxconf_regs(void)
+{
+	/* platform specific muxes */
+	MUX_ZOOM1_MDK();
+}
diff -Naur u-boot-2009.01/board/omap3/zoom1/zoom1.h u-boot/board/omap3/zoom1/zoom1.h
--- u-boot-2009.01/board/omap3/zoom1/zoom1.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/omap3/zoom1/zoom1.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,134 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments
+ * Nishanth Menon <nm@ti.com>
+ *
+ * Derived from: board/omap3/beagle/beagle.h
+ * Dirk Behme <dirk.behme@gmail.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _BOARD_ZOOM1_H_
+#define _BOARD_ZOOM1_H_
+
+const omap3_sysinfo sysinfo = {
+	SDP_3430_V1,
+	SDP_3430_V2,
+	DDR_STACKED,
+	"OMAP3 Zoom MDK Rev 1",
+	"NAND",
+};
+
+/*
+ * IEN	- Input Enable
+ * IDIS	- Input Disable
+ * PTD	- Pull type Down
+ * PTU	- Pull type Up
+ * DIS	- Pull type selection is inactive
+ * EN	- Pull type selection is active
+ * M0	- Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+#define MUX_ZOOM1_MDK() \
+ /*SDRC*/\
+ MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) /*SDRC_D0*/\
+ MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) /*SDRC_D1*/\
+ MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) /*SDRC_D2*/\
+ MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) /*SDRC_D3*/\
+ MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) /*SDRC_D4*/\
+ MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) /*SDRC_D5*/\
+ MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) /*SDRC_D6*/\
+ MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) /*SDRC_D7*/\
+ MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) /*SDRC_D8*/\
+ MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) /*SDRC_D9*/\
+ MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) /*SDRC_D10*/\
+ MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) /*SDRC_D11*/\
+ MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) /*SDRC_D12*/\
+ MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) /*SDRC_D13*/\
+ MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) /*SDRC_D14*/\
+ MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) /*SDRC_D15*/\
+ MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) /*SDRC_D16*/\
+ MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) /*SDRC_D17*/\
+ MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) /*SDRC_D18*/\
+ MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) /*SDRC_D19*/\
+ MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) /*SDRC_D20*/\
+ MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) /*SDRC_D21*/\
+ MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) /*SDRC_D22*/\
+ MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) /*SDRC_D23*/\
+ MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) /*SDRC_D24*/\
+ MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) /*SDRC_D25*/\
+ MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) /*SDRC_D26*/\
+ MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) /*SDRC_D27*/\
+ MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) /*SDRC_D28*/\
+ MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) /*SDRC_D29*/\
+ MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) /*SDRC_D30*/\
+ MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) /*SDRC_D31*/\
+ MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) /*SDRC_CLK*/\
+ MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS0*/\
+ MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS1*/\
+ MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS2*/\
+ MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS3*/\
+ /*GPMC*/\
+ MUX_VAL(CP(GPMC_A1),		(IDIS | PTD | DIS | M0)) /*GPMC_A1*/\
+ MUX_VAL(CP(GPMC_A2),		(IDIS | PTD | DIS | M0)) /*GPMC_A2*/\
+ MUX_VAL(CP(GPMC_A3),		(IDIS | PTD | DIS | M0)) /*GPMC_A3*/\
+ MUX_VAL(CP(GPMC_A4),		(IDIS | PTD | DIS | M0)) /*GPMC_A4*/\
+ MUX_VAL(CP(GPMC_A5),		(IDIS | PTD | DIS | M0)) /*GPMC_A5*/\
+ MUX_VAL(CP(GPMC_A6),		(IDIS | PTD | DIS | M0)) /*GPMC_A6*/\
+ MUX_VAL(CP(GPMC_A7),		(IDIS | PTD | DIS | M0)) /*GPMC_A7*/\
+ MUX_VAL(CP(GPMC_A8),		(IDIS | PTD | DIS | M0)) /*GPMC_A8*/\
+ MUX_VAL(CP(GPMC_A9),		(IDIS | PTD | DIS | M0)) /*GPMC_A9*/\
+ MUX_VAL(CP(GPMC_A10),		(IDIS | PTD | DIS | M0)) /*GPMC_A10*/\
+ MUX_VAL(CP(GPMC_D0),		(IEN  | PTD | DIS | M0)) /*GPMC_D0*/\
+ MUX_VAL(CP(GPMC_D1),		(IEN  | PTD | DIS | M0)) /*GPMC_D1*/\
+ MUX_VAL(CP(GPMC_D2),		(IEN  | PTD | DIS | M0)) /*GPMC_D2*/\
+ MUX_VAL(CP(GPMC_D3),		(IEN  | PTD | DIS | M0)) /*GPMC_D3*/\
+ MUX_VAL(CP(GPMC_D4),		(IEN  | PTD | DIS | M0)) /*GPMC_D4*/\
+ MUX_VAL(CP(GPMC_D5),		(IEN  | PTD | DIS | M0)) /*GPMC_D5*/\
+ MUX_VAL(CP(GPMC_D6),		(IEN  | PTD | DIS | M0)) /*GPMC_D6*/\
+ MUX_VAL(CP(GPMC_D7),		(IEN  | PTD | DIS | M0)) /*GPMC_D7*/\
+ MUX_VAL(CP(GPMC_D8),		(IEN  | PTD | DIS | M0)) /*GPMC_D8*/\
+ MUX_VAL(CP(GPMC_D9),		(IEN  | PTD | DIS | M0)) /*GPMC_D9*/\
+ MUX_VAL(CP(GPMC_D10),		(IEN  | PTD | DIS | M0)) /*GPMC_D10*/\
+ MUX_VAL(CP(GPMC_D11),		(IEN  | PTD | DIS | M0)) /*GPMC_D11*/\
+ MUX_VAL(CP(GPMC_D12),		(IEN  | PTD | DIS | M0)) /*GPMC_D12*/\
+ MUX_VAL(CP(GPMC_D13),		(IEN  | PTD | DIS | M0)) /*GPMC_D13*/\
+ MUX_VAL(CP(GPMC_D14),		(IEN  | PTD | DIS | M0)) /*GPMC_D14*/\
+ MUX_VAL(CP(GPMC_D15),		(IEN  | PTD | DIS | M0)) /*GPMC_D15*/\
+ MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS0*/\
+ MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M7)) /*GPMC_nCS1*/\
+ MUX_VAL(CP(GPMC_NCS2),		(IDIS | PTU | EN  | M7)) /*GPMC_nCS2*/\
+ MUX_VAL(CP(GPMC_NCS3),		(IDIS | PTU | EN  | M7)) /*GPMC_nCS3*/\
+ MUX_VAL(CP(GPMC_NCS4),		(IDIS | PTU | EN  | M7)) /*GPMC_nCS4*/\
+ MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTD | DIS | M7)) /*GPMC_nCS5*/\
+ MUX_VAL(CP(GPMC_NCS6),		(IEN  | PTD | DIS | M7)) /*GPMC_nCS6*/\
+ MUX_VAL(CP(GPMC_NCS7),		(IEN  | PTU | EN  | M7)) /*GPMC_nCS7*/\
+ MUX_VAL(CP(GPMC_CLK),		(IDIS | PTD | DIS | M0)) /*GPMC_CLK*/\
+ MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0)) /*GPMC_nADV_ALE*/\
+ MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0)) /*GPMC_nOE*/\
+ MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0)) /*GPMC_nWE*/\
+ MUX_VAL(CP(GPMC_NWP),		(IDIS | PTU | DIS | M0)) /*GPMC_nWP*/\
+ MUX_VAL(CP(GPMC_NBE0_CLE),	(IDIS | PTD | DIS | M0)) /*GPMC_nBE0_CLE*/\
+ MUX_VAL(CP(GPMC_NBE1),		(IEN  | PTD | DIS | M0)) /*GPMC_nBE1*/\
+ MUX_VAL(CP(GPMC_WAIT0),	(IEN  | PTD | EN  | M0)) /*GPMC_WAIT0*/\
+ MUX_VAL(CP(GPMC_WAIT1),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT1*/\
+ MUX_VAL(CP(GPMC_WAIT2),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT2*/\
+ MUX_VAL(CP(GPMC_WAIT3),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT3*/
+
+#endif /* _BOARD_ZOOM_H_ */
diff -Naur u-boot-2009.01/board/pcippc2/cpc710_pci.c u-boot/board/pcippc2/cpc710_pci.c
--- u-boot-2009.01/board/pcippc2/cpc710_pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/pcippc2/cpc710_pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -215,7 +215,7 @@
 		 PCI_MEMORY_BUS,
 		 PCI_MEMORY_PHYS,
 		 PCI_MEMORY_MAXSIZE,
-		 PCI_REGION_MEM | PCI_REGION_MEMORY);
+		 PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
   /* PCI memory space */
   pci_set_region(local_hose.regions + 1,
@@ -265,7 +265,7 @@
 		 PCI_MEMORY_BUS,
 		 PCI_MEMORY_PHYS,
 		 PCI_MEMORY_MAXSIZE,
-		 PCI_REGION_MEMORY);
+		 PCI_REGION_SYS_MEMORY);
 
   /* PCI memory space */
   pci_set_region(cpci_hose.regions + 1,
diff -Naur u-boot-2009.01/board/pcippc2/pcippc2.c u-boot/board/pcippc2/pcippc2.c
--- u-boot-2009.01/board/pcippc2/pcippc2.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/pcippc2/pcippc2.c	2009-02-26 14:03:58.000000000 +0100
@@ -230,13 +230,13 @@
 	default:
 		break;
 	}
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
 U_BOOT_CMD(
 	wd,	2,	1,	do_wd,
-	"wd      - check and set watchdog\n",
+	"check and set watchdog",
 	"on   - switch watchDog on\n"
 	"wd off  - switch watchdog off\n"
 	"wd      - print current status\n"
diff -Naur u-boot-2009.01/board/pcs440ep/pcs440ep.c u-boot/board/pcs440ep/pcs440ep.c
--- u-boot-2009.01/board/pcs440ep/pcs440ep.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/pcs440ep/pcs440ep.c	2009-02-26 14:03:58.000000000 +0100
@@ -761,7 +761,7 @@
 
 U_BOOT_CMD(
 	led,	2,	1,	do_led,
-	"led [bitmask]   - set the DIAG-LED\n",
+	"set the DIAG-LED",
 	"[bitmask] 0x01 = DIAG 1 on\n"
 	"              0x02 = DIAG 2 on\n"
 	"              0x04 = DIAG 3 on\n"
@@ -780,7 +780,7 @@
 
 	if (argc < 2) {
   usage:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -823,7 +823,7 @@
 
 U_BOOT_CMD(
 	sha1,	4,	1,	do_sha1,
-	"sha1    - calculate the SHA1 Sum\n",
+	"calculate the SHA1 Sum",
 	"address len [addr]  calculate the SHA1 sum [save at addr]\n"
 	"     -p calculate the SHA1 sum from the U-Boot image in flash and print\n"
 	"     -c check the U-Boot image in flash\n"
diff -Naur u-boot-2009.01/board/pn62/cmd_pn62.c u-boot/board/pn62/cmd_pn62.c
--- u-boot-2009.01/board/pn62/cmd_pn62.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/pn62/cmd_pn62.c	2009-02-26 14:03:58.000000000 +0100
@@ -41,7 +41,7 @@
     unsigned int number, function;
 
     if (argc != 3) {
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
     }
     number = simple_strtoul(argv[1], NULL, 10);
@@ -53,7 +53,7 @@
 }
 U_BOOT_CMD(
 	led    ,	3,	1,	do_led,
-	"led     - set LED 0..11 on the PN62 board\n",
+	"set LED 0..11 on the PN62 board",
 	"i fun\n"
 	"    - set 'i'th LED to function 'fun'\n"
 );
@@ -83,7 +83,7 @@
 	addr = simple_strtoul(argv[1], NULL, 16);
 	break;
     default:
-       printf ("Usage:\n%s\n", cmdtp->usage);
+       cmd_usage(cmdtp);
 	return 1;
     }
 
@@ -174,7 +174,7 @@
 
 U_BOOT_CMD(
 	loadpci,	2,	1,	do_loadpci,
-	"loadpci - load binary file over PCI\n",
+	"load binary file over PCI",
 	"[addr]\n"
 	"    - load binary file over PCI to address 'addr'\n"
 );
diff -Naur u-boot-2009.01/board/ppmc7xx/pci.c u-boot/board/ppmc7xx/pci.c
--- u-boot-2009.01/board/ppmc7xx/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/ppmc7xx/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -45,7 +45,7 @@
 	CONFIG_SYS_PCI_MEMORY_BUS,
 	CONFIG_SYS_PCI_MEMORY_PHYS,
 	CONFIG_SYS_PCI_MEMORY_SIZE,
-	PCI_REGION_MEM | PCI_REGION_MEMORY);
+	PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
     /* PCI memory space */
     pci_set_region(hose->regions + 1,
diff -Naur u-boot-2009.01/board/prodrive/pdnb3/pdnb3.c u-boot/board/prodrive/pdnb3/pdnb3.c
--- u-boot-2009.01/board/prodrive/pdnb3/pdnb3.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/prodrive/pdnb3/pdnb3.c	2009-02-26 14:03:58.000000000 +0100
@@ -216,7 +216,7 @@
 	ulong addr;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -227,7 +227,7 @@
 
 U_BOOT_CMD(
 	fpga,     2,     0,      do_fpga,
-	"fpga    - boot FPGA\n",
+	"boot FPGA",
 	"address size\n    - boot FPGA with gzipped image at <address>\n"
 );
 
diff -Naur u-boot-2009.01/board/pxa255_idp/pxa_idp.c u-boot/board/pxa255_idp/pxa_idp.c
--- u-boot-2009.01/board/pxa255_idp/pxa_idp.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/pxa255_idp/pxa_idp.c	2009-02-26 14:03:58.000000000 +0100
@@ -128,7 +128,7 @@
 }
 
 U_BOOT_CMD(idpcmd, CONFIG_SYS_MAXARGS, 0, do_idpcmd,
-	   "idpcmd    - custom IDP command\n",
+	   "custom IDP command",
 	   "no args at this time\n"
 );
 
diff -Naur u-boot-2009.01/board/r360mpi/r360mpi.c u-boot/board/r360mpi/r360mpi.c
--- u-boot-2009.01/board/r360mpi/r360mpi.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/r360mpi/r360mpi.c	2009-02-26 14:03:58.000000000 +0100
@@ -414,6 +414,6 @@
 
 U_BOOT_CMD(
 	kbd,	1,	1,	do_kbd,
-	"kbd     - read keyboard status\n",
+	"read keyboard status",
 	NULL
 );
diff -Naur u-boot-2009.01/board/renesas/sh7785lcr/rtl8169_mac.c u-boot/board/renesas/sh7785lcr/rtl8169_mac.c
--- u-boot-2009.01/board/renesas/sh7785lcr/rtl8169_mac.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/renesas/sh7785lcr/rtl8169_mac.c	2009-02-26 14:03:58.000000000 +0100
@@ -305,7 +305,7 @@
 	char *s, *e;
 
 	if (argc != 2) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -323,7 +323,7 @@
 
 U_BOOT_CMD(
 	setmac,	2,	1,	do_set_mac,
-	"setmac - write MAC address for RTL8110SCL\n",
+	"write MAC address for RTL8110SCL",
 	"\n"
 	"setmac <mac address> - write MAC address for RTL8110SCL\n"
 );
@@ -331,7 +331,7 @@
 int do_print_mac(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc != 1) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -342,7 +342,7 @@
 
 U_BOOT_CMD(
 	printmac,	1,	1,	do_print_mac,
-	"printmac - print MAC address for RTL8110\n",
+	"print MAC address for RTL8110",
 	"\n"
 	"    - print MAC address for RTL8110\n"
 );
diff -Naur u-boot-2009.01/board/renesas/sh7785lcr/selfcheck.c u-boot/board/renesas/sh7785lcr/selfcheck.c
--- u-boot-2009.01/board/renesas/sh7785lcr/selfcheck.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/renesas/sh7785lcr/selfcheck.c	2009-02-26 14:03:58.000000000 +0100
@@ -113,7 +113,7 @@
 	char *cmd;
 
 	if (argc != 2) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -150,7 +150,7 @@
 		test_net();
 		break;
 	default:
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -159,7 +159,7 @@
 
 U_BOOT_CMD(
 	hwtest,	2,	1,	do_hw_test,
-	"hwtest - hardware test for R0P7785LC0011RL board\n",
+	"hardware test for R0P7785LC0011RL board",
 	"\n"
 	"hwtest all   - test all hardware\n"
 	"hwtest pld   - output PLD version\n"
diff -Naur u-boot-2009.01/board/samsung/smdk2400/config.mk u-boot/board/samsung/smdk2400/config.mk
--- u-boot-2009.01/board/samsung/smdk2400/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2400/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,25 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+#
+# SAMSUNG board with S3C2400X (ARM920T) CPU
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+#
+# SAMSUNG has 1 bank of 32 MB DRAM
+#
+# 0C00'0000 to 0E00'0000
+#
+# Linux-Kernel is expected to be at 0cf0'0000, entry 0cf0'0000
+# optionally with a ramdisk at 0c80'0000
+#
+# we load ourself to 0CF80000 (must be high enough not to be
+# overwritten by the uncompessing Linux kernel)
+#
+# download area is 0C80'0000
+#
+
+
+TEXT_BASE = 0x0CF80000
diff -Naur u-boot-2009.01/board/samsung/smdk2400/flash.c u-boot/board/samsung/smdk2400/flash.c
--- u-boot-2009.01/board/samsung/smdk2400/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2400/flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,490 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* #define DEBUG */
+
+#include <common.h>
+#include <environment.h>
+
+#define FLASH_BANK_SIZE 0x1000000	/* 2 x   8 MB */
+#define MAIN_SECT_SIZE  0x40000		/* 2 x 128 kB */
+
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
+
+
+#define CMD_READ_ARRAY		0x00FF00FF
+#define CMD_IDENTIFY		0x00900090
+#define CMD_ERASE_SETUP		0x00200020
+#define CMD_ERASE_CONFIRM	0x00D000D0
+#define CMD_PROGRAM		0x00400040
+#define CMD_RESUME		0x00D000D0
+#define CMD_SUSPEND		0x00B000B0
+#define CMD_STATUS_READ		0x00700070
+#define CMD_STATUS_RESET	0x00500050
+
+#define BIT_BUSY		0x00800080
+#define BIT_ERASE_SUSPEND	0x00400040
+#define BIT_ERASE_ERROR		0x00200020
+#define BIT_PROGRAM_ERROR	0x00100010
+#define BIT_VPP_RANGE_ERROR	0x00080008
+#define BIT_PROGRAM_SUSPEND	0x00040004
+#define BIT_PROTECT_ERROR	0x00020002
+#define BIT_UNDEFINED		0x00010001
+
+#define BIT_SEQUENCE_ERROR	0x00300030
+#define BIT_TIMEOUT		0x80000000
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_info[i].flash_id =
+			(INTEL_MANUFACT     & FLASH_VENDMASK) |
+			(INTEL_ID_28F640J3A & FLASH_TYPEMASK);
+		flash_info[i].size = FLASH_BANK_SIZE;
+		flash_info[i].sector_count = CONFIG_SYS_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CONFIG_SYS_MAX_FLASH_SECT);
+		if (i == 0)
+			flashbase = CONFIG_SYS_FLASH_BASE;
+		else
+			panic ("configured too many flash banks!\n");
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			flash_info[i].start[j] = flashbase;
+
+			/* uniform sector size */
+			flashbase += MAIN_SECT_SIZE;
+		}
+		size += flash_info[i].size;
+	}
+
+	/*
+	 * Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CONFIG_SYS_FLASH_BASE,
+			CONFIG_SYS_FLASH_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CONFIG_ENV_ADDR,
+			CONFIG_ENV_ADDR + CONFIG_ENV_SIZE - 1, &flash_info[0]);
+
+#ifdef CONFIG_ENV_ADDR_REDUND
+	flash_protect ( FLAG_PROTECT_SET,
+			CONFIG_ENV_ADDR_REDUND,
+			CONFIG_ENV_ADDR_REDUND + CONFIG_ENV_SIZE_REDUND - 1,
+			&flash_info[0]);
+#endif
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (INTEL_MANUFACT & FLASH_VENDMASK):
+		printf ("Intel: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (INTEL_ID_28F640J3A & FLASH_TYPEMASK):
+		printf ("2x 28F640J3A (64Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		goto Done;
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s",
+			info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+
+Done:	;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_error (ulong code)
+{
+	/* Check bit patterns */
+	/* SR.7=0 is busy, SR.7=1 is ready */
+	/* all other flags indicate error on 1 */
+	/* SR.0 is undefined */
+	/* Timeout is our faked flag */
+
+	/* sequence is described in Intel 290644-005 document */
+
+	/* check Timeout */
+	if (code & BIT_TIMEOUT) {
+		puts ("Timeout\n");
+		return ERR_TIMOUT;
+	}
+
+	/* check Busy, SR.7 */
+	if (~code & BIT_BUSY) {
+		puts ("Busy\n");
+		return ERR_PROG_ERROR;
+	}
+
+	/* check Vpp low, SR.3 */
+	if (code & BIT_VPP_RANGE_ERROR) {
+		puts ("Vpp range error\n");
+		return ERR_PROG_ERROR;
+	}
+
+	/* check Device Protect Error, SR.1 */
+	if (code & BIT_PROTECT_ERROR) {
+		puts ("Device protect error\n");
+		return ERR_PROG_ERROR;
+	}
+
+	/* check Command Seq Error, SR.4 & SR.5 */
+	if (code & BIT_SEQUENCE_ERROR) {
+		puts ("Command seqence error\n");
+		return ERR_PROG_ERROR;
+	}
+
+	/* check Block Erase Error, SR.5 */
+	if (code & BIT_ERASE_ERROR) {
+		puts ("Block erase error\n");
+		return ERR_PROG_ERROR;
+	}
+
+	/* check Program Error, SR.4 */
+	if (code & BIT_PROGRAM_ERROR) {
+		puts ("Program error\n");
+		return ERR_PROG_ERROR;
+	}
+
+	/* check Block Erase Suspended, SR.6 */
+	if (code & BIT_ERASE_SUSPEND) {
+		puts ("Block erase suspended\n");
+		return ERR_PROG_ERROR;
+	}
+
+	/* check Program Suspended, SR.2 */
+	if (code & BIT_PROGRAM_SUSPEND) {
+		puts ("Program suspended\n");
+		return ERR_PROG_ERROR;
+	}
+
+	/* OK, no error */
+	return ERR_OK;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	ulong result, result1;
+	int iflag, prot, sect;
+	int rc = ERR_OK;
+
+#ifdef USE_920T_MMU
+	int cflag;
+#endif
+
+	debug ("flash_erase: s_first %d  s_last %d\n", s_first, s_last);
+
+	/* first look for protection bits */
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+		(INTEL_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+#ifdef USE_920T_MMU
+	cflag = dcache_status ();
+	dcache_disable ();
+#endif
+	iflag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		debug ("Erasing sector %2d @ %08lX... ",
+			sect, info->start[sect]);
+
+		/* arm simple, non interrupt dependent timer */
+		reset_timer_masked ();
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			vu_long *addr = (vu_long *) (info->start[sect]);
+			ulong bsR7, bsR7_2, bsR5, bsR5_2;
+
+			/* *addr = CMD_STATUS_RESET; */
+			*addr = CMD_ERASE_SETUP;
+			*addr = CMD_ERASE_CONFIRM;
+
+			/* wait until flash is ready */
+			do {
+				/* check timeout */
+				if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
+					*addr = CMD_STATUS_RESET;
+					result = BIT_TIMEOUT;
+					break;
+				}
+
+				*addr = CMD_STATUS_READ;
+				result = *addr;
+				bsR7 = result & (1 << 7);
+				bsR7_2 = result & (1 << 23);
+			} while (!bsR7 | !bsR7_2);
+
+			*addr = CMD_STATUS_READ;
+			result1 = *addr;
+			bsR5 = result1 & (1 << 5);
+			bsR5_2 = result1 & (1 << 21);
+#ifdef SAMSUNG_FLASH_DEBUG
+			printf ("bsR5 %lx bsR5_2 %lx\n", bsR5, bsR5_2);
+			if (bsR5 != 0 && bsR5_2 != 0)
+				printf ("bsR5 %lx bsR5_2 %lx\n", bsR5, bsR5_2);
+#endif
+
+			*addr = CMD_READ_ARRAY;
+			*addr = CMD_RESUME;
+
+			if ((rc = flash_error (result)) != ERR_OK)
+				goto outahere;
+#if 0
+			printf ("ok.\n");
+		} else {		/* it was protected */
+
+			printf ("protected!\n");
+#endif
+		}
+	}
+
+outahere:
+	/* allow flash to settle - wait 10 ms */
+	udelay_masked (10000);
+
+	if (iflag)
+		enable_interrupts ();
+
+#ifdef USE_920T_MMU
+	if (cflag)
+		dcache_enable ();
+#endif
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, ulong data)
+{
+	vu_long *addr = (vu_long *) dest;
+	ulong result;
+	int rc = ERR_OK;
+	int iflag;
+
+#ifdef USE_920T_MMU
+	int cflag;
+#endif
+
+	/*
+	 * Check if Flash is (sufficiently) erased
+	 */
+	result = *addr;
+	if ((result & data) != data)
+		return ERR_NOT_ERASED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+#ifdef USE_920T_MMU
+	cflag = dcache_status ();
+	dcache_disable ();
+#endif
+	iflag = disable_interrupts ();
+
+	/* *addr = CMD_STATUS_RESET; */
+	*addr = CMD_PROGRAM;
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait until flash is ready */
+	do {
+		/* check timeout */
+		if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
+			*addr = CMD_SUSPEND;
+			result = BIT_TIMEOUT;
+			break;
+		}
+
+		*addr = CMD_STATUS_READ;
+		result = *addr;
+	} while (~result & BIT_BUSY);
+
+	/* *addr = CMD_READ_ARRAY; */
+	*addr = CMD_STATUS_READ;
+	result = *addr;
+
+	rc = flash_error (result);
+
+	if (iflag)
+		enable_interrupts ();
+
+#ifdef USE_920T_MMU
+	if (cflag)
+		dcache_enable ();
+#endif
+	*addr = CMD_READ_ARRAY;
+	*addr = CMD_RESUME;
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp, data;
+	int l;
+	int i, rc;
+
+	wp = (addr & ~3);			/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 24);
+		}
+		for (; i < 4 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 24);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 4; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 24);
+		}
+
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 4;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 4) {
+		data = *((vu_long *) src);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 4;
+		wp += 4;
+		cnt -= 4;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 4 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 24);
+		--cnt;
+	}
+	for (; i < 4; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 24);
+	}
+
+	return write_word (info, wp, data);
+}
diff -Naur u-boot-2009.01/board/samsung/smdk2400/lowlevel_init.S u-boot/board/samsung/smdk2400/lowlevel_init.S
--- u-boot-2009.01/board/samsung/smdk2400/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2400/lowlevel_init.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,163 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung development board by
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2400.S
+ *
+ * Copyright (C) 2001 Samsung Electronics by chc, 010406
+ *
+ * S3C2400 specific tweaks.
+ *
+ */
+
+/* memory controller */
+#define BWSCON 0x14000000
+#define BANKCON3 0x14000010	/* for cs8900, ethernet */
+
+/* Bank0 */
+#define B0_Tacs	0x0	/* 0 clk */
+#define B0_Tcos	0x0	/* 0 clk */
+#define B0_Tacc	0x7	/* 14 clk */
+#define B0_Tcoh	0x0	/* 0 clk */
+#define B0_Tah	0x0	/* 0 clk */
+#define B0_Tacp	0x0
+#define B0_PMC	0x0	/* normal */
+
+/* Bank1 */
+#define B1_Tacs	0x0	/* 0 clk */
+#define B1_Tcos	0x0	/* 0 clk */
+#define B1_Tacc	0x7	/* 14 clk */
+#define B1_Tcoh	0x0	/* 0 clk */
+#define B1_Tah	0x0	/* 0 clk */
+#define B1_Tacp	0x0
+#define B1_PMC	0x0	/* normal */
+
+/* Bank2 */
+#define B2_Tacs	0x0	/* 0 clk */
+#define B2_Tcos	0x0	/* 0 clk */
+#define B2_Tacc	0x7	/* 14 clk */
+#define B2_Tcoh	0x0	/* 0 clk */
+#define B2_Tah	0x0	/* 0 clk */
+#define B2_Tacp	0x0
+#define B2_PMC	0x0	/* normal */
+
+/* Bank3 - setup for the cs8900 */
+#define B3_Tacs	0x0	/* 0 clk */
+#define B3_Tcos	0x3	/* 4 clk */
+#define B3_Tacc	0x7	/* 14 clk */
+#define B3_Tcoh	0x1	/* 1 clk */
+#define B3_Tah	0x0	/* 0 clk */
+#define B3_Tacp	0x3	/* 6 clk */
+#define B3_PMC	0x0	/* normal */
+
+/* Bank4 */
+#define B4_Tacs	0x0	/* 0 clk */
+#define B4_Tcos	0x0	/* 0 clk */
+#define B4_Tacc	0x7	/* 14 clk */
+#define B4_Tcoh	0x0	/* 0 clk */
+#define B4_Tah	0x0	/* 0 clk */
+#define B4_Tacp	0x0
+#define B4_PMC	0x0	/* normal */
+
+/* Bank5 */
+#define B5_Tacs	0x0	/* 0 clk */
+#define B5_Tcos	0x0	/* 0 clk */
+#define B5_Tacc	0x7	/* 14 clk */
+#define B5_Tcoh	0x0	/* 0 clk */
+#define B5_Tah	0x0	/* 0 clk */
+#define B5_Tacp	0x0
+#define B5_PMC	0x0	/* normal */
+
+/* Bank6 */
+#define	B6_MT	0x3	/* SDRAM */
+#define	B6_Trcd	0x1	/* 3clk */
+#define	B6_SCAN	0x1	/* 9 bit */
+
+/* Bank7 */
+#define	B7_MT	0x3	/* SDRAM */
+#define	B7_Trcd	0x1	/* 3clk */
+#define	B7_SCAN	0x1	/* 9 bit */
+
+/* refresh parameter */
+#define REFEN	0x1	/* enable refresh */
+#define TREFMD	0x0	/* CBR(CAS before RAS)/auto refresh */
+#define Trp	0x0	/* 2 clk */
+#define Trc	0x3	/* 7 clk */
+#define Tchr	0x2	/* 3 clk */
+
+#define REFCNT	1113	/* period=15.6 us, HCLK=60Mhz, (2048+1-15.6*66) */
+
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #52
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+	.word	0x2211d114	/* d->Ethernet, BUSWIDTH=32 */
+	.word	((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC)) /* GCS0 */
+	.word	((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC)) /* GCS1 */
+	.word	((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC)) /* GCS2 */
+	.word	((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC)) /* GCS3 */
+	.word	((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC)) /* GCS4 */
+	.word	((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC)) /* GCS5 */
+	.word	((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN)) /* GCS6 */
+	.word	((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN)) /* GCS7 */
+	.word	((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+	.word	0x10	/* BUSWIDTH=32, SCLK power saving mode, BANKSIZE 32M/32M */
+	.word	0x30	/* MRSR6, CL=3clk */
+	.word	0x30	/* MRSR7 */
diff -Naur u-boot-2009.01/board/samsung/smdk2400/Makefile u-boot/board/samsung/smdk2400/Makefile
--- u-boot-2009.01/board/samsung/smdk2400/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2400/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= smdk2400.o flash.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/samsung/smdk2400/smdk2400.c u-boot/board/samsung/smdk2400/smdk2400.c
--- u-boot-2009.01/board/samsung/smdk2400/smdk2400.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2400/smdk2400.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,112 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <s3c2400.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_MODEM_SUPPORT
+static int key_pressed(void);
+int mdm_init (bd_t *);
+extern void disable_putc(void);
+extern void enable_putc(void);
+extern int hwflow_onoff(int);
+extern int do_mdm_init; /* defined in common/main.c */
+#endif /* CONFIG_MODEM_SUPPORT */
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+	/* memory and cpu-speed are setup before relocation */
+	/* change the clock to be 50 MHz 1:1:1 */
+	clk_power->MPLLCON = 0x5c042;
+	clk_power->CLKDIVN = 0;
+	/* set up the I/O ports */
+	gpio->PACON = 0x3ffff;
+	gpio->PBCON = 0xaaaaaaaa;
+	gpio->PBUP = 0xffff;
+	gpio->PECON = 0x0;
+	gpio->PEUP = 0x0;
+#ifdef CONFIG_HWFLOW
+	/*CTS[0] RTS[0] INPUT INPUT TXD[0] INPUT RXD[0] */
+	/*   10,   10,   00,   00,    10,   00,    10 */
+	gpio->PFCON=0xa22;
+	/* Disable pull-up on Rx, Tx, CTS and RTS pins */
+	gpio->PFUP=0x35;
+#else
+	/*INPUT INPUT INPUT INPUT TXD[0] INPUT RXD[0] */
+	/*   00,   00,   00,   00,    10,   00,    10 */
+	gpio->PFCON = 0x22;
+	/* Disable pull-up on Rx and Tx pins */
+	gpio->PFUP = 0x5;
+#endif	/* CONFIG_HWFLOW */
+	gpio->PGCON = 0x0;
+	gpio->PGUP = 0x0;
+	gpio->OPENCR = 0x0;
+
+	/* arch number of SAMSUNG-Board to MACH_TYPE_SMDK2400 */
+	gd->bd->bi_arch_number = MACH_TYPE_SMDK2400;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x0C000100;
+
+#ifdef CONFIG_MODEM_SUPPORT
+	if (key_pressed()) {
+		disable_putc();	/* modem doesn't understand banner etc */
+		do_mdm_init = 1;
+	}
+#endif	/* CONFIG_MODEM_SUPPORT */
+
+	return 0;
+}
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
+
+#ifdef CONFIG_MODEM_SUPPORT
+static int key_pressed(void)
+{
+	int rc;
+	if (1) {	/* check for button push here, now just return 1 */
+		rc = 1;
+	}
+
+	return rc;
+}
+#endif	/* CONFIG_MODEM_SUPPORT */
diff -Naur u-boot-2009.01/board/samsung/smdk2400/u-boot.lds u-boot/board/samsung/smdk2400/u-boot.lds
--- u-boot-2009.01/board/samsung/smdk2400/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2400/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,57 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm920t/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss (NOLOAD) : { *(.bss) . = ALIGN(4); }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/samsung/smdk2410/config.mk u-boot/board/samsung/smdk2410/config.mk
--- u-boot-2009.01/board/samsung/smdk2410/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2410/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,25 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# SAMSUNG SMDK2410 board with S3C2410X (ARM920T) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+#
+# SMDK2410 has 1 bank of 64 MB DRAM
+#
+# 3000'0000 to 3400'0000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# we load ourself to 33F8'0000
+#
+# download area is 3300'0000
+#
+
+
+TEXT_BASE = 0x33F80000
diff -Naur u-boot-2009.01/board/samsung/smdk2410/flash.c u-boot/board/samsung/smdk2410/flash.c
--- u-boot-2009.01/board/samsung/smdk2410/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2410/flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,433 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+ulong myflush (void);
+
+
+#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
+#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
+
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
+
+
+#define CMD_READ_ARRAY		0x000000F0
+#define CMD_UNLOCK1		0x000000AA
+#define CMD_UNLOCK2		0x00000055
+#define CMD_ERASE_SETUP		0x00000080
+#define CMD_ERASE_CONFIRM	0x00000030
+#define CMD_PROGRAM		0x000000A0
+#define CMD_UNLOCK_BYPASS	0x00000020
+
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CONFIG_SYS_FLASH_BASE + (0x00000555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CONFIG_SYS_FLASH_BASE + (0x000002AA << 1)))
+
+#define BIT_ERASE_DONE		0x00000080
+#define BIT_RDY_MASK		0x00000080
+#define BIT_PROGRAM_ERROR	0x00000020
+#define BIT_TIMEOUT		0x80000000	/* our flag */
+
+#define READY 1
+#define ERR   2
+#define TMO   4
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_info[i].flash_id =
+#if defined(CONFIG_AMD_LV400)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV400B & FLASH_TYPEMASK);
+#elif defined(CONFIG_AMD_LV800)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV800B & FLASH_TYPEMASK);
+#else
+#error "Unknown flash configured"
+#endif
+			flash_info[i].size = FLASH_BANK_SIZE;
+		flash_info[i].sector_count = CONFIG_SYS_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CONFIG_SYS_MAX_FLASH_SECT);
+		if (i == 0)
+			flashbase = PHYS_FLASH_1;
+		else
+			panic ("configured too many flash banks!\n");
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			if (j <= 3) {
+				/* 1st one is 16 KB */
+				if (j == 0) {
+					flash_info[i].start[j] =
+						flashbase + 0;
+				}
+
+				/* 2nd and 3rd are both 8 KB */
+				if ((j == 1) || (j == 2)) {
+					flash_info[i].start[j] =
+						flashbase + 0x4000 + (j -
+								      1) *
+						0x2000;
+				}
+
+				/* 4th 32 KB */
+				if (j == 3) {
+					flash_info[i].start[j] =
+						flashbase + 0x8000;
+				}
+			} else {
+				flash_info[i].start[j] =
+					flashbase + (j - 3) * MAIN_SECT_SIZE;
+			}
+		}
+		size += flash_info[i].size;
+	}
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_SYS_FLASH_BASE,
+		       CONFIG_SYS_FLASH_BASE + monitor_flash_len - 1,
+		       &flash_info[0]);
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_ENV_ADDR,
+		       CONFIG_ENV_ADDR + CONFIG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_LV400B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV400BB (4Mbit)\n");
+		break;
+	case (AMD_ID_LV800B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV800BB (8Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		goto Done;
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+
+      Done:;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	ushort result;
+	int iflag, cflag, prot, sect;
+	int rc = ERR_OK;
+	int chip;
+
+	/* first look for protection bits */
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+		printf ("Erasing sector %2d ... ", sect);
+
+		/* arm simple, non interrupt dependent timer */
+		reset_timer_masked ();
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			vu_short *addr = (vu_short *) (info->start[sect]);
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			*addr = CMD_ERASE_CONFIRM;
+
+			/* wait until flash is ready */
+			chip = 0;
+
+			do {
+				result = *addr;
+
+				/* check timeout */
+				if (get_timer_masked () >
+				    CONFIG_SYS_FLASH_ERASE_TOUT) {
+					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+					chip = TMO;
+					break;
+				}
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_ERASE_DONE)
+					chip = READY;
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
+					chip = ERR;
+
+			} while (!chip);
+
+			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+
+			if (chip == ERR) {
+				rc = ERR_PROG_ERROR;
+				goto outahere;
+			}
+			if (chip == TMO) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+
+			printf ("ok.\n");
+		} else {	/* it was protected */
+
+			printf ("protected!\n");
+		}
+	}
+
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+      outahere:
+	/* allow flash to settle - wait 10 ms */
+	udelay_masked (10000);
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_hword (flash_info_t * info, ulong dest, ushort data)
+{
+	vu_short *addr = (vu_short *) dest;
+	ushort result;
+	int rc = ERR_OK;
+	int cflag, iflag;
+	int chip;
+
+	/*
+	 * Check if Flash is (sufficiently) erased
+	 */
+	result = *addr;
+	if ((result & data) != data)
+		return ERR_NOT_ERASED;
+
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
+	*addr = CMD_PROGRAM;
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait until flash is ready */
+	chip = 0;
+	do {
+		result = *addr;
+
+		/* check timeout */
+		if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
+			chip = ERR | TMO;
+			break;
+		}
+		if (!chip && ((result & 0x80) == (data & 0x80)))
+			chip = READY;
+
+		if (!chip && ((result & 0xFFFF) & BIT_PROGRAM_ERROR)) {
+			result = *addr;
+
+			if ((result & 0x80) == (data & 0x80))
+				chip = READY;
+			else
+				chip = ERR;
+		}
+
+	} while (!chip);
+
+	*addr = CMD_READ_ARRAY;
+
+	if (chip == ERR || *addr != data)
+		rc = ERR_PROG_ERROR;
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	int l;
+	int i, rc;
+	ushort data;
+
+	wp = (addr & ~1);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_hword (info, wp, data);
+}
diff -Naur u-boot-2009.01/board/samsung/smdk2410/lowlevel_init.S u-boot/board/samsung/smdk2410/lowlevel_init.S
--- u-boot-2009.01/board/samsung/smdk2410/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2410/lowlevel_init.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,167 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ *
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8			(0x0)
+#define DW16			(0x1)
+#define DW32			(0x2)
+#define WAIT			(0x1<<2)
+#define UBLB			(0x1<<3)
+
+#define B1_BWSCON		(DW32)
+#define B2_BWSCON		(DW16)
+#define B3_BWSCON		(DW16 + WAIT + UBLB)
+#define B4_BWSCON		(DW16)
+#define B5_BWSCON		(DW16)
+#define B6_BWSCON		(DW32)
+#define B7_BWSCON		(DW32)
+
+/* BANK0CON */
+#define B0_Tacs			0x0	/*  0clk */
+#define B0_Tcos			0x0	/*  0clk */
+#define B0_Tacc			0x7	/* 14clk */
+#define B0_Tcoh			0x0	/*  0clk */
+#define B0_Tah			0x0	/*  0clk */
+#define B0_Tacp			0x0
+#define B0_PMC			0x0	/* normal */
+
+/* BANK1CON */
+#define B1_Tacs			0x0	/*  0clk */
+#define B1_Tcos			0x0	/*  0clk */
+#define B1_Tacc			0x7	/* 14clk */
+#define B1_Tcoh			0x0	/*  0clk */
+#define B1_Tah			0x0	/*  0clk */
+#define B1_Tacp			0x0
+#define B1_PMC			0x0
+
+#define B2_Tacs			0x0
+#define B2_Tcos			0x0
+#define B2_Tacc			0x7
+#define B2_Tcoh			0x0
+#define B2_Tah			0x0
+#define B2_Tacp			0x0
+#define B2_PMC			0x0
+
+#define B3_Tacs			0x0	/*  0clk */
+#define B3_Tcos			0x3	/*  4clk */
+#define B3_Tacc			0x7	/* 14clk */
+#define B3_Tcoh			0x1	/*  1clk */
+#define B3_Tah			0x0	/*  0clk */
+#define B3_Tacp			0x3     /*  6clk */
+#define B3_PMC			0x0	/* normal */
+
+#define B4_Tacs			0x0	/*  0clk */
+#define B4_Tcos			0x0	/*  0clk */
+#define B4_Tacc			0x7	/* 14clk */
+#define B4_Tcoh			0x0	/*  0clk */
+#define B4_Tah			0x0	/*  0clk */
+#define B4_Tacp			0x0
+#define B4_PMC			0x0	/* normal */
+
+#define B5_Tacs			0x0	/*  0clk */
+#define B5_Tcos			0x0	/*  0clk */
+#define B5_Tacc			0x7	/* 14clk */
+#define B5_Tcoh			0x0	/*  0clk */
+#define B5_Tah			0x0	/*  0clk */
+#define B5_Tacp			0x0
+#define B5_PMC			0x0	/* normal */
+
+#define B6_MT			0x3	/* SDRAM */
+#define B6_Trcd			0x1
+#define B6_SCAN			0x1	/* 9bit */
+
+#define B7_MT			0x3	/* SDRAM */
+#define B7_Trcd			0x1	/* 3clk */
+#define B7_SCAN			0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN			0x1	/* Refresh enable */
+#define TREFMD			0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trp			0x0	/* 2clk */
+#define Trc			0x3	/* 7clk */
+#define Tchr			0x2	/* 3clk */
+#define REFCNT			1113	/* period=15.6us, HCLK=60Mhz, (2048+1-15.6*60) */
+/**************************************/
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28))
+    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
+    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
+    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
+    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
+    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
+    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
+    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
+    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
+    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+    .word 0x32
+    .word 0x30
+    .word 0x30
diff -Naur u-boot-2009.01/board/samsung/smdk2410/Makefile u-boot/board/samsung/smdk2410/Makefile
--- u-boot-2009.01/board/samsung/smdk2410/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2410/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= smdk2410.o flash.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/samsung/smdk2410/smdk2410.c u-boot/board/samsung/smdk2410/smdk2410.c
--- u-boot-2009.01/board/samsung/smdk2410/smdk2410.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2410/smdk2410.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,123 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <s3c2410.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define FCLK_SPEED 1
+
+#if FCLK_SPEED==0		/* Fout = 203MHz, Fin = 12MHz for Audio */
+#define M_MDIV	0xC3
+#define M_PDIV	0x4
+#define M_SDIV	0x1
+#elif FCLK_SPEED==1		/* Fout = 202.8MHz */
+#define M_MDIV	0xA1
+#define M_PDIV	0x3
+#define M_SDIV	0x1
+#endif
+
+#define USB_CLOCK 1
+
+#if USB_CLOCK==0
+#define U_M_MDIV	0xA1
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x1
+#elif USB_CLOCK==1
+#define U_M_MDIV	0x48
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x2
+#endif
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+	  "subs %0, %1, #1\n"
+	  "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+	/* to reduce PLL lock time, adjust the LOCKTIME register */
+	clk_power->LOCKTIME = 0xFFFFFF;
+
+	/* configure MPLL */
+	clk_power->MPLLCON = ((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (4000);
+
+	/* configure UPLL */
+	clk_power->UPLLCON = ((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (8000);
+
+	/* set up the I/O ports */
+	gpio->GPACON = 0x007FFFFF;
+	gpio->GPBCON = 0x00044555;
+	gpio->GPBUP = 0x000007FF;
+	gpio->GPCCON = 0xAAAAAAAA;
+	gpio->GPCUP = 0x0000FFFF;
+	gpio->GPDCON = 0xAAAAAAAA;
+	gpio->GPDUP = 0x0000FFFF;
+	gpio->GPECON = 0xAAAAAAAA;
+	gpio->GPEUP = 0x0000FFFF;
+	gpio->GPFCON = 0x000055AA;
+	gpio->GPFUP = 0x000000FF;
+	gpio->GPGCON = 0xFF95FFBA;
+	gpio->GPGUP = 0x0000FFFF;
+	gpio->GPHCON = 0x002AFAAA;
+	gpio->GPHUP = 0x000007FF;
+
+	/* arch number of SMDK2410-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_SMDK2410;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+
+	return 0;
+}
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
diff -Naur u-boot-2009.01/board/samsung/smdk2410/u-boot.lds u-boot/board/samsung/smdk2410/u-boot.lds
--- u-boot-2009.01/board/samsung/smdk2410/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/samsung/smdk2410/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,57 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm920t/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss (NOLOAD) : { *(.bss) . = ALIGN(4); }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/sandburst/common/ppc440gx_i2c.c u-boot/board/sandburst/common/ppc440gx_i2c.c
--- u-boot-2009.01/board/sandburst/common/ppc440gx_i2c.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/sandburst/common/ppc440gx_i2c.c	2009-02-26 14:03:58.000000000 +0100
@@ -500,7 +500,7 @@
 
 U_BOOT_CMD(
 	iprobe1,	1,	1,	do_i2c1_probe,
-	"iprobe1  - probe to discover valid I2C chip addresses\n",
+	"probe to discover valid I2C chip addresses",
 	"\n    -discover valid I2C chip addresses\n"
 );
 
diff -Naur u-boot-2009.01/board/sandburst/karef/karef.c u-boot/board/sandburst/karef/karef.c
--- u-boot-2009.01/board/sandburst/karef/karef.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/sandburst/karef/karef.c	2009-02-26 14:03:58.000000000 +0100
@@ -578,7 +578,7 @@
 }
 
 U_BOOT_CMD(kasetup, 1, 1, karefSetupVars,
-	   "kasetup - Set environment to factory defaults\n", NULL);
+	   "Set environment to factory defaults", NULL);
 
 U_BOOT_CMD(karecover, 1, 1, karefRecover,
-	   "karecover - Set environment to allow for fs recovery\n", NULL);
+	   "Set environment to allow for fs recovery", NULL);
diff -Naur u-boot-2009.01/board/sandburst/metrobox/metrobox.c u-boot/board/sandburst/metrobox/metrobox.c
--- u-boot-2009.01/board/sandburst/metrobox/metrobox.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/sandburst/metrobox/metrobox.c	2009-02-26 14:03:58.000000000 +0100
@@ -544,7 +544,7 @@
 }
 
 U_BOOT_CMD(mbsetup, 1, 1, metroboxSetupVars,
-	   "mbsetup - Set environment to factory defaults\n", NULL);
+	   "Set environment to factory defaults", NULL);
 
 U_BOOT_CMD(mbrecover, 1, 1, metroboxRecover,
-	   "mbrecover - Set environment to allow for fs recovery\n", NULL);
+	   "Set environment to allow for fs recovery", NULL);
diff -Naur u-boot-2009.01/board/sbc8349/pci.c u-boot/board/sbc8349/pci.c
--- u-boot-2009.01/board/sbc8349/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/sbc8349/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -197,7 +197,7 @@
 		       CONFIG_PCI_SYS_MEM_BUS,
 		       CONFIG_PCI_SYS_MEM_PHYS,
 		       gd->ram_size,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose->region_count = 4;
 
@@ -293,7 +293,7 @@
 		       CONFIG_PCI_SYS_MEM_BUS,
 		       CONFIG_PCI_SYS_MEM_PHYS,
 		       gd->ram_size,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose->region_count = 4;
 
diff -Naur u-boot-2009.01/board/sbc8548/sbc8548.c u-boot/board/sbc8548/sbc8548.c
--- u-boot-2009.01/board/sbc8548/sbc8548.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/sbc8548/sbc8548.c	2009-02-26 14:03:58.000000000 +0100
@@ -470,7 +470,7 @@
 			       CONFIG_SYS_PCI_MEMORY_BUS,
 			       CONFIG_SYS_PCI_MEMORY_PHYS,
 			       CONFIG_SYS_PCI_MEMORY_SIZE,
-			       PCI_REGION_MEM | PCI_REGION_MEMORY);
+			       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 		/* outbound memory */
 		pci_set_region(r++,
diff -Naur u-boot-2009.01/board/sbc8560/sbc8560.c u-boot/board/sbc8560/sbc8560.c
--- u-boot-2009.01/board/sbc8560/sbc8560.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/sbc8560/sbc8560.c	2009-02-26 14:03:58.000000000 +0100
@@ -247,7 +247,7 @@
 #else
 	printf ("Board: Wind River SBC8540 Board\n");
 #endif
-	printf ("\tCPU: %s MHz\n", strmhz(buf, sysinfo.freqProcessor));
+	printf ("\tCPU: %s MHz\n", strmhz(buf, sysinfo.freqProcessor[0]));
 	printf ("\tCCB: %s MHz\n", strmhz(buf, sysinfo.freqSystemBus));
 	printf ("\tDDR: %s MHz\n", strmhz(buf, sysinfo.freqSystemBus/2));
 	if((CONFIG_SYS_LBC_LCRR & 0x0f) == 2 || (CONFIG_SYS_LBC_LCRR & 0x0f) == 4 \
diff -Naur u-boot-2009.01/board/sbc8641d/sbc8641d.c u-boot/board/sbc8641d/sbc8641d.c
--- u-boot-2009.01/board/sbc8641d/sbc8641d.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/sbc8641d/sbc8641d.c	2009-02-26 14:03:58.000000000 +0100
@@ -384,3 +384,32 @@
 
 	return val;
 }
+
+void board_reset(void)
+{
+#ifdef CONFIG_SYS_RESET_ADDRESS
+	ulong addr = CONFIG_SYS_RESET_ADDRESS;
+
+	/* flush and disable I/D cache */
+	__asm__ __volatile__ ("mfspr	3, 1008"	::: "r3");
+	__asm__ __volatile__ ("ori	5, 5, 0xcc00"	::: "r5");
+	__asm__ __volatile__ ("ori	4, 3, 0xc00"	::: "r4");
+	__asm__ __volatile__ ("andc	5, 3, 5"	::: "r5");
+	__asm__ __volatile__ ("sync");
+	__asm__ __volatile__ ("mtspr	1008, 4");
+	__asm__ __volatile__ ("isync");
+	__asm__ __volatile__ ("sync");
+	__asm__ __volatile__ ("mtspr	1008, 5");
+	__asm__ __volatile__ ("isync");
+	__asm__ __volatile__ ("sync");
+
+	/*
+	 * SRR0 has system reset vector, SRR1 has default MSR value
+	 * rfi restores MSR from SRR1 and sets the PC to the SRR0 value
+	 */
+	__asm__ __volatile__ ("mtspr	26, %0"		:: "r" (addr));
+	__asm__ __volatile__ ("li	4, (1 << 6)"	::: "r4");
+	__asm__ __volatile__ ("mtspr	27, 4");
+	__asm__ __volatile__ ("rfi");
+#endif
+}
diff -Naur u-boot-2009.01/board/sc520_cdp/u-boot.lds u-boot/board/sc520_cdp/u-boot.lds
--- u-boot-2009.01/board/sc520_cdp/u-boot.lds	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/sc520_cdp/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -75,7 +75,7 @@
 	 * The fe00 and ff00 offsets of the start32 and start16
 	 * segments are arbitrary, the just have to be mapped
 	 * at reset and the code have to fit.
-	 * The fff0 offset of reset is important, however.
+	 * The fff0 offset of resetvec is important, however.
 	 */
 
 
@@ -86,6 +86,6 @@
 	.start16 : AT (0x387fff00) { *(.start16); }
 
 	. = 0xfff0;
-	.reset : AT (0x387ffff0) { *(.reset); }
-	_i386boot_end = (LOADADDR(.reset) + SIZEOF(.reset) );
+	.resetvec : AT (0x387ffff0) { *(.resetvec); }
+	_i386boot_end = (LOADADDR(.resetvec) + SIZEOF(.resetvec) );
 }
diff -Naur u-boot-2009.01/board/sc520_spunk/u-boot.lds u-boot/board/sc520_spunk/u-boot.lds
--- u-boot-2009.01/board/sc520_spunk/u-boot.lds	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/sc520_spunk/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -76,7 +76,7 @@
 	 * The fe00 and ff00 offsets of the start32 and start16
 	 * segments are arbitrary, the just have to be mapped
 	 * at reset and the code have to fit.
-	 * The fff0 offset of reset is important, however.
+	 * The fff0 offset of resetvec is important, however.
 	 */
 
 
@@ -87,6 +87,6 @@
 	.start16 : AT (0x387fff00) { *(.start16); }
 
 	. = 0xfff0;
-	.reset : AT (0x387ffff0) { *(.reset); }
-	_i386boot_end = (LOADADDR(.reset) + SIZEOF(.reset) );
+	.resetvec : AT (0x387ffff0) { *(.resetvec); }
+	_i386boot_end = (LOADADDR(.resetvec) + SIZEOF(.resetvec) );
 }
diff -Naur u-boot-2009.01/board/sheldon/simpc8313/config.mk u-boot/board/sheldon/simpc8313/config.mk
--- u-boot-2009.01/board/sheldon/simpc8313/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/sheldon/simpc8313/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,13 @@
+ifndef NAND_SPL
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+endif
+
+ifndef TEXT_BASE
+TEXT_BASE = 0x00100000
+endif
+
+ifdef CONFIG_NAND_LP
+PAD_TO = 0xFFF20000
+else
+PAD_TO = 0xFFF04000
+endif
diff -Naur u-boot-2009.01/board/sheldon/simpc8313/Makefile u-boot/board/sheldon/simpc8313/Makefile
--- u-boot-2009.01/board/sheldon/simpc8313/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/sheldon/simpc8313/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,50 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= $(BOARD).o sdram.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/sheldon/simpc8313/sdram.c u-boot/board/sheldon/simpc8313/sdram.c
--- u-boot-2009.01/board/sheldon/simpc8313/sdram.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/sheldon/simpc8313/sdram.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) Freescale Semiconductor, Inc. 2006-2007
+ * Copyright (C) Sheldon Instruments, Inc. 2008
+ *
+ * Author: Ron Madrid <info@sheldoninst.com>
+ *
+ * (C) Copyright 2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <mpc83xx.h>
+#include <spd_sdram.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static long fixed_sdram(void);
+
+#if defined(CONFIG_NAND_SPL)
+void si_wait_i2c(void)
+{
+	volatile immap_t *im = (immap_t *) CONFIG_SYS_IMMR;
+
+	while (!(__raw_readb(&im->i2c[0].sr) & 0x02))
+		;
+
+	__raw_writeb(0x00, &im->i2c[0].sr);
+
+	sync();
+
+	return;
+}
+
+void si_read_i2c(u32 lbyte, int count, u8 *buffer)
+{
+	volatile immap_t *im = (immap_t *) CONFIG_SYS_IMMR;
+	u32 i;
+	u8 chip = 0x50 << 1; /* boot sequencer I2C */
+	u32 ubyte = (lbyte & 0xff00) >> 8;
+
+	lbyte &= 0xff;
+
+	/*
+	 * Set up controller
+	 */
+	__raw_writeb(0x3f, &im->i2c[0].fdr);
+	__raw_writeb(0x00, &im->i2c[0].adr);
+	__raw_writeb(0x00, &im->i2c[0].sr);
+	__raw_writeb(0x00, &im->i2c[0].dr);
+
+	while (__raw_readb(&im->i2c[0].sr) & 0x20)
+		;
+
+	/*
+	 * Writing address to device
+	 */
+	__raw_writeb(0xb0, &im->i2c[0].cr);
+	sync();
+	__raw_writeb(chip, &im->i2c[0].dr);
+	si_wait_i2c();
+
+	__raw_writeb(0xb0, &im->i2c[0].cr);
+	sync();
+	__raw_writeb(ubyte, &im->i2c[0].dr);
+	si_wait_i2c();
+
+	__raw_writeb(lbyte, &im->i2c[0].dr);
+	si_wait_i2c();
+
+	__raw_writeb(0xb4, &im->i2c[0].cr);
+	sync();
+	__raw_writeb(chip + 1, &im->i2c[0].dr);
+	si_wait_i2c();
+
+	__raw_writeb(0xa0, &im->i2c[0].cr);
+	sync();
+
+	/*
+	 * Dummy read
+	 */
+	__raw_readb(&im->i2c[0].dr);
+
+	si_wait_i2c();
+
+	/*
+	 * Read actual data
+	 */
+	for (i = 0; i < count; i++)
+	{
+		if (i == (count - 2))	/* Reached next to last byte, No ACK */
+			__raw_writeb(0xa8, &im->i2c[0].cr);
+		if (i == (count - 1))	/* Reached last byte, STOP */
+			__raw_writeb(0x88, &im->i2c[0].cr);
+
+		/* Read byte of data */
+		buffer[i] = __raw_readb(&im->i2c[0].dr);
+
+		if (i == (count - 1))
+			break;
+		si_wait_i2c();
+	}
+
+	return;
+}
+#endif /* CONFIG_NAND_SPL */
+
+phys_size_t initdram(int board_type)
+{
+	volatile immap_t *im = (immap_t *) CONFIG_SYS_IMMR;
+	volatile fsl_lbus_t *lbc= &im->lbus;
+	u32 msize;
+
+	if ((__raw_readl(&im->sysconf.immrbar) & IMMRBAR_BASE_ADDR) != (u32) im)
+		return -1;
+
+	/* DDR SDRAM - Main SODIMM */
+	__raw_writel(CONFIG_SYS_DDR_BASE & LAWBAR_BAR, &im->sysconf.ddrlaw[0].bar);
+
+	msize = fixed_sdram();
+
+	/* Local Bus setup lbcr and mrtpr */
+	__raw_writel(CONFIG_SYS_LBC_LBCR, &lbc->lbcr);
+	__raw_writel(CONFIG_SYS_LBC_MRTPR, &lbc->mrtpr);
+	sync();
+
+	/* return total bus SDRAM size(bytes)  -- DDR */
+	return (msize * 1024 * 1024);
+}
+
+/*************************************************************************
+ *  fixed sdram init -- reads values from boot sequencer I2C
+ ************************************************************************/
+static long fixed_sdram(void)
+{
+	volatile immap_t *im = (immap_t *) CONFIG_SYS_IMMR;
+	u32 msizelog2, msize = 1;
+#if defined(CONFIG_NAND_SPL)
+	u32 i;
+	const u8 bytecount = 135;
+	u8 buffer[bytecount];
+	u32 addr, data;
+
+	si_read_i2c(0, bytecount, buffer);
+
+	for (i = 18; i < bytecount; i += 7){
+		addr = (u32)buffer[i];
+		addr <<= 8;
+		addr |= (u32)buffer[i + 1];
+		addr <<= 2;
+		data = (u32)buffer[i + 2];
+		data <<= 8;
+		data |= (u32)buffer[i + 3];
+		data <<= 8;
+		data |= (u32)buffer[i + 4];
+		data <<= 8;
+		data |= (u32)buffer[i + 5];
+
+		__raw_writel(data, (u32 *)(CONFIG_SYS_IMMR + addr));
+	}
+
+	sync();
+
+	/* enable DDR controller */
+	__raw_writel((__raw_readl(&im->ddr.sdram_cfg) | SDRAM_CFG_MEM_EN), &im->ddr.sdram_cfg);
+#endif /* (CONFIG_NAND_SPL) */
+
+	msizelog2 = ((__raw_readl(&im->sysconf.ddrlaw[0].ar) & LAWAR_SIZE) + 1);
+	msize <<= (msizelog2 - 20);
+
+	return msize;
+}
diff -Naur u-boot-2009.01/board/sheldon/simpc8313/simpc8313.c u-boot/board/sheldon/simpc8313/simpc8313.c
--- u-boot-2009.01/board/sheldon/simpc8313/simpc8313.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/sheldon/simpc8313/simpc8313.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) Freescale Semiconductor, Inc. 2006-2007
+ * Copyright (C) Sheldon Instruments, Inc. 2008
+ *
+ * Author: Ron Madrid <info@sheldoninst.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <libfdt.h>
+#include <pci.h>
+#include <mpc83xx.h>
+#include <ns16550.h>
+#include <nand.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	puts("Board: Sheldon Instruments SIMPC8313\n");
+	return 0;
+}
+
+#ifndef CONFIG_NAND_SPL
+static struct pci_region pci_regions[] = {
+	{
+		bus_start: CONFIG_SYS_PCI1_MEM_BASE,
+		phys_start: CONFIG_SYS_PCI1_MEM_PHYS,
+		size: CONFIG_SYS_PCI1_MEM_SIZE,
+		flags: PCI_REGION_MEM | PCI_REGION_PREFETCH
+	},
+	{
+		bus_start: CONFIG_SYS_PCI1_MMIO_BASE,
+		phys_start: CONFIG_SYS_PCI1_MMIO_PHYS,
+		size: CONFIG_SYS_PCI1_MMIO_SIZE,
+		flags: PCI_REGION_MEM
+	},
+	{
+		bus_start: CONFIG_SYS_PCI1_IO_BASE,
+		phys_start: CONFIG_SYS_PCI1_IO_PHYS,
+		size: CONFIG_SYS_PCI1_IO_SIZE,
+		flags: PCI_REGION_IO
+	}
+};
+
+void pci_init_board(void)
+{
+	volatile immap_t *immr = (volatile immap_t *)CONFIG_SYS_IMMR;
+	volatile clk83xx_t *clk = (volatile clk83xx_t *)&immr->clk;
+	volatile law83xx_t *pci_law = immr->sysconf.pcilaw;
+	struct pci_region *reg[] = { pci_regions };
+	int warmboot;
+
+	/* Enable all 3 PCI_CLK_OUTPUTs. */
+	clk->occr |= 0xe0000000;
+
+	/*
+	 * Configure PCI Local Access Windows
+	 */
+	pci_law[0].bar = CONFIG_SYS_PCI1_MEM_PHYS & LAWBAR_BAR;
+	pci_law[0].ar = LBLAWAR_EN | LBLAWAR_512MB;
+
+	pci_law[1].bar = CONFIG_SYS_PCI1_IO_PHYS & LAWBAR_BAR;
+	pci_law[1].ar = LBLAWAR_EN | LBLAWAR_1MB;
+
+	warmboot = gd->bd->bi_bootflags & BOOTFLAG_WARM;
+
+	mpc83xx_pci_init(1, reg, warmboot);
+}
+
+/*
+ * Miscellaneous late-boot configurations
+ */
+int misc_init_r(void)
+{
+	int rc = 0;
+
+	return rc;
+}
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	ft_cpu_setup(blob, bd);
+#ifdef CONFIG_PCI
+	ft_pci_setup(blob, bd);
+#endif
+}
+#endif
+#else /* CONFIG_NAND_SPL */
+void board_init_f(ulong bootflag)
+{
+	NS16550_init((NS16550_t)(CONFIG_SYS_IMMR + 0x4500),
+				CONFIG_SYS_NS16550_CLK / 16 / CONFIG_BAUDRATE);
+	puts("NAND boot... ");
+	init_timebase();
+	initdram(0);
+	relocate_code(CONFIG_SYS_NAND_U_BOOT_RELOC + 0x10000, (gd_t *)gd,
+				  CONFIG_SYS_NAND_U_BOOT_RELOC);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	nand_boot();
+}
+
+void putc(char c)
+{
+	if (gd->flags & GD_FLG_SILENT)
+		return;
+
+	if (c == '\n')
+		NS16550_putc((NS16550_t)(CONFIG_SYS_IMMR + 0x4500), '\r');
+
+	NS16550_putc((NS16550_t)(CONFIG_SYS_IMMR + 0x4500), c);
+}
+#endif
diff -Naur u-boot-2009.01/board/siemens/common/fpga.c u-boot/board/siemens/common/fpga.c
--- u-boot-2009.01/board/siemens/common/fpga.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/siemens/common/fpga.c	2009-02-26 14:03:58.000000000 +0100
@@ -286,13 +286,13 @@
     return 0;
 
  failure:
-    printf ("Usage:\n%s\n", cmdtp->usage);
+    cmd_usage(cmdtp);
     return 1;
 }
 
 U_BOOT_CMD(
 	fpga,	4,	1,	do_fpga,
-	"fpga    - access FPGA(s)\n",
+	"access FPGA(s)",
 	"fpga status [name] - print FPGA status\n"
 	"fpga reset  [name] - reset FPGA\n"
 	"fpga load [name] addr - load FPGA configuration data\n"
diff -Naur u-boot-2009.01/board/siemens/pcu_e/pcu_e.c u-boot/board/siemens/pcu_e/pcu_e.c
--- u-boot-2009.01/board/siemens/pcu_e/pcu_e.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/siemens/pcu_e/pcu_e.c	2009-02-26 14:03:58.000000000 +0100
@@ -399,12 +399,12 @@
 	default:
 		break;
 	}
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
 U_BOOT_CMD (puma, 4, 1, do_puma,
-	    "puma    - access PUMA FPGA\n",
+	    "access PUMA FPGA",
 	    "status - print PUMA status\n"
 	    "puma load addr len - load PUMA configuration data\n");
 
diff -Naur u-boot-2009.01/board/smdk2400/config.mk u-boot/board/smdk2400/config.mk
--- u-boot-2009.01/board/smdk2400/config.mk	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2400/config.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-#
-# (C) Copyright 2002
-# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
-#
-# SAMSUNG board with S3C2400X (ARM920T) CPU
-#
-# see http://www.samsung.com/ for more information on SAMSUNG
-#
-
-#
-# SAMSUNG has 1 bank of 32 MB DRAM
-#
-# 0C00'0000 to 0E00'0000
-#
-# Linux-Kernel is expected to be at 0cf0'0000, entry 0cf0'0000
-# optionally with a ramdisk at 0c80'0000
-#
-# we load ourself to 0CF80000 (must be high enough not to be
-# overwritten by the uncompessing Linux kernel)
-#
-# download area is 0C80'0000
-#
-
-
-TEXT_BASE = 0x0CF80000
diff -Naur u-boot-2009.01/board/smdk2400/flash.c u-boot/board/smdk2400/flash.c
--- u-boot-2009.01/board/smdk2400/flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2400/flash.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,490 +0,0 @@
-/*
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Marius Groeger <mgroeger@sysgo.de>
- *
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-/* #define DEBUG */
-
-#include <common.h>
-#include <environment.h>
-
-#define FLASH_BANK_SIZE 0x1000000	/* 2 x   8 MB */
-#define MAIN_SECT_SIZE  0x40000		/* 2 x 128 kB */
-
-flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
-
-
-#define CMD_READ_ARRAY		0x00FF00FF
-#define CMD_IDENTIFY		0x00900090
-#define CMD_ERASE_SETUP		0x00200020
-#define CMD_ERASE_CONFIRM	0x00D000D0
-#define CMD_PROGRAM		0x00400040
-#define CMD_RESUME		0x00D000D0
-#define CMD_SUSPEND		0x00B000B0
-#define CMD_STATUS_READ		0x00700070
-#define CMD_STATUS_RESET	0x00500050
-
-#define BIT_BUSY		0x00800080
-#define BIT_ERASE_SUSPEND	0x00400040
-#define BIT_ERASE_ERROR		0x00200020
-#define BIT_PROGRAM_ERROR	0x00100010
-#define BIT_VPP_RANGE_ERROR	0x00080008
-#define BIT_PROGRAM_SUSPEND	0x00040004
-#define BIT_PROTECT_ERROR	0x00020002
-#define BIT_UNDEFINED		0x00010001
-
-#define BIT_SEQUENCE_ERROR	0x00300030
-#define BIT_TIMEOUT		0x80000000
-
-/*-----------------------------------------------------------------------
- */
-
-ulong flash_init (void)
-{
-	int i, j;
-	ulong size = 0;
-
-	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
-		ulong flashbase = 0;
-
-		flash_info[i].flash_id =
-			(INTEL_MANUFACT     & FLASH_VENDMASK) |
-			(INTEL_ID_28F640J3A & FLASH_TYPEMASK);
-		flash_info[i].size = FLASH_BANK_SIZE;
-		flash_info[i].sector_count = CONFIG_SYS_MAX_FLASH_SECT;
-		memset (flash_info[i].protect, 0, CONFIG_SYS_MAX_FLASH_SECT);
-		if (i == 0)
-			flashbase = CONFIG_SYS_FLASH_BASE;
-		else
-			panic ("configured too many flash banks!\n");
-		for (j = 0; j < flash_info[i].sector_count; j++) {
-			flash_info[i].start[j] = flashbase;
-
-			/* uniform sector size */
-			flashbase += MAIN_SECT_SIZE;
-		}
-		size += flash_info[i].size;
-	}
-
-	/*
-	 * Protect monitor and environment sectors
-	 */
-	flash_protect ( FLAG_PROTECT_SET,
-			CONFIG_SYS_FLASH_BASE,
-			CONFIG_SYS_FLASH_BASE + monitor_flash_len - 1,
-			&flash_info[0]);
-
-	flash_protect ( FLAG_PROTECT_SET,
-			CONFIG_ENV_ADDR,
-			CONFIG_ENV_ADDR + CONFIG_ENV_SIZE - 1, &flash_info[0]);
-
-#ifdef CONFIG_ENV_ADDR_REDUND
-	flash_protect ( FLAG_PROTECT_SET,
-			CONFIG_ENV_ADDR_REDUND,
-			CONFIG_ENV_ADDR_REDUND + CONFIG_ENV_SIZE_REDUND - 1,
-			&flash_info[0]);
-#endif
-
-	return size;
-}
-
-/*-----------------------------------------------------------------------
- */
-void flash_print_info (flash_info_t * info)
-{
-	int i;
-
-	switch (info->flash_id & FLASH_VENDMASK) {
-	case (INTEL_MANUFACT & FLASH_VENDMASK):
-		printf ("Intel: ");
-		break;
-	default:
-		printf ("Unknown Vendor ");
-		break;
-	}
-
-	switch (info->flash_id & FLASH_TYPEMASK) {
-	case (INTEL_ID_28F640J3A & FLASH_TYPEMASK):
-		printf ("2x 28F640J3A (64Mbit)\n");
-		break;
-	default:
-		printf ("Unknown Chip Type\n");
-		goto Done;
-		break;
-	}
-
-	printf ("  Size: %ld MB in %d Sectors\n",
-			info->size >> 20, info->sector_count);
-
-	printf ("  Sector Start Addresses:");
-	for (i = 0; i < info->sector_count; i++) {
-		if ((i % 5) == 0) {
-			printf ("\n   ");
-		}
-		printf (" %08lX%s",
-			info->start[i],
-			info->protect[i] ? " (RO)" : "     ");
-	}
-	printf ("\n");
-
-Done:	;
-}
-
-/*-----------------------------------------------------------------------
- */
-
-int flash_error (ulong code)
-{
-	/* Check bit patterns */
-	/* SR.7=0 is busy, SR.7=1 is ready */
-	/* all other flags indicate error on 1 */
-	/* SR.0 is undefined */
-	/* Timeout is our faked flag */
-
-	/* sequence is described in Intel 290644-005 document */
-
-	/* check Timeout */
-	if (code & BIT_TIMEOUT) {
-		puts ("Timeout\n");
-		return ERR_TIMOUT;
-	}
-
-	/* check Busy, SR.7 */
-	if (~code & BIT_BUSY) {
-		puts ("Busy\n");
-		return ERR_PROG_ERROR;
-	}
-
-	/* check Vpp low, SR.3 */
-	if (code & BIT_VPP_RANGE_ERROR) {
-		puts ("Vpp range error\n");
-		return ERR_PROG_ERROR;
-	}
-
-	/* check Device Protect Error, SR.1 */
-	if (code & BIT_PROTECT_ERROR) {
-		puts ("Device protect error\n");
-		return ERR_PROG_ERROR;
-	}
-
-	/* check Command Seq Error, SR.4 & SR.5 */
-	if (code & BIT_SEQUENCE_ERROR) {
-		puts ("Command seqence error\n");
-		return ERR_PROG_ERROR;
-	}
-
-	/* check Block Erase Error, SR.5 */
-	if (code & BIT_ERASE_ERROR) {
-		puts ("Block erase error\n");
-		return ERR_PROG_ERROR;
-	}
-
-	/* check Program Error, SR.4 */
-	if (code & BIT_PROGRAM_ERROR) {
-		puts ("Program error\n");
-		return ERR_PROG_ERROR;
-	}
-
-	/* check Block Erase Suspended, SR.6 */
-	if (code & BIT_ERASE_SUSPEND) {
-		puts ("Block erase suspended\n");
-		return ERR_PROG_ERROR;
-	}
-
-	/* check Program Suspended, SR.2 */
-	if (code & BIT_PROGRAM_SUSPEND) {
-		puts ("Program suspended\n");
-		return ERR_PROG_ERROR;
-	}
-
-	/* OK, no error */
-	return ERR_OK;
-}
-
-/*-----------------------------------------------------------------------
- */
-
-int flash_erase (flash_info_t * info, int s_first, int s_last)
-{
-	ulong result, result1;
-	int iflag, prot, sect;
-	int rc = ERR_OK;
-
-#ifdef USE_920T_MMU
-	int cflag;
-#endif
-
-	debug ("flash_erase: s_first %d  s_last %d\n", s_first, s_last);
-
-	/* first look for protection bits */
-
-	if (info->flash_id == FLASH_UNKNOWN)
-		return ERR_UNKNOWN_FLASH_TYPE;
-
-	if ((s_first < 0) || (s_first > s_last)) {
-		return ERR_INVAL;
-	}
-
-	if ((info->flash_id & FLASH_VENDMASK) !=
-		(INTEL_MANUFACT & FLASH_VENDMASK)) {
-		return ERR_UNKNOWN_FLASH_VENDOR;
-	}
-
-	prot = 0;
-	for (sect = s_first; sect <= s_last; ++sect) {
-		if (info->protect[sect]) {
-			prot++;
-		}
-	}
-
-	if (prot) {
-		printf ("- Warning: %d protected sectors will not be erased!\n",
-			prot);
-	} else {
-		printf ("\n");
-	}
-
-	/*
-	 * Disable interrupts which might cause a timeout
-	 * here. Remember that our exception vectors are
-	 * at address 0 in the flash, and we don't want a
-	 * (ticker) exception to happen while the flash
-	 * chip is in programming mode.
-	 */
-#ifdef USE_920T_MMU
-	cflag = dcache_status ();
-	dcache_disable ();
-#endif
-	iflag = disable_interrupts ();
-
-	/* Start erase on unprotected sectors */
-	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
-
-		debug ("Erasing sector %2d @ %08lX... ",
-			sect, info->start[sect]);
-
-		/* arm simple, non interrupt dependent timer */
-		reset_timer_masked ();
-
-		if (info->protect[sect] == 0) {	/* not protected */
-			vu_long *addr = (vu_long *) (info->start[sect]);
-			ulong bsR7, bsR7_2, bsR5, bsR5_2;
-
-			/* *addr = CMD_STATUS_RESET; */
-			*addr = CMD_ERASE_SETUP;
-			*addr = CMD_ERASE_CONFIRM;
-
-			/* wait until flash is ready */
-			do {
-				/* check timeout */
-				if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
-					*addr = CMD_STATUS_RESET;
-					result = BIT_TIMEOUT;
-					break;
-				}
-
-				*addr = CMD_STATUS_READ;
-				result = *addr;
-				bsR7 = result & (1 << 7);
-				bsR7_2 = result & (1 << 23);
-			} while (!bsR7 | !bsR7_2);
-
-			*addr = CMD_STATUS_READ;
-			result1 = *addr;
-			bsR5 = result1 & (1 << 5);
-			bsR5_2 = result1 & (1 << 21);
-#ifdef SAMSUNG_FLASH_DEBUG
-			printf ("bsR5 %lx bsR5_2 %lx\n", bsR5, bsR5_2);
-			if (bsR5 != 0 && bsR5_2 != 0)
-				printf ("bsR5 %lx bsR5_2 %lx\n", bsR5, bsR5_2);
-#endif
-
-			*addr = CMD_READ_ARRAY;
-			*addr = CMD_RESUME;
-
-			if ((rc = flash_error (result)) != ERR_OK)
-				goto outahere;
-#if 0
-			printf ("ok.\n");
-		} else {		/* it was protected */
-
-			printf ("protected!\n");
-#endif
-		}
-	}
-
-outahere:
-	/* allow flash to settle - wait 10 ms */
-	udelay_masked (10000);
-
-	if (iflag)
-		enable_interrupts ();
-
-#ifdef USE_920T_MMU
-	if (cflag)
-		dcache_enable ();
-#endif
-	return rc;
-}
-
-/*-----------------------------------------------------------------------
- * Copy memory to flash
- */
-
-static int write_word (flash_info_t * info, ulong dest, ulong data)
-{
-	vu_long *addr = (vu_long *) dest;
-	ulong result;
-	int rc = ERR_OK;
-	int iflag;
-
-#ifdef USE_920T_MMU
-	int cflag;
-#endif
-
-	/*
-	 * Check if Flash is (sufficiently) erased
-	 */
-	result = *addr;
-	if ((result & data) != data)
-		return ERR_NOT_ERASED;
-
-	/*
-	 * Disable interrupts which might cause a timeout
-	 * here. Remember that our exception vectors are
-	 * at address 0 in the flash, and we don't want a
-	 * (ticker) exception to happen while the flash
-	 * chip is in programming mode.
-	 */
-#ifdef USE_920T_MMU
-	cflag = dcache_status ();
-	dcache_disable ();
-#endif
-	iflag = disable_interrupts ();
-
-	/* *addr = CMD_STATUS_RESET; */
-	*addr = CMD_PROGRAM;
-	*addr = data;
-
-	/* arm simple, non interrupt dependent timer */
-	reset_timer_masked ();
-
-	/* wait until flash is ready */
-	do {
-		/* check timeout */
-		if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
-			*addr = CMD_SUSPEND;
-			result = BIT_TIMEOUT;
-			break;
-		}
-
-		*addr = CMD_STATUS_READ;
-		result = *addr;
-	} while (~result & BIT_BUSY);
-
-	/* *addr = CMD_READ_ARRAY; */
-	*addr = CMD_STATUS_READ;
-	result = *addr;
-
-	rc = flash_error (result);
-
-	if (iflag)
-		enable_interrupts ();
-
-#ifdef USE_920T_MMU
-	if (cflag)
-		dcache_enable ();
-#endif
-	*addr = CMD_READ_ARRAY;
-	*addr = CMD_RESUME;
-	return rc;
-}
-
-/*-----------------------------------------------------------------------
- * Copy memory to flash.
- */
-
-int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
-{
-	ulong cp, wp, data;
-	int l;
-	int i, rc;
-
-	wp = (addr & ~3);			/* get lower word aligned address */
-
-	/*
-	 * handle unaligned start bytes
-	 */
-	if ((l = addr - wp) != 0) {
-		data = 0;
-		for (i = 0, cp = wp; i < l; ++i, ++cp) {
-			data = (data >> 8) | (*(uchar *) cp << 24);
-		}
-		for (; i < 4 && cnt > 0; ++i) {
-			data = (data >> 8) | (*src++ << 24);
-			--cnt;
-			++cp;
-		}
-		for (; cnt == 0 && i < 4; ++i, ++cp) {
-			data = (data >> 8) | (*(uchar *) cp << 24);
-		}
-
-		if ((rc = write_word (info, wp, data)) != 0) {
-			return (rc);
-		}
-		wp += 4;
-	}
-
-	/*
-	 * handle word aligned part
-	 */
-	while (cnt >= 4) {
-		data = *((vu_long *) src);
-		if ((rc = write_word (info, wp, data)) != 0) {
-			return (rc);
-		}
-		src += 4;
-		wp += 4;
-		cnt -= 4;
-	}
-
-	if (cnt == 0) {
-		return ERR_OK;
-	}
-
-	/*
-	 * handle unaligned tail bytes
-	 */
-	data = 0;
-	for (i = 0, cp = wp; i < 4 && cnt > 0; ++i, ++cp) {
-		data = (data >> 8) | (*src++ << 24);
-		--cnt;
-	}
-	for (; i < 4; ++i, ++cp) {
-		data = (data >> 8) | (*(uchar *) cp << 24);
-	}
-
-	return write_word (info, wp, data);
-}
diff -Naur u-boot-2009.01/board/smdk2400/lowlevel_init.S u-boot/board/smdk2400/lowlevel_init.S
--- u-boot-2009.01/board/smdk2400/lowlevel_init.S	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2400/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,163 +0,0 @@
-/*
- * Memory Setup stuff - taken from blob memsetup.S
- *
- * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
- *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
- *
- * Modified for the Samsung development board by
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include <config.h>
-#include <version.h>
-
-
-/* some parameters for the board */
-
-/*
- *
- * Taken from linux/arch/arm/boot/compressed/head-s3c2400.S
- *
- * Copyright (C) 2001 Samsung Electronics by chc, 010406
- *
- * S3C2400 specific tweaks.
- *
- */
-
-/* memory controller */
-#define BWSCON 0x14000000
-#define BANKCON3 0x14000010	/* for cs8900, ethernet */
-
-/* Bank0 */
-#define B0_Tacs	0x0	/* 0 clk */
-#define B0_Tcos	0x0	/* 0 clk */
-#define B0_Tacc	0x7	/* 14 clk */
-#define B0_Tcoh	0x0	/* 0 clk */
-#define B0_Tah	0x0	/* 0 clk */
-#define B0_Tacp	0x0
-#define B0_PMC	0x0	/* normal */
-
-/* Bank1 */
-#define B1_Tacs	0x0	/* 0 clk */
-#define B1_Tcos	0x0	/* 0 clk */
-#define B1_Tacc	0x7	/* 14 clk */
-#define B1_Tcoh	0x0	/* 0 clk */
-#define B1_Tah	0x0	/* 0 clk */
-#define B1_Tacp	0x0
-#define B1_PMC	0x0	/* normal */
-
-/* Bank2 */
-#define B2_Tacs	0x0	/* 0 clk */
-#define B2_Tcos	0x0	/* 0 clk */
-#define B2_Tacc	0x7	/* 14 clk */
-#define B2_Tcoh	0x0	/* 0 clk */
-#define B2_Tah	0x0	/* 0 clk */
-#define B2_Tacp	0x0
-#define B2_PMC	0x0	/* normal */
-
-/* Bank3 - setup for the cs8900 */
-#define B3_Tacs	0x0	/* 0 clk */
-#define B3_Tcos	0x3	/* 4 clk */
-#define B3_Tacc	0x7	/* 14 clk */
-#define B3_Tcoh	0x1	/* 1 clk */
-#define B3_Tah	0x0	/* 0 clk */
-#define B3_Tacp	0x3	/* 6 clk */
-#define B3_PMC	0x0	/* normal */
-
-/* Bank4 */
-#define B4_Tacs	0x0	/* 0 clk */
-#define B4_Tcos	0x0	/* 0 clk */
-#define B4_Tacc	0x7	/* 14 clk */
-#define B4_Tcoh	0x0	/* 0 clk */
-#define B4_Tah	0x0	/* 0 clk */
-#define B4_Tacp	0x0
-#define B4_PMC	0x0	/* normal */
-
-/* Bank5 */
-#define B5_Tacs	0x0	/* 0 clk */
-#define B5_Tcos	0x0	/* 0 clk */
-#define B5_Tacc	0x7	/* 14 clk */
-#define B5_Tcoh	0x0	/* 0 clk */
-#define B5_Tah	0x0	/* 0 clk */
-#define B5_Tacp	0x0
-#define B5_PMC	0x0	/* normal */
-
-/* Bank6 */
-#define	B6_MT	0x3	/* SDRAM */
-#define	B6_Trcd	0x1	/* 3clk */
-#define	B6_SCAN	0x1	/* 9 bit */
-
-/* Bank7 */
-#define	B7_MT	0x3	/* SDRAM */
-#define	B7_Trcd	0x1	/* 3clk */
-#define	B7_SCAN	0x1	/* 9 bit */
-
-/* refresh parameter */
-#define REFEN	0x1	/* enable refresh */
-#define TREFMD	0x0	/* CBR(CAS before RAS)/auto refresh */
-#define Trp	0x0	/* 2 clk */
-#define Trc	0x3	/* 7 clk */
-#define Tchr	0x2	/* 3 clk */
-
-#define REFCNT	1113	/* period=15.6 us, HCLK=60Mhz, (2048+1-15.6*66) */
-
-
-_TEXT_BASE:
-	.word	TEXT_BASE
-
-.globl lowlevel_init
-lowlevel_init:
-	/* memory control configuration */
-	/* make r0 relative the current location so that it */
-	/* reads SMRDATA out of FLASH rather than memory ! */
-	ldr     r0, =SMRDATA
-	ldr	r1, _TEXT_BASE
-	sub	r0, r0, r1
-	ldr	r1, =BWSCON	/* Bus Width Status Controller */
-	add     r2, r0, #52
-0:
-	ldr     r3, [r0], #4
-	str     r3, [r1], #4
-	cmp     r2, r0
-	bne     0b
-
-	/* everything is fine now */
-	mov	pc, lr
-
-	.ltorg
-/* the literal pools origin */
-
-SMRDATA:
-	.word	0x2211d114	/* d->Ethernet, BUSWIDTH=32 */
-	.word	((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC)) /* GCS0 */
-	.word	((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC)) /* GCS1 */
-	.word	((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC)) /* GCS2 */
-	.word	((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC)) /* GCS3 */
-	.word	((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC)) /* GCS4 */
-	.word	((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC)) /* GCS5 */
-	.word	((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN)) /* GCS6 */
-	.word	((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN)) /* GCS7 */
-	.word	((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
-	.word	0x10	/* BUSWIDTH=32, SCLK power saving mode, BANKSIZE 32M/32M */
-	.word	0x30	/* MRSR6, CL=3clk */
-	.word	0x30	/* MRSR7 */
diff -Naur u-boot-2009.01/board/smdk2400/Makefile u-boot/board/smdk2400/Makefile
--- u-boot-2009.01/board/smdk2400/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2400/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-#
-# (C) Copyright 2000-2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= $(obj)lib$(BOARD).a
-
-COBJS	:= smdk2400.o flash.o
-SOBJS	:= lowlevel_init.o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
-
-$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
-	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
-
-clean:
-	rm -f $(SOBJS) $(OBJS)
-
-distclean:	clean
-	rm -f $(LIB) core *.bak $(obj).depend
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff -Naur u-boot-2009.01/board/smdk2400/smdk2400.c u-boot/board/smdk2400/smdk2400.c
--- u-boot-2009.01/board/smdk2400/smdk2400.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2400/smdk2400.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-/*
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Marius Groeger <mgroeger@sysgo.de>
- *
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <s3c2400.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#ifdef CONFIG_MODEM_SUPPORT
-static int key_pressed(void);
-int mdm_init (bd_t *);
-extern void disable_putc(void);
-extern void enable_putc(void);
-extern int hwflow_onoff(int);
-extern int do_mdm_init; /* defined in common/main.c */
-#endif /* CONFIG_MODEM_SUPPORT */
-
-/*
- * Miscellaneous platform dependent initialisations
- */
-
-int board_init (void)
-{
-	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
-	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
-
-	/* memory and cpu-speed are setup before relocation */
-	/* change the clock to be 50 MHz 1:1:1 */
-	clk_power->MPLLCON = 0x5c042;
-	clk_power->CLKDIVN = 0;
-	/* set up the I/O ports */
-	gpio->PACON = 0x3ffff;
-	gpio->PBCON = 0xaaaaaaaa;
-	gpio->PBUP = 0xffff;
-	gpio->PECON = 0x0;
-	gpio->PEUP = 0x0;
-#ifdef CONFIG_HWFLOW
-	/*CTS[0] RTS[0] INPUT INPUT TXD[0] INPUT RXD[0] */
-	/*   10,   10,   00,   00,    10,   00,    10 */
-	gpio->PFCON=0xa22;
-	/* Disable pull-up on Rx, Tx, CTS and RTS pins */
-	gpio->PFUP=0x35;
-#else
-	/*INPUT INPUT INPUT INPUT TXD[0] INPUT RXD[0] */
-	/*   00,   00,   00,   00,    10,   00,    10 */
-	gpio->PFCON = 0x22;
-	/* Disable pull-up on Rx and Tx pins */
-	gpio->PFUP = 0x5;
-#endif	/* CONFIG_HWFLOW */
-	gpio->PGCON = 0x0;
-	gpio->PGUP = 0x0;
-	gpio->OPENCR = 0x0;
-
-	/* arch number of SAMSUNG-Board to MACH_TYPE_SMDK2400 */
-	gd->bd->bi_arch_number = MACH_TYPE_SMDK2400;
-
-	/* adress of boot parameters */
-	gd->bd->bi_boot_params = 0x0C000100;
-
-#ifdef CONFIG_MODEM_SUPPORT
-	if (key_pressed()) {
-		disable_putc();	/* modem doesn't understand banner etc */
-		do_mdm_init = 1;
-	}
-#endif	/* CONFIG_MODEM_SUPPORT */
-
-	return 0;
-}
-
-int dram_init (void)
-{
-	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
-	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
-
-	return 0;
-}
-
-#ifdef CONFIG_MODEM_SUPPORT
-static int key_pressed(void)
-{
-	int rc;
-	if (1) {	/* check for button push here, now just return 1 */
-		rc = 1;
-	}
-
-	return rc;
-}
-#endif	/* CONFIG_MODEM_SUPPORT */
diff -Naur u-boot-2009.01/board/smdk2400/u-boot.lds u-boot/board/smdk2400/u-boot.lds
--- u-boot-2009.01/board/smdk2400/u-boot.lds	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2400/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-/*
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
-/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
-OUTPUT_ARCH(arm)
-ENTRY(_start)
-SECTIONS
-{
-	. = 0x00000000;
-
-	. = ALIGN(4);
-	.text      :
-	{
-	  cpu/arm920t/start.o	(.text)
-	  *(.text)
-	}
-
-	. = ALIGN(4);
-	.rodata : { *(.rodata) }
-
-	. = ALIGN(4);
-	.data : { *(.data) }
-
-	. = ALIGN(4);
-	.got : { *(.got) }
-
-	. = .;
-	__u_boot_cmd_start = .;
-	.u_boot_cmd : { *(.u_boot_cmd) }
-	__u_boot_cmd_end = .;
-
-	. = ALIGN(4);
-	__bss_start = .;
-	.bss (NOLOAD) : { *(.bss) . = ALIGN(4); }
-	_end = .;
-}
diff -Naur u-boot-2009.01/board/smdk2410/config.mk u-boot/board/smdk2410/config.mk
--- u-boot-2009.01/board/smdk2410/config.mk	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2410/config.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-#
-# (C) Copyright 2002
-# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
-# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
-#
-# SAMSUNG SMDK2410 board with S3C2410X (ARM920T) cpu
-#
-# see http://www.samsung.com/ for more information on SAMSUNG
-#
-
-#
-# SMDK2410 has 1 bank of 64 MB DRAM
-#
-# 3000'0000 to 3400'0000
-#
-# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
-# optionally with a ramdisk at 3080'0000
-#
-# we load ourself to 33F8'0000
-#
-# download area is 3300'0000
-#
-
-
-TEXT_BASE = 0x33F80000
diff -Naur u-boot-2009.01/board/smdk2410/flash.c u-boot/board/smdk2410/flash.c
--- u-boot-2009.01/board/smdk2410/flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2410/flash.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,433 +0,0 @@
-/*
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Alex Zuepke <azu@sysgo.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-
-ulong myflush (void);
-
-
-#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
-#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
-
-flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
-
-
-#define CMD_READ_ARRAY		0x000000F0
-#define CMD_UNLOCK1		0x000000AA
-#define CMD_UNLOCK2		0x00000055
-#define CMD_ERASE_SETUP		0x00000080
-#define CMD_ERASE_CONFIRM	0x00000030
-#define CMD_PROGRAM		0x000000A0
-#define CMD_UNLOCK_BYPASS	0x00000020
-
-#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CONFIG_SYS_FLASH_BASE + (0x00000555 << 1)))
-#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CONFIG_SYS_FLASH_BASE + (0x000002AA << 1)))
-
-#define BIT_ERASE_DONE		0x00000080
-#define BIT_RDY_MASK		0x00000080
-#define BIT_PROGRAM_ERROR	0x00000020
-#define BIT_TIMEOUT		0x80000000	/* our flag */
-
-#define READY 1
-#define ERR   2
-#define TMO   4
-
-/*-----------------------------------------------------------------------
- */
-
-ulong flash_init (void)
-{
-	int i, j;
-	ulong size = 0;
-
-	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
-		ulong flashbase = 0;
-
-		flash_info[i].flash_id =
-#if defined(CONFIG_AMD_LV400)
-			(AMD_MANUFACT & FLASH_VENDMASK) |
-			(AMD_ID_LV400B & FLASH_TYPEMASK);
-#elif defined(CONFIG_AMD_LV800)
-			(AMD_MANUFACT & FLASH_VENDMASK) |
-			(AMD_ID_LV800B & FLASH_TYPEMASK);
-#else
-#error "Unknown flash configured"
-#endif
-			flash_info[i].size = FLASH_BANK_SIZE;
-		flash_info[i].sector_count = CONFIG_SYS_MAX_FLASH_SECT;
-		memset (flash_info[i].protect, 0, CONFIG_SYS_MAX_FLASH_SECT);
-		if (i == 0)
-			flashbase = PHYS_FLASH_1;
-		else
-			panic ("configured too many flash banks!\n");
-		for (j = 0; j < flash_info[i].sector_count; j++) {
-			if (j <= 3) {
-				/* 1st one is 16 KB */
-				if (j == 0) {
-					flash_info[i].start[j] =
-						flashbase + 0;
-				}
-
-				/* 2nd and 3rd are both 8 KB */
-				if ((j == 1) || (j == 2)) {
-					flash_info[i].start[j] =
-						flashbase + 0x4000 + (j -
-								      1) *
-						0x2000;
-				}
-
-				/* 4th 32 KB */
-				if (j == 3) {
-					flash_info[i].start[j] =
-						flashbase + 0x8000;
-				}
-			} else {
-				flash_info[i].start[j] =
-					flashbase + (j - 3) * MAIN_SECT_SIZE;
-			}
-		}
-		size += flash_info[i].size;
-	}
-
-	flash_protect (FLAG_PROTECT_SET,
-		       CONFIG_SYS_FLASH_BASE,
-		       CONFIG_SYS_FLASH_BASE + monitor_flash_len - 1,
-		       &flash_info[0]);
-
-	flash_protect (FLAG_PROTECT_SET,
-		       CONFIG_ENV_ADDR,
-		       CONFIG_ENV_ADDR + CONFIG_ENV_SIZE - 1, &flash_info[0]);
-
-	return size;
-}
-
-/*-----------------------------------------------------------------------
- */
-void flash_print_info (flash_info_t * info)
-{
-	int i;
-
-	switch (info->flash_id & FLASH_VENDMASK) {
-	case (AMD_MANUFACT & FLASH_VENDMASK):
-		printf ("AMD: ");
-		break;
-	default:
-		printf ("Unknown Vendor ");
-		break;
-	}
-
-	switch (info->flash_id & FLASH_TYPEMASK) {
-	case (AMD_ID_LV400B & FLASH_TYPEMASK):
-		printf ("1x Amd29LV400BB (4Mbit)\n");
-		break;
-	case (AMD_ID_LV800B & FLASH_TYPEMASK):
-		printf ("1x Amd29LV800BB (8Mbit)\n");
-		break;
-	default:
-		printf ("Unknown Chip Type\n");
-		goto Done;
-		break;
-	}
-
-	printf ("  Size: %ld MB in %d Sectors\n",
-		info->size >> 20, info->sector_count);
-
-	printf ("  Sector Start Addresses:");
-	for (i = 0; i < info->sector_count; i++) {
-		if ((i % 5) == 0) {
-			printf ("\n   ");
-		}
-		printf (" %08lX%s", info->start[i],
-			info->protect[i] ? " (RO)" : "     ");
-	}
-	printf ("\n");
-
-      Done:;
-}
-
-/*-----------------------------------------------------------------------
- */
-
-int flash_erase (flash_info_t * info, int s_first, int s_last)
-{
-	ushort result;
-	int iflag, cflag, prot, sect;
-	int rc = ERR_OK;
-	int chip;
-
-	/* first look for protection bits */
-
-	if (info->flash_id == FLASH_UNKNOWN)
-		return ERR_UNKNOWN_FLASH_TYPE;
-
-	if ((s_first < 0) || (s_first > s_last)) {
-		return ERR_INVAL;
-	}
-
-	if ((info->flash_id & FLASH_VENDMASK) !=
-	    (AMD_MANUFACT & FLASH_VENDMASK)) {
-		return ERR_UNKNOWN_FLASH_VENDOR;
-	}
-
-	prot = 0;
-	for (sect = s_first; sect <= s_last; ++sect) {
-		if (info->protect[sect]) {
-			prot++;
-		}
-	}
-	if (prot)
-		return ERR_PROTECTED;
-
-	/*
-	 * Disable interrupts which might cause a timeout
-	 * here. Remember that our exception vectors are
-	 * at address 0 in the flash, and we don't want a
-	 * (ticker) exception to happen while the flash
-	 * chip is in programming mode.
-	 */
-	cflag = icache_status ();
-	icache_disable ();
-	iflag = disable_interrupts ();
-
-	/* Start erase on unprotected sectors */
-	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
-		printf ("Erasing sector %2d ... ", sect);
-
-		/* arm simple, non interrupt dependent timer */
-		reset_timer_masked ();
-
-		if (info->protect[sect] == 0) {	/* not protected */
-			vu_short *addr = (vu_short *) (info->start[sect]);
-
-			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
-			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
-			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
-
-			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
-			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
-			*addr = CMD_ERASE_CONFIRM;
-
-			/* wait until flash is ready */
-			chip = 0;
-
-			do {
-				result = *addr;
-
-				/* check timeout */
-				if (get_timer_masked () >
-				    CONFIG_SYS_FLASH_ERASE_TOUT) {
-					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
-					chip = TMO;
-					break;
-				}
-
-				if (!chip
-				    && (result & 0xFFFF) & BIT_ERASE_DONE)
-					chip = READY;
-
-				if (!chip
-				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
-					chip = ERR;
-
-			} while (!chip);
-
-			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
-
-			if (chip == ERR) {
-				rc = ERR_PROG_ERROR;
-				goto outahere;
-			}
-			if (chip == TMO) {
-				rc = ERR_TIMOUT;
-				goto outahere;
-			}
-
-			printf ("ok.\n");
-		} else {	/* it was protected */
-
-			printf ("protected!\n");
-		}
-	}
-
-	if (ctrlc ())
-		printf ("User Interrupt!\n");
-
-      outahere:
-	/* allow flash to settle - wait 10 ms */
-	udelay_masked (10000);
-
-	if (iflag)
-		enable_interrupts ();
-
-	if (cflag)
-		icache_enable ();
-
-	return rc;
-}
-
-/*-----------------------------------------------------------------------
- * Copy memory to flash
- */
-
-static int write_hword (flash_info_t * info, ulong dest, ushort data)
-{
-	vu_short *addr = (vu_short *) dest;
-	ushort result;
-	int rc = ERR_OK;
-	int cflag, iflag;
-	int chip;
-
-	/*
-	 * Check if Flash is (sufficiently) erased
-	 */
-	result = *addr;
-	if ((result & data) != data)
-		return ERR_NOT_ERASED;
-
-
-	/*
-	 * Disable interrupts which might cause a timeout
-	 * here. Remember that our exception vectors are
-	 * at address 0 in the flash, and we don't want a
-	 * (ticker) exception to happen while the flash
-	 * chip is in programming mode.
-	 */
-	cflag = icache_status ();
-	icache_disable ();
-	iflag = disable_interrupts ();
-
-	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
-	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
-	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
-	*addr = CMD_PROGRAM;
-	*addr = data;
-
-	/* arm simple, non interrupt dependent timer */
-	reset_timer_masked ();
-
-	/* wait until flash is ready */
-	chip = 0;
-	do {
-		result = *addr;
-
-		/* check timeout */
-		if (get_timer_masked () > CONFIG_SYS_FLASH_ERASE_TOUT) {
-			chip = ERR | TMO;
-			break;
-		}
-		if (!chip && ((result & 0x80) == (data & 0x80)))
-			chip = READY;
-
-		if (!chip && ((result & 0xFFFF) & BIT_PROGRAM_ERROR)) {
-			result = *addr;
-
-			if ((result & 0x80) == (data & 0x80))
-				chip = READY;
-			else
-				chip = ERR;
-		}
-
-	} while (!chip);
-
-	*addr = CMD_READ_ARRAY;
-
-	if (chip == ERR || *addr != data)
-		rc = ERR_PROG_ERROR;
-
-	if (iflag)
-		enable_interrupts ();
-
-	if (cflag)
-		icache_enable ();
-
-	return rc;
-}
-
-/*-----------------------------------------------------------------------
- * Copy memory to flash.
- */
-
-int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
-{
-	ulong cp, wp;
-	int l;
-	int i, rc;
-	ushort data;
-
-	wp = (addr & ~1);	/* get lower word aligned address */
-
-	/*
-	 * handle unaligned start bytes
-	 */
-	if ((l = addr - wp) != 0) {
-		data = 0;
-		for (i = 0, cp = wp; i < l; ++i, ++cp) {
-			data = (data >> 8) | (*(uchar *) cp << 8);
-		}
-		for (; i < 2 && cnt > 0; ++i) {
-			data = (data >> 8) | (*src++ << 8);
-			--cnt;
-			++cp;
-		}
-		for (; cnt == 0 && i < 2; ++i, ++cp) {
-			data = (data >> 8) | (*(uchar *) cp << 8);
-		}
-
-		if ((rc = write_hword (info, wp, data)) != 0) {
-			return (rc);
-		}
-		wp += 2;
-	}
-
-	/*
-	 * handle word aligned part
-	 */
-	while (cnt >= 2) {
-		data = *((vu_short *) src);
-		if ((rc = write_hword (info, wp, data)) != 0) {
-			return (rc);
-		}
-		src += 2;
-		wp += 2;
-		cnt -= 2;
-	}
-
-	if (cnt == 0) {
-		return ERR_OK;
-	}
-
-	/*
-	 * handle unaligned tail bytes
-	 */
-	data = 0;
-	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
-		data = (data >> 8) | (*src++ << 8);
-		--cnt;
-	}
-	for (; i < 2; ++i, ++cp) {
-		data = (data >> 8) | (*(uchar *) cp << 8);
-	}
-
-	return write_hword (info, wp, data);
-}
diff -Naur u-boot-2009.01/board/smdk2410/lowlevel_init.S u-boot/board/smdk2410/lowlevel_init.S
--- u-boot-2009.01/board/smdk2410/lowlevel_init.S	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2410/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,167 +0,0 @@
-/*
- * Memory Setup stuff - taken from blob memsetup.S
- *
- * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
- *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
- *
- * Modified for the Samsung SMDK2410 by
- * (C) Copyright 2002
- * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include <config.h>
-#include <version.h>
-
-
-/* some parameters for the board */
-
-/*
- *
- * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
- *
- * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
- *
- */
-
-#define BWSCON	0x48000000
-
-/* BWSCON */
-#define DW8			(0x0)
-#define DW16			(0x1)
-#define DW32			(0x2)
-#define WAIT			(0x1<<2)
-#define UBLB			(0x1<<3)
-
-#define B1_BWSCON		(DW32)
-#define B2_BWSCON		(DW16)
-#define B3_BWSCON		(DW16 + WAIT + UBLB)
-#define B4_BWSCON		(DW16)
-#define B5_BWSCON		(DW16)
-#define B6_BWSCON		(DW32)
-#define B7_BWSCON		(DW32)
-
-/* BANK0CON */
-#define B0_Tacs			0x0	/*  0clk */
-#define B0_Tcos			0x0	/*  0clk */
-#define B0_Tacc			0x7	/* 14clk */
-#define B0_Tcoh			0x0	/*  0clk */
-#define B0_Tah			0x0	/*  0clk */
-#define B0_Tacp			0x0
-#define B0_PMC			0x0	/* normal */
-
-/* BANK1CON */
-#define B1_Tacs			0x0	/*  0clk */
-#define B1_Tcos			0x0	/*  0clk */
-#define B1_Tacc			0x7	/* 14clk */
-#define B1_Tcoh			0x0	/*  0clk */
-#define B1_Tah			0x0	/*  0clk */
-#define B1_Tacp			0x0
-#define B1_PMC			0x0
-
-#define B2_Tacs			0x0
-#define B2_Tcos			0x0
-#define B2_Tacc			0x7
-#define B2_Tcoh			0x0
-#define B2_Tah			0x0
-#define B2_Tacp			0x0
-#define B2_PMC			0x0
-
-#define B3_Tacs			0x0	/*  0clk */
-#define B3_Tcos			0x3	/*  4clk */
-#define B3_Tacc			0x7	/* 14clk */
-#define B3_Tcoh			0x1	/*  1clk */
-#define B3_Tah			0x0	/*  0clk */
-#define B3_Tacp			0x3     /*  6clk */
-#define B3_PMC			0x0	/* normal */
-
-#define B4_Tacs			0x0	/*  0clk */
-#define B4_Tcos			0x0	/*  0clk */
-#define B4_Tacc			0x7	/* 14clk */
-#define B4_Tcoh			0x0	/*  0clk */
-#define B4_Tah			0x0	/*  0clk */
-#define B4_Tacp			0x0
-#define B4_PMC			0x0	/* normal */
-
-#define B5_Tacs			0x0	/*  0clk */
-#define B5_Tcos			0x0	/*  0clk */
-#define B5_Tacc			0x7	/* 14clk */
-#define B5_Tcoh			0x0	/*  0clk */
-#define B5_Tah			0x0	/*  0clk */
-#define B5_Tacp			0x0
-#define B5_PMC			0x0	/* normal */
-
-#define B6_MT			0x3	/* SDRAM */
-#define B6_Trcd			0x1
-#define B6_SCAN			0x1	/* 9bit */
-
-#define B7_MT			0x3	/* SDRAM */
-#define B7_Trcd			0x1	/* 3clk */
-#define B7_SCAN			0x1	/* 9bit */
-
-/* REFRESH parameter */
-#define REFEN			0x1	/* Refresh enable */
-#define TREFMD			0x0	/* CBR(CAS before RAS)/Auto refresh */
-#define Trp			0x0	/* 2clk */
-#define Trc			0x3	/* 7clk */
-#define Tchr			0x2	/* 3clk */
-#define REFCNT			1113	/* period=15.6us, HCLK=60Mhz, (2048+1-15.6*60) */
-/**************************************/
-
-_TEXT_BASE:
-	.word	TEXT_BASE
-
-.globl lowlevel_init
-lowlevel_init:
-	/* memory control configuration */
-	/* make r0 relative the current location so that it */
-	/* reads SMRDATA out of FLASH rather than memory ! */
-	ldr     r0, =SMRDATA
-	ldr	r1, _TEXT_BASE
-	sub	r0, r0, r1
-	ldr	r1, =BWSCON	/* Bus Width Status Controller */
-	add     r2, r0, #13*4
-0:
-	ldr     r3, [r0], #4
-	str     r3, [r1], #4
-	cmp     r2, r0
-	bne     0b
-
-	/* everything is fine now */
-	mov	pc, lr
-
-	.ltorg
-/* the literal pools origin */
-
-SMRDATA:
-    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28))
-    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
-    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
-    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
-    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
-    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
-    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
-    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
-    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
-    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
-    .word 0x32
-    .word 0x30
-    .word 0x30
diff -Naur u-boot-2009.01/board/smdk2410/Makefile u-boot/board/smdk2410/Makefile
--- u-boot-2009.01/board/smdk2410/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2410/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-#
-# (C) Copyright 2000-2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= $(obj)lib$(BOARD).a
-
-COBJS	:= smdk2410.o flash.o
-SOBJS	:= lowlevel_init.o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
-
-$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
-	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
-
-clean:
-	rm -f $(SOBJS) $(OBJS)
-
-distclean:	clean
-	rm -f $(LIB) core *.bak $(obj).depend
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff -Naur u-boot-2009.01/board/smdk2410/smdk2410.c u-boot/board/smdk2410/smdk2410.c
--- u-boot-2009.01/board/smdk2410/smdk2410.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2410/smdk2410.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,123 +0,0 @@
-/*
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Marius Groeger <mgroeger@sysgo.de>
- *
- * (C) Copyright 2002
- * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <s3c2410.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#define FCLK_SPEED 1
-
-#if FCLK_SPEED==0		/* Fout = 203MHz, Fin = 12MHz for Audio */
-#define M_MDIV	0xC3
-#define M_PDIV	0x4
-#define M_SDIV	0x1
-#elif FCLK_SPEED==1		/* Fout = 202.8MHz */
-#define M_MDIV	0xA1
-#define M_PDIV	0x3
-#define M_SDIV	0x1
-#endif
-
-#define USB_CLOCK 1
-
-#if USB_CLOCK==0
-#define U_M_MDIV	0xA1
-#define U_M_PDIV	0x3
-#define U_M_SDIV	0x1
-#elif USB_CLOCK==1
-#define U_M_MDIV	0x48
-#define U_M_PDIV	0x3
-#define U_M_SDIV	0x2
-#endif
-
-static inline void delay (unsigned long loops)
-{
-	__asm__ volatile ("1:\n"
-	  "subs %0, %1, #1\n"
-	  "bne 1b":"=r" (loops):"0" (loops));
-}
-
-/*
- * Miscellaneous platform dependent initialisations
- */
-
-int board_init (void)
-{
-	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
-	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
-
-	/* to reduce PLL lock time, adjust the LOCKTIME register */
-	clk_power->LOCKTIME = 0xFFFFFF;
-
-	/* configure MPLL */
-	clk_power->MPLLCON = ((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV);
-
-	/* some delay between MPLL and UPLL */
-	delay (4000);
-
-	/* configure UPLL */
-	clk_power->UPLLCON = ((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV);
-
-	/* some delay between MPLL and UPLL */
-	delay (8000);
-
-	/* set up the I/O ports */
-	gpio->GPACON = 0x007FFFFF;
-	gpio->GPBCON = 0x00044555;
-	gpio->GPBUP = 0x000007FF;
-	gpio->GPCCON = 0xAAAAAAAA;
-	gpio->GPCUP = 0x0000FFFF;
-	gpio->GPDCON = 0xAAAAAAAA;
-	gpio->GPDUP = 0x0000FFFF;
-	gpio->GPECON = 0xAAAAAAAA;
-	gpio->GPEUP = 0x0000FFFF;
-	gpio->GPFCON = 0x000055AA;
-	gpio->GPFUP = 0x000000FF;
-	gpio->GPGCON = 0xFF95FFBA;
-	gpio->GPGUP = 0x0000FFFF;
-	gpio->GPHCON = 0x002AFAAA;
-	gpio->GPHUP = 0x000007FF;
-
-	/* arch number of SMDK2410-Board */
-	gd->bd->bi_arch_number = MACH_TYPE_SMDK2410;
-
-	/* adress of boot parameters */
-	gd->bd->bi_boot_params = 0x30000100;
-
-	icache_enable();
-	dcache_enable();
-
-	return 0;
-}
-
-int dram_init (void)
-{
-	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
-	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
-
-	return 0;
-}
diff -Naur u-boot-2009.01/board/smdk2410/u-boot.lds u-boot/board/smdk2410/u-boot.lds
--- u-boot-2009.01/board/smdk2410/u-boot.lds	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/smdk2410/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-/*
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
-/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
-OUTPUT_ARCH(arm)
-ENTRY(_start)
-SECTIONS
-{
-	. = 0x00000000;
-
-	. = ALIGN(4);
-	.text      :
-	{
-	  cpu/arm920t/start.o	(.text)
-	  *(.text)
-	}
-
-	. = ALIGN(4);
-	.rodata : { *(.rodata) }
-
-	. = ALIGN(4);
-	.data : { *(.data) }
-
-	. = ALIGN(4);
-	.got : { *(.got) }
-
-	. = .;
-	__u_boot_cmd_start = .;
-	.u_boot_cmd : { *(.u_boot_cmd) }
-	__u_boot_cmd_end = .;
-
-	. = ALIGN(4);
-	__bss_start = .;
-	.bss (NOLOAD) : { *(.bss) . = ALIGN(4); }
-	_end = .;
-}
diff -Naur u-boot-2009.01/board/ssv/common/cmd_sled.c u-boot/board/ssv/common/cmd_sled.c
--- u-boot-2009.01/board/ssv/common/cmd_sled.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/ssv/common/cmd_sled.c	2009-02-26 14:03:58.000000000 +0100
@@ -133,7 +133,7 @@
 	default:
 		break;
 	}
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
@@ -156,7 +156,7 @@
 #endif
 
 U_BOOT_CMD (sled, 3, 0, do_sled,
-	    "sled    - check and set status led\n",
+	    "check and set status led",
 	    "sled [name [state]]\n" __NAME_STR "    - state: on|off|blink\n");
 #endif
 #endif	/* CONFIG_STATUS_LED */
diff -Naur u-boot-2009.01/board/ssv/common/wd_pio.c u-boot/board/ssv/common/wd_pio.c
--- u-boot-2009.01/board/ssv/common/wd_pio.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/ssv/common/wd_pio.c	2009-02-26 14:03:58.000000000 +0100
@@ -145,13 +145,13 @@
 	default:
 		break;
 	}
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
 U_BOOT_CMD(
 	wd,	2,	1,	do_wd,
-	"wd      - check and set watchdog\n",
+	"check and set watchdog",
 	"on   - switch watchDog on\n"
 	"wd off  - switch watchdog off\n"
 	"wd      - print current status\n"
diff -Naur u-boot-2009.01/board/st/nmdk8815/config.mk u-boot/board/st/nmdk8815/config.mk
--- u-boot-2009.01/board/st/nmdk8815/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/st/nmdk8815/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,26 @@
+# (C) Copyright 2007
+# STMicroelectronics, <www.st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# image should be loaded at 0x01000000
+#
+
+TEXT_BASE = 0x03F80000
diff -Naur u-boot-2009.01/board/st/nmdk8815/Makefile u-boot/board/st/nmdk8815/Makefile
--- u-boot-2009.01/board/st/nmdk8815/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/st/nmdk8815/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,55 @@
+#
+# (C) Copyright 2000-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2004
+# ARM Ltd.
+# Philippe Robin, <philippe.robin@arm.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= nmdk8815.o
+SOBJS	:= platform.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB): $(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/st/nmdk8815/nmdk8815.c u-boot/board/st/nmdk8815/nmdk8815.c
--- u-boot-2009.01/board/st/nmdk8815/nmdk8815.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/st/nmdk8815/nmdk8815.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+ * (C) Copyright 2005
+ * STMicrolelctronics, <www.st.com>
+ *
+ * (C) Copyright 2004
+ * ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+void show_boot_progress(int progress)
+{
+	printf("%i\n", progress);
+}
+#endif
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+int board_init(void)
+{
+	gd->bd->bi_arch_number = MACH_TYPE_NOMADIK;
+	gd->bd->bi_boot_params = 0x00000100;
+	writel(0xC37800F0, NOMADIK_GPIO1_BASE + 0x20);
+	writel(0x00000000, NOMADIK_GPIO1_BASE + 0x24);
+	writel(0x00000000, NOMADIK_GPIO1_BASE + 0x28);
+	writel(readl(NOMADIK_SRC_BASE) | 0x8000, NOMADIK_SRC_BASE);
+
+	/* Set up SMCS1 for Ethernet: sram-like, enabled, timing values */
+	writel(0x0000305b, REG_FSMC_BCR1);
+	writel(0x00033f33, REG_FSMC_BTR1);
+
+	icache_enable();
+	return 0;
+}
+
+int misc_init_r(void)
+{
+	setenv("verify", "n");
+	return 0;
+}
+
+int dram_init(void)
+{
+	/* set dram bank start addr and size */
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+	gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+	return 0;
+}
diff -Naur u-boot-2009.01/board/st/nmdk8815/platform.S u-boot/board/st/nmdk8815/platform.S
--- u-boot-2009.01/board/st/nmdk8815/platform.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/st/nmdk8815/platform.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,340 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2005
+ * STMicrolelctronics, <www.st.com>
+ *
+ * (C) Copyright 2004, ARM Ltd.
+ * Philippe Robin, <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+.globl lowlevel_init
+lowlevel_init:
+	/* Jump to the flash address */
+	ldr r0, =CFG_ONENAND_BASE
+
+	/*
+	 * Make it independent whether we boot from 0x0 or 0x30000000.
+	 * Non-portable: it relies on the knowledge that ip has to be updated
+	 */
+	orr ip, ip, r0	/* adjust return address of cpu_init_crit */
+	orr lr, lr, r0	/* adjust return address */
+	orr pc, pc, r0	/* jump to the normal address */
+	nop
+
+	/* Initialize PLL, Remap clear, FSMC, MPMC here! */
+	/* What about GPIO, CLCD and UART */
+
+	/* PLL Initialization */
+	/* Prog the PLL1 @ 266 MHz ==> SDRAM Clock = 100.8 MHz */
+	ldr r0, =NOMADIK_SRC_BASE
+
+	ldr r1, =0x2B013502
+
+	str r1, [r0, #0x14]
+
+	/* Used to set all the timers clock to 2.4MHZ */
+	ldr r1, =0x2AAAA004
+	str r1, [r0]
+
+	ldr r1, =0x10000000
+	str r1, [r0, #0x10]
+
+	/* FSMC setup ---- */
+	ldr r0, =NOMADIK_FSMC_BASE
+
+	ldr r1, =0x10DB		/* For 16-bit NOR flash */
+	str r1, [r0, #0x08]
+
+	ldr r1, =0x03333333	/* For 16-bit NOR flash */
+	str r1, [r0, #0xc]
+
+	/* oneNAND setting */
+	ldr r1, =0x0000105B	/* BCR0 Prog control register */
+	str r1, [r0]
+
+	ldr r1, =0x0A200551	/* BTR0 Prog timing register */
+	str r1, [r0, #0x04]
+
+	/* preload the instructions into icache */
+	add r0, pc, #0x1F
+	bic r0, r0, #0x1F
+	mcr p15, 0, r0, c7, c13, 1
+	add r0, r0, #0x20
+	mcr p15, 0, r0, c7, c13, 1
+
+	/* Now Clear Remap */
+	ldr r0, =NOMADIK_SRC_BASE
+
+	ldr r1, =0x2004
+	str r1, [r0]
+
+	ldr r1, =0x10000000
+	str r1, [r0, #0x10]
+
+	ldr r0, =0x101E9000
+	ldr r1, =0x2004
+	str r1, [r0]
+
+	ldr r0, =NOMADIK_SRC_BASE
+	ldr r1, =0x2104
+	str r1, [r0]
+
+	/* FSMC setup -- */
+	mov r0, #(NOMADIK_FSMC_BASE & 0x10000000)
+	orr r0, r0, #(NOMADIK_FSMC_BASE & 0x0FFFFFFF)
+
+	ldr r1, =0x10DB		/* For 16-bit NOR flash */
+	str r1, [r0, #0x8]
+
+	ldr r1, =0x03333333	/* For 16-bit NOR flash */
+	str r1, [r0, #0xc]
+
+	/* MPMC Setup */
+	ldr r0, =NOMADIK_MPMC_BASE
+
+	ldr r1, =0xF00003
+	str r1, [r0]		/* Enable the MPMC and the DLL */
+
+	ldr r1, =0x183
+	str r1, [r0, #0x20]
+
+	ldr r2, =NOMADIK_PMU_BASE
+
+	ldr r1, =0x1111
+	str r1, [r2]
+
+	ldr r1, =0x1111		/* Prog the, mand delay strategy */
+	str r1, [r0, #0x28]
+
+	ldr r1, =0x103		/* NOP ,mand */
+	str r1, [r0, #0x20]
+
+	/* FIXME -- Wait required here */
+
+	ldr r1, =0x103		/* PALL ,mand*/
+	str r1, [r0, #0x20]
+
+	ldr r1, =0x1
+	str r1, [r0, #0x24]	/* To do at least two auto-refresh */
+
+	/* FIXME -- Wait required here */
+
+	/* Auto-refresh period = 7.8us @ SDRAM Clock = 100.8 MHz */
+	ldr r1, =0x31
+	str r1, [r0, #0x24]
+
+	/* Prog Little Endian, Not defined in 8800 board */
+	ldr r1, =0x0
+	str r1,	[r0, #0x8]
+
+
+	ldr r1, =0x2
+	str r1, [r0, #0x30]		/* Prog tRP timing */
+
+	ldr r1, =0x4			/* Change for 8815 */
+	str r1, [r0, #0x34]		/* Prog tRAS timing */
+
+	ldr r1, =0xB
+	str r1, [r0, #0x38]		/* Prog tSREX timing */
+
+
+	ldr r1, =0x1
+	str r1, [r0, #0x44]		/* Prog tWR timing */
+
+	ldr r1, =0x8
+	str r1, [r0, #0x48]		/* Prog tRC timing */
+
+	ldr r1, =0xA
+	str r1, [r0, #0x4C]		/* Prog tRFC timing */
+
+	ldr r1, =0xB
+	str r1, [r0, #0x50]		/* Prog tXSR timing */
+
+	ldr r1, =0x1
+	str r1, [r0, #0x54]		/* Prog tRRD timing */
+
+	ldr r1, =0x1
+	str r1, [r0, #0x58]		/* Prog tMRD timing */
+
+	ldr r1, =0x1
+	str r1, [r0, #0x5C]		/* Prog tCDLR timing */
+
+	/* DDR-SDRAM MEMORY IS ON BANK0 8815 */
+	ldr r1, =0x304			/* Prog RAS and CAS for CS 0 */
+	str r1, [r0, #0x104]
+
+	/* SDR-SDRAM MEMORY IS ON BANK1 8815 */
+	ldr r1, =0x304			/* Prog RAS and CAS for CS 1 */
+	str r1, [r0, #0x124]
+	/* THE DATA BUS WIDE IS PROGRAM FOR 16-BITS */
+	/* DDR-SDRAM MEMORY IS ON BANK0*/
+
+	ldr r1, =0x884			/* 8815 : config reg in BRC for CS0 */
+	str r1, [r0, #0x100]
+
+	/*SDR-SDRAM MEMORY IS ON BANK1*/
+
+	ldr r1, =0x884			/* 8815 : config reg in BRC for CS1 */
+	str r1, [r0, #0x120]
+
+	ldr r1, =0x83			/*MODE Mand*/
+	str r1, [r0, #0x20]
+
+	/* LOAD MODE REGISTER FOR 2 bursts of 16b, with DDR mem ON BANK0 */
+
+	ldr r1, =0x62000			/*Data in*/
+	ldr r1, [r1]
+
+	/* LOAD MODE REGISTER FOR 2 bursts of 16b, with DDR mem ON BANK1 */
+
+	ldr r1, =0x8062000
+	ldr r1, [r1]
+
+	ldr r1, =0x003
+	str r1, [r0, #0x20]
+
+	/* ENABLE ALL THE BUFFER FOR EACH AHB PORT*/
+
+	ldr r1, =0x01			/* Enable buffer 0 */
+	str r1, [r0, #0x400]
+
+	ldr r1, =0x01			/* Enable buffer 1 */
+	str r1, [r0, #0x420]
+
+	ldr r1, =0x01			/* Enable buffer 2 */
+	str r1, [r0, #0x440]
+
+	ldr r1, =0x01			/* Enable buffer 3 */
+	str r1, [r0, #0x460]
+
+	ldr r1, =0x01			/* Enable buffer 4 */
+	str r1, [r0, #0x480]
+
+	ldr r1, =0x01			/* Enable buffer 5 */
+	str r1, [r0, #0x4A0]
+
+	/* GPIO settings */
+
+	ldr r0, =NOMADIK_GPIO1_BASE
+
+	ldr r1, =0xC0600000
+	str r1, [r0, #0x20]
+
+	ldr r1, =0x3F9FFFFF		/* ABHI change this for uart1 */
+	str r1, [r0, #0x24]
+
+	ldr r1, =0x3F9FFFFF		/* ABHI change this for uart1 */
+	str r1, [r0, #0x28]
+
+	ldr r0, =NOMADIK_GPIO0_BASE
+
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #0x20]
+
+	ldr r1, =0x00
+	str r1, [r0, #0x24]
+
+	ldr r1, =0x00
+	str r1, [r0, #0x28]
+
+	/* Configure CPLD_CTRL register for enabling MUX logic for UART0/UART2 */
+
+	ldr r0, =NOMADIK_FSMC_BASE
+
+	ldr r1, =0x10DB			/* INIT FSMC bank 0 */
+	str r1, [r0, #0x00]
+
+	ldr r1, =0x0FFFFFFF
+	str r1, [r0, #0x04]
+
+	ldr r1, =0x010DB		/* INIT FSMC bank 1 */
+	str r1, [r0, #0x08]
+
+	ldr r1, =0x00FFFFFFF
+	str r1, [r0, #0x0C]
+
+	ldr r0, =NOMADIK_UART0_BASE
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x30]
+
+	ldr r1, =0x0000004e
+	str r1, [r0, #0x24]
+
+	ldr r1, =0x00000008
+	str r1, [r0, #0x28]
+
+	ldr r1, =0x00000060
+	str r1, [r0, #0x2C]
+
+	ldr r1, =0x00000301
+	str r1, [r0, #0x30]
+
+	ldr r1, =0x00000066
+	str r1, [r0]
+
+	ldr r0, =NOMADIK_UART1_BASE
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x30]
+
+	ldr r1, =0x0000004e
+	str r1, [r0, #0x24]
+
+	ldr r1, =0x00000008
+	str r1, [r0, #0x28]
+
+	ldr r1, =0x00000060
+	str r1, [r0, #0x2C]
+
+	ldr r1, =0x00000301
+	str r1, [r0, #0x30]
+
+	ldr r1, =0x00000066
+	str r1, [r0]
+
+	ldr r0, =NOMADIK_UART2_BASE
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x30]
+
+	ldr r1, =0x0000004e
+	str r1, [r0, #0x24]
+
+	ldr r1, =0x00000008
+	str r1, [r0, #0x28]
+
+	ldr r1, =0x00000060
+	str r1, [r0, #0x2C]
+
+	ldr r1, =0x00000301
+	str r1, [r0, #0x30]
+
+	ldr r1, =0x00000066
+	str r1, [r0]
+
+	/* Configure CPLD to enable UART0 */
+
+	mov pc, lr
diff -Naur u-boot-2009.01/board/st/nmdk8815/u-boot.lds u-boot/board/st/nmdk8815/u-boot.lds
--- u-boot-2009.01/board/st/nmdk8815/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/st/nmdk8815/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,51 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm926ejs/start.o	(.text)
+		*(.text)
+	}
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss (NOLOAD) : { *(.bss) . = ALIGN(4); }
+	_end = .;
+}
diff -Naur u-boot-2009.01/board/stxgp3/ddr.c u-boot/board/stxgp3/ddr.c
--- u-boot-2009.01/board/stxgp3/ddr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/stxgp3/ddr.c	2009-02-26 14:03:58.000000000 +0100
@@ -65,6 +65,9 @@
 	 */
 	popts->write_data_delay = 3;
 
+	/* 2T timing enable */
+	popts->twoT_en = 1;
+
 	/*
 	 * Factors to consider for half-strength driver enable:
 	 *	- number of DIMMs installed
diff -Naur u-boot-2009.01/board/stxssa/ddr.c u-boot/board/stxssa/ddr.c
--- u-boot-2009.01/board/stxssa/ddr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/stxssa/ddr.c	2009-02-26 14:03:58.000000000 +0100
@@ -65,6 +65,9 @@
 	 */
 	popts->write_data_delay = 3;
 
+	/* 2T timing enable */
+	popts->twoT_en = 1;
+
 	/*
 	 * Factors to consider for half-strength driver enable:
 	 *	- number of DIMMs installed
diff -Naur u-boot-2009.01/board/tb0229/vr4131-pci.c u-boot/board/tb0229/vr4131-pci.c
--- u-boot-2009.01/board/tb0229/vr4131-pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tb0229/vr4131-pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -235,7 +235,7 @@
 	pci_set_region (hose->regions + 3,
 			0x00000000,
 			0x80000000,
-			0x04000000, PCI_REGION_MEM | PCI_REGION_MEMORY);
+			0x04000000, PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose->region_count = 4;
 
diff -Naur u-boot-2009.01/board/tqc/tqm5200/cmd_stk52xx.c u-boot/board/tqc/tqm5200/cmd_stk52xx.c
--- u-boot-2009.01/board/tqc/tqm5200/cmd_stk52xx.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tqc/tqm5200/cmd_stk52xx.c	2009-02-26 14:03:58.000000000 +0100
@@ -327,7 +327,7 @@
 	switch (argc) {
 	case 0:
 	case 1:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	case 2:
 		if (strncmp(argv[1],"saw",3) == 0) {
@@ -342,7 +342,7 @@
 			return rcode;
 		}
 
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	case 3:
 		if (strncmp(argv[1],"saw",3) == 0) {
@@ -358,7 +358,7 @@
 						LEFT_RIGHT);
 			return rcode;
 		}
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	case 4:
 		if (strncmp(argv[1],"saw",3) == 0) {
@@ -382,7 +382,7 @@
 			pcm1772_write_reg((uchar)reg, (uchar)val);
 			return 0;
 		}
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	case 5:
 		if (strncmp(argv[1],"saw",3) == 0) {
@@ -412,7 +412,7 @@
 						channel);
 			return rcode;
 		}
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	printf ("Usage:\nsound cmd [arg1] [arg2] ...\n");
@@ -513,7 +513,7 @@
 			channel = LEFT_RIGHT;
 		break;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -1194,7 +1194,7 @@
 
 U_BOOT_CMD(
 	sound ,    5,    1,     cmd_sound,
-	"sound   - Sound sub-system\n",
+	"Sound sub-system",
 	"saw [duration] [freq] [channel]\n"
 	"    - generate sawtooth for 'duration' ms with frequency 'freq'\n"
 	"      on left \"l\" or right \"r\" channel\n"
@@ -1206,14 +1206,14 @@
 
 U_BOOT_CMD(
 	wav ,    3,    1,     cmd_wav,
-	"wav     - play wav file\n",
+	"play wav file",
 	"[addr] [bytes]\n"
 	"    - play wav file at address 'addr' with length 'bytes'\n"
 );
 
 U_BOOT_CMD(
 	beep ,    2,    1,     cmd_beep,
-	"beep    - play short beep\n",
+	"play short beep",
 	"[channel]\n"
 	"    - play short beep on \"l\"eft or \"r\"ight channel\n"
 );
@@ -1222,7 +1222,7 @@
 #if defined(CONFIG_STK52XX)
 U_BOOT_CMD(
 	fkt ,	4,	1,	cmd_fkt,
-	"fkt     - Function test routines\n",
+	"Function test routines",
 	"led number on/off\n"
 	"     - 'number's like printed on STK52XX board\n"
 	"fkt can\n"
@@ -1237,7 +1237,7 @@
 #elif defined(CONFIG_FO300)
 U_BOOT_CMD(
 	fkt ,	3,	1,	cmd_fkt,
-	"fkt     - Function test routines\n",
+	"Function test routines",
 	"fkt can\n"
 	"     - loopback plug for X16/X29 required\n"
 	"fkt rs232 number\n"
diff -Naur u-boot-2009.01/board/tqc/tqm5200/cmd_tb5200.c u-boot/board/tqc/tqm5200/cmd_tb5200.c
--- u-boot-2009.01/board/tqc/tqm5200/cmd_tb5200.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tqc/tqm5200/cmd_tb5200.c	2009-02-26 14:03:58.000000000 +0100
@@ -90,13 +90,13 @@
 
 U_BOOT_CMD(
 	led ,	2,	1,	cmd_led,
-	"led     - switch status LED on or off\n",
+	"switch status LED on or off",
 	"on/off\n"
 );
 
 U_BOOT_CMD(
 	backlight ,	2,	1,	cmd_backlight,
-	"backlight - switch backlight on or off\n",
+	"switch backlight on or off",
 	"on/off\n"
 	);
 
diff -Naur u-boot-2009.01/board/tqc/tqm8272/tqm8272.c u-boot/board/tqc/tqm8272/tqm8272.c
--- u-boot-2009.01/board/tqc/tqm8272/tqm8272.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tqc/tqm8272/tqm8272.c	2009-02-26 14:03:58.000000000 +0100
@@ -866,7 +866,7 @@
 
 U_BOOT_CMD(
 	  hwib, 1,	1,	do_hwib_dump,
-	  "hwib	   - dump HWIB'\n",
+	  "dump HWIB'",
 	  "\n"
 );
 
diff -Naur u-boot-2009.01/board/tqc/tqm834x/pci.c u-boot/board/tqc/tqm834x/pci.c
--- u-boot-2009.01/board/tqc/tqm834x/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tqc/tqm834x/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -181,7 +181,7 @@
 		       CONFIG_PCI_SYS_MEM_BUS,
 		       CONFIG_PCI_SYS_MEM_PHYS,
 		       CONFIG_PCI_SYS_MEM_SIZE,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose->region_count = 3;
 
diff -Naur u-boot-2009.01/board/tqc/tqm85xx/config.mk u-boot/board/tqc/tqm85xx/config.mk
--- u-boot-2009.01/board/tqc/tqm85xx/config.mk	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tqc/tqm85xx/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -23,7 +23,9 @@
 
 #
 # tqm85xx board
-# default CCARBAR is at 0xff700000
-# assume U-Boot is less than 256k
 #
+ifeq ($(CONFIG_TQM8548_BE),y)
+TEXT_BASE = 0xfff80000
+else
 TEXT_BASE = 0xfffc0000
+endif
diff -Naur u-boot-2009.01/board/tqc/tqm85xx/law.c u-boot/board/tqc/tqm85xx/law.c
--- u-boot-2009.01/board/tqc/tqm85xx/law.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tqc/tqm85xx/law.c	2009-02-26 14:03:58.000000000 +0100
@@ -66,7 +66,7 @@
 #endif
 
 struct law_entry law_table[] = {
-	SET_LAW(CONFIG_SYS_DDR_SDRAM_BASE, LAW_SIZE_512M, LAW_TRGT_IF_DDR),
+	SET_LAW(CONFIG_SYS_DDR_SDRAM_BASE, LAW_SIZE_2G, LAW_TRGT_IF_DDR),
 	SET_LAW(CONFIG_SYS_PCI1_MEM_PHYS, LAW_SIZE_512M, LAW_TRGT_IF_PCI),
 	SET_LAW(CONFIG_SYS_LBC_FLASH_BASE, LAW_3_SIZE, LAW_TRGT_IF_LBC),
 	SET_LAW(CONFIG_SYS_PCI1_IO_PHYS, LAW_SIZE_16M, LAW_TRGT_IF_PCI),
diff -Naur u-boot-2009.01/board/tqc/tqm85xx/nand.c u-boot/board/tqc/tqm85xx/nand.c
--- u-boot-2009.01/board/tqc/tqm85xx/nand.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tqc/tqm85xx/nand.c	2009-02-26 14:03:58.000000000 +0100
@@ -395,7 +395,7 @@
  */
 static void nand_upm_setup (volatile ccsr_lbc_t *lbc)
 {
-	uint i;
+	uint i, j;
 	uint or3 = CONFIG_SYS_OR3_PRELIM;
 	uint clock = get_lbc_clock ();
 
@@ -429,8 +429,8 @@
 	/* Assign address of table */
 	nand_upm_patt = upm_freq_table[i].upm_patt;
 
-	for (i = 0; i < 64; i++) {
-		upmb_write (i, *nand_upm_patt);
+	for (j = 0; j < 64; j++) {
+		upmb_write (j, *nand_upm_patt);
 		nand_upm_patt++;
 	}
 
diff -Naur u-boot-2009.01/board/tqc/tqm85xx/sdram.c u-boot/board/tqc/tqm85xx/sdram.c
--- u-boot-2009.01/board/tqc/tqm85xx/sdram.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tqc/tqm85xx/sdram.c	2009-02-26 14:03:58.000000000 +0100
@@ -1,3 +1,4 @@
+
 /*
  * (C) Copyright 2005
  * Stefan Roese, DENX Software Engineering, sr@denx.de.
@@ -38,11 +39,20 @@
 typedef struct sdram_conf_s sdram_conf_t;
 
 #ifdef CONFIG_TQM8548
+#ifdef CONFIG_TQM8548_AG
+sdram_conf_t ddr_cs_conf[] = {
+	{(1024 << 20), 0x80044202, 0x0002D000},	/* 1024MB, 14x10(4)	*/
+	{ (512 << 20), 0x80044102, 0x0001A000},	/*  512MB, 13x10(4)	*/
+	{ (256 << 20), 0x80040102, 0x00014000},	/*  256MB, 13x10(4)	*/
+	{ (128 << 20), 0x80040101, 0x0000C000},	/*  128MB, 13x9(4)	*/
+};
+#else /* !CONFIG_TQM8548_AG */
 sdram_conf_t ddr_cs_conf[] = {
 	{(512 << 20), 0x80044102, 0x0001A000},	/* 512MB, 13x10(4)	*/
 	{(256 << 20), 0x80040102, 0x00014000},	/* 256MB, 13x10(4)	*/
 	{(128 << 20), 0x80040101, 0x0000C000},	/* 128MB, 13x9(4)	*/
 };
+#endif /* CONFIG_TQM8548_AG */
 #else /* !CONFIG_TQM8548 */
 sdram_conf_t ddr_cs_conf[] = {
 	{(512 << 20), 0x80000202},	/* 512MB, 14x10(4)	*/
@@ -69,6 +79,9 @@
 	volatile ccsr_ddr_t *ddr = (void *)(CONFIG_SYS_MPC85xx_DDR_ADDR);
 #ifdef CONFIG_TQM8548
 	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+#if defined(CONFIG_TQM8548_AG) || defined(CONFIG_TQM8548_BE)
+	volatile ccsr_local_ecm_t *ecm = (void *)(CONFIG_SYS_MPC85xx_ECM_ADDR);
+#endif
 #else /* !CONFIG_TQM8548 */
 	unsigned long cfg_ddr_timing1;
 	unsigned long cfg_ddr_mode;
@@ -81,21 +94,23 @@
 	ddr->sdram_cfg = 0;
 
 #ifdef CONFIG_TQM8548
+	/* Timing and refresh settings for DDR2-533 and below */
+
 	ddr->cs0_bnds = (ddr_cs_conf[0].size - 1) >> 24;
 	ddr->cs0_config = ddr_cs_conf[0].reg;
-	ddr->timing_cfg_3 = 0x00010000;
+	ddr->timing_cfg_3 = 0x00020000;
 
 	/* TIMING CFG 1, 533MHz
 	 * PRETOACT: 4 Clocks
 	 * ACTTOPRE: 12 Clocks
 	 * ACTTORW:  4 Clocks
 	 * CASLAT:   4 Clocks
-	 * REFREC:   34 Clocks
+	 * REFREC:   EXT_REFREC:REFREC 53 Clocks
 	 * WRREC:    4 Clocks
 	 * ACTTOACT: 3 Clocks
 	 * WRTORD:   2 Clocks
 	 */
-	ddr->timing_cfg_1 = 0x4C47A432;
+	ddr->timing_cfg_1 = 0x4C47D432;
 
 	/* TIMING CFG 2, 533MHz
 	 * ADD_LAT:       3 Clocks
@@ -103,10 +118,10 @@
 	 * WR_LAT:        3 Clocks
 	 * RD_TO_PRE:     2 Clocks
 	 * WR_DATA_DELAY: 1/2 Clock
-	 * CKE_PLS:       1 Clock
-	 * FOUR_ACT:      13 Clocks
+	 * CKE_PLS:       3 Clock
+	 * FOUR_ACT:      14 Clocks
 	 */
-	ddr->timing_cfg_2 = 0x3318484D;
+	ddr->timing_cfg_2 = 0x331848CE;
 
 	/* DDR SDRAM Mode, 533MHz
 	 * MRS:          Extended Mode Register
@@ -136,13 +151,12 @@
 	ddr->sdram_interval = (1040 << 16) | 0x100;
 
 	/*
-	 * workaround for erratum DD10 of MPC8458 family below rev. 2.0:
-	 * DDR IO receiver must be set to an acceptable bias point by modifying
-	 * a hidden register.
+	 * Workaround for erratum DDR19 according to MPC8548 Device Errata
+	 * document, Rev. 1: DDR IO receiver must be set to an acceptable
+	 * bias point by modifying a hidden register.
 	 */
-	if (SVR_REV (get_svr ()) < 0x20) {
+	if (SVR_REV (get_svr ()) < 0x21)
 		gur->ddrioovcr = 0x90000000;	/* enable, VSEL 1.8V */
-	}
 
 	/* DDR SDRAM CFG 2
 	 * FRC_SR:      normal mode
@@ -170,7 +184,104 @@
 
 	/* wait for clock stabilization */
 	asm ("sync;isync;msync");
-	udelay(1000);
+	udelay (1000);
+
+#if defined(CONFIG_TQM8548_AG) || defined(CONFIG_TQM8548_BE)
+	/*
+	 * Workaround for erratum DDR20 according to MPC8548 Device Errata
+	 * document, Rev. 1: "CKE signal may not function correctly after
+	 * assertion of HRESET"
+	 */
+
+	/* 1. Configure DDR register as is done in normal DDR configuration.
+	 *    Do not set DDR_SDRAM_CFG[MEM_EN].
+	 *
+	 * 2. Set reserved bit EEBACR[3] at offset 0x1000
+	 */
+	ecm->eebacr |= 0x10000000;
+
+	/*
+	 * 3. Before DDR_SDRAM_CFG[MEM_EN] is set, write DDR_SDRAM_CFG_2[D_INIT]
+	 *
+	 * DDR_SDRAM_CFG_2:
+	 * FRC_SR:      normal mode
+	 * SR_IE:       no self-refresh interrupt
+	 * DLL_RST_DIS: don't care, leave at reset value
+	 * DQS_CFG:     differential DQS signals
+	 * ODT_CFG:     assert ODT to internal IOs only during reads to DRAM
+	 * LVWx_CFG:    don't care, leave at reset value
+	 * NUM_PR:      1 refresh will be issued at a time
+	 * DM_CFG:      don't care, leave at reset value
+	 * D_INIT:      enable data initialization
+	 */
+	ddr->sdram_cfg_2 |= 0x00000010;
+
+	/*
+	 * 4. Before DDR_SDRAM_CFG[MEM_EN] set, write D3[21] to disable data
+	 *    training
+	 */
+	ddr->debug_3 |= 0x00000400;
+
+	/*
+	 * 5. Wait 200 micro-seconds
+	 */
+	udelay (200);
+
+	/*
+	 * 6. Set DDR_SDRAM_CFG[MEM_EN]
+	 *
+	 * BTW, initialize DDR_SDRAM_CFG:
+	 * MEM_EN:       enabled
+	 * SREN:         don't care, leave at reset value
+	 * ECC_EN:       no error report
+	 * RD_EN:        no registered DIMMs
+	 * SDRAM_TYPE:   DDR2
+	 * DYN_PWR:      no power management
+	 * 32_BE:        don't care, leave at reset value
+	 * 8_BE:         4 beat burst
+	 * NCAP:         don't care, leave at reset value
+	 * 2T_EN:        1T Timing
+	 * BA_INTLV_CTL: no interleaving
+	 * x32_EN:       x16 organization
+	 * PCHB8:        MA[10] for auto-precharge
+	 * HSE:          half strength for single and 2-layer stacks
+	 *               (full strength for 3- and 4-layer stacks not
+	 *               yet considered)
+	 * MEM_HALT:     no halt
+	 * BI:           automatic initialization
+	 */
+	ddr->sdram_cfg = 0x83000008;
+
+	/*
+	 * 7. Poll DDR_SDRAM_CFG_2[D_INIT] until it is cleared by hardware
+	 */
+	asm ("sync;isync;msync");
+	while (ddr->sdram_cfg_2 & 0x00000010)
+		asm ("eieio");
+
+	/*
+	 * 8. Clear D3[21] to re-enable data training
+	 */
+	ddr->debug_3 &= ~0x00000400;
+
+	/*
+	 * 9. Set D2(21) to force data training to run
+	 */
+	ddr->debug_2 |= 0x00000400;
+
+	/*
+	 * 10. Poll on D2[21] until it is cleared by hardware
+	 */
+	asm ("sync;isync;msync");
+	while (ddr->debug_2 & 0x00000400)
+		asm ("eieio");
+
+	/*
+	 * 11. Clear reserved bit EEBACR[3] at offset 0x1000
+	 */
+	ecm->eebacr &= ~0x10000000;
+
+#else /* !(CONFIG_TQM8548_AG || CONFIG_TQM8548_BE) */
 
 	/* DDR SDRAM CLK CNTL
 	 * MEM_EN:       enabled
@@ -192,9 +303,11 @@
 	 * BI:           automatic initialization
 	 */
 	ddr->sdram_cfg = 0x83000008;
-	asm ("sync; isync; msync");
-	udelay(1000);
 
+#endif /* CONFIG_TQM8548_AG || CONFIG_TQM8548_BE */
+
+	asm ("sync; isync; msync");
+	udelay (1000);
 #else /* !CONFIG_TQM8548 */
 	switch (casl) {
 	case 20:
diff -Naur u-boot-2009.01/board/tqc/tqm85xx/tlb.c u-boot/board/tqc/tqm85xx/tlb.c
--- u-boot-2009.01/board/tqc/tqm85xx/tlb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tqc/tqm85xx/tlb.c	2009-02-26 14:03:58.000000000 +0100
@@ -121,12 +121,25 @@
 		       MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
 		       0, 6, BOOKE_PAGESZ_64M, 1),
 
+#if defined(CONFIG_TQM8548_AG) || defined (CONFIG_TQM8548_BE)
+	/*
+	 * TLB 7+8:	  2G	 DDR, cache enabled
+	 * 0x00000000	  2G	 DDR System memory
+	 * Without SPD EEPROM configured DDR, this must be setup manually.
+	 */
+	SET_TLB_ENTRY (1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
+		       MAS3_SX | MAS3_SW | MAS3_SR, 0,
+		       0, 7, BOOKE_PAGESZ_1G, 1),
+
+	SET_TLB_ENTRY (1, CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
+		       CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
+		       MAS3_SX | MAS3_SW | MAS3_SR, 0,
+		       0, 8, BOOKE_PAGESZ_1G, 1),
+#else
 	/*
 	 * TLB 7+8:	512M	 DDR, cache disabled (needed for memory test)
 	 * 0x00000000	512M	 DDR System memory
 	 * Without SPD EEPROM configured DDR, this must be setup manually.
-	 * Make sure the TLB count at the top of this table is correct.
-	 * Likely it needs to be increased by two for these entries.
 	 */
 	SET_TLB_ENTRY (1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
 		       MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
@@ -136,7 +149,7 @@
 		       CONFIG_SYS_DDR_SDRAM_BASE + 0x10000000,
 		       MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
 		       0, 8, BOOKE_PAGESZ_256M, 1),
-
+#endif
 #ifdef CONFIG_PCIE1
 	/*
 	 * TLB 9:	 16M	Non-cacheable, guarded
diff -Naur u-boot-2009.01/board/tqc/tqm85xx/tqm85xx.c u-boot/board/tqc/tqm85xx/tqm85xx.c
--- u-boot-2009.01/board/tqc/tqm85xx/tqm85xx.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tqc/tqm85xx/tqm85xx.c	2009-02-26 14:03:58.000000000 +0100
@@ -315,8 +315,7 @@
 
 	/* Monitor protection ON by default */
 	flash_protect (FLAG_PROTECT_SET,
-		       CONFIG_SYS_MONITOR_BASE,
-		       CONFIG_SYS_MONITOR_BASE + monitor_flash_len - 1,
+		       CONFIG_SYS_MONITOR_BASE, 0xffffffff,
 		       &flash_info[CONFIG_SYS_MAX_FLASH_BANKS - 1]);
 
 	/* Environment protection ON by default */
@@ -541,9 +540,9 @@
 extern int fsl_pci_setup_inbound_windows(struct pci_region *r);
 extern void fsl_pci_init(struct pci_controller *hose);
 
-#if defined(CONFIG_PCI) || defined(CONFIG_PCI1)
+#ifdef CONFIG_PCI1
 static struct pci_controller pci1_hose;
-#endif /* CONFIG_PCI || CONFIG_PCI1 */
+#endif /* CONFIG_PCI1 */
 
 #ifdef CONFIG_PCIE1
 static struct pci_controller pcie1_hose;
@@ -552,7 +551,7 @@
 static inline void init_pci1(void)
 {
 	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
-#if defined(CONFIG_PCI) || defined(CONFIG_PCI1)
+#ifdef CONFIG_PCI1
 	uint host_agent = (gur->porbmsr & MPC85xx_PORBMSR_HA) >> 16;
 	volatile ccsr_fsl_pci_t *pci = (ccsr_fsl_pci_t *)CONFIG_SYS_PCI1_ADDR;
 	struct pci_controller *hose = &pci1_hose;
@@ -627,9 +626,9 @@
 	} else {
 		puts ("PCI1:  disabled\n");
 	}
-#else /* !(CONFIG_PCI || CONFIG_PCI1) */
+#else /* !CONFIG_PCI1 */
 	gur->devdisr |= MPC85xx_DEVDISR_PCI1; /* disable */
-#endif /* CONFIG_PCI || CONFIG_PCI1) */
+#endif /* CONFIG_PCI1 */
 }
 
 static inline void init_pcie1(void)
@@ -708,7 +707,7 @@
 {
 	ft_cpu_setup (blob, bd);
 
-#if defined(CONFIG_PCI) || defined(CONFIG_PCI1)
+#ifdef CONFIG_PCI1
 	ft_fsl_pci_setup(blob, "pci0", &pci1_hose);
 #endif
 #ifdef CONFIG_PCIE1
diff -Naur u-boot-2009.01/board/tqc/tqm8xx/u-boot.lds u-boot/board/tqc/tqm8xx/u-boot.lds
--- u-boot-2009.01/board/tqc/tqm8xx/u-boot.lds	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/tqc/tqm8xx/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -63,7 +63,6 @@
     lib_generic/crc32.o		(.text)
     lib_generic/zlib.o		(.text)
     lib_ppc/cache.o		(.text)
-    lib_ppc/time.o		(.text)
 
     . = DEFINED(env_offset) ? env_offset : .;
     common/env_embedded.o	(.ppcenv)
diff -Naur u-boot-2009.01/board/trab/cmd_trab.c u-boot/board/trab/cmd_trab.c
--- u-boot-2009.01/board/trab/cmd_trab.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/trab/cmd_trab.c	2009-02-26 14:03:58.000000000 +0100
@@ -168,7 +168,7 @@
 	int cycle_status;
 
 	if (argc > 1) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -258,7 +258,7 @@
 
 U_BOOT_CMD(
 	burn_in,	1,	1,	do_burn_in,
-	"burn_in - start burn-in test application on TRAB\n",
+	"start burn-in test application on TRAB",
 	"\n"
 	"    -  start burn-in test application\n"
 	"       The burn-in test could took a while to finish!\n"
@@ -271,7 +271,7 @@
 	int i, dip;
 
 	if (argc > 1) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -292,7 +292,7 @@
 
 U_BOOT_CMD(
 	dip,	1,	1,	do_dip,
-	"dip     - read dip switch on TRAB\n",
+	"read dip switch on TRAB",
 	"\n"
 	"    - read state of dip switch (S1) on TRAB board\n"
 	"      read sequence: 1-2-3-4; ON=1; OFF=0; e.g.: \"0100\"\n"
@@ -304,7 +304,7 @@
 	int vcc5v;
 
 	if (argc > 1) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -321,7 +321,7 @@
 
 U_BOOT_CMD(
 	vcc5v,	1,	1,	do_vcc5v,
-	"vcc5v   - read VCC5V on TRAB\n",
+	"read VCC5V on TRAB",
 	"\n"
 	"    - read actual value of voltage VCC5V\n"
 );
@@ -332,7 +332,7 @@
 	int contact_temp;
 
 	if (argc > 1) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -346,7 +346,7 @@
 
 U_BOOT_CMD(
 	c_temp,	1,	1,	do_contact_temp,
-	"c_temp  - read contact temperature on TRAB\n",
+	"read contact temperature on TRAB",
 	"\n"
 	"    -  reads the onboard temperature (=contact temperature)\n"
 );
@@ -355,7 +355,7 @@
 int do_burn_in_status (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc > 1) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -398,7 +398,7 @@
 
 U_BOOT_CMD(
 	bis,	1,	1,	do_burn_in_status,
-	"bis     - print burn in status on TRAB\n",
+	"print burn in status on TRAB",
 	"\n"
 	"    -  prints the status variables of the last burn in test\n"
 	"       stored in the onboard EEPROM on TRAB board\n"
@@ -851,7 +851,7 @@
 #endif
 
 	if (argc > 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -886,7 +886,7 @@
 
 U_BOOT_CMD(
 	tlog,	2,	1,	do_temp_log,
-	"tlog    - log contact temperature [1/100 C] to console (endlessly)\n",
+	"log contact temperature [1/100 C] to console (endlessly)",
 	"delay\n"
 	"    - contact temperature [1/100 C] is printed endlessly to console\n"
 	"      <delay> specifies the seconds to wait between two measurements\n"
diff -Naur u-boot-2009.01/board/trab/trab.c u-boot/board/trab/trab.c
--- u-boot-2009.01/board/trab/trab.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/trab/trab.c	2009-02-26 14:03:58.000000000 +0100
@@ -322,7 +322,7 @@
 
 U_BOOT_CMD(
 	kbd,	1,	1,	do_kbd,
-	"kbd     - read keyboard status\n",
+	"read keyboard status",
 	NULL
 );
 
diff -Naur u-boot-2009.01/board/trizepsiv/eeprom.c u-boot/board/trizepsiv/eeprom.c
--- u-boot-2009.01/board/trizepsiv/eeprom.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/trizepsiv/eeprom.c	2009-02-26 14:03:58.000000000 +0100
@@ -43,7 +43,7 @@
 	int offset,value;
 
 	if (argc < 4) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -51,7 +51,7 @@
 	value=simple_strtoul(argv[3],NULL,16);
 	if (offset > 0x40) {
 		printf("Wrong offset : 0x%x\n",offset);
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	write_srom_word(offset, value);
@@ -60,7 +60,7 @@
 
 int do_dm9000_eeprom ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]) {
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -69,14 +69,14 @@
 	} else if (strcmp (argv[1],"write") == 0) {
 		return (do_write_dm9000_eeprom(cmdtp,flag,argc,argv));
 	} else {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 }
 
 U_BOOT_CMD(
 	dm9000ee,4,1,do_dm9000_eeprom,
-	"dm9000ee- Read/Write eeprom connected to Ethernet Controller\n",
+	"Read/Write eeprom connected to Ethernet Controller",
 	"\ndm9000ee write <word offset> <value> \n"
 	"\tdm9000ee read \n"
 	"\tword:\t\t00-02 : MAC Address\n"
diff -Naur u-boot-2009.01/board/versatile/config.mk u-boot/board/versatile/config.mk
--- u-boot-2009.01/board/versatile/config.mk	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/versatile/config.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-#
-# image should be loaded at 0x01000000
-#
-
-TEXT_BASE = 0x01000000
diff -Naur u-boot-2009.01/board/versatile/flash.c u-boot/board/versatile/flash.c
--- u-boot-2009.01/board/versatile/flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/versatile/flash.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,514 +0,0 @@
-/*
- * (C) Copyright 2001
- * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
- *
- * (C) Copyright 2001-2004
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * (C) Copyright 2003
- * Texas Instruments, <www.ti.com>
- * Kshitij Gupta <Kshitij@ti.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <linux/byteorder/swab.h>
-
-#define PHYS_FLASH_SECT_SIZE	0x00020000	/* 256 KB sectors (x2) */
-flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];	/* info for FLASH chips    */
-
-/* Board support for 1 or 2 flash devices */
-#define FLASH_PORT_WIDTH32
-#undef FLASH_PORT_WIDTH16
-
-#ifdef FLASH_PORT_WIDTH16
-#define FLASH_PORT_WIDTH		ushort
-#define FLASH_PORT_WIDTHV		vu_short
-#define SWAP(x)			__swab16(x)
-#else
-#define FLASH_PORT_WIDTH		ulong
-#define FLASH_PORT_WIDTHV		vu_long
-#define SWAP(x)			__swab32(x)
-#endif
-
-#define FPW	FLASH_PORT_WIDTH
-#define FPWV	FLASH_PORT_WIDTHV
-
-#define mb() __asm__ __volatile__ ("" : : : "memory")
-
-
-/* Flash Organization Structure */
-typedef struct OrgDef {
-	unsigned int sector_number;
-	unsigned int sector_size;
-} OrgDef;
-
-
-/* Flash Organizations */
-OrgDef OrgIntel_28F256K3[] = {
-	{256, 128 * 1024},		/* 256 * 128kBytes sectors */
-};
-
-
-/*-----------------------------------------------------------------------
- * Functions
- */
-unsigned long flash_init (void);
-static ulong flash_get_size (FPW * addr, flash_info_t * info);
-static int write_data (flash_info_t * info, ulong dest, FPW data);
-static void flash_get_offsets (ulong base, flash_info_t * info);
-void inline spin_wheel (void);
-void flash_print_info (flash_info_t * info);
-void flash_unprotect_sectors (FPWV * addr);
-int flash_erase (flash_info_t * info, int s_first, int s_last);
-int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt);
-
-/*-----------------------------------------------------------------------
- */
-
-static void flash_vpp(int on)
-{
-	unsigned int tmp;
-
-	tmp = *(unsigned int *)(VERSATILE_FLASHCTRL);
-
-	if (on)
-	    tmp |= VERSATILE_FLASHPROG_FLVPPEN;
-	else
-	    tmp &= ~VERSATILE_FLASHPROG_FLVPPEN;
-
-	*(unsigned int *)(VERSATILE_FLASHCTRL) = tmp;
-}
-
-unsigned long flash_init (void)
-{
-	int i;
-	ulong size = 0;
-	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
-		switch (i) {
-		case 0:
-		        flash_vpp(1);
-			flash_get_size ((FPW *) PHYS_FLASH_1, &flash_info[i]);
-			flash_get_offsets (PHYS_FLASH_1, &flash_info[i]);
-			flash_vpp(0);
-			break;
-		default:
-			panic ("configured too many flash banks!\n");
-			break;
-		}
-		size += flash_info[i].size;
-	}
-
-	/* Protect monitor and environment sectors
-	 */
-	flash_protect (FLAG_PROTECT_SET,
-			CONFIG_SYS_FLASH_BASE,
-			CONFIG_SYS_FLASH_BASE + monitor_flash_len - 1, &flash_info[0]);
-
-	return size;
-}
-
-/*-----------------------------------------------------------------------
- */
-static void flash_get_offsets (ulong base, flash_info_t * info)
-{
-	int i;
-	OrgDef *pOrgDef;
-
-	pOrgDef = OrgIntel_28F256K3;
-	if (info->flash_id == FLASH_UNKNOWN) {
-		return;
-	}
-
-	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL) {
-		for (i = 0; i < info->sector_count; i++) {
-			if (i > 255) {
-				info->start[i] = base + (i * 0x8000);
-				info->protect[i] = 0;
-			} else {
-				info->start[i] = base +
-						(i * PHYS_FLASH_SECT_SIZE);
-				info->protect[i] = 0;
-			}
-		}
-	}
-}
-
-/*-----------------------------------------------------------------------
- */
-void flash_print_info (flash_info_t * info)
-{
-	int i;
-
-	if (info->flash_id == FLASH_UNKNOWN) {
-		printf ("missing or unknown FLASH type\n");
-		return;
-	}
-
-	switch (info->flash_id & FLASH_VENDMASK) {
-	case FLASH_MAN_INTEL:
-		printf ("INTEL ");
-		break;
-	default:
-		printf ("Unknown Vendor ");
-		break;
-	}
-
-	switch (info->flash_id & FLASH_TYPEMASK) {
-	case FLASH_28F256L18T:
-		printf ("FLASH 28F256L18T\n");
-		break;
-	case FLASH_28F256K3:
-		printf ("FLASH 28F256K3\n");
-		break;
-	default:
-		printf ("Unknown Chip Type\n");
-		break;
-	}
-
-	printf ("  Size: %ld MB in %d Sectors\n",
-			info->size >> 20, info->sector_count);
-
-	printf ("  Sector Start Addresses:");
-	for (i = 0; i < info->sector_count; ++i) {
-		if ((i % 5) == 0)
-			printf ("\n   ");
-		printf (" %08lX%s",
-			info->start[i], info->protect[i] ? " (RO)" : "     ");
-	}
-	printf ("\n");
-	return;
-}
-
-/*
- * The following code cannot be run from FLASH!
- */
-static ulong flash_get_size (FPW * addr, flash_info_t * info)
-{
-	volatile FPW value;
-
-	/* Write auto select command: read Manufacturer ID */
-	addr[0x5555] = (FPW) 0x00AA00AA;
-	addr[0x2AAA] = (FPW) 0x00550055;
-	addr[0x5555] = (FPW) 0x00900090;
-
-	mb ();
-	value = addr[0];
-	switch (value) {
-
-	case (FPW) INTEL_MANUFACT:
-		info->flash_id = FLASH_MAN_INTEL;
-		break;
-
-	default:
-		info->flash_id = FLASH_UNKNOWN;
-		info->sector_count = 0;
-		info->size = 0;
-		addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
-		return (0);		/* no or unknown flash  */
-	}
-
-	mb ();
-	value = addr[1];	/* device ID        */
-	switch (value) {
-
-	case (FPW) (INTEL_ID_28F256L18T):
-		info->flash_id += FLASH_28F256L18T;
-		info->sector_count = 259;
-		info->size = 0x02000000;
-		break;			/* => 32 MB     */
-
-	case (FPW)(INTEL_ID_28F256K3):
-		info->flash_id += FLASH_28F256K3;
-		info->sector_count = 256;
-		info->size = 0x02000000;
-		break;
-
-	default:
-		info->flash_id = FLASH_UNKNOWN;
-		break;
-	}
-
-	if (info->sector_count > CONFIG_SYS_MAX_FLASH_SECT) {
-		printf ("** ERROR: sector count %d > max (%d) **\n",
-				info->sector_count, CONFIG_SYS_MAX_FLASH_SECT);
-		info->sector_count = CONFIG_SYS_MAX_FLASH_SECT;
-	}
-
-	addr[0] = (FPW) 0x00FF00FF;	/* restore read mode */
-
-	return (info->size);
-}
-
-
-/* unprotects a sector for write and erase
- * on some intel parts, this unprotects the entire chip, but it
- * wont hurt to call this additional times per sector...
- */
-void flash_unprotect_sectors (FPWV * addr)
-{
-#define PD_FINTEL_WSMS_READY_MASK    0x0080
-
-	*addr = (FPW) 0x00500050;	/* clear status register */
-
-	/* this sends the clear lock bit command */
-	*addr = (FPW) 0x00600060;
-	*addr = (FPW) 0x00D000D0;
-}
-
-
-/*-----------------------------------------------------------------------
- */
-
-int flash_erase (flash_info_t * info, int s_first, int s_last)
-{
-	int flag, prot, sect;
-	ulong type, start, last;
-	int rcode = 0;
-
-	if ((s_first < 0) || (s_first > s_last)) {
-		if (info->flash_id == FLASH_UNKNOWN) {
-			printf ("- missing\n");
-		} else {
-			printf ("- no sectors to erase\n");
-		}
-		return 1;
-	}
-
-	type = (info->flash_id & FLASH_VENDMASK);
-	if ((type != FLASH_MAN_INTEL)) {
-		printf ("Can't erase unknown flash type %08lx - aborted\n",
-				info->flash_id);
-		return 1;
-	}
-
-	prot = 0;
-	for (sect = s_first; sect <= s_last; ++sect) {
-		if (info->protect[sect]) {
-			prot++;
-		}
-	}
-
-	if (prot) {
-		printf ("- Warning: %d protected sectors will not be erased!\n",
-				prot);
-	} else {
-		printf ("\n");
-	}
-
-	flash_vpp(1);
-
-	start = get_timer (0);
-	last = start;
-
-	/* Disable interrupts which might cause a timeout here */
-	flag = disable_interrupts ();
-
-	/* Start erase on unprotected sectors */
-	for (sect = s_first; sect <= s_last; sect++) {
-		if (info->protect[sect] == 0) {	/* not protected */
-			FPWV *addr = (FPWV *) (info->start[sect]);
-			FPW status;
-
-			printf ("Erasing sector %2d ... ", sect);
-
-			flash_unprotect_sectors (addr);
-
-			/* arm simple, non interrupt dependent timer */
-			reset_timer_masked ();
-
-			*addr = (FPW) 0x00500050;/* clear status register */
-			*addr = (FPW) 0x00200020;/* erase setup */
-			*addr = (FPW) 0x00D000D0;/* erase confirm */
-
-			while (((status =
-				*addr) & (FPW) 0x00800080) !=
-				(FPW) 0x00800080) {
-					if (get_timer_masked () >
-					CONFIG_SYS_FLASH_ERASE_TOUT) {
-					printf ("Timeout\n");
-					/* suspend erase     */
-					*addr = (FPW) 0x00B000B0;
-					/* reset to read mode */
-					*addr = (FPW) 0x00FF00FF;
-					rcode = 1;
-					break;
-				}
-			}
-
-			/* clear status register cmd.   */
-			*addr = (FPW) 0x00500050;
-			*addr = (FPW) 0x00FF00FF;/* resest to read mode */
-			printf (" done\n");
-		}
-	}
-
-	flash_vpp(0);
-
-	return rcode;
-}
-
-/*-----------------------------------------------------------------------
- * Copy memory to flash, returns:
- * 0 - OK
- * 1 - write timeout
- * 2 - Flash not erased
- * 4 - Flash not identified
- */
-
-int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
-{
-	ulong cp, wp;
-	FPW data;
-	int count, i, l, rc, port_width;
-
-	if (info->flash_id == FLASH_UNKNOWN) {
-		return 4;
-	}
-/* get lower word aligned address */
-#ifdef FLASH_PORT_WIDTH16
-	wp = (addr & ~1);
-	port_width = 2;
-#else
-	wp = (addr & ~3);
-	port_width = 4;
-#endif
-
-	flash_vpp(1);
-
-	/*
-	 * handle unaligned start bytes
-	 */
-	if ((l = addr - wp) != 0) {
-		data = 0;
-		for (i = 0, cp = wp; i < l; ++i, ++cp) {
-			data = (data << 8) | (*(uchar *) cp);
-		}
-		for (; i < port_width && cnt > 0; ++i) {
-			data = (data << 8) | *src++;
-			--cnt;
-			++cp;
-		}
-		for (; cnt == 0 && i < port_width; ++i, ++cp) {
-			data = (data << 8) | (*(uchar *) cp);
-		}
-
-		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
-			flash_vpp(0);
-			return (rc);
-		}
-		wp += port_width;
-	}
-
-	/*
-	 * handle word aligned part
-	 */
-	count = 0;
-	while (cnt >= port_width) {
-		data = 0;
-		for (i = 0; i < port_width; ++i) {
-			data = (data << 8) | *src++;
-		}
-		if ((rc = write_data (info, wp, SWAP (data))) != 0) {
-			flash_vpp(0);
-			return (rc);
-		}
-		wp += port_width;
-		cnt -= port_width;
-		if (count++ > 0x800) {
-			spin_wheel ();
-			count = 0;
-		}
-	}
-
-	if (cnt == 0) {
-		flash_vpp(0);
-		return (0);
-	}
-
-	/*
-	 * handle unaligned tail bytes
-	 */
-	data = 0;
-	for (i = 0, cp = wp; i < port_width && cnt > 0; ++i, ++cp) {
-		data = (data << 8) | *src++;
-		--cnt;
-	}
-	for (; i < port_width; ++i, ++cp) {
-		data = (data << 8) | (*(uchar *) cp);
-	}
-
-	rc = write_data (info, wp, SWAP (data));
-
-	flash_vpp(0);
-
-	return rc;
-}
-
-/*-----------------------------------------------------------------------
- * Write a word or halfword to Flash, returns:
- * 0 - OK
- * 1 - write timeout
- * 2 - Flash not erased
- */
-static int write_data (flash_info_t * info, ulong dest, FPW data)
-{
-	FPWV *addr = (FPWV *) dest;
-	ulong status;
-	int flag;
-
-	/* Check if Flash is (sufficiently) erased */
-	if ((*addr & data) != data) {
-		printf ("not erased at %08lx (%lx)\n", (ulong) addr, (ulong) *addr);
-		return (2);
-	}
-
-	flash_vpp(1);
-
-	flash_unprotect_sectors (addr);
-	/* Disable interrupts which might cause a timeout here */
-	flag = disable_interrupts ();
-	*addr = (FPW) 0x00400040;	/* write setup */
-	*addr = data;
-
-	/* arm simple, non interrupt dependent timer */
-	reset_timer_masked ();
-
-	/* wait while polling the status register */
-	while (((status = *addr) & (FPW) 0x00800080) != (FPW) 0x00800080) {
-		if (get_timer_masked () > CONFIG_SYS_FLASH_WRITE_TOUT) {
-			*addr = (FPW) 0x00FF00FF;	/* restore read mode */
-			flash_vpp(0);
-			return (1);
-		}
-	}
-	*addr = (FPW) 0x00FF00FF;	/* restore read mode */
-	flash_vpp(0);
-	return (0);
-}
-
-void inline spin_wheel (void)
-{
-	static int p = 0;
-	static char w[] = "\\/-";
-
-	printf ("\010%c", w[p]);
-	(++p == 3) ? (p = 0) : 0;
-}
diff -Naur u-boot-2009.01/board/versatile/lowlevel_init.S u-boot/board/versatile/lowlevel_init.S
--- u-boot-2009.01/board/versatile/lowlevel_init.S	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/versatile/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,34 +0,0 @@
-/*
- * Board specific setup info
- *
- * (C) Copyright 2003, ARM Ltd.
- * Philippe Robin, <philippe.robin@arm.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <version.h>
-
-/* Set up the platform, once the cpu has been initialized */
-.globl lowlevel_init
-lowlevel_init:
-
-	/* All done by Versatile's boot monitor! */
-	mov pc, lr
diff -Naur u-boot-2009.01/board/versatile/Makefile u-boot/board/versatile/Makefile
--- u-boot-2009.01/board/versatile/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/versatile/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-#
-# (C) Copyright 2000-2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= $(obj)lib$(BOARD).a
-
-COBJS	:= versatile.o flash.o
-SOBJS	:= lowlevel_init.o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
-
-$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
-	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
-
-clean:
-	rm -f $(SOBJS) $(OBJS)
-
-distclean:	clean
-	rm -f $(LIB) core *.bak $(obj).depend
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff -Naur u-boot-2009.01/board/versatile/split_by_variant.sh u-boot/board/versatile/split_by_variant.sh
--- u-boot-2009.01/board/versatile/split_by_variant.sh	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/versatile/split_by_variant.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-#!/bin/sh
-# ---------------------------------------------------------
-#  Set the core module defines according to Core Module
-# ---------------------------------------------------------
-# ---------------------------------------------------------
-# Set up the Versatile type define
-# ---------------------------------------------------------
-
-mkdir -p ${obj}include
-variant=PB926EJ-S
-if [ "$1" = "" ]
-then
-	echo "$0:: No parameters - using versatilepb_config"
-	echo "#define CONFIG_ARCH_VERSATILE_PB" > ${obj}include/config.h
-	variant=PB926EJ-S
-else
-	case "$1" in
-	versatilepb_config	|	\
-	versatile_config)
-	echo "#define CONFIG_ARCH_VERSATILE_PB" > ${obj}include/config.h
-	;;
-
-	versatileab_config)
-	echo "#define CONFIG_ARCH_VERSATILE_AB" > ${obj}include/config.h
-	variant=AB926EJ-S
-	;;
-
-
-	*)
-	echo "$0:: Unrecognised config - using versatilepb_config"
-	echo "#define CONFIG_ARCH_VERSATILE_PB" > ${obj}include/config.h
-	variant=PB926EJ-S
-	;;
-
-	esac
-
-fi
-# ---------------------------------------------------------
-# Complete the configuration
-# ---------------------------------------------------------
-$MKCONFIG -a versatile arm arm926ejs versatile NULL versatile
-echo "Variant:: $variant"
diff -Naur u-boot-2009.01/board/versatile/u-boot.lds u-boot/board/versatile/u-boot.lds
--- u-boot-2009.01/board/versatile/u-boot.lds	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/versatile/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-/*
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
-OUTPUT_ARCH(arm)
-ENTRY(_start)
-SECTIONS
-{
-	. = 0x00000000;
-	. = ALIGN(4);
-	.text	:
-	{
-	  cpu/arm926ejs/start.o	(.text)
-	  *(.text)
-	}
-	.rodata : { *(.rodata) }
-	. = ALIGN(4);
-	.data : { *(.data) }
-	. = ALIGN(4);
-	.got : { *(.got) }
-
-	. = .;
-	__u_boot_cmd_start = .;
-	.u_boot_cmd : { *(.u_boot_cmd) }
-	__u_boot_cmd_end = .;
-
-	. = ALIGN(4);
-	__bss_start = .;
-	.bss (NOLOAD) : { *(.bss) . = ALIGN(4); }
-	_end = .;
-}
diff -Naur u-boot-2009.01/board/versatile/versatile.c u-boot/board/versatile/versatile.c
--- u-boot-2009.01/board/versatile/versatile.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/versatile/versatile.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-/*
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Marius Groeger <mgroeger@sysgo.de>
- *
- * (C) Copyright 2002
- * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
- *
- * (C) Copyright 2003
- * Texas Instruments, <www.ti.com>
- * Kshitij Gupta <Kshitij@ti.com>
- *
- * (C) Copyright 2004
- * ARM Ltd.
- * Philippe Robin, <philippe.robin@arm.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#if defined(CONFIG_SHOW_BOOT_PROGRESS)
-void show_boot_progress(int progress)
-{
-    printf("Boot reached stage %d\n", progress);
-}
-#endif
-
-#define COMP_MODE_ENABLE ((unsigned int)0x0000EAEF)
-
-static inline void delay (unsigned long loops)
-{
-	__asm__ volatile ("1:\n"
-		"subs %0, %1, #1\n"
-		"bne 1b":"=r" (loops):"0" (loops));
-}
-
-/*
- * Miscellaneous platform dependent initialisations
- */
-
-int board_init (void)
-{
-	/*
-	 * set clock frequency:
-	 *	VERSATILE_REFCLK is 32KHz
-	 *	VERSATILE_TIMCLK is 1MHz
-	 */
-	*(volatile unsigned int *)(VERSATILE_SCTL_BASE) |=
-	  ((VERSATILE_TIMCLK << VERSATILE_TIMER1_EnSel) | (VERSATILE_TIMCLK << VERSATILE_TIMER2_EnSel) |
-	   (VERSATILE_TIMCLK << VERSATILE_TIMER3_EnSel) | (VERSATILE_TIMCLK << VERSATILE_TIMER4_EnSel));
-
-	/* arch number of Versatile Board */
-	gd->bd->bi_arch_number = MACH_TYPE_VERSATILE_PB;
-
-	/* adress of boot parameters */
-	gd->bd->bi_boot_params = 0x00000100;
-
-	gd->flags = 0;
-
-	icache_enable ();
-
-	return 0;
-}
-
-
-int misc_init_r (void)
-{
-	setenv("verify", "n");
-	return (0);
-}
-
-/******************************
- Routine:
- Description:
-******************************/
-int dram_init (void)
-{
-	return 0;
-}
diff -Naur u-boot-2009.01/board/w7o/cmd_vpd.c u-boot/board/w7o/cmd_vpd.c
--- u-boot-2009.01/board/w7o/cmd_vpd.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/w7o/cmd_vpd.c	2009-02-26 14:03:58.000000000 +0100
@@ -39,7 +39,7 @@
 
 	/* Validate usage */
 	if (argc > 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -58,7 +58,7 @@
 
 U_BOOT_CMD(
 	  vpd,	2,	1,	do_vpd,
-	  "vpd     - Read Vital Product Data\n",
+	  "Read Vital Product Data",
 	  "[dev_addr]\n"
 	  "        - Read VPD Data from default address, or device address 'dev_addr'.\n"
 );
diff -Naur u-boot-2009.01/board/xilinx/microblaze-generic/config.mk u-boot/board/xilinx/microblaze-generic/config.mk
--- u-boot-2009.01/board/xilinx/microblaze-generic/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/xilinx/microblaze-generic/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2007 Michal Simek
+#
+# Michal  SIMEK <monstr@monstr.eu>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+# CAUTION: This file is automatically generated by libgen.
+# Version: Xilinx EDK 6.3 EDK_Gmm.12.3
+#
+
+TEXT_BASE = 0x29000000
+
+PLATFORM_CPPFLAGS += -mno-xl-soft-mul
+PLATFORM_CPPFLAGS += -mno-xl-soft-div
+PLATFORM_CPPFLAGS += -mxl-barrel-shift
diff -Naur u-boot-2009.01/board/xilinx/microblaze-generic/Makefile u-boot/board/xilinx/microblaze-generic/Makefile
--- u-boot-2009.01/board/xilinx/microblaze-generic/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/xilinx/microblaze-generic/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,50 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/board/xilinx/microblaze-generic/microblaze-generic.c u-boot/board/xilinx/microblaze-generic/microblaze-generic.c
--- u-boot-2009.01/board/xilinx/microblaze-generic/microblaze-generic.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/xilinx/microblaze-generic/microblaze-generic.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,69 @@
+/*
+ * (C) Copyright 2007 Michal Simek
+ *
+ * Michal  SIMEK <monstr@monstr.eu>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* This is a board specific file.  It's OK to include board specific
+ * header files */
+
+#include <common.h>
+#include <config.h>
+#include <asm/microblaze_intc.h>
+#include <asm/asm.h>
+
+void do_reset (void)
+{
+#ifdef CONFIG_SYS_GPIO_0
+	*((unsigned long *)(CONFIG_SYS_GPIO_0_ADDR)) =
+	    ++(*((unsigned long *)(CONFIG_SYS_GPIO_0_ADDR)));
+#endif
+#ifdef CONFIG_SYS_RESET_ADDRESS
+	puts ("Reseting board\n");
+	asm ("bra r0");
+#endif
+}
+
+int gpio_init (void)
+{
+#ifdef CONFIG_SYS_GPIO_0
+	*((unsigned long *)(CONFIG_SYS_GPIO_0_ADDR)) = 0xFFFFFFFF;
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_SYS_FSL_2
+void fsl_isr2 (void *arg) {
+	volatile int num;
+	*((unsigned int *)(CONFIG_SYS_GPIO_0_ADDR + 0x4)) =
+	    ++(*((unsigned int *)(CONFIG_SYS_GPIO_0_ADDR + 0x4)));
+	GET (num, 2);
+	NGET (num, 2);
+	puts("*");
+}
+
+void fsl_init2 (void) {
+	puts("fsl_init2\n");
+	install_interrupt_handler (FSL_INTR_2,\
+ fsl_isr2,\
+ NULL);
+}
+#endif
diff -Naur u-boot-2009.01/board/xilinx/microblaze-generic/u-boot.lds u-boot/board/xilinx/microblaze-generic/u-boot.lds
--- u-boot-2009.01/board/xilinx/microblaze-generic/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/xilinx/microblaze-generic/u-boot.lds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 Atmark Techno, Inc.
+ *
+ * Yasushi SHOJI <yashi@atmark-techno.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(microblaze)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/microblaze/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		. = .;
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		. = ALIGN(4);
+		__bss_end = .;
+	}
+	__end = . ;
+}
diff -Naur u-boot-2009.01/board/xilinx/microblaze-generic/xparameters.h u-boot/board/xilinx/microblaze-generic/xparameters.h
--- u-boot-2009.01/board/xilinx/microblaze-generic/xparameters.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/board/xilinx/microblaze-generic/xparameters.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,71 @@
+/*
+ * (C) Copyright 2007 Michal Simek
+ *
+ * Michal  SIMEK <monstr@monstr.eu>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * CAUTION: This file is automatically generated by libgen.
+ * Version: Xilinx EDK 8.2.02 EDK_Im_Sp2.4
+ */
+
+#define XILINX_BOARD_NAME	microblaze-generic
+
+/* System Clock Frequency */
+#define XILINX_CLOCK_FREQ	100000000
+
+/* Microblaze is microblaze_0 */
+#define XILINX_USE_MSR_INSTR	1
+#define XILINX_FSL_NUMBER	3
+
+/* Interrupt controller is opb_intc_0 */
+#define XILINX_INTC_BASEADDR	0x41200000
+#define XILINX_INTC_NUM_INTR_INPUTS	6
+
+/* Timer pheriphery is opb_timer_1 */
+#define XILINX_TIMER_BASEADDR	0x41c00000
+#define XILINX_TIMER_IRQ	0
+
+/* Uart pheriphery is RS232_Uart */
+#define XILINX_UARTLITE_BASEADDR	0x40600000
+#define XILINX_UARTLITE_BAUDRATE	115200
+
+/* IIC pheriphery is IIC_EEPROM */
+#define XILINX_IIC_0_BASEADDR	0x40800000
+#define XILINX_IIC_0_FREQ	100000
+#define XILINX_IIC_0_BIT	0
+
+/* GPIO is LEDs_4Bit*/
+#define XILINX_GPIO_BASEADDR	0x40000000
+
+/* Flash Memory is FLASH_2Mx32 */
+#define XILINX_FLASH_START	0x2c000000
+#define XILINX_FLASH_SIZE	0x00800000
+
+/* Main Memory is DDR_SDRAM_64Mx32 */
+#define XILINX_RAM_START	0x28000000
+#define XILINX_RAM_SIZE	0x04000000
+
+/* Sysace Controller is SysACE_CompactFlash */
+#define XILINX_SYSACE_BASEADDR	0x41800000
+#define XILINX_SYSACE_HIGHADDR	0x4180ffff
+#define XILINX_SYSACE_MEM_WIDTH	16
+
+/* Ethernet controller is Ethernet_MAC */
+#define XILINX_EMACLITE_BASEADDR       0x40C00000
diff -Naur u-boot-2009.01/board/xilinx/ml401/config.mk u-boot/board/xilinx/ml401/config.mk
--- u-boot-2009.01/board/xilinx/ml401/config.mk	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/xilinx/ml401/config.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-#
-# (C) Copyright 2007 Michal Simek
-#
-# Michal  SIMEK <monstr@monstr.eu>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-# CAUTION: This file is automatically generated by libgen.
-# Version: Xilinx EDK 6.3 EDK_Gmm.12.3
-#
-
-TEXT_BASE = 0x29000000
-
-PLATFORM_CPPFLAGS += -mno-xl-soft-mul
-PLATFORM_CPPFLAGS += -mno-xl-soft-div
-PLATFORM_CPPFLAGS += -mxl-barrel-shift
diff -Naur u-boot-2009.01/board/xilinx/ml401/Makefile u-boot/board/xilinx/ml401/Makefile
--- u-boot-2009.01/board/xilinx/ml401/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/xilinx/ml401/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-#
-# (C) Copyright 2000-2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= $(obj)lib$(BOARD).a
-
-COBJS	= $(BOARD).o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
-
-$(LIB):	$(OBJS) $(SOBJS)
-	$(AR) $(ARFLAGS) $@ $^
-
-clean:
-	rm -f $(SOBJS) $(OBJS)
-
-distclean:	clean
-	rm -f $(LIB) core *.bak $(obj).depend
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff -Naur u-boot-2009.01/board/xilinx/ml401/ml401.c u-boot/board/xilinx/ml401/ml401.c
--- u-boot-2009.01/board/xilinx/ml401/ml401.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/xilinx/ml401/ml401.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-/*
- * (C) Copyright 2007 Michal Simek
- *
- * Michal  SIMEK <monstr@monstr.eu>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-/* This is a board specific file.  It's OK to include board specific
- * header files */
-
-#include <common.h>
-#include <config.h>
-#include <asm/microblaze_intc.h>
-#include <asm/asm.h>
-
-void do_reset (void)
-{
-#ifdef CONFIG_SYS_GPIO_0
-	*((unsigned long *)(CONFIG_SYS_GPIO_0_ADDR)) =
-	    ++(*((unsigned long *)(CONFIG_SYS_GPIO_0_ADDR)));
-#endif
-#ifdef CONFIG_SYS_RESET_ADDRESS
-	puts ("Reseting board\n");
-	asm ("bra r0");
-#endif
-}
-
-int gpio_init (void)
-{
-#ifdef CONFIG_SYS_GPIO_0
-	*((unsigned long *)(CONFIG_SYS_GPIO_0_ADDR)) = 0xFFFFFFFF;
-#endif
-	return 0;
-}
-
-#ifdef CONFIG_SYS_FSL_2
-void fsl_isr2 (void *arg) {
-	volatile int num;
-	*((unsigned int *)(CONFIG_SYS_GPIO_0_ADDR + 0x4)) =
-	    ++(*((unsigned int *)(CONFIG_SYS_GPIO_0_ADDR + 0x4)));
-	GET (num, 2);
-	NGET (num, 2);
-	puts("*");
-}
-
-void fsl_init2 (void) {
-	puts("fsl_init2\n");
-	install_interrupt_handler (FSL_INTR_2,\
- fsl_isr2,\
- NULL);
-}
-#endif
diff -Naur u-boot-2009.01/board/xilinx/ml401/u-boot.lds u-boot/board/xilinx/ml401/u-boot.lds
--- u-boot-2009.01/board/xilinx/ml401/u-boot.lds	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/xilinx/ml401/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-/*
- * (C) Copyright 2004 Atmark Techno, Inc.
- *
- * Yasushi SHOJI <yashi@atmark-techno.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_ARCH(microblaze)
-ENTRY(_start)
-
-SECTIONS
-{
-	.text ALIGN(0x4):
-	{
-		__text_start = .;
-		cpu/microblaze/start.o (.text)
-		*(.text)
-		__text_end = .;
-	}
-
-	.rodata ALIGN(0x4):
-	{
-		__rodata_start = .;
-		*(.rodata)
-		__rodata_end = .;
-	}
-
-	.data ALIGN(0x4):
-	{
-		__data_start = .;
-		*(.data)
-		__data_end = .;
-	}
-
-	.u_boot_cmd ALIGN(0x4):
-	{
-		. = .;
-		__u_boot_cmd_start = .;
-		*(.u_boot_cmd)
-		__u_boot_cmd_end = .;
-	}
-
-	.bss ALIGN(0x4):
-	{
-		__bss_start = .;
-		*(.bss)
-		. = ALIGN(4);
-		__bss_end = .;
-	}
-	__end = . ;
-}
diff -Naur u-boot-2009.01/board/xilinx/ml401/xparameters.h u-boot/board/xilinx/ml401/xparameters.h
--- u-boot-2009.01/board/xilinx/ml401/xparameters.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/xilinx/ml401/xparameters.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-/*
- * (C) Copyright 2007 Michal Simek
- *
- * Michal  SIMEK <monstr@monstr.eu>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- *
- * CAUTION: This file is automatically generated by libgen.
- * Version: Xilinx EDK 8.2.02 EDK_Im_Sp2.4
- */
-
-/* System Clock Frequency */
-#define XILINX_CLOCK_FREQ	100000000
-
-/* Microblaze is microblaze_0 */
-#define XILINX_USE_MSR_INSTR	1
-#define XILINX_FSL_NUMBER	3
-
-/* Interrupt controller is opb_intc_0 */
-#define XILINX_INTC_BASEADDR	0x41200000
-#define XILINX_INTC_NUM_INTR_INPUTS	6
-
-/* Timer pheriphery is opb_timer_1 */
-#define XILINX_TIMER_BASEADDR	0x41c00000
-#define XILINX_TIMER_IRQ	0
-
-/* Uart pheriphery is RS232_Uart */
-#define XILINX_UARTLITE_BASEADDR	0x40600000
-#define XILINX_UARTLITE_BAUDRATE	115200
-
-/* IIC pheriphery is IIC_EEPROM */
-#define XILINX_IIC_0_BASEADDR	0x40800000
-#define XILINX_IIC_0_FREQ	100000
-#define XILINX_IIC_0_BIT	0
-
-/* GPIO is LEDs_4Bit*/
-#define XILINX_GPIO_BASEADDR	0x40000000
-
-/* Flash Memory is FLASH_2Mx32 */
-#define XILINX_FLASH_START	0x2c000000
-#define XILINX_FLASH_SIZE	0x00800000
-
-/* Main Memory is DDR_SDRAM_64Mx32 */
-#define XILINX_RAM_START	0x28000000
-#define XILINX_RAM_SIZE	0x04000000
-
-/* Sysace Controller is SysACE_CompactFlash */
-#define XILINX_SYSACE_BASEADDR	0x41800000
-#define XILINX_SYSACE_HIGHADDR	0x4180ffff
-#define XILINX_SYSACE_MEM_WIDTH	16
-
-/* Ethernet controller is Ethernet_MAC */
-#define XILINX_EMACLITE_BASEADDR       0x40C00000
diff -Naur u-boot-2009.01/board/zeus/update.c u-boot/board/zeus/update.c
--- u-boot-2009.01/board/zeus/update.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/zeus/update.c	2009-02-26 14:03:58.000000000 +0100
@@ -98,7 +98,7 @@
 
 U_BOOT_CMD (
 	update_boot_eeprom, 1, 1, do_update_boot_eeprom,
-	"update_boot_eeprom  - update boot eeprom content\n",
+	"update boot eeprom content",
 	NULL
 );
 
diff -Naur u-boot-2009.01/board/zeus/zeus.c u-boot/board/zeus/zeus.c
--- u-boot-2009.01/board/zeus/zeus.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/zeus/zeus.c	2009-02-26 14:03:58.000000000 +0100
@@ -327,7 +327,7 @@
 
 U_BOOT_CMD(
 	setdef,	4,	1,	do_set_default,
-	"setdef  - write board-specific values to EEPROM (ethaddr...)\n",
+	"write board-specific values to EEPROM (ethaddr...)",
 	"ethaddr eth1addr serial#\n    - write board-specific values to EEPROM\n"
 	);
 
@@ -418,7 +418,7 @@
 
 U_BOOT_CMD (
 	chkreset, 1, 1, do_chkreset,
-	"chkreset- Check for status of SW-reset button and act accordingly\n",
+	"Check for status of SW-reset button and act accordingly",
 	NULL
 );
 
diff -Naur u-boot-2009.01/board/zylonite/lowlevel_init.S u-boot/board/zylonite/lowlevel_init.S
--- u-boot-2009.01/board/zylonite/lowlevel_init.S	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/board/zylonite/lowlevel_init.S	2009-02-26 14:03:58.000000000 +0100
@@ -121,7 +121,7 @@
 /*	ldr r2, [r3] */
 /*	cmp r4, r2 */
 /*	bgt 1b */
-	wait #300
+	wait #0x300
 
 mem_init:
 
diff -Naur u-boot-2009.01/CHANGELOG u-boot/CHANGELOG
--- u-boot-2009.01/CHANGELOG	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/CHANGELOG	2009-02-26 14:03:58.000000000 +0100
@@ -1,3 +1,4976 @@
+commit 80b827c2b78329c6503b271e43d9eb693d644710
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Sun Feb 22 23:45:40 2009 +0100
+
+    ARM: synchronize mach-types.h with linux v2.6.29-rc5-315-g683fdc5
+
+    The file was generated from building versatile_defconfig.
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit 14209ac13ff631e36c9a9dd426c59c2e2f5dab00
+Author: Shinya Kuribayashi <skuribay@ruby.dti.ne.jp>
+Date:	Sun Feb 22 14:24:11 2009 +0900
+
+    MIPS: Fix GCC-4.2 'discards qualifiers from pointer target type' warnings
+
+    Compiling dbau1x00 and gth2 boards with GCC-4.2, you would see new warnings
+    like this:
+
+    skuribay@ubuntu:u-boot.git$ ./MAKEALL dbau1000
+    Configuring for dbau1x00 board...
+    au1x00_eth.c: In function 'au1x00_send':
+    au1x00_eth.c:158: warning: passing argument 1 of 'virt_to_phys' discards qualifiers from pointer target type
+    au1x00_eth.c: In function 'au1x00_recv':
+    au1x00_eth.c:211: warning: passing argument 1 of 'virt_to_phys' discards qualifiers from pointer target type
+    au1x00_eth.c: In function 'au1x00_init':
+    au1x00_eth.c:252: warning: passing argument 1 of 'virt_to_phys' discards qualifiers from pointer target type
+    au1x00_eth.c: In function 'au1x00_recv':
+    au1x00_eth.c:211: warning: passing argument 1 of 'virt_to_phys' discards qualifiers from pointer target type
+    au1x00_eth.c: In function 'au1x00_init':
+    au1x00_eth.c:252: warning: passing argument 1 of 'virt_to_phys' discards qualifiers from pointer target type
+    au1x00_eth.c: In function 'au1x00_send':
+    au1x00_eth.c:158: warning: passing argument 1 of 'virt_to_phys' discards qualifiers from pointer target type
+
+    We're passing a volatile pointer to a function which is expecting a non-
+    volatile pointer.  That's potentially dangerous, so gcc warns about it.
+    Confirmed with ELDK 4.2 (GCC 4.2.2) and Sourcey G++ 4.2 (GCC 4.2.3).
+
+    To fix this, we add a volatile attribute to the argument in question.
+    The virt_to_phys function in Linux kernel also does the same thing.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Shinya Kuribayashi <skuribay@ruby.dti.ne.jp>
+
+commit aba45c85b22f8c57fc2fedba8e948e06c2e2f5b3
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Fri Feb 20 17:51:28 2009 +0100
+
+    OMAP3: Clean up MMC code
+
+    Clean up OMAP3 MMC code:
+
+    * Convert register access to struct & readx/writex style
+    * Replace hardcode values by macros
+    * Remove macro defined twice
+
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit cfcdf4a9b361d015c0debac73fbf7c511df4a934
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Thu Feb 12 18:55:43 2009 +0100
+
+    OMAP3: Pandora: Update pin mux
+
+    Clock pin must have input enabled for MMC3 to work.
+    Also enable pull-ups for cmd/data lines to be consistent
+    with remaining MMC host pin setup.
+
+    Signed-off-by: Grazvydas Ignotas <notasas@gmail.com>
+
+commit 6530a8bf8a0274b9419141e4c2c5a235cce5380f
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Thu Feb 12 18:55:42 2009 +0100
+
+    OMAP3: Add OMAP3 auto detection
+
+    This patch adds OMAP3 cpu type auto detection based on OMAP3 register
+    and removes hardcoded values.
+
+    Signed-off-by: Steve Sakoman <sakoman@gmail.com>
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit f956fd0338f4990793a10f767929ba4963665261
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Thu Feb 12 18:55:41 2009 +0100
+
+    OMAP3: Beagle: Add board revision detection
+
+    With BeagleBoard revision C some HW changes are introduced (e.g. PinMUX)
+    which might need different software handling. For this, GPIO pin 171 (GPIO
+    module 6, offset 11) can be used to check for board revision. If this pin
+    is low, we have a rev C board. Else it must be a revision Ax or Bx board.
+
+    To handle board differences you can call function beagle_get_revision().
+    E.g.:
+
+    if (beagle_get_revision()) {
+
+    /* do special revision C stuff here */
+
+    }
+
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit 288f3cd912918b97919d13b6f7fb13fbddf74d68
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Thu Feb 12 18:55:40 2009 +0100
+
+    OMAP3: Overo: Clean up pin mux and GPIO configuration
+
+    * Make Overo GPIO114 an input for touchscreen PENDOWN
+    * Make Overo GPIO144-147 readable
+    * Make Overo EHCI pinmux match beagle rev c setup
+    * Adjust pinmux for SMSC911X network chip support
+    * Remove unnecessary GPIO setup
+    * Fix merge error in Makefile
+
+    Signed-off-by: Steve Sakoman <sakoman@gmail.com>
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit 2579019b8248e5f166e60e37065766efc8a49dbc
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sun Feb 22 17:08:41 2009 +0100
+
+    nmdk8815: fix onenand support
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 0176c03a2469676df5bf19cf93a1a6f582f6a120
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sun Feb 22 17:56:50 2009 +0100
+
+    nomadik/nand: fix 'ecc512' discards qualifiers from pointer target type
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 9751a456f702ba2fcdfd1bdbc0138927ef007858
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sun Feb 22 17:49:43 2009 +0100
+
+    davinci: fix implicit declaration of function 'davinci_errata_workarounds'
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 4f5728987f4f9f7845688482aa2b7f2127768165
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sun Feb 22 15:49:28 2009 +0100
+
+    arm: add uart dcc support
+
+    Serial driver via the EmbeddedICE macrocell's DCC channel using
+    co-processor 14.
+
+    It does include a timeout to ensure that the system does not
+    totally freeze when there is nothing connected to read.
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 0cd18fa982f9a8c1a90ce971379a7d6408976d48
+Author: Hugo Villeneuve <hugo.villeneuve@lyrtech.com>
+Date:	Fri Nov 21 14:35:56 2008 -0500
+
+    ARM DaVinci: Add common peripherals and modules enable functions.
+
+    Taken all the duplicated code for enabling common modules and apply
+    software workarounds from the board specific code into common
+    functions. Also added comments explaining the workarounds
+    (from TI errata documents) and replaced some numerical bit numbers
+    with more meaningful defines.
+
+    Signed-off-by: Hugo Villeneuve <hugo.villeneuve@lyrtech.com>
+
+commit d3be1bcae7a8207e0a79ffd035d0e90f80378295
+Author: Alessandro Rubini <rubini@unipv.it>
+Date:	Mon Feb 9 15:53:33 2009 +0100
+
+    Enable Ethernet for Nomadik 8815 Evaluation Kit
+
+    This trivially enables Ethernet support in the debug board
+    by setting up the proper chip select.
+
+    Signed-off-by: Alessandro Rubini <rubini@unipv.it>
+    Acked-by: Andrea Gallo <andrea.gallo@stnwireless.com>
+
+commit 0d8c6eab2481046e9446264bfe9402bb98ddf433
+Author: Alessandro Rubini <rubini@unipv.it>
+Date:	Mon Feb 9 15:53:31 2009 +0100
+
+    Nand driver for Nomadik SoC
+
+    This driver implements the ECC algorithm described in
+    the CPU data sheet and uses the OOB layout chosen in
+    already-released development systems (shipped with a custom-made
+    u-boot 1.3.1).
+
+    Signed-off-by: Alessandro Rubini <rubini@unipv.it>
+    Acked-by: Andrea Gallo <andrea.gallo@stnwireless.com>
+
+commit ef339cc2b68e4cbef3f9376a45315e1b974bbd8d
+Author: Alessandro Rubini <rubini@unipv.it>
+Date:	Mon Feb 9 15:53:31 2009 +0100
+
+    Added nomadik.h header
+
+    Signed-off-by: Alessandro Rubini <rubini@unipv.it>
+    Acked-by: Andrea Gallo <andrea.gallo@stnwireless.com>
+
+commit 60ece6d8043d1dd80f5dd32c541213716d624b19
+Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
+Date:	Wed Oct 29 20:05:18 2008 +0900
+
+    r8a66597-hcd: fix cannot use external hub
+
+    Fix the problem that cannot use external hub, because this driver
+    did not control correctly a DEVADDx register.
+
+    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit e1ffaee728190e76a4596a3579d94e730143585f
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Feb 19 01:20:27 2009 -0500
+
+    Blackfin: disable syscontrol code for now
+
+    Looks like the initcode updates fell out of order during my merges.  The
+    patch that really fixes up this code is part of power-on overhaul and so
+    is too large for merging at this point.  Instead, we can disable the code
+    as no currently in-tree board depends on it.  The next merge window will
+    fix things up properly.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 1b228d68f54832edd867ef98520f760f68192ab7
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Feb 19 01:19:49 2009 -0500
+
+    Blackfin: bf537-stamp: fix I2C board defines
+
+    The previous merge for cleaning up the I2C driver incorrectly reverted the
+    CFG_xxx rename for some of the I2C defines.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+
+commit 09fee8e8677a6265e89144ccc163bf00e321769e
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Sun Feb 22 01:19:52 2009 +0100
+
+    Coding Style cleanup; update CHANGELOG
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit 1dcb50afbb63a439320a985380a0af2dca079d1e
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Sun Feb 22 01:17:47 2009 +0100
+
+    Makefile: fix cleanup
+
+    Commit e4943ec5 moved the ARM boards to a vendor directory but forgot
+    to adapt the cleanup rules in the Makefile
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit edff7bcc4d5540df8b416274652ff02e94c38b9e
+Author: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+Date:	Fri Feb 20 13:01:56 2009 -0500
+
+    Cleanup the comment for m68k linux boot argument passing.
+
+    This patch clarifies the way m68k passes linux boot argument.
+    The one gotcha here is that the assembly instruction that
+    the compiler uses to jump to the kernel is 'jsr' which pushes the
+    program counter for the instruction after the jsr into the stack pointer.
+
+    Signed-off-by: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit 4d41650eec959668280a612467bd95c7b8398513
+Author: Peter Griffin <pgriffin@mpc-data.co.uk>
+Date:	Tue Feb 10 16:44:45 2009 +0000
+
+    sh: Fix rsk7203 in tree build
+
+    Signed-off-by: Peter Griffin <pgriffin@mpc-data.co.uk>
+
+commit fca0cecff73db99d99ad094cca7980472b8a11b5
+Author: Minkyu Kang <mk7.kang@samsung.com>
+Date:	Wed Feb 18 09:05:52 2009 +0900
+
+    bootm: Reduce the unnecessary memmove
+
+    Although load address and image start address are same address,
+    bootm command always does memmove.
+    That is unnecessary memmove and can be taken few milliseconds
+    (about 500 msec to 1000 msec).
+    If skip this memmove, we can reduce the boot time.
+
+    Signed-off-by: Minkyu Kang <mk7.kang@samsung.com>
+
+commit 670cbde8da83690fed1064c3358f54ae1d693ed2
+Author: Matthias Fuchs <matthias.fuchs@esd.eu>
+Date:	Sun Feb 15 22:29:15 2009 +0100
+
+    fpga: Fix Spartan III FPGA booting
+
+    This patch does some minor fixing of the Xilinx Spartan III
+    FPGA boot code:
+
+    - Fixed call order of post configuration callback and
+      success message printing (result of copy-paste?)
+    - remove obsolete comment
+    - minor coding style cleanup
+
+    Signed-off-by: Matthias Fuchs <matthias.fuchs@esd-electronics.com>
+
+commit 3818b677641038d27b2663fbd6771ad38c932f86
+Author: Matthias Fuchs <matthias.fuchs@esd.eu>
+Date:	Sun Feb 15 22:28:36 2009 +0100
+
+    fpga: Fix Spartan II FPGA booting
+
+    This patch does some minor fixing of the Xilinx Spartan II
+    FPGA boot code:
+
+    - Fixed call order of post configuration callback and
+      success message printing (result of copy-paste?)
+    - relocate post configuration callback only when it
+      is implemented
+    - remove obsolete comment
+    - minor coding style cleanup
+
+    Signed-off-by: Matthias Fuchs <matthias.fuchs@esd-electronics.com>
+
+commit b4746d8bf9f4ed6dc8a76c5d52db669604aff84b
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Feb 11 20:26:52 2009 -0500
+
+    drivers/serial/ns16550: move ifdef into Makefile COBJS-$(...)
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 6bcb4b806cef8a5dd08fac9a4a672b96d9ee804e
+Author: Derek Ou <dou@siconix.com>
+Date:	Tue Feb 3 16:00:07 2009 -0700
+
+    lcd_putc bug fix for tab.
+
+    Signed-off-by: Derek Ou <dou@siconix.com>
+
+commit 35c9e14d8096e519fe76c953a43d52a09617345c
+Author: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
+Date:	Mon Feb 2 09:46:21 2009 +0900
+
+    MIPS: cpu/mips/Makefile: Add a missing START line
+
+    In the commit 79b51ff8205f0354d5300570614c1d2db499679c ([MIPS] cpu/mips/
+    Makefile: Split [CS]OBJS onto separate lines), I wrongly deleted a START
+    line.  This patch puts it back.
+
+    Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
+
+commit 9a63b7f4f8f3c99cf017e0d3d4a152dfcd913b5a
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Sat Feb 21 21:51:21 2009 +0100
+
+    Enable ext2 support for TQM8xxL/M based boards
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit e3ba7f137c7c454ad626cd0bd2e84d73c7a8644f
+Author: Tom Rix <Tom.Rix@windriver.com>
+Date:	Fri Feb 20 03:47:50 2009 +0100
+
+    ARM:PXA Use new definitions in mmc.h
+
+    Signed-off-by: Tom Rix <Tom.Rix@windriver.com>
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 682beeac34dc9ab18fab58b26973d2e29d113717
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Fri Feb 20 03:47:50 2009 +0100
+
+    Reduce the scope of PXA's mmc_read/mmc_write/mmc_bread functions
+
+    These names are being taken over by the new MMC framework.	Hopefuly
+    the PXA can be easily ported, and these functions will go away entirely.
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit b03d92e5584935886ff91d5aa0755dc8888b7187
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Fri Feb 20 03:47:50 2009 +0100
+
+    pxa: move mmc drivers to drivers/mmc
+
+    introduce new macro CONFIG_PXA_MMC to activate it
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 9490f465642c80c054854689a2ef1a77d65cf1f3
+Author: Tom Rix <Tom.Rix@windriver.com>
+Date:	Thu Feb 19 19:27:22 2009 -0600
+
+    ARM:PXA Remove redefinition of mmc_cid and mmc_csd.
+
+    These structures are defined in the common mmc.h
+
+    This was compile checked on cerf250.
+
+commit 94a3312920b6f9b5da27309549fb73650718c10a
+Author: Micha Kalfon <smichak.uv@gmail.com>
+Date:	Wed Feb 11 19:50:11 2009 +0200
+
+    pxa: fixing get_timer to return time in miliseconds.
+
+    Fixing the get_timer function to return time in miliseconds instead of
+    ticks. Also fixed PXA boards to use the conventional value of 1000 for
+    CONFIG_SYS_HZ.
+
+    Signed-off-by: Micha Kalfon <smichak.uv@gmail.com>
+
+commit e5e88c3614b79b54719905f66aefb51f9494bc1f
+Author: Tom Rix <Tom.Rix@windriver.com>
+Date:	Thu Feb 19 16:45:43 2009 -0600
+
+    ARM:OMAP3 Change mmc_init to mmc_legacy_init
+
+    omap3_mmc.c was changed to define mmc_legacy_init.
+    Remove unused functions.
+
+    Compile tested on all arm
+    Runtime tested on Zoom1.
+
+    Signed-off-by: Tom Rix <Tom.Rix@windriver.com>
+
+commit 9e80bb21629988063574f88ca0d28baadff4d963
+Author: Heiko Schocher <hs@denx.de>
+Date:	Thu Feb 19 17:23:58 2009 +0100
+
+    82xx, mgcoge: updates for 2009.03
+
+    - activate CS4 for accessing the FPGA
+    - activate Rx buf len > 1 on SMC
+    - pram activated
+    - MTDPARTS_DEFAULT defined
+    - update the size of the flashes in the DTS
+      before booting Linux
+    - MONITOR_LEN updated to 384k
+    - added CONFIG_HOSTNAME
+    - added CONFIG_ENV_BUFFER_PRINT
+    - Environment size reduced to 16k
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+
+commit df909554e2401f307925e1bd45d576e4176d9de9
+Author: Heiko Schocher <hs@denx.de>
+Date:	Thu Feb 19 17:24:01 2009 +0100
+
+    8xx, mgsuvd: updates for 2009.03
+
+    - activate Rx buf len > 1 on SMC
+    - pram activated
+    - MTDPARTS_DEFAULT defined
+    - update the size of the flash in the DTS
+      before booting Linux
+    - MONITOR_LEN updated to 384k
+    - added CONFIG_HOSTNAME
+    - added CONFIG_ENV_BUFFER_PRINT
+    - Environment size reduced to 16k
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+
+commit 3511b4e208e12be85b532866f1c660aa2e021557
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Wed Feb 18 19:59:39 2009 +0100
+
+    MMC: Don't use new framework code if not enabled
+
+    Don't use code of new MMC framework in cmd_mmc if CONFIG_GENERIC_MMC
+    isn't enabled.
+
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit 32482be67775e00b4cbc49fba62347c1ecc6229c
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Thu Feb 19 13:53:29 2009 +0100
+
+    TQM8xxL: make some room in low memory for future needs
+
+    THe TQM8xxL use a ahnd-optimized linker script to efficiently use the
+    small boot sectors in the flash. This patch makes some room in the
+    first sector to prepare for a size increase of lib_generic/vsprintf.o
+    by a future patch.
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit c157cec3c3f6dfc194532b3a3ca87f85b642962a
+Author: Kim Phillips <kim.phillips@freescale.com>
+Date:	Wed Feb 18 18:06:18 2009 -0600
+
+    README: remove duplicate entry
+
+    it's been around since the original commit (2ad6b513) that added two
+    identical entries.
+
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit 1bba30efe1717bea13026e15c7c7d906419fac69
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Thu Feb 19 00:41:08 2009 +0100
+
+    Coding style cleanup, update CHANGELOG
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit 369d0aa9674b65c83f8553b9bcf9d207dc369223
+Author: Kim Phillips <kim.phillips@freescale.com>
+Date:	Wed Feb 18 17:43:59 2009 -0600
+
+    sata_sil3114: fix compiler warning
+
+    judging from other printfs in the same file, it seems ata should be
+    postpended with the interface number, not the address of the global
+    port variable.  Fixes this for current u-boot-mpc83xx tree:
+
+    Configuring for MPC8349ITX board...
+    sata_sil3114.c: In function 'sata_bus_softreset':
+    sata_sil3114.c:99: warning: format '%u' expects type 'unsigned int', but argument 2 has type 'struct sata_port *'
+    sata_sil3114.c:108: warning: format '%u' expects type 'unsigned int', but argument 2 has type 'struct sata_port *'
+
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit f5675aa5ceeef30740970ab8ca0c8cbc324945cd
+Author: Ron Madrid <ron_madrid@sbcglobal.net>
+Date:	Wed Feb 18 14:30:44 2009 -0800
+
+    Create configuration option for restricted ns16550 functions
+
+    This patch will create a configuration option for a minimum configuration for
+    the ns16550 serial driver at drivers/serial/ns16550.c and will apply this new
+    configuration option to the SIMPC8313.h config file in order to fix the NAND
+    bootstrap build error.  This option will exclude all functions with exception of
+    NS16550_putc and NS16550_init.  This will be used primarily to save space and
+    remove unused code from builds in which space is limited.
+
+    Signed-off-by: Ron Madrid <ron_madrid@sbcglobal.net>
+
+commit 7b0bc0219db8981613259473cf19699ac259b4fb
+Author: Kim Phillips <kim.phillips@freescale.com>
+Date:	Wed Feb 18 16:14:29 2009 -0600
+
+    mkconfig: include board config.h before asm/config.h
+
+    swapping the include order suppresses warnings for board configs
+    that define their own CONFIG_MAX_MEM_MAPPED:
+
+    In file included from /home/r1aaha/git/u-boot/include/config.h:5,
+		    from /home/r1aaha/git/u-boot/include/common.h:35,
+		    from simpc8313.c:26:
+    /home/r1aaha/git/u-boot/include/configs/SIMPC8313.h:81:1: warning:
+    "CONFIG_MAX_MEM_MAPPED" redefined
+    In file included from /home/r1aaha/git/u-boot/include/config.h:4,
+		    from /home/r1aaha/git/u-boot/include/common.h:35,
+		    from simpc8313.c:26:
+    /home/r1aaha/git/u-boot/include/asm/config.h:28:1: warning: this is
+    the location of the previous definition
+
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit b8845abdc0dcf20d0944e965153f5ae7a9c3077c
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Wed Feb 18 21:35:38 2009 +0100
+
+    Fix build errors after making flash_get_info() non-static
+
+    Fix for these build problems:
+    error: static declaration of 'flash_get_info' follows non-static declaration
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit b4996d6b2140e5da7f1c346f37a67b19907b307a
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Feb 18 13:18:00 2009 +0100
+
+    ppc4xx: PCIe: Change 16GB inbound memory to 4GB
+
+    This patch fixes a problem recently seen on some 4xx platforms. For
+    example on Kilauea PCIe slot #0.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit f50fe4bd613c6d35a2c34055f02e9501dd6a9ad5
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Feb 18 14:05:37 2009 +0100
+
+    ppc4xx: Some more PMC405 coding-style cleanup
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 2f6eb9170bf91b72ea51dcea2a8b9c11b0e20bc5
+Author: Matthias Fuchs <matthias.fuchs@esd.eu>
+Date:	Sun Feb 15 22:27:47 2009 +0100
+
+    ppc4xx: Update PMC405 board support
+
+    This patch prepares the good old PMC405 board support for
+    upcoming PMC405V2 patches.
+
+    Signed-off-by: Matthias Fuchs <matthias.fuchs@esd-electronics.com>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit c553b5f4a0c77fc76e1d25e71c8aaa47657e2d6f
+Author: Matthias Fuchs <matthias.fuchs@esd.eu>
+Date:	Sun Feb 15 22:26:54 2009 +0100
+
+    ppc4xx: Cleanup PMC405 board support
+
+    This patch fixes coding style for PMC405 board support.
+    Also some unneeded features/code is removed.
+
+    Signed-off-by: Matthias Fuchs <matthias.fuchs@esd-electronics.com>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit b4e85d0f37b5b924fbf834867ad6d0b31b86f667
+Author: Ilya Yanok <yanok@emcraft.com>
+Date:	Thu Feb 5 04:08:20 2009 +0100
+
+    qong: changes to Dave/DENX Qong configuration
+
+    1. Changes to the default environment:
+      - "bootcmd" defined as "run flash_self"
+      - "saveenv" command removed from "update"
+      - "uboot" changed to "u-boot" (also in "load")
+      - "addmtd" variable defined (and added to all boot commands)
+    2. CONFIG_CMD_JFFS2 defined to enable "mtdparts" command
+    3. MTDIDS_DEFAULT and MTDPARTS_DEFAULT defined
+    4. CONFIG_SYS_CBSIZE changed from 256 to 512. That solves the problem
+    with truncated "bootargs" environment variable.
+
+    Signed-off-by: Ilya Yanok <yanok@emcraft.com>
+
+commit 5f0320108870e5d62983d1d5c13a2a087dddf686
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sun Feb 1 17:07:52 2009 +0100
+
+    common/console: avoid ifdef CONFIG_CONSOLE_MUX when it's possible
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit ec6f14994602276660f7264c6ab3b91ef1f7614d
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sun Feb 1 17:07:51 2009 +0100
+
+    common/console: coding style cleanup
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit daaf74f176b548dfd34a9990231f4189201d57ba
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Jan 29 20:02:23 2009 -0500
+
+    mpc8xx_pcmcia: move CONFIG_8xx out of .c file and into Makefile
+
+    Move the CONFIG_8xx mpc8xx_pcmcia.c protection out of the C file and
+    into the Makefile so we avoid pointless compiling of the file.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 7bd2722e890bc877a3c057d7ccddc80451c99939
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Jan 29 20:02:07 2009 -0500
+
+    disk: convert part_* files to COBJ-$(CONFIG_XXX) style
+
+    Move the CONFIG_XXX out of the part_XXX.c file and into Makefile to
+    avoid pointless compiles.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit f05fa9205e04986176dc7ab8b710bcb5fbe9f338
+Author: Petri Lehtinen <petri.lehtinen@inoi.fi>
+Date:	Thu Jan 29 10:35:40 2009 +0200
+
+    include/image.h: Ease grepping of image_* functions
+
+    Because the functions have been defined using macros, grepping for
+    their definitions is not possible. This patch adds the real function
+    names in comments.
+
+    Signed-off-by: Petri Lehtinen <petri.lehtinen@inoi.fi>
+    Acked-by: Mike Frysinger <vapier@gentoo.org>
+
+commit bdab39d358e63aa47f400a8a76b8d5f283842df3
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Jan 28 19:08:14 2009 -0500
+
+    rename CONFIG_CMD_ENV to CONFIG_CMD_SAVEENV
+
+    The CONFIG_CMD_ENV option controls enablement of the `saveenv` command
+    rather than a generic "env" command, or anything else related to the
+    environment.  So, let's make sure the define is named accordingly.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 8b0592b89e0f9f81c9e150c81d96f8a43e4d6101
+Author: Valeriy Glushkov <gvv@lstec.com>
+Date:	Fri Jan 23 20:02:17 2009 +0200
+
+    disable imls command if no flash is defined
+
+    Default CONFIG_CMD_IMLS must be disabled when CONFIG_SYS_NO_FLASH is defined
+
+    Signed-off-by: Valeriy Glushkov <gvv@lstec.com>
+
+commit 923aa48126259c13de95131203f1d28bfa5cb889
+Author: Rafal Jaworowski <raj@semihalf.com>
+Date:	Fri Jan 23 13:27:18 2009 +0100
+
+    API: Improve glue mid-layer of the API demo application.
+
+    - Extend ub_dev_read() and ub_dev_recv() so they return the length actually
+    read, which allows for better control and error handling (this introduces
+    additional error code API_ESYSC returned by the glue mid-layer).
+
+    - Clean up definitions naming and usage.
+
+    - Other minor cosmetics.
+
+    Note these changes do not touch the API proper, so the interface between
+    U-Boot and standalone applications remains unchanged.
+
+    Signed-off-by: Rafal Jaworowski <raj@semihalf.com>
+
+commit 44a94e596ba0f6d0951b165403c520bf55b1c56f
+Author: Rafal Jaworowski <raj@semihalf.com>
+Date:	Fri Jan 23 13:27:17 2009 +0100
+
+    API: Only output test data when reading was successful.
+
+    Signed-off-by: Rafal Czubak <rcz@semihalf.com>
+
+commit 7fb6c4f9b06c5539043c8bfc6565710b8090841d
+Author: Rafal Jaworowski <raj@semihalf.com>
+Date:	Fri Jan 23 13:27:16 2009 +0100
+
+    API: Provide syscall entry point for the ARM architecture.
+
+    Signed-off-by: Rafal Czubak <rcz@semihalf.com>
+    Acked-by: Rafal Jaworowski <raj@semihalf.com>
+
+commit b84d7d8f1e1066f810866304a16a3583f88e7c98
+Author: Rafal Jaworowski <raj@semihalf.com>
+Date:	Fri Jan 23 13:27:15 2009 +0100
+
+    API: Use stack pointer as API signature search hint in the glue layer.
+
+    De-hardcode range in RAM we search for the API signature. Instead use the stack
+    pointer as a hint to narrow down the range in which the signature could reside
+    (it is malloc'ed on the U-Boot heap, and is hoped to remain in some proximity
+    from stack area). Adjust PowerPC code in API demo to the new scheme.
+
+    Signed-off-by: Rafal Czubak <rcz@semihalf.com>
+    Signed-off-by: Rafal Jaworowski <raj@semihalf.com>
+
+commit 86b4bafdfaf669ede8fd99044abc7e27ea29b4f5
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Tue Feb 17 10:26:38 2009 +0100
+
+    TQM8260: fix locations of kernel and ramdisk images in flash
+
+    After introducing redundant environment the kernel images was
+    overlapping with environment.
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit e1ac387f4645499746856adc1aeaa9787da2eca6
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Thu Oct 30 16:50:14 2008 -0500
+
+    83xx: Add eSDHC support on 8379 EMDS board
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+
+commit 80522dc8369a89938369fbcee572e662373bc9a3
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Thu Oct 30 16:51:33 2008 -0500
+
+    85xx: Add eSDHC support for 8536 DS
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+
+commit 50586ef24ed5caf6ce5591df76f355009da2cd79
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Thu Oct 30 16:47:16 2008 -0500
+
+    Add support for the Freescale eSDHC found on 8379 and 8536 SoCs
+
+    This uses the new MMC framework
+
+    Some contributions by Dave Liu <daveliu@freescale.com>
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+
+commit 272cc70b211e945e4413122aa73868f6ada732a5
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Thu Oct 30 16:41:01 2008 -0500
+
+    Add MMC Framework
+
+    Here's a new framework (based roughly off the linux one) for managing
+    MMC controllers.  It handles all of the standard SD/MMC transactions,
+    leaving the host drivers to implement only what is necessary to
+    deal with their specific hardware.
+
+    This also hooks the infrastructure into the PowerPC board code
+    (similar to how the ethernet infrastructure now hooks in)
+
+    Some of this code was contributed by Dave Liu <daveliu@freescale.com>
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+
+commit 1de97f9856f697380cc504126ab92561ed238803
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Thu Oct 30 16:31:39 2008 -0500
+
+    Eliminated arch-specific mmc header requirement
+
+    The current MMC infrastructure relies on the existence of an
+    arch-specific header file.	This isn't necessary, and a couple
+    drivers were forced to implement dummy files to meet this requirement.
+    Instead, we move the stuff in those header files into a more appropriate
+    place, and eliminate the stubs and the #include of asm/arch/mmc.h
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+
+commit abb5466ccf4ce50f412d459586f4f4b81cb73ac3
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Thu Oct 30 16:21:00 2008 -0500
+
+    Convert mmc_init to mmc_legacy_init
+
+    This is to get it out of the way of incoming MMC framework
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+
+commit b2e2ed0233a5ef299361abec4fbdaefb63456eff
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Thu Oct 30 16:19:25 2008 -0500
+
+    Eliminate support for using MMC as memory
+
+    MMC cards are not memory, so we stop treating them that way.
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+
+commit e1be0d25ecf494ae81245ca438738ba839d6329b
+Author: Poonam_Aggrwal-b10812 <b10812@freescale.com>
+Date:	Sun Jan 4 08:46:38 2009 +0530
+
+    32bit BUg fix for DDR2 on 8572
+
+    This errata fix is required for 32 bit DDR2 controller on 8572.
+    May  also be required for P10XX20XX platforms
+
+    Signed-off-by: Poonam_Agarwal-b10812 <b10812@lc1106.zin33.ap.freescale.net>
+
+commit e0c4fac79d4d74572ddd43f75e7189cecca8d0ad
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Mon Feb 16 09:40:20 2009 -0600
+
+    TQM85xx: Fix a couple warnings in TQM8548 build
+
+    The ecm variable in sdram.c was being declared for all 8548, but only
+    used by specific 8548 boards, so we make that variable require those
+    specific boards, too
+
+    The nand code was using an index "i" into a table, and then re-using "i"
+    to set addresses for each upm.  However, then it relied on the old value
+    of i still being there to enable things.  Changed the second "i" to "j"
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+
+commit cf07a5baece0ecfc5284cfda8a4e68eaf92782f8
+Author: Wolfgang Grandegger <wg@grandegger.com>
+Date:	Wed Feb 11 18:38:26 2009 +0100
+
+    MPC85xx: TQM8548: workaround for erratum DDR 19 and 20
+
+    This patch adds the workaround for erratum DDR20 according to MPC8548
+    Device Errata document, Rev. 1: "CKE signal may not function correctly
+    after assertion of HRESET". Furthermore, the bug DDR19 is fixed in
+    processor version 2.1 and the work-around must be removed.
+
+    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
+
+commit 080408fdc71706adcb883d22125637c54f6010b1
+Author: Wolfgang Grandegger <wg@grandegger.com>
+Date:	Wed Feb 11 18:38:25 2009 +0100
+
+    MPC85xx: TQM8548: use cache for AG and BE variants
+
+    This patch makes accesses to the system memory cachable by removing the
+    caching-inhibited and guarded flags from the relevant TLB entries for
+    the TQM8548_BE and TQM8548_AG modules. FYI, the Freescale MPC85* boards
+    are configured similarly.
+
+    This results in a big averall performace improvement. TFTP downloads,
+    NAND Flash accesses, kernel boots, etc. are much faster.
+
+    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
+
+commit dc5f55d636d7bf21ba17758fac4b929ec4c059f2
+Author: Wolfgang Grandegger <wg@grandegger.com>
+Date:	Wed Feb 11 18:38:24 2009 +0100
+
+    MPC85xx: TQM8548_AG: add 1 GiB DDR2-SDRAM configuration
+
+    This patch add support for the 1 GiB DDR2-SDRAM on the TQM8548_AG
+    module.
+
+    Signed-off-by: Jens Gehrlein <sew_s@tqs.de>
+    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
+
+commit 88b0e88d186479349e5a2b771e82775109e10fb4
+Author: Wolfgang Grandegger <wg@grandegger.com>
+Date:	Wed Feb 11 18:38:23 2009 +0100
+
+    MPC85xx: TQM8548: fix SDRAM timing for 533 MHz
+
+    According to new TQM8548 timing specification:
+    Refresh Recovery: 34 -> 53 clocks
+    CKE pulse width:  1 -> 3 cycles
+    Window for four activities: 13 -> 14 cycles
+
+    Signed-off-by: Jens Gehrlein <sew_s@tqs.de>
+    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
+
+commit a865bcdac89278cac4dfc07dec8299403110499d
+Author: Wolfgang Grandegger <wg@grandegger.com>
+Date:	Wed Feb 11 18:38:22 2009 +0100
+
+    MPC85xx: TQM8548: add support for the TQM8548_AG module
+
+    The TQM8548_AG is a variant of the TQM8548 module with 1 GiB memory,
+    CAN and without PCI/PCI-X and RTC. U-Boot can be built for this module
+    with "$ make TQM8548_AG_config".
+
+    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
+
+commit ad7ee5d43b0db94079d56521dabca25674f28747
+Author: Wolfgang Grandegger <wg@grandegger.com>
+Date:	Wed Feb 11 18:38:21 2009 +0100
+
+    MPC85xx: TQM8548: add support for the TQM8548_BE module
+
+    The TQM8548_BE is a variant of the TQM8548 module with NAND and CAN
+    interface. With NAND support, the image is significantly larger and
+    TEXT_BASE is adjusted accordingly. U-Boot can be built for this
+    module with "$ make TQM8548_BE_config".
+
+    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
+
+commit a318234878c346e673b2ef8dc4b14b338fe7fc2b
+Author: Wolfgang Grandegger <wg@grandegger.com>
+Date:	Wed Feb 11 18:38:20 2009 +0100
+
+    MPC85xx: TQM85xx: make standard PCI/PCI-X configurable
+
+    The TQM8548_AG module does not have the standard PCI/PCI-X interface
+    connected but just the PCI Express interface . So far it was not
+    possible to disable it without disabling the complete PCI interface
+    (CONFIG_PCI) including PCI Express.
+
+    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
+
+commit 31ca9119c3186cec579b54d2a7a2b361b4d2b7bf
+Author: Wolfgang Grandegger <wg@grandegger.com>
+Date:	Wed Feb 11 18:38:19 2009 +0100
+
+    MPC85xx: TQM85xx: fix flash protection for boot loader
+
+    As the reset vector is located at 0xfffffffc, all flash sectors from the
+    beginning of the U-Boot binary to 0xffffffff must be protected. On the
+    TQM8548-AG having small sectors at the end of the flash it happened that
+    the last two sector were not protected and an "erase all" left an
+    un-bootable system behind:
+
+    Bank # 2: CFI conformant FLASH (32 x 16)  Size: 32 MB in 270 Sectors
+      AMD Standard command set, Manufacturer ID: 0xEC, Device ID: 0x257E
+      Erase timeout: 8192 ms, write timeout: 1 ms
+
+      FFFA0000 E RO   FFFC0000	 RO   FFFE0000	 RO   FFFE4000	 RO   FFFE8000	 RO
+      FFFEC000	 RO   FFFF0000	 RO   FFFF4000	 RO   FFFF8000 E      FFFFC000
+
+    The same bug seems to be in drivers/mtd/cfi_flash.c:flash_init() and many
+    board BSPs as well.
+
+    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
+
+commit a1c8a719262151f97119e76166043ee3da3f97b2
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Fri Feb 6 14:30:40 2009 -0600
+
+    86xx: Update CPU info output on bootup
+
+    - Update style of 86xx CPU information on boot to more closely
+      match 85xx boards
+    - Fix detection of 8641/8641D
+    - Use strmhz() to display frequencies
+    - Display L1 information
+    - Display L2 cache size
+    - Fixed CPU/SVR version output
+
+    == Before ==
+    Freescale PowerPC
+    CPU:
+	Core: E600 Core 0, Version: 0.2, (0x80040202)
+	System: Unknown, Version: 2.1, (0x80900121)
+	Clocks: CPU:1066 MHz, MPX: 533 MHz, DDR: 266 MHz, LBC: 133 MHz
+	L2: Enabled
+    Board: X-ES XPedite5170 3U VPX SBC
+
+    == After ==
+    CPU:   8641D, Version: 2.1, (0x80900121)
+    Core:  E600 Core 0, Version: 2.2, (0x80040202)
+    Clock Configuration:
+	   CPU:1066.667 MHz, MPX:533.333 MHz
+	   DDR:266.667 MHz (533.333 MT/s data rate), LBC:133.333 MHz
+    L1:    D-cache 32 KB enabled
+	   I-cache 32 KB enabled
+    L2:    512 KB enabled
+    Board: X-ES XPedite5170 3U VPX SBC
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+
+commit 22c00f8d7d454d77e759df58415d2d3f3d7e154c
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Thu Feb 5 11:25:24 2009 -0600
+
+    86xx: Update Global Utilities structure
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+
+commit 4ef630df773e45806d701bf5d25c328778bb4cde
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Thu Feb 5 11:25:25 2009 -0600
+
+    86xx: Reset update
+
+    Update the 86xx reset sequence to try executing a board-specific reset
+    function.  If the board-specific reset is not implemented or does not
+    succeed, then assert #HRESET_REQ.  Using #HRESET_REQ is a more standard
+    reset procedure than the previous method and allows all board
+    peripherals to be reset if needed.
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+
+commit edf0e2524a8c6a3e91c009c496a0aa0ae89cd8ab
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Tue Feb 10 23:53:40 2009 -0600
+
+    fsl-ddr: Allow system to boot if we have more than 4G of memory
+
+    Previously if we >=4G of memory and !CONFIG_PHYS_64BIT we'd report
+    an error and hang.	Instead of doing that since DDR is mapped in the
+    lowest priority LAWs we setup the DDR controller and the max amount
+    of memory we report back is what we can map (CONFIG_MAX_MEM_MAPPED)
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+    Acked-by: Becky Bruce <beckyb@kernel.crashing.org>
+
+commit 8d949aff38cfb4388cbd73876e77bcd06d601f20
+Author: Srikanth Srinivasan <srikanth.srinivasan@freescale.com>
+Date:	Wed Jan 21 17:17:33 2009 -0600
+
+    mpc85xx: Add support for the P2020
+
+    Added various p2020 processor specific details:
+    * SVR for p2020, p2020E
+    * immap updates for LAWs and DDR on p2020
+    * LAW defines related to p2020
+
+    Signed-off-by: Srikanth Srinivasan <srikanth.srinivasan@freescale.com>
+    Signed-off-by: Travis Wheatley <Travis.Wheatley@freescale.com>
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit cb69e4de8702e108324e1c40363f30ef6f2e2918
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Tue Feb 10 17:36:15 2009 -0600
+
+    85xx: print boot header info to distinquish 36-bit addr map on MPC8572 DS
+
+    Added some info that is printed out when we boot to distiquish if we
+    built MPC8572DS_config vs MPC8572DS_36BIT_config since they have
+    different address maps.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit feede8b07013b33fca8dd2a916b3ac86bf4d4c0a
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Fri Dec 5 20:10:22 2008 -0600
+
+    Fixup SGMII PHY ids in the device tree
+
+    The device tree's PHY addresses need to be fixed up if we're using the
+    SGMII Riser Card.
+
+    The 8572, 8536, and 8544 DS boards were modified to call this function.
+
+    Code idea taken from Liu Yu <yu.liu@freescale.com>
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+
+commit 5dc0cf68f8f101042997d75188081d8526d705ea
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Wed Feb 11 15:10:31 2009 -0600
+
+    Make some minor whitespace changes to eliminate line-wrapping
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+
+commit 9e56986a2b74d197f51eca70fad7b836b1900c4d
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Wed Feb 11 15:07:24 2009 -0600
+
+    Add eth_get_dev_by_index
+
+    This allows code to iterate through the ethernet devices
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+
+commit b67305120aaf268a6140125346678166d14f1f47
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Mon Feb 9 22:03:04 2009 -0600
+
+    85xx: Fix bug in device tree setup in 36-bit physical confg
+
+    In the 36-bit physical config for MPC8572DS when need the start address
+    of memory and it size to be kept in phys_*_t instead of a ulong since
+    we support >4G of memory in the config and ulong cant represent that.
+    Otherwise we end up seeing the memory node in the device tree reporting
+    back we have memory starting @ 0 and of size 0.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit ad97dce18445ff05bf326094e691a01aa95aa8dc
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Mon Feb 9 22:03:05 2009 -0600
+
+    85xx: Fix address map for 36-bit config of MPC8572DS
+
+    When we introduced the 36-bit config of the MPC8572DS board we had the
+    wrong PCI MEM bus address map.  Additionally, the change to the address
+    map exposes a small issue in our dummy read on the ULI bus.  We need
+    to use the new mapping functions to handle that read properly in the
+    36-bit config.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit f8523cb0815b2d3d2d780b7d49ca614105555f58
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Fri Feb 6 09:56:35 2009 -0600
+
+    85xx: Fix how we map DDR memory
+
+    Previously we only allowed power-of-two memory sizes and didnt
+    handle >2G of memory.  Now we will map up to CONFIG_MAX_MEM_MAPPED
+    and should properly handle any size that we can make in the TLBs
+    we have available to us
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit 1542fbdeec0d1e2a6df13189df8dcb1ce8802be3
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Fri Feb 6 09:56:34 2009 -0600
+
+    fsl-ddr: ignore memctl_intlv_ctl setting if only one DDR controller
+
+    If we only have one controller we can completely ignore how
+    memctl_intlv_ctl is set.  Otherwise other levels of code get confused
+    and think we have twice as much memory.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit b29dee3c906e9daaf6baf7772d2e15e26b8636b8
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Wed Feb 4 09:35:57 2009 -0600
+
+    85xx: Format cpu freq printing to handle 8 cores
+
+    Only print 4 cpu freq per line.  This way when we have 8 cores its a
+    bit more readable.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit 9704f9caf53f5cae547d8c5e1ae94aa4e57b160f
+Author: Abraham, Thomas <t-abraham@ti.com>
+Date:	Tue Oct 28 16:51:31 2008 +0530
+
+    USB: Remove LUN number from CDB
+
+    The LUN number is not part of the Command Descriptor Block (CDB) for scsi inquiry, request sense, test unit ready, read capacity and read10 commands. This patch removes the LUN number information from the CDB.
+
+    Signed-off-by: Thomas Abraham <t-abraham@ti.com>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit f3c0de636252f3a18654c8f9c6370a9574a7e755
+Author: Atin Malaviya <atin.malaviya@gmail.com>
+Date:	Tue Feb 3 15:17:10 2009 -0500
+
+    Added usbtty_configured() check. Fixed attribute(packed) warnings.
+
+    V3: Fixed line-wrap problem due to user error in mail!
+
+    Added usb_configured() checks in usbtty_puts() and usbtty_putc() to get around a hang
+    when usb is not connected and the user has set up multi-io (setenv stdout serial,usbtty etc).
+    Got rid of redundant __attribute__((packed)) directives that were causing warnings from gcc.
+
+    Signed-off-by: Atin Malaviya <atin.malaviya@gmail.com>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit e7de18afe8ecf96a51ef981d06066eeb6b1254e7
+Author: Guennadi Liakhovetski <lg@denx.de>
+Date:	Fri Feb 13 09:23:36 2009 +0100
+
+    i.MX31: Start the I2C clock on driver initialisation
+
+    i.MX31 powers on with most clocks running, so, after a power on this explicit
+    clock start up is not required. However, as Linux boots it disables most clocks
+    to save power. This includes the I2C clock. If we then soft reboot from Linux
+    the I2C clock stays off. This breaks the phycore, which has its environment in
+    I2C EEPROM. Fix the problem by explicitly starting the clock in I2C driver
+    initialisation routine.
+
+    Signed-off-by: Guennadi Liakhovetski <lg@denx.de>
+    Ack-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 15208ac9eae1c340c4bc11f70cbf5c9da78a57ba
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Feb 11 20:36:14 2009 -0500
+
+    i2c.h: drop i2c_reg_{read, write} hack for Blackfin parts
+
+    The Blackfin i2c driver has been rewritten thus the special ifdefs in the
+    common code are no longer needed.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit c2d9befa0b4695b89476fb5d259742c09afe243f
+Author: Heiko Schocher <hs@denx.de>
+Date:	Thu Feb 12 08:08:54 2009 +0100
+
+    82xx, mgcoge: fix compile error
+
+    With actual u-boot compiling the mgcoge port fails, because
+    since commit ba705b5b1a97b47388ed48858bef6bf7b6bfcd56 it is
+    necessary to define CONFIG_NET_MULTI.
+
+    Seems to me the mgcoge port is the only actual existing 8260
+    port who uses CONFIG_ETHER_ON_SCC, so no other 8260 port needed
+    to be fixed.
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+
+commit 9cacf4fc4035eabe9d9ae2a9a188c51a8027c91e
+Author: Dirk Eibach <eibach@gdsys.de>
+Date:	Mon Feb 9 08:18:34 2009 +0100
+
+    ppc4xx: Add README entry for CONFIG_PCI_DISABLE_PCIE
+
+    Signed-off-by: Dirk Eibach <eibach@gdsys.de>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 7369f0e384e2a831be13a7773a58242c9173fa9c
+Author: Carolyn Smith <carolyn.smith@tektronix.com>
+Date:	Thu Feb 12 06:13:44 2009 +0100
+
+    ppc4xx: Fix initialization of the SDRAM_CODT register
+
+    This fixes the initialization of the SDRAM_CODT register in the ppc4xx DDR2
+    initialization code. It also removes use of the SDRAM_CODT_FEEDBACK_RCV_SINGLE_END
+    and SDRAM_CODT_FEEDBACK_DRV_SINGLE_END #define's since they are reserved bits.
+
+    Signed-off-by: Carolyn Smith <carolyn.smith@tektronix.com>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit cef0efaf2fa55d1f25066cfb02bd984c27f9ca31
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Feb 11 09:29:33 2009 +0100
+
+    ppc4xx: Fix problem with board_eth_init() vs cpu_eth_init() on AMCC boards
+
+    Some AMCC eval boards do have a board_eth_init() function calling
+    pci_eth_init(). These boards need to call cpu_eth_init() explicitly now
+    with the new eth_init rework.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit c645012aefebb301e6907d148c6c8efacac049d4
+Author: Adam Graham <agraham@amcc.com>
+Date:	Mon Feb 9 13:18:12 2009 -0800
+
+    ppc4xx: Autocalibration can set RDCC to over aggressive value.
+
+    The criteria of the AMCC SDRAM Controller DDR autocalibration
+    U-Boot code is to pick the largest passing write/read/compare
+    window that also has the smallest SDRAM_RDCC.[RDSS] Read Sample
+    Cycle Select value.
+
+    On some Kilauea boards the DDR autocalibration algorithm can
+    find a large passing write/read/compare window with a small
+    SDRAM_RDCC.[RDSS] aggressive value of Read Sample Cycle Select
+    value "T1 Sample".
+
+    This SDRAM_RDCC.[RDSS] Read Sample Cycle Select value of
+    "T1 Sample" proves to be to aggressive when later on U-Boot
+    relocates into DDR memory and executes.
+
+    The memory traces on the Kilauea board are short so on some
+    Kilauea boards the SDRAM_RDCC.[RDSS] Read Sample Cycle Select
+    value of "T1 Sample" shows up as a potentially valid value for
+    the DDR autocalibratiion algorithm.
+
+    The fix is to define a weak default function which provides
+    the minimum SDRAM_RDCC.[RDSS] Read Sample Cycle Select value
+    to accept for DDR autocalibration.	The default will be the
+    "T2 Sample" value.	A board developer who has a well defined
+    board and chooses to be more aggressive can always provide
+    their own board specific string function with the more
+    aggressive "T1 Sample" value or stick with the default
+    minimum SDRAM_RDCC.[RDSS] value of "T2".
+
+    Also put in a autocalibration loop fix for case where current
+    write/read/compare passing window size is the same as a prior
+    window size, then in this case choose the write/read/compare
+    result that has the associated smallest RDCC T-Sample value.
+
+    Signed-off-by: Adam Graham <agraham@amcc.com>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 2ede879fcb67470524847bb4fc8972651bb46184
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Feb 11 09:37:12 2009 +0100
+
+    ppc4xx: Fix problem with CONFIG_MAX_MEM_MAPPED in include/asm-ppc/config.h
+
+    CONFIG_SDRAM_PPC4xx_IBM_DDR2 is not set when include/asm-ppc/config.h is
+    included. So for katmai, CONFIG_MAX_MEM_MAPPED will get set to 256MB.
+
+    It makes perfect sense to set CONFIG_MAX_MEM_MAPPED to 2GB for all PPC4xx
+    boards right now.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit f15c6515fc23f83c51f3de272ca23d86b80e81b1
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Thu Feb 12 00:08:39 2009 +0100
+
+    Coding style cleanup; update CHANGELOG
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit 5fc56b907d993260b9ebdb137af66fe69635ae9e
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Fri Jan 30 16:36:40 2009 -0600
+
+    Add feature-removal-schedule.txt
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+
+commit 255d28e1642e8fc32a6753226be1a96b481ce111
+Author: Heiko Schocher <hs@denx.de>
+Date:	Tue Feb 10 09:32:38 2009 +0100
+
+    8xx serial, smc: Coding-Style cleanup serial SMC driver
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+
+commit 2b3f12c214346508cae3f1245808c1ca54c81fdd
+Author: Heiko Schocher <hs@denx.de>
+Date:	Tue Feb 10 09:31:47 2009 +0100
+
+    8xx serial, smc: add configurable SMC Rx buffer len
+
+    This patch adds the configuration option CONFIG_SYS_SMC_RXBUFLEN.
+    With this option it is possible to allow the receive
+    buffer for the SMC on 8xx to be greater then 1. In case
+    CONFIG_SYS_SMC_RXBUFLEN == 1 this driver works as the
+    old version.
+
+    When defining CONFIG_SYS_SMC_RXBUFLEN also
+    CONFIG_SYS_MAXIDLE must be defined to setup the maximum
+    idle timeout for the SMC.
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+
+commit e915f8bb73d74178bc21d3a457959883b1afd1c0
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Feb 5 21:04:36 2009 -0500
+
+    common/{hush, kgdb, serial}.c: build by COBJS-$(...) in Makefile
+
+    Move global '#ifdef CONFIG_xxx .... #endif' out of the .c files and into
+    the COBJS-$(CONFIG_xxx) in the Makefile.  Also delete unused var in kgdb
+    code in the process.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit ab76e9848a1f4db64d14233741d739a3b3360c93
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Feb 5 21:04:50 2009 -0500
+
+    bzip2: move ifdef handling to Makefile COBJS-$(...)
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit ae0b05df04e1cc65c5ad19ccd362f4be82df7316
+Author: Jerry Van Baren <gvb.uboot@gmail.com>
+Date:	Thu Feb 5 22:18:02 2009 -0500
+
+    Fix whitespace damage: double space changed to a tab
+
+    At some point an intentional double space at the end of the sentence
+    got changed into a tab in the GPL header line:
+     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+    This patch fixes the damage.
+
+    Signed-off-by: Gerald Van Baren <vanbaren@cideas.com>
+
+commit 4f975678de995b55749d5e84590c268972a7c835
+Author: Heiko Schocher <hs@denx.de>
+Date:	Tue Feb 10 09:53:29 2009 +0100
+
+    cfi: make flash_get_info() non static
+
+    If on your board is more than one flash, you must know
+    the size of every single flash, for example, for updating
+    the DTS before booting Linux. So make this function
+    flash_get_info() extern, and you can have all info
+    about your flashes.
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 86321fc1128c93a10ac4afb9d317b0df8ece0f9e
+Author: Ben Warren <biggerbadderben@gmail.com>
+Date:	Thu Feb 5 23:58:25 2009 -0800
+
+    net: removed board-specific CONFIGs from MPC5xxx FEC driver
+
+    Added new CONFIG options for the three type of MAC-PHY interconnect and
+    applied them all relevant board config files
+
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 638ed3e296e70fab286d157b7adedaaa4a09a474
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Feb 5 21:04:47 2009 -0500
+
+    net/sntp.c: move ifdef into Makefile COBJS-$(...)
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 9e5be8214ba751436e57c3be044bf6dccb9a6687
+Author: Andy Fleming <afleming@freescale.com>
+Date:	Tue Feb 3 18:26:41 2009 -0600
+
+    tsec: Fix a bug in soft-resetting
+
+    SOFT_RESET must be asserted for at least 3 TX clocks.  Usually, that's about 30
+    clock cycles, so it's been mostly working.	But we had no guarantee, and at
+    slower bitrates, it's just over a microsecond (over 1000 clock cycles).  This
+    enforces a 2 microsecond gap between assertion and deassertion.
+
+    Signed-off-by: Andy Fleming <afleming@freescale.com>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 09fcc8b5d86903b76e7e4d1d879d6f4bca25c27b
+Author: Simon Munton <simon@nidoran.m5data.com>
+Date:	Mon Feb 2 09:44:08 2009 +0000
+
+    Fix 100Mbs ethernet operation on sh7763 based boards
+
+    100Mbs ethernet does not work on sh7763 chips due to the wrong value being
+    used in the GECMR register. Following diff fixes the problem
+
+    Signed-off-by: Simon Munton	<simon@nidoran.m5data.com>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 2bc2a8f6dc9fdda465317da59474e65c24a398a2
+Author: ksi@koi8.net <ksi@koi8.net>
+Date:	Fri Feb 6 16:27:55 2009 -0800
+
+    Fix MPC8260 with ethernet on SCC
+
+    This fixes MPC8260 compilation with ethernet on SCC. Probably was a
+    typo or something...
+
+    Signed-off-by: Sergey Kubushyn <ksi@koi8.net>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit ae5d8f613cec1a6af7bf1fc9c42a3b856f021023
+Author: Heiko Schocher <hs@denx.de>
+Date:	Fri Jan 30 12:56:15 2009 +0100
+
+    82xx serial, smc: Coding-Style cleanup serial SMC driver
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+
+commit c92fac91a06c60f874c605e3ca80dd407c1caaa7
+Author: Heiko Schocher <hs@denx.de>
+Date:	Fri Jan 30 12:55:38 2009 +0100
+
+    82xx serial, smc: add configurable SMC Rx buffer len
+
+    This patch adds the configuration option CONFIG_SYS_SMC_RXBUFLEN.
+    With this option it is possible to allow the receive
+    buffer for the SMC on 82xx to be greater then 1. In case
+    CONFIG_SYS_SMC_RXBUFLEN == 1 this driver works as the
+    old version.
+
+    When defining CONFIG_SYS_SMC_RXBUFLEN also
+    CONFIG_SYS_MAXIDLE must be defined to setup the maximum
+    idle timeout for the SMC.
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+
+commit bced7ccefa08512c54a6d146658ff7dbc33d5dfe
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Fri Feb 6 08:08:06 2009 -0600
+
+    ppc: Fix roll over bug in flush_cache()
+
+    If we call flush_cache(0xfffff000, 0x1000) it would never
+    terminate the loop since end = 0xffffffff and we'd roll over
+    our counter from 0xfffffe0 to 0 (assuming a 32-byte cache line)
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit 87c9063963561d3d01064be34d0c30855a56587b
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Thu Feb 5 20:40:58 2009 -0600
+
+    ppc: Move CONFIG_MAX_MEM_MAPPED to common config.h
+
+    Moved CONFIG_MAX_MEM_MAPPED to the asm/config.h so its kept consistent
+    between the two current users (lib_ppc/board.c, 44x SPD DDR2).
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+    Acked-by: Stefan Roese <sr@denx.de>
+
+commit 47d41cc3a11a03c6d56146d056145df73f47eb50
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Thu Feb 5 20:40:57 2009 -0600
+
+    Add an architecture specific config.h for common defines
+
+    We have common defines that we duplicate in various ways.  Having an
+    arch specific config.h gives us a common location for those defines.
+
+    Eventually we should be able to replace this when we have proper
+    Kconfig support.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit 4c78d4a6c01621721b732418e1c6da684a56bbb1
+Author: Becky Bruce <beckyb@kernel.crashing.org>
+Date:	Tue Feb 3 18:10:56 2009 -0600
+
+    mpc8641hpcn: Change PCI MEM pci bus address
+
+    Now that the rest of u-boot can support it, change the PCI bus
+    address of the PCI MEM regions from 0x80000000 to 0xc0000000,
+    and use the same bus address for both PCI1 and PCI2.  This will
+    maximize the amount of PCI address space left over to map RAM
+    on systems with large amounts of memory.
+
+    Signed-off-by: Becky Bruce <beckyb@kernel.crashing.org>
+
+commit 1785dbeed43599eed1d8875673c96912cd770141
+Author: Becky Bruce <beckyb@kernel.crashing.org>
+Date:	Tue Feb 3 18:10:55 2009 -0600
+
+    drivers/block/ahci: Fix pci mapping bug
+
+    The code assumes that the pci bus address and the virtual
+    address used to access a region are the same, but they might
+    not be.  Fix this assumption.
+
+    Signed-off-by: Becky Bruce <beckyb@kernel.crashing.org>
+
+commit d591a80e74091e7a0658d165721e6c7de2ef0bcd
+Author: Becky Bruce <beckyb@kernel.crashing.org>
+Date:	Tue Feb 3 18:10:54 2009 -0600
+
+    MPC8641HPCN: Enable CONFIG_ADDR_MAP
+
+    Signed-off-by: Becky Bruce <beckyb@kernel.crashing.org>
+
+commit 49f46f3bf08aaf7b1db131a1082f1e603bb7a94b
+Author: Becky Bruce <beckyb@kernel.crashing.org>
+Date:	Tue Feb 3 18:10:53 2009 -0600
+
+    mpc8641hpcn: Clean up PCI mapping concepts
+
+    Clean up PCI mapping concepts in the 8641 config - rename _BASE
+    to _BUS, as it's actually a PCI bus address, separate virtual
+    and physical addresses into _VIRT and _PHYS, and use each
+    appopriately.
+
+    Signed-off-by: Becky Bruce <beckyb@kernel.crashing.org>
+
+commit c9315e6b4f244981de0b2eaaa29a7838a165b494
+Author: Becky Bruce <beckyb@kernel.crashing.org>
+Date:	Tue Feb 3 18:10:52 2009 -0600
+
+    mpc86xx: Add support to populate addr map based on BATs
+
+    If CONFIG_ADDR_MAP is enabled, update the address map
+    whenever we write a bat.
+
+    Signed-off-by: Becky Bruce <beckyb@kernel.crashing.org>
+
+commit d35ae5a938679bd7e18167faf79d0fb3c6639b51
+Author: Becky Bruce <beckyb@kernel.crashing.org>
+Date:	Tue Feb 3 18:10:51 2009 -0600
+
+    powerpc: Move duplicated BAT defines to mmu.h
+
+    The BAT fields are architected; there's no need for these to be in
+    cpu-specific files.  Drop the duplication and move these to
+    include/asm-ppc/mmu.h.  Also, remove the BL_xxx defines that were only
+    used by the alaska board, and switch to using the BATU_BL_xxx defines
+    used by all the other boards.  The BL_ defines previously in use
+    had to be shifted into the proper position for use, which was inefficient.
+
+    Signed-off-by: Becky Bruce <beckyb@kernel.crashing.org>
+
+commit 6e61fae4d360a1380b63e7d007b31477e366bcce
+Author: Becky Bruce <beckyb@kernel.crashing.org>
+Date:	Tue Feb 3 18:10:50 2009 -0600
+
+    drivers/pci: Create pci_map_bar function
+
+    It is no longer always true that the pci bus address can be
+    used as the virtual address for pci accesses.  pci_map_bar()
+    is created to return the virtual address for a pci region.
+
+    Signed-off-by: Becky Bruce <beckyb@kernel.crashing.org>
+
+commit 2ecca3401775b125c3b9ff65766befb23989414b
+Author: Becky Bruce <beckyb@kernel.crashing.org>
+Date:	Tue Feb 3 18:10:49 2009 -0600
+
+    mpc8641hpcn: Set up outbound pci windows before inbound
+
+    Because the inbound pci windows are mapped generously, set up
+    the more specific outbound windows first.  This way, when we
+    search the pci regions for something, we will hit on the more
+    specific region.  This can actually be a problem on systems
+    with large amounts of RAM.
+
+    Signed-off-by: Becky Bruce <beckyb@kernel.crashing.org>
+
+commit b81b773ead0687114dc8a800f99ea6e504447739
+Author: Becky Bruce <beckyb@kernel.crashing.org>
+Date:	Mon Feb 2 16:34:52 2009 -0600
+
+    mpc8641hpcn: Use physical address in flash banks defintion
+
+    If the VA and PA of the flash aren't the same, the banks list
+    should be initialized to hold the physical address.  Correct this.
+
+    Signed-off-by: Becky Bruce <beckyb@kernel.crashing.org>
+
+commit 0d19f6c8cbe71b9e6d8c6bd6742ed2551e918870
+Author: Ilya Yanok <yanok@emcraft.com>
+Date:	Tue Feb 10 00:22:31 2009 +0100
+
+    qong: support for Dave/DENX QongEVB-LITE board
+
+    This patch adds support for Dave/DENX QongEVB-LITE i.MX31-based board.
+
+    Signed-off-by: Ilya Yanok <yanok@emcraft.com>
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 62cbc408f52fc9a5eb849e0b882c504780c9d183
+Author: Ilya Yanok <yanok@emcraft.com>
+Date:	Mon Feb 9 18:45:28 2009 +0100
+
+    dnet: driver for Dave DNET ethernet controller
+
+    Driver for Dave DNET ethernet controller (used on Dave/DENX
+    QongEVB-LITE board).
+
+    Signed-off-by: Ilya Yanok <yanok@emcraft.com>
+    Acked-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 2d43e873a29ca4959ba6a30fc7fb396d3fd0dccf
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Fri Feb 6 09:49:32 2009 -0600
+
+    pci: give preference to non-PCI_REGION_SYS_MEMORY regions when matching
+
+    When we search for an address match in pci_hose_{phys_to_bus,bus_to_phys}
+    we should give preference to memory regions that aren't system memory.
+
+    Its possible that we have over mapped system memory in the regions and
+    we want to avoid depending on the order of the regions.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit ff4e66e93c1ad47644be3b4ffd6a46e1ce9b6612
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Fri Feb 6 09:49:31 2009 -0600
+
+    pci: Rename PCI_REGION_MEMORY to PCI_REGION_SYS_MEMORY for clarity
+
+    The PCI_REGION_MEMORY and PCI_REGION_MEM are a bit to similar and
+    can be confusing when reading the code.
+
+    Rename PCI_REGION_MEMORY to PCI_REGION_SYS_MEMORY to clarify its used
+    for system memory mapping purposes.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit 54dc517328709c204a9cbf7a253d9f8e6c4b26ec
+Author: Ilya Yanok <yanok@emcraft.com>
+Date:	Sun Feb 8 00:59:43 2009 +0300
+
+    mx31: add GPIO registers definitions
+
+    Added definitions for i.MX31 processor GPIO registers.
+
+    Signed-off-by: Ilya Yanok <yanok@emcraft.com>
+
+commit 8da601280a8acbc3385784780ed35130e53812f1
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Wed Feb 4 13:47:22 2009 -0600
+
+    NAND: Add timeout for reset command
+
+    Without the timeout present an infinite loop can occur if the
+    NAND device is broken or not present.
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit 10dc6a9bef73d7d4cb25b3fde27ee91f8484b126
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Wed Feb 4 13:39:40 2009 -0600
+
+    NAND: Silence warning when CONFIG_SYS_NAND_QUIET_TEST
+
+    Commit cfa460adfdefcc30d104e1a9ee44994ee349bb7b removed support
+    for disabling the "No NAND device found!!!" warning when
+    CONFIG_SYS_NAND_QUIET_TEST was defined.  This re-adds support
+    for silencing the warning.
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit ad09ab2e3ac28f304372eceb4a5cb4d24e102a13
+Author: Valeriy Glushkov <gvv@lstec.com>
+Date:	Mon Jan 19 16:32:59 2009 +0200
+
+    NAND: Fixed invalid pointers to static relocated chip names
+
+    Dear Wolfgang,
+
+    You are right, the patch was ugly.
+    The new one seems to be better.
+
+    Signed-off-by: Valeriy Glushkov <gvv@lstec.com>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit e7deec1bf6fa3b3a21cd8d14fe2a909a42efc9d8
+Author: Nishanth Menon <nm@ti.com>
+Date:	Mon Feb 2 18:20:12 2009 -0600
+
+    ARM:OMAP3:Zoom1: Add nand unlock option
+
+    Enable NAND_UNLOCK option for unlocking nand for
+    erase/write operations
+
+    Signed-off-by: Nishanth Menon <nm@ti.com>
+
+commit 5a9427dc9b8438759db3f67a1e547062f76eb18d
+Author: derek@siconix.com <derek@siconix.com>
+Date:	Mon Jan 26 14:08:17 2009 -0700
+
+    env_nand: fix env memory release
+
+    This fixes a bug that tmp environment memory not being released.
+
+    Signed-off-by: Derek Ou <dou@siconix.com>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit 05fd88776419df59e7f37bac063a209409dd801d
+Author: Guennadi Liakhovetski <lg@denx.de>
+Date:	Fri Feb 6 10:37:45 2009 +0100
+
+    ARM: remove unused variable
+
+    The "size" variable in start_armboot() in lib_arm/board.c is only really
+    used in "#ifndef CONFIG_SYS_NO_FLASH" case, and even there it can be
+    eliminated (thanks to Jean-Christophe PLAGNIOL-VILLARD for a suggestion.)
+
+    Signed-off-by: Guennadi Liakhovetski <lg@denx.de>
+
+commit 6989e4f546d960a407dd5425f800dff9751c8132
+Author: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+Date:	Thu Feb 5 09:33:50 2009 -0500
+
+    Coldfire: M527x: Add missing GPIO register address defines
+
+    Add missing GPIO registers address definition for Coldfire M5271.
+
+    Signed-off-by: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+
+commit c4ff77f5e6c3a01610ce97434c0d59acb1476f95
+Author: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+Date:	Fri Jan 23 14:42:58 2009 -0500
+
+    Coldfire: mcfmii: Allow non-autonegotiating PHYs to use mii command
+
+    Modified mii_init to support boards with PHYs that are not set to
+    autonegotiate, but still want to use u-boot's mii commands to probe
+    the smi bus. Such PHYs will not set the Autonegotiate-done bit.
+
+    Signed-off-by: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+
+commit 92d3e6e0ffcbb7224c83104f8d87b5b4bf39a38f
+Author: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+Date:	Fri Jan 23 11:44:30 2009 -0500
+
+    Coldfire: Applied baudrate formula of serial_init to serial_setbrg
+
+    Applied the patch for baudrate divider value truncation for
+    serial_init to serial_setbrg as well.
+
+    Signed-off-by: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+
+commit 8706ef378f2db1ef65b9c2f909561f23e3dc2148
+Author: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+Date:	Fri Jan 23 14:07:05 2009 -0500
+
+    Coldfire: M5271EVB: Board header update (dependencies)
+
+    Cleanup for M5271EVB:
+    Added clarification on the use of CONFIG_SYS_CLOCK.
+    Modified to use u-boot's HUSH parser.
+    Cleanup on environment settings.
+    Removed compiler warning by defining CONFIG_SYS_CS0_*
+
+    Dependencies:
+    Added the use of CONFIG_SYS_MCF_SYNCR for clock multiplier.
+    This depends on a patch to include/asm-m68k/m5271.h
+    that defines the multiplier and divider ratios.
+
+    Removed the definition of CONFIG_SYS_FECI2C.
+    This depends on a patch that removes the use of it in
+    cpu/mcf52x2/cpu_init.c
+
+    Signed-off-by: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+
+commit e0db344fabfeb4f9649846f94838f51172f6a1f6
+Author: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+Date:	Thu Jan 29 14:36:06 2009 -0500
+
+    Coldfire: M5271: Allow board header file to specify clock multiplier
+
+    M5271 dynamic clock multiplier. It is currently fixed at 100MHz.
+
+    Allow the board header file to set their own multiplier and divider.
+    Added the #define for the multiplier and divider to the cpu header file.
+
+    Signed-off-by: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+
+commit d1ef25dd81c79dcfad5c2ff0162b1bea21d04bc3
+Author: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+Date:	Fri Jan 23 10:47:13 2009 -0500
+
+    Coldfire: M5271EVB: Remove usage of CONFIG_SYS_FECI2C
+
+    Discontinue the use of CONFIG_SYS_FECI2C (only used by M5271EVB).
+    Use read-modify-write to activate the FEC pins without disabling I2C.
+
+    Signed-off-by: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+
+commit ee73cc59ab904976af3c33b454fc84f78618b2d1
+Author: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+Date:	Fri Jan 23 09:45:34 2009 -0500
+
+    Coldfire: cmd_bdinfo cleanup
+
+    CONFIG_M68K bdinfo cleanup:
+
+    Fixed compiler warning about baudrate printing.
+    format '%d' expects type 'int', but argument 2 has type 'long unsigned int'.
+
+    Added printing of "cpufreq"
+
+    Signed-off-by: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+
+commit 4ffc39050aa46ed8a3d29732293dff769e54fffa
+Author: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+Date:	Fri Jan 23 09:27:00 2009 -0500
+
+    Coldfire: Fix half-baud UART by adding M5271 to Coldfire v2 core list
+
+    Added the CONFIG_M5271 to the list of Coldfire V2 processor. This
+    was causing the bus clock (not CPU clock) to be declared twice as
+    fast as it actually is. This causes UARTS to operate at half the
+    specified baudrate.
+
+    Signed-off-by: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+
+commit 59d1bda7f92c8a28c3aba94e48063749d425949f
+Author: Dirk Eibach <eibach@gdsys.de>
+Date:	Tue Feb 3 15:15:21 2009 +0100
+
+    ppc4xx: Make PCIE support selectable
+
+    On some platforms PCIE support is not required, but would be included
+    because the cpu supports it. To reduce fooprint it is now configurable
+    via CONFIG_PCI_DISABLE_PCIE.
+
+    Signed-off-by: Dirk Eibach <eibach@gdsys.de>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit b129eff5ede394cc1faeb6dbf6a987e91abce552
+Author: Matthias Fuchs <matthias.fuchs@esd-electronics.com>
+Date:	Tue Feb 3 22:13:16 2009 +0100
+
+    ppc4xx: Only fixup opb attached UARTs
+
+    This patch updates the fdt UART clock fixup code to
+    only touch CPU internal UARTs on 4xx systems.
+    Only these UARTs are definitely clocked by gd->uart_clk.
+
+    Signed-off-by: Matthias Fuchs <matthias.fuchs@esd-electronics.com>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 4b7e3d045cc82f7f7b6f3a19b54a814da36ac52c
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Jan 13 11:00:29 2009 -0500
+
+    Blackfin: move default boot SPI CS to common code
+
+    Move the default SPI CS that we boot from into common code so that it can
+    be used in other SPI drivers and environment settings.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit f790ef6ff12381cb0e43de54fb2b0f1204ad8ed6
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Dec 10 12:33:54 2008 -0500
+
+    Blackfin: dynamically update UART speed when initializing
+
+    Previously, booting over the UART required the baud rate to be known ahead
+    of time.  Using a bit of tricky simple math, we can calculate the new board
+    rate based on the old divisors.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Signed-off-by: Robin Getz <rgetz@blackfin.uclinux.org>
+
+commit 97f265f14f23050f3cb997f617f3a6917b843ea2
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Dec 9 17:21:08 2008 -0500
+
+    Blackfin: add support for fast SPI reads with Boot ROM
+
+    Newer Blackfin boot roms support using the fast SPI read command rather than
+    just the slow one.	If the functionality is available, then use it.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 67619982bfc5cd62710a48e3cbffc304cb78c341
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 21:46:52 2008 -0400
+
+    Blackfin: check for reserved settings in DDR MMRs
+
+    Some bits of the DDR MMRs should not be set.  If they do, bad things may
+    happen (like random failures or hardware destruction).
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 622a8dc0958dd599743348ea94eb10b9d0be8ae6
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 21:54:00 2008 -0400
+
+    Blackfin: set default voltage levels for BF538/BF539 parts
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 09dc6b0bbd1d5e39cdddeebc059f9a75630e4f6f
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sun Jun 1 01:29:57 2008 -0400
+
+    Blackfin: use on-chip syscontrol() rom function when available
+
+    Newer Blackfin's have an on-chip rom with a syscontrol() function that needs
+    to be used to properly program the memory and voltage settings as it will
+    include (possibly critical) factory tested bias values.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit e1fb6d0d52fbe3fbc1a4c651dacf11e9c1417f63
+Author: Stefan Roese <sr@denx.de>
+Date:	Thu Feb 5 11:44:52 2009 +0100
+
+    cfi_flash: Fix typo in cfi_flash.c
+
+    Patch "flash/cfi_flash: Use virtual sector start address, not phys"
+    introduced a small typo and compilation warning for systems with CFI
+    legacy support (e.g. hcu4). This patch fixes it.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 28745db969b72693754991c838f68a7fb4a8b1ab
+Author: Stefan Roese <sr@denx.de>
+Date:	Thu Jan 29 11:21:38 2009 +0100
+
+    jedec_flash: Only use manufacturer defines from common flash.h
+
+    This patch removes the double defined manufacturer defines from
+    jedec_flash.c. Since the common defines in flash.h are 32bit
+    we now need the (16) cast. This patch also removes the compilation
+    warning (e.g. seen on hcu5):
+
+    ./MAKEALL hcu5
+    Configuring for hcu5 board...
+    jedec_flash.c:219: warning: large integer implicitly truncated to unsigned type
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit ec21d5cfcb6b4e7fcdd5c6e926e1a824900706f2
+Author: Stefan Roese <sr@denx.de>
+Date:	Thu Feb 5 11:25:57 2009 +0100
+
+    cfi_flash: Silence compilation warning
+
+    Patch "flash/cfi_flash: Use virtual sector start address, not phys"
+    introduced a small compilation warning. This patch fixes it.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 09ce9921a7d8b1ce764656b14b42217bbf4faa38
+Author: Becky Bruce <beckyb@kernel.crashing.org>
+Date:	Mon Feb 2 16:34:51 2009 -0600
+
+    flash/cfi_flash: Use virtual sector start address, not phys
+
+    include/flash.h was commented to say that the address in
+    flash_info->start was a physical address.  However, from u-boot's
+    point of view, and looking at most flash code, it makes more
+    sense for this to be a virtual address.  So I corrected the
+    comment to indicate that this was a virtual address.
+
+    The only flash driver that was actually treating the address
+    as physical was the mtd/cfi_flash driver.  However, this code
+    was using it inconsistently as it actually directly dereferenced
+    the "start" element, while it used map_physmem to get a
+    virtual address in other places.  I changed this driver so
+    that the code which initializes the info->start field calls
+    map_physmem to get a virtual address, eliminating the need for
+    further map_physmem calls.	The code is now consistent.
+
+    The *only* place a physical address should be used is when defining the
+    flash banks list that is used to initialize the flash_info struct,
+    usually found in the board config file.
+
+    Signed-off-by: Becky Bruce <beckyb@kernel.crashing.org>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 657f2062d8e17ebf4a55f52c9e71c07c0c94c779
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Wed Feb 4 09:42:20 2009 +0100
+
+    Fix compiler warning
+
+    (shows up only when DEBUG is enabled)
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit 47832cd15ae02fb6fde8ebed5b272f85775f2ceb
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Oct 6 03:45:55 2008 -0400
+
+    Blackfin: update anomaly lists
+
+    Update the anomaly lists to match latest anomaly sheets.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 70a4da45e16b72e8e5b0baaecdaee9be8619647d
+Author: Ralph Kondziella <rk@argos-messtechnik.de>
+Date:	Mon Jan 26 12:34:36 2009 -0700
+
+    ADS5121 Add PATA support
+
+    Original patch from Ralph Kondziella
+    plus clean up by Wolfgang Denk
+    plus changes by John Rigby
+	use ips clock not lpc
+	port forward to current u-boot release
+
+    Signed-off-by: Ralph Kondziella <rk@argos-messtechnik.de>
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+    Signed-off-by: John Rigby <jrigby@freescale.com>
+
+commit abfbd0ae4967df18102345db4f4b529a13da107b
+Author: Martha Marx <mmarx@silicontkx.com>
+Date:	Mon Jan 26 10:45:07 2009 -0700
+
+    ADS5121 Add IC Ident Module (IIM) support
+
+    IIM (IC Identification Module) is the fusebox for the mpc5121.
+    Use #define CONFIG_IIM to turn on the clock for this module
+    use #define CONFIG_CMD_FUSE to add fusebox commands.
+    Fusebox commands include the ability to read
+    the status, read the register cache, override the register cache,
+    program the fuses and sense them.
+
+    Signed-off-by: Martha Marx <mmarx@silicontkx.com>
+    Signed-off-by: John Rigby <jrigby@freescale.com>
+
+commit 14d19cd1bce9a24b1335598f1568140f4950e4d9
+Author: John Rigby <jrigby@freescale.com>
+Date:	Fri Jan 23 10:33:15 2009 -0700
+
+    ADS5121 Fix rev2 silicon pci iopad config
+
+    Reset config is not correct
+
+    Signed-off-by: John Rigby <jrigby@freescale.com>
+
+commit 4c154252c480b13f69ce1b71a9530b0515da76a6
+Author: John Rigby <jrigby@freescale.com>
+Date:	Wed Nov 19 13:57:34 2008 -0700
+
+    ADS5121 DIU Add diu_bmp_addr env
+
+    Add support for using a bmp other than
+    FSL_Logo_BMP for the DIU splash screen.
+
+    Can now set the env var "diu_bmp_addr" to
+    the address of a BMP in flash to use instead
+    of the default FSL_Logo_BMP.
+
+    Signed-off-by: Martha Marx <mmarx@silicontkx.com>
+    Signed-off-by: John Rigby <jrigby@freescale.com>
+
+commit 92c20fbd3a7788c1a154f50a3f44f28a7763f99a
+Author: John Rigby <jrigby@freescale.com>
+Date:	Thu Oct 30 16:39:35 2008 -0600
+
+    ADS5121 DIU Make inclusion of FSL logo optional
+
+    Make inclusion of FSL logo optional and
+    turn it off by default.
+
+    Signed-off-by: John Rigby <jrigby@freescale.com>
+
+commit bd99ec149abe94e7f6b2bda4766d701b4005053f
+Author: Remy Bohmer <linux@bohmer.net>
+Date:	Sun Feb 1 12:27:53 2009 +0100
+
+    Compile warning fix in onenand_uboot.h
+
+    Regression since merge window after 2009.01
+
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit a270d1e7295c3d829f42c0480117941dfc1c6477
+Author: Stefan Roese <sr@denx.de>
+Date:	Thu Jan 29 06:33:55 2009 +0100
+
+    USB: Add EHCI support for VCT EHCI controller (really with driver now)
+
+    Somehow I missed the real driver part in my last patch version. This patch
+    now adds the driver.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 716ebf436c9e43df6740e0172f6b2a81ddbf1b8e
+Author: Cliff Cai <cliff.cai@analog.com>
+Date:	Sat Nov 29 18:22:38 2008 -0500
+
+    Blackfin: add driver for on-chip MMC/SD controller
+
+    This is a port of the Linux Blackfin on-chip SDH driver to U-Boot.
+
+    Signed-off-by: Cliff Cai <cliff.cai@analog.com>
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 6e87ea0ca951465eba144ab2e6dba6fb507737a2
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 22:47:34 2008 -0400
+
+    Blackfin: add port muxing for BF51x SPI
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit fc68f9f85959664d528daea2aef5ef54974331ce
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Jan 6 06:16:19 2009 -0500
+
+    Blackfin: output booting source when booting
+
+    Knowing the booting source of the part is useful, especially when the part
+    can switch dynamically between sources.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 8df3ce0f49c37947800ac7c84e751499882619fc
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Dec 11 06:30:46 2008 -0500
+
+    Blackfin: set default CONFIG_ENV_SPI_CS based on bootrom
+
+    Set the default CONFIG_ENV_SPI_CS value to match the SPI CS that is used by
+    the Blackfin on-chip bootrom to boot out of SPI flash.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 2b4a486e6fac502d8b883e344cc4012283945b3d
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Dec 11 04:06:26 2008 -0500
+
+    Blackfin: update asm-blackfin/posix_types.h to latest Linux version
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit e5eb93e77391bcc308697116c544ea1340aaae8a
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Dec 6 02:54:52 2008 -0500
+
+    Blackfin: add port I bits
+
+    Some people need to access port I, so make sure the pins are defined.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 8a6b272596d43de0db4943eac7af58c3534c4026
+Author: Sonic Zhang <Sonic.Zhang@analog.com>
+Date:	Wed Nov 26 22:16:45 2008 -0500
+
+    Blackfin: add driver for on-chip ATAPI controller
+
+    This is a port of the Linux Blackfin on-chip ATAPI driver to U-Boot.
+
+    Signed-off-by: Sonic Zhang <Sonic.Zhang@analog.com>
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit be9d8c780e6831cb84b7d4590ceae03dca8fc10b
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Nov 26 21:43:06 2008 -0500
+
+    Blackfin: add driver for on-chip NAND controller
+
+    This is a port of the Linux Blackfin on-chip NFC driver to U-Boot.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 4148e02abae9a099f4444b5e168ebc2b911d2295
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Nov 12 07:18:15 2008 -0500
+
+    Blackfin: build with -mno-fdpic
+
+    Use the -mno-fdpic flag so that any Blackfin toolchain can be used to build
+    up u-boot, including ones that output FDPIC ELF by default.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 70e95589a24a2d83ad00317e4a9611d0211ecb58
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Nov 11 05:43:57 2008 -0500
+
+    Blackfin: fix up EBIU defines
+
+    The EBIU defines for EBSZ 256/512 were incorrect.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 961954ea0ec8dc4341034c1a1ff3107ec0527809
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Nov 5 12:45:24 2008 -0500
+
+    Blackfin: use 8/16/32 bit transfer widths in dma_memcpy()
+
+    Rather than using 8bit transfers for everything, use 8/16/32 bit transfers
+    as usable with the source/destination addresses and the count size.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit b93c68648426f906d63b98117496b6415f505f39
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Nov 5 08:50:23 2008 -0500
+
+    Blackfin: only flag L1 instruction for DMA memcpy
+
+    The performance difference from doing an 8 bit DMA memcpy vs an optimized
+    core memcpy can be pretty big when you add in the overhead of setting up the
+    MDMA registers, cache flushes, etc...  So only use dma_memcpy() when we
+    actually require it.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit e347c092a3b3a2ce1e72f25f4829163634d09fbe
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Nov 5 07:20:37 2008 -0500
+
+    Blackfin: dma_memcpy(): fix random failures
+
+    We have to make sure the DMA channel is actually disabled in hardware before
+    attempting to reprogram it.  Otherwise the new settings are ignored and we
+    end up with random hangs/failures.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit fdce83c108846d6f0d5b1774e1cc29f2573a6ad3
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Nov 4 00:04:03 2008 -0500
+
+    Blackfin: rewrite cache handling functions
+
+    Take the cache flush functions from the kernel as they use hardware loops in
+    order to get optimal performance.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 84c5f0dc47d17593fd81206614891bdc94f6d51c
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Nov 3 22:30:05 2008 -0500
+
+    Blackfin: setup bi_enetaddr for single nets
+
+    For systems with CONFIG_NET_MULTI disabled, bi_enetaddr does not get setup
+    based on $ethaddr, so set it up.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 40599239e7875b39e2a5c12e6545992041c72c52
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Fri Oct 24 22:48:47 2008 -0400
+
+    Blackfin: cache core/system clock values
+
+    Calculating the clocks requires a bit of calls to gcc math functions, so
+    cache the values after the first run since they'll most likely never
+    change once U-Boot is up and running.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 6957a6209b02f6b69607fc47425f13731cc477f1
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Fri Oct 24 18:18:16 2008 -0400
+
+    Blackfin: enable --gc-sections
+
+    Start building all Blackfin boards with -ffunction-sections/-fdata-sections
+    and linking with --gc-sections.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit ee1d2001ea7fbabb2b9256026dc5468f057337f8
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Oct 20 21:08:54 2008 -0400
+
+    Blackfin: dont check baud if it wont actually get used
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 400f5778f375bc99c73c8488c555def261ccfab7
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Oct 14 07:54:09 2008 -0400
+
+    Blackfin: add driver for on-chip SPI controller
+
+    This fills out the SPI backend for the Blackfin on-chip SPI peripheral.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 7a1e87b1062e6eac0704c6fc2f7c661caf8814cd
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 18 05:33:51 2008 -0400
+
+    Blackfin: only build post code when CONFIG_POST
+
+    Save some time by using CONFIG_POST in the Makefile rather than C files.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 6d7d4803c74bb86e1b401b1199e63381a62b9382
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Jan 8 11:57:57 2009 -0500
+
+    Blackfin: bfin_mac: cleanup pointer/casts for aliasing issues
+
+    Redo how pointers are managed to get rid of ugly casts and strict pointer
+    aliasing issues that are highlighted by gcc 4.3.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Acked-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 092d2487baf7c29343c165e3ae82ea8a7f9e679b
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Dec 9 17:46:21 2008 -0500
+
+    Blackfin: bfin_mac: convert CONFIG_BFIN_MAC_RMII to CONFIG_RMII
+
+    No point in having a Blackfin-specific define "CONFIG_BFIN_MAC_RMII" that
+    does exactly the same thing as common "CONFIG_RMII".
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Acked-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 8eed6ca51e50fade6887e8bdb1ff6a44116b42b5
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Nov 5 06:36:15 2008 -0500
+
+    Blackfin: bfin_mac: use common debug()
+
+    Rather then defining our own DEBUGF(), just use the common debug().
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Acked-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit a7ec6ac8b2c6dce6fc670a2a855deb6eee340e04
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Oct 20 13:59:51 2008 -0400
+
+    Blackfin: bfin_mac: respect CONFIG_PHY_{ADDR,CLOCK_FREQ}
+
+    Rather than having the on-chip MAC hardcoded to phy address 1 and a speed
+    of 2.5mhz, use these as defaults if the board doesn't specify otherwise.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Acked-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit ac45af4e63ea925f4accc98453aab1a1166c196d
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Oct 14 04:52:00 2008 -0400
+
+    Blackfin: bfin_mac: cleanup MII/PHY functions
+
+    Cleanup and rewrite the MII/PHY related functions so that we can reuse the
+    existing common linux/miiphy.h code and hook into the `mii` command.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Acked-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 6b310a05f0d10c751f22468040932139f71c71d3
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Oct 14 00:31:30 2008 -0400
+
+    Blackfin: bfin_mac: set MDCDIV based on SCLK
+
+    Rather than hardcoding MDCDIV to 24 (which is correct for ~125mhz SCLK),
+    use the real algorithm so it gets set correctly regardless of SCLK.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Acked-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 930590f3e49c8f32256edf2e5861e1535a329c6c
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sat Jan 31 09:10:48 2009 +0100
+
+    ixp: move serial to drivers/serial
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit f90c8022f448bc5e93090e4b714368e52e912f0f
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sat Jan 31 09:04:58 2009 +0100
+
+    ixp: move pci init in arm/board instead of cpu
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 8cb79b5f275f1888ccb278a2d2197140444a84b7
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sat Jan 31 08:56:49 2009 +0100
+
+    ixp: move pci drivers to drivers/pci
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 012d5bab09a534e4800b02f50cf508e6837202ea
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sat Jan 31 08:53:44 2009 +0100
+
+    ixp: Move conditional compilation to Makefile
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit f693f501d67434df1f815fd1824a71973ae08207
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sat Jan 31 08:53:44 2009 +0100
+
+    ixp: add missing os define
+
+    need by arm-elf toolchains and no impact on the arm-linux one
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit b4e2f89dfcb206a22d34fa6b34878d85b498b39f
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Sat Jan 31 09:53:39 2009 +0100
+
+    ixp: remove the option to include the Microcode
+
+    instead the board will have to load it from flash or ram
+    which will be specified by npe_ucode env var
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 1b017baf2071d8daf643bce87250db898c606c66
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Fri Jan 30 09:45:23 2009 +0100
+
+    ixp/npe: Move conditional compilation to Makefile
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 4e69087a1d6ef2eca6f46026cf5e7399b6c9e7c0
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Wed Jan 28 21:58:04 2009 +0100
+
+    SX1: add hardware V2 support
+
+    In the V2 the 2 flash has been replace by one 32MB flash
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit f877f2233dbcd7417c2f0babe6a849099b167f3c
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Wed Jan 28 21:58:03 2009 +0100
+
+    SX1: Fix second flash mapping
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 47fd3bffed6430c91eb2660f859574ed98be5bd8
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Wed Jan 28 21:58:03 2009 +0100
+
+    SX1: add CONFIG_STDOUT_USBTTY to enable preboot stdout redirect to usbtty
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit cfca33837ec83829c6a49c3bcc86c31bc2495ff6
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Wed Jan 28 21:57:59 2009 +0100
+
+    move Samsung's board to board/samsung
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit e4943ec57466ea5dfa085e7a9e0ec44cb93c4e1e
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Thu Jan 29 12:07:21 2009 +0100
+
+    move ARM Ltd. to vendor dir
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit a87fb1b308a2a375cb9ca74ca0dd3e2c5793d3bf
+Author: Larry Johnson <lrj@acm.org>
+Date:	Wed Jan 28 15:30:37 2009 -0500
+
+    ppc4xx: Clean up configuration file for Korat board
+
+    This patch updates the default environmental variables for the
+    Korat PPC 440EPx board, and makes additional minor fixes.
+
+    Signed-off-by: Larry Johnson <lrj@acm.org>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit f20405e31680efc36293c59b4963db57c9d93df4
+Author: Larry Johnson <lrj@acm.org>
+Date:	Wed Jan 28 15:30:02 2009 -0500
+
+    ppc4xx: Add variable "korat_usbcf" for Korat board
+
+    The new environment variable "korat_usbcf" selects the USB
+    port used by the Korat board's CompactFlash controller.
+
+    Signed-off-by: Larry Johnson <lrj@acm.org>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit fc01ea1e27d5b124f0a1868d0ce569f156d58dfe
+Author: Gunnar Rangoy <gunnar@rangoy.com>
+Date:	Fri Jan 23 12:56:31 2009 +0100
+
+    AVR32: macb - Search for PHY id
+
+    This patch adds support for searching through available PHY-addresses in
+    the macb-driver. This is needed for the ATEVK1100 evaluation board,
+    where the PHY-address will be initialized to either 1 or 7.
+
+    This patch adds a config option, CONFIG_MACB_SEARCH_PHY, which when
+    enabled tells the driver to search for the PHY address.
+
+    Signed-off-by: Gunnar Rangoy <gunnar@rangoy.com>
+    Signed-off-by: Paul Driveklepp <pauldriveklepp@gmail.com>
+    Signed-off-by: Olav Morken <olavmrk@gmail.com>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit af8626e0c08a780d9ded1d9c4883a89355f60e75
+Author: Olav Morken <olavmrk@gmail.com>
+Date:	Fri Jan 23 12:56:26 2009 +0100
+
+    Fix IP alignment problem
+
+    This patch removes volatile from:
+    volatile IP_t *ip = (IP_t *)xip;
+
+    Due to a bug, avr32-gcc will assume that ip is aligned on a word boundary when
+    using volatile, which causes an exception since xip isn't aligned on a word
+    boundary.
+
+    Signed-off-by: Gunnar Rangoy <gunnar@rangoy.com>
+    Signed-off-by: Paul Driveklepp <pauldriveklepp@gmail.com>
+    Signed-off-by: Olav Morken <olavmrk@gmail.com>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 12a8b9db12f82a189ff143a58731007f5469da61
+Author: Ron Madrid <ron_madrid@sbcglobal.net>
+Date:	Wed Jan 28 16:17:21 2009 -0800
+
+    Marvell 88E1118 interrupt fix
+
+    This patch adjusts the LED control so that interrupt lines are not reading LEDs
+    and effectively causing indefinite interrupts to the controller.
+
+    Signed-off-by: Ron Madrid <ron_madrid@sbcglobal.net>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 9a37f2acc31a3296dddd3574ea9eaf7f319807b9
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Jan 21 17:14:26 2009 +0100
+
+    net: smc911x.c: Add LAN9211 to chip_ids[] array
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 75edebe3011c963a7cd84be0f4a987477f2aaf89
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Jan 27 16:53:39 2009 -0500
+
+    Move is_valid_ether_addr() to include/net.h
+
+    Import the is_valid_ether_addr() function from the Linux kernel.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 268859338c0188eab1d0d3b867b7dad3c5cc734a
+Author: Michal Simek <monstr@monstr.eu>
+Date:	Mon Jan 5 12:25:13 2009 +0100
+
+    net: Sort Makefile labels
+
+    Signed-off-by: Michal Simek <monstr@monstr.eu>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 1fbcbe9a95f39afb2df6ab8cba25b284b47ebfb2
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Wed Jan 28 23:06:42 2009 +0100
+
+    85xx: Fix compile breakage with sbc8540 and sbc8560
+
+    This fixes an error which raises just a warning:
+    sbc8560.c:250: warning: passing argument 2 of 'strmhz' makes integer from pointer without a cast
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit 62625c0b081bd4019cecab14e9fc2e05e48d2a58
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Jan 28 13:48:55 2009 -0500
+
+    SPD823TS: do not define CONFIG_CMD_ENV
+
+    Since the SPD823TS board does not actually have any writable flash to save
+    its environment, undefine CONFIG_CMD_ENV so the "saveenv" command is
+    disabled.
+
+    This fixes the build error:
+    common/libcommon.a(cmd_nvedit.o): In function `do_saveenv':
+    common/cmd_nvedit.c:557: undefined reference to `saveenv'
+    make: *** [u-boot] Error 1
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 7379f45a7bc71941c3920c2f6b3c3faa4d7fd315
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Wed Jan 28 21:40:16 2009 +0100
+
+    OMAP3: Add Zoom1 board support
+
+    Support for Zoom MDK with OMAP3430. Details of Zoom MDK available here:
+    http://www.logicpd.com/products/devkit/ti/zoom_mobile_development_kit
+
+    Signed-off-by: Nishanth Menon <nm@ti.com>
+    Signed-off-by: Jason Kridner <jkridner@beagleboard.org>
+
+commit 2be2c6cc674e26237962f5cf4c0d311e139e4241
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Wed Jan 28 21:39:58 2009 +0100
+
+    OMAP3: Add Pandora support
+
+    Add Pandora support.
+
+    Signed-off-by: Grazvydas Ignotas <notasas@gmail.com>
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+    Signed-off-by: Jason Kridner <jkridner@beagleboard.org>
+
+commit ad9bc8e52d174d699d1367be0b90089e4fdeb933
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Wed Jan 28 21:39:58 2009 +0100
+
+    OMAP3: Add EVM board
+
+    Add EVM board support.
+
+    Signed-off-by: Manikandan Pillai <mani.pillai@ti.com>
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+    Signed-off-by: Jason Kridner <jkridner@beagleboard.org>
+
+commit 9d0fc8110e7e755239329c26f300d5fc9946d3ec
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Wed Jan 28 21:39:57 2009 +0100
+
+    OMAP3: Add Overo board
+
+    Add Overo board support.
+
+    Signed-off-by: Steve Sakoman <sakoman@gmail.com>
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+    Signed-off-by: Jason Kridner <jkridner@beagleboard.org>
+
+commit f904cdbb68167c647887f19929ad295dbaac8862
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Tue Jan 27 18:19:12 2009 +0100
+
+    OMAP3: Add common power code, README, and BeagleBoard
+
+    Add BeagleBoard support, common power code and README.
+
+    Signed-off-by: Jason Kridner <jkridner@beagleboard.org>
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit 9cda4f104b5313fadc21b75aa781c7a6aaf6ea60
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Wed Jan 28 08:31:10 2009 -0600
+
+    85xx: Fix compile breakage with MPC8540EVAL
+
+    Configuring for MPC8540EVAL board...
+    mpc8540eval.c: In function 'checkboard':
+    mpc8540eval.c:53: error: invalid operands to binary /
+    make[1]: *** [mpc8540eval.o] Error 1
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit 1a448db77b10153703bc5e4ad13dd55d88beb1d6
+Author: Bryan Wu <bryan.wu@analog.com>
+Date:	Sun Jan 18 23:04:27 2009 -0500
+
+    usb_scan_devices: fix output with no devices
+
+    We should check the return of usb_new_device() so that if no USB device is
+    found, we print out the right message rather than always saying "new usb
+    device found".
+
+    Signed-off-by: Bryan Wu <bryan.wu@analog.com>
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit f1c1f540243438246aefb703fdcf16957e3a72e1
+Author: Stefan Roese <sr@denx.de>
+Date:	Thu Jan 22 10:11:21 2009 +0100
+
+    USB: Add high-speed (480Mb/s) to all USB related outputs
+
+    With this patch the USB related connection speed output ("usb tree" command and
+    debug output) is now high-speed enabled.
+
+    This patch also fixes a compilation warning when debugging is enabled.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit daa2dafb450a8073a4e42fd46cd4e995b208e4cb
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Jan 21 17:12:19 2009 +0100
+
+    USB: Add dcache support to the EHCI driver
+
+    This patch adds routines to handle (flush/invalidate) the dcache for the
+    QH and qTD structures and data buffers. This is needed on platforms using
+    this EHCI support with dcache enabled (like the MIPS VCT board port).
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 4e0ea0efc1e501186aca8577a4042fc6fa641602
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Jan 21 17:12:28 2009 +0100
+
+    USB: Add EHCI support for VCT EHCI controller
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 832e61418eedfea172bd2fdfd0ea0d199cc70a9d
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Jan 21 17:12:10 2009 +0100
+
+    USB: Add config option to call ehci_hcd_init() again after EHCI reset
+
+    This patch adds the config option CONFIG_EHCI_HCD_INIT_AFTER_RESET
+    to call ehci_hcd_init() again after ehci_reset() is executed. This
+    is needed for the upcoming VCT EHCI support which needs to re-init
+    the hcd part again after the EHCI CMD_RESET is executed.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 597eb28bd9691266b7b804364cda577cdb51d106
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Jan 21 17:12:01 2009 +0100
+
+    USB: Fix speed detection on EHCI cntr with root hub transaction translators
+
+    This patch fixes an issue that the speed of USB devices was not detected
+    correctly on some EHCI controllers. This will be used on the upcoming VCT
+    EHCI support.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 20cc06611ea33fc0a67a5e56e6476379d2de3091
+Author: Thomas Abraham <t-abraham@ti.com>
+Date:	Sun Jan 4 09:41:20 2009 +0530
+
+    usb : musb : Enabling USB MSC support for DM6446 (TI DaVinci) platform
+
+    Enabling USB MSC support for DM6446 (TI DaVinci) platform in the
+    configuration file.
+
+    Signed-off-by: Ravi Babu <ravibabu@ti.com>
+    Signed-off-by: Swaminathan S <swami.iyer@ti.com>
+    Signed-off-by: Thomas Abraham <t-abraham@ti.com>
+    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 538ef967715322f64ee08efa2296d9682111b014
+Author: Thomas Abraham <t-abraham@ti.com>
+Date:	Sun Jan 4 09:41:16 2009 +0530
+
+    usb : musb : Enabling DM6446 (TI DaVinci) USB module power
+
+    Enabling DM6446 (TI DaVinci) USB module power and MUSB low-level
+    controller hook up to USB core layer.
+
+    Signed-off-by: Ravi Babu <ravibabu@ti.com>
+    Signed-off-by: Swaminathan S <swami.iyer@ti.com>
+    Signed-off-by: Thomas Abraham <t-abraham@ti.com>
+    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit e142e9f35f8ec61e74bf8019428b003f5070c33b
+Author: Thomas Abraham <t-abraham@ti.com>
+Date:	Sun Jan 4 09:41:13 2009 +0530
+
+    usb : musb : Adding DM6446 (TI DaVinci) platform specific USB support
+
+    Adding DM6446 (TI DaVinci) platform specific USB functionality for
+    USB Phy and VBUS initialization.
+
+    Signed-off-by: Ravi Babu <ravibabu@ti.com>
+    Signed-off-by: Swaminathan S <swami.iyer@ti.com>
+    Signed-off-by: Thomas Abraham <t-abraham@ti.com>
+    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit a9d39ebe91ecdd5ac0a0cf56ea162a19773db8da
+Author: Thomas Abraham <t-abraham@ti.com>
+Date:	Sun Jan 4 09:41:09 2009 +0530
+
+    usb : musb : Adding USB VBUS enable functionality for DM644x DVEVM
+
+    Adding USB VBUS enable functionality for DM644x DVEVM (TI DaVinci)
+    platform.
+
+    Signed-off-by: Ravi Babu <ravibabu@ti.com>
+    Signed-off-by: Swaminathan S <swami.iyer@ti.com>
+    Signed-off-by: Thomas Abraham <t-abraham@ti.com>
+    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit a142896934c755e679ba87e227a8e449f39b0012
+Author: Thomas Abraham <t-abraham@ti.com>
+Date:	Sun Jan 4 09:41:03 2009 +0530
+
+    usb : musb : Adding host controller driver for Mentor USB controller
+
+    Adding Mentor USB core functionality and Mentor USB Host controller
+    functionality for Mentor USB OTG controller (musbhdrc).
+
+    Signed-off-by: Ravi Babu <ravibabu@ti.com>
+    Signed-off-by: Swaminathan S <swami.iyer@ti.com>
+    Signed-off-by: Thomas Abraham <t-abraham@ti.com>
+    Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit c7d703f3f3c3d6b020bda4cf633f8a6167c3cd2a
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Jan 1 18:27:27 2009 -0500
+
+    usb.h: use standard __LITTLE_ENDIAN from Linux headers
+
+    Rather than forcing people to define a custom "LITTLEENDIAN", just use the
+    __LITTLE_ENDIAN one from the Linux byteorder headers that every arch is
+    already setting up.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 7b6e31eb17e3ff76238a60803fc531517d516223
+Author: Michael Trimarchi <trimarchi@gandalf.sssup.it>
+Date:	Wed Dec 31 10:33:56 2008 +0100
+
+    USB ehci ixp4xx support
+
+    Add USB ehci ixp4xx host controller. Test on ixdp465 board.
+
+    Signed-off-by: Michael Trimarchi <trimarchimichael@yahoo.it>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 1ed9f9adc88218841dfeb60b9094a5a548bff009
+Author: Michael Trimarchi <trimarchi@gandalf.sssup.it>
+Date:	Wed Dec 31 10:33:22 2008 +0100
+
+    USB ehci remove infinite loop and use handshake function
+
+    USB ehci code cleanup. Use handshake instead of infinite while loop
+    to check the STD_ASS status
+
+    Signed-off-by: Michael Trimarchi <trimarchimichael@yahoo.it>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 8fea2914ac974029b65926ef8247d908f84d202d
+Author: Michael Trimarchi <trimarchi@gandalf.sssup.it>
+Date:	Wed Dec 31 10:32:41 2008 +0100
+
+    Add initial support for USB ehci pci
+
+    Add USB ehci pci support. This patch doesn't include any
+    pci_ids and it is not tested on real hardware.
+
+    Signed-off-by: Michael Trimarchi <trimarchimichael@yahoo.it>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 14e4111cdab7e7738ff6a203d445e4d8377f058f
+Author: Bryan Wu <Bryan.Wu@analog.com>
+Date:	Thu Jan 1 19:48:07 2009 -0500
+
+    usb_storage: do not reset SanDisk Corporation U3 Cruzer Micro USB thumb drive
+
+    The SanDisk Corporation U3 Cruzer Micro 1/4GB Flash Drive 000016244373FFB4
+    does not like to be reset, so check for it.
+
+    Signed-off-by: Bryan Wu <bryan.wu@analog.com>
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 1eb734fed3b79a5e6106dad16e88041894fdab30
+Author: Thomas Abraham <t-abraham@ti.com>
+Date:	Sun Jan 4 12:15:35 2009 +0530
+
+    usb : usb_kbd : Populating 'priv' member of USB keyboard device_t structure
+
+    This patch populates the 'priv' field of the USB keyboard device_t
+    structure. The 'priv' field is populated with the address of the
+    'struct usb_device' structure that represents the USB device.
+
+    The 'priv' field can then be used in the 'usb_event_poll' function to
+    determine the USB device that requires to be polled. An
+    example of its usage in 'usb_event_poll' function is as below.
+
+	device_t *dev;
+	struct usb_device *usb_kbd_dev;
+
+	<snip>
+
+	dev = device_get_by_name("usbkbd");
+	usb_kbd_dev = (struct usb_device *)dev->priv;
+	iface = &usb_kbd_dev->config.if_desc[0];
+
+    Signed-off-by: Thomas Abraham <t-abraham@ti.com>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit 366523c26b6320af171459b19e6e0e9e3baa83ca
+Author: Michael Trimarchi <trimarchi@gandalf.sssup.it>
+Date:	Thu Dec 18 10:05:37 2008 +0100
+
+    USB change speed
+
+    USB changes the speed according to the port status
+
+    Signed-off-by: Michael Trimarchi <trimarchimichael@yahoo.it>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit c0d722fe7ee1cb452dfd9246419188b3f6d9c4df
+Author: Remy Bhmer <linux@bohmer.net>
+Date:	Sat Dec 13 22:51:58 2008 +0100
+
+    EHCI fix code and ixp4xx test.
+    USB ehci configuration parameter:
+
+    #define CONFIG_CMD_USB	    1
+    #define CONFIG_USB_STORAGE	    1
+    #define CONFIG_USB_EHCI
+    #define CONFIG_USB_EHCI_IXP4XX	1
+    #define CONFIG_EHCI_IS_TDI	1
+    #define CONFIG_EHCI_DESC_BIG_ENDIAN     1
+    #define CONFIG_EHCI_MMIO_BIG_ENDIAN     1
+    #define CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS 2
+    #define CONFIG_LEGACY_USB_INIT_SEQ	    1
+
+    2 USB Device(s) found
+	   scanning bus for storage devices... 0 Storage Device(s) found
+    => usb tree
+
+    Device Tree:
+      1  Hub (1.5MBit/s, 0mA)
+      |  u-boot EHCI Host Controller
+      |
+      |+-2  Mass Storage (12MBit/s, 100mA)
+	   Sony Storage Media 0C07040930296
+
+    =>
+
+    Signed-off-by: Michael Trimarchi <trimarchimichael@yahoo.it>
+    Signed-off-by: Remy Bhmer <linux@bohmer.net>
+
+commit 51ab142b8b546d5e627b2c8c36d0adae222565f7
+Author: michael <michael@panicking.retis>
+Date:	Thu Dec 11 13:43:55 2008 +0100
+
+    [PATCH] This patch add varius fix to the ehci.
+    - fix ehci_readl, ehci_writel
+    - introduce new define in ehci.h
+    - introduce the handshake function for waiting on a register
+    - fix usb_ehci_fsl with the new HC_LENGTH macro
+
+    Signed-off-by: Michael Trimarchi <trimarchimichael@yahoo.it>
+    Signed-off-by: Remy Bhmer <linux@bohmer.net>
+
+commit db63299b1dd2894ade542278210bccd046de6435
+Author: michael <michael@panicking.retis>
+Date:	Wed Dec 10 17:55:19 2008 +0100
+
+    [PATCH] Fix EHCI usb. I start to test on a
+    IXP465 board and I find some errors in the code. This
+    patch fix:
+    - descriptor initizialization (config, interface and endpoint
+      must be one next-to the other when the USB_DT_CONFIG message
+      is send.
+    - FIX little/endian bigendian (introduce the CONFIG_EHCI_DESC_BIG_ENDIAN
+      and the CONFIG_EHCI_MMIO_BIG_ENDIAN)
+    - Introduce the linux version of the usb_config_descriptor and
+      usb_interface descriptor. This descriptor does't contains
+      u-boot extension.
+
+    Signed-off-by: Michael Trimarchi <trimarchimichael@yahoo.it>
+    Signed-off-by: Remy Bhmer <linux@bohmer.net>
+
+commit 6b92487dcf9afe83a3570153d66940fdb293be76
+Author: Michael Trimarchi <trimarchi@gandalf.sssup.it>
+Date:	Fri Nov 28 13:22:09 2008 +0100
+
+    USB ehci freescale support
+
+    Add USB ehci freescale support
+
+    Signed-off-by: Michael Trimarchi <trimarchi@gandalf.sssup.it>
+    Signed-off-by: Remy Bhmer <linux@bohmer.net>
+
+commit aaf098cfeed04595d4c5100ffd39095d79edbf90
+Author: Michael Trimarchi <trimarchi@gandalf.sssup.it>
+Date:	Fri Nov 28 13:20:46 2008 +0100
+
+    USB ehci core support
+
+    Add USB ehci core support
+
+    Signed-off-by: Michael Trimarchi <trimarchi@gandalf.sssup.it>
+    Signed-off-by: Remy Bhmer <linux@bohmer.net>
+
+commit 3e126484df7868e341545cce740b24b62b0cd3b7
+Author: Michael Trimarchi <trimarchi@gandalf.sssup.it>
+Date:	Fri Nov 28 13:19:19 2008 +0100
+
+    Prepare USB layer for ehci
+
+    Prepare USB layer for ehci support
+
+    Signed-off-by: Michael Trimarchi <trimarchi@gandalf.sssup.it>
+    Signed-off-by: Remy Bhmer <linux@bohmer.net>
+
+commit a0cb3fc31e58996a1c5732715ac04159d4d284fd
+Author: Michael Trimarchi <trimarchi@gandalf.sssup.it>
+Date:	Wed Dec 10 15:52:06 2008 +0100
+
+    USB storage cleanup patch
+
+    Cleanup usb storage
+
+    Signed-off-by: Michael Trimarchi <trimarchimichael@yahoo.it>
+    Signed-off-by: Remy Bohmer <linux@bohmer.net>
+
+commit fe033ad6d0883063fe857237abb9436fab03208c
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sun Oct 12 06:02:55 2008 -0400
+
+    Blackfin: fixup misc warnings such as printf's and missing casts
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 1f4a3bb50343719c434d7e2541a2f86480a6d25c
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sun Oct 12 22:09:26 2008 -0400
+
+    Blackfin: convert old boards to use COBJS-y Makefile style
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 1f75d6f0ff005762d3e6ad92ae4ce2ab366b3bb5
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 22:38:37 2008 -0400
+
+    Blackfin: bf533-stamp: rewrite resource swap logic
+
+    The old swap function tended to clobber unrelated pins and screw up masks.
+    Rewrite the thing from scratch so it only uses the resources it needs.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 29d4ea0a9073c82469184331010136f52edf8db6
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 22:08:42 2008 -0400
+
+    Blackfin: bootldr: implement BF53x/BF56x LDR loader
+
+    The BF53x/BF56x parts do not have an on-chip ROM to boot LDRs out of
+    arbitrary memory locations, so implement a basic one in software.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 8b35e3aeff6c2d747c37697997b3f8a808432329
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 22:05:42 2008 -0400
+
+    Blackfin: implement real write support for OTP
+
+    Now that real documentation has been released for the OTP interface and
+    the on-chip ROM wrt writing/timings, implement support for reading/writing
+    as well as dumping/locking.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 9372c3214808fab545227d8d0f76b3bfcc6760ec
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 22:04:05 2008 -0400
+
+    Blackfin: update on-chip ROM API
+
+    This brings the API for the on-chip ROM in line with the toolchain and
+    hardware documentation.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 7633903bff432ec7b27905dce7396958553f2be6
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 21:52:17 2008 -0400
+
+    Blackfin: allow serial console to be disabled
+
+    Some devices have no UART device pulled out, so allow people to disable the
+    driver completely in favor of other methods (like JTAG-console).
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 36ea8e9ad1107af12d244bba8c73e85b9f655e45
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 21:51:20 2008 -0400
+
+    Blackfin: support console-over-JTAG
+
+    The Blackfin JTAG has the ability to pass data via a back-channel without
+    halting the processor.  Utilize that channel to emulate a console.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit cf8f2efb5f39c5225da92391c14a07eecbeca881
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 21:49:06 2008 -0400
+
+    Blackfin: handle new anomalies with reset
+
+    Workaround fun new anomalies related to software reset of the processor.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit b1e9435b643043dd8fbd1fcc47309c6acb7b3c8e
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 21:44:00 2008 -0400
+
+    Blackfin: pass RETX to Linux
+
+    Make sure we save the value of RETX at power on and then pass it on to the
+    kernel so that it can nicely debug a "double-fault-caused-a-reset" crash.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit b5eba3fafcccd1979380f12a256bd0e19be3d61e
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 21:40:26 2008 -0400
+
+    Blackfin: clarify relocation comment during init
+
+    People often ask questions about the init process and when things go
+    from flash to relocated base, so clarify the comments a bit.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 95433f6d43ede6b40c1d900f3f704c839aa074f1
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 21:23:41 2008 -0400
+
+    Blackfin: just set SP register directly during init
+
+    No need to set the SP register indirectly to the configured value when it
+    can be set directly.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 51230e6e356ccf4c932e0c4ff54f1e49da02285c
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 21:15:53 2008 -0400
+
+    Blackfin: add portmuxing for UARTs on the BF51x
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 4f6a313240c531042f16909a3a170ab047b95779
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sun Jun 1 01:26:29 2008 -0400
+
+    Blackfin: respect CONFIG_CLKIN_HALF
+
+    As pointed out by Ivan Koryakovskiy, the initialization code was not
+    actually respecting the CONFIG_CLKIN_HALF option when configuring the
+    PLL_CTL register.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit dc2bfb0b58d7462b9eba68f3ae38e38cada0ad33
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sun Jun 1 01:21:34 2008 -0400
+
+    Blackfin: use common memcpy routine during init
+
+    Rather than using a local custom memcpy function, just call the existing
+    optimized Blackfin version.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 362c943347364e9373af4c5530778491ab56ec2e
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Apr 9 02:27:06 2008 -0400
+
+    Blackfin: set default boot SPI CS for BF538/BF539
+
+    The BF538/BF539 use CS2 for booting off of rather than CS1 like newer
+    Blackfin parts.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 74dde80bd5d55bc146630853ca191aaeea7c30f4
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Apr 9 02:20:59 2008 -0400
+
+    Blackfin: punt unused BF533-STAMP definitions
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit fee531eeefc3b5f2c63c7fe27b9f55d924c59c26
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Fri Apr 18 20:44:11 2008 -0400
+
+    Blackfin: resurrect BF533-STAMP video splash driver
+
+    This video driver used to live in the Blackfin cpu directory, but it was
+    lost during the unification process.  This brings it back.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit a750d038f2548d846ea1e046d873dc932d041319
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Apr 9 02:31:29 2008 -0400
+
+    Blackfin: tighten up post memory coding style
+
+    No functional changes here; just cleanup code style a bit.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 0649908f92c9bd214dd139aa3d4698c1654a45c6
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Wed Apr 9 02:29:18 2008 -0400
+
+    Blackfin: bf537-stamp nand: fix more style errors in previous commit
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 41f3325ae9add641036d7cb362e884b698e53f07
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 20:31:17 2008 -0400
+
+    Blackfin: drop dead/wrong debug code in initdram()
+
+    The DEBUG code in initdram() is quite old and was never really useful, so
+    just drop it altogether.  Common Blackfin debug code does a better job.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 65ba1abd3b90e0b2585745809b78e2651bd3bacb
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Oct 11 20:30:28 2008 -0400
+
+    Blackfin: bf533-ezkit: shuffle flash defines a little
+
+    Some of the flash defines weren't in the correct location and caused build
+    problems in some configurations, so let's move types and defines to better
+    local locations.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit be853bf86b41e91f4c422f0f56fdf87ea3191266
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Oct 6 04:16:47 2008 -0400
+
+    Blackfin: overhaul i2c driver
+
+    The current Blackfin i2c driver does not work properly with certain devices
+    due to it breaking up transfers incorrectly.  This is a rewrite of the
+    driver and relocates it to the newer place in the source tree.
+
+    Also remove duplicated I2C speed defines in Blackfin board configs and
+    disable I2C slave address usage since it isn't implemented.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit b6edc719a106ab7fa6e6950b4d97bc39c1368e45
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Oct 6 04:00:07 2008 -0400
+
+    Blackfin: respect CONFIG_SYS_MONITOR_LEN for default flash protection
+
+    Respect the CONFIG_SYS_MONITOR_LEN define rather than assuming a size of
+    128kB when setting up the default flash protection region for U-Boot
+    itself.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 78a0ba7dc24c9682371f6ee8549b569fb573a329
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Oct 6 03:57:39 2008 -0400
+
+    Blackfin: respect/check CONFIG_SYS_GBL_DATA_SIZE
+
+    When setting up the global data, rather than relying on sizeof(), use the
+    common CONFIG_SYS_GBL_DATA_SIZE define.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 01815c2d06c5b838f2cd536703e47bd2c9148194
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Oct 6 03:52:24 2008 -0400
+
+    Blackfin: implement general support for CONFIG_STATUS_LED
+
+    Here are the Blackfin-specific and board-independent pieces for status leds.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 6882b5a79a3247494b62c05015fa672557f1bfaa
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Oct 6 03:49:32 2008 -0400
+
+    Blackfin: do not init i2c in Blackfin board init
+
+    The common code takes care of calling i2c_init() when needed, so no point
+    in us doing it as well.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 1118ea73698eee6e72ef5cbfc00e41746040304f
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Oct 6 03:42:20 2008 -0400
+
+    Blackfin: bfin_mac: update port muxing
+
+    Adds support more Blackfin parts and fixes broken muxing for older ones.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 05b75e48832fc4afeecf8e76d704349557dffa35
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Oct 6 03:35:44 2008 -0400
+
+    Blackfin: fix dcache handling when doing dma memcpy's
+
+    Our dcache invalidate function doesn't just invalidate, it also flushes.
+    So rename the function accordingly and fix the dma_memcpy() function so it
+    doesn't inadvertently corrupt the data destination.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 68e5632494168095d75f120af70043b68afd2476
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Aug 7 18:56:56 2008 -0400
+
+    Blackfin: dont generate ldrs with --force
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 746290dfd86a70b41fc5fdd3df1424a647d5c5e8
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Aug 7 18:55:30 2008 -0400
+
+    Blackfin: pass --bmode/--initcode when creating ldr
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 0332e4df71fccf9a96c5a4393e3c5d5daa50880a
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Aug 7 18:39:27 2008 -0400
+
+    Blackfin: minimize time cache is turned off when replacing cplb entries
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 21d631360430cf0ae9099612273cd4de28911ba9
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Aug 7 15:31:13 2008 -0400
+
+    Blackfin: split cache handling out of dma_memcpy()
+
+    Creating a new dma_memcpy() function that skips all cache checks allows us
+    to use the function in very early init where the cache is not yet setup.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit d31eb38512bed377d5d4b3c696662e52120a2e4c
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Aug 7 15:30:49 2008 -0400
+
+    Blackfin: abort dma_memcpy() for L1 scratchpad
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 81b799add709177e838466461f7b9989488b0fd5
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Aug 7 15:27:52 2008 -0400
+
+    Blackfin: rename bootm.c to boot.c
+
+    The boot file contains functions for more than just "bootm", so rename it
+    accordingly.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit d7ca7dd5bfc418ac173e9d2712f6cc2d8147a091
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Aug 7 13:22:37 2008 -0400
+
+    Blackfin: set more sane default board config values
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 36cd52a00794fb15ffab05d640acca92d7482993
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Aug 7 15:24:59 2008 -0400
+
+    Blackfin: convert CMD_LINE_ADDR to CONFIG_LINUX_CMDLINE_{ADDR,SIZE}
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit c8054bc12e00669bd7588f2b30fef48aa94babac
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Aug 7 13:21:27 2008 -0400
+
+    Blackfin: add bit defines for DDR parts
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 154502fe0796f3b7a4698378c5d2080ae28a9782
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Thu Aug 7 13:21:11 2008 -0400
+
+    Blackfin: add defines to describe active bootrom behavior
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 2b6fd5c77db9c6ed3cea9799c86ff922cf0107b2
+Author: Kim Phillips <kim.phillips@freescale.com>
+Date:	Tue Jan 27 16:03:53 2009 -0600
+
+    mpc83xx: fix undefined reference to `flush_cache' error in simpc8313 build
+
+    extend commit c70564e6b1bd08f3230182392238907f3531a87e
+    "NAND: Fix cache and memory inconsistency issue" to add the cache.o dependency
+    to the simpc8313 build and fix this:
+
+    ...Large Page NAND...Configuring for SIMPC8313 board...
+    nand_boot_fsl_elbc.o: In function `nand_boot':
+    nand_spl/board/sheldon/simpc8313/nand_boot_fsl_elbc.c:150: undefined reference to `flush_cache'
+    make[1]: *** [/home/r1aaha/git/u-boot-mpc83xx/nand_spl/u-boot-spl] Error 1
+    make: *** [nand_spl] Error 2
+
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit 54a7cc4912feefa45be961cc47cc159563725d2f
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Wed Jan 28 09:25:31 2009 +0100
+
+    mpc8536ds.c: include sata.h to for needed function prototypes
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit 2fb2604d5c20beb061b0a94282b7f6eb14d00cb8
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Tue Jan 27 18:03:12 2009 -0600
+
+    Command usage cleanup
+
+    Remove command name from all command "usage" fields and update
+    common/command.c to display "name - usage" instead of
+    just "usage". Also remove newlines from command usage fields.
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+
+commit 79621bc10ba8b8c45d348994aba5b9e4923cb77b
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Tue Jan 27 18:03:11 2009 -0600
+
+    amcc: Clean up command usage output
+
+    Update taihu and taishan commands to use cmd_usage() function
+    to display usage messages.
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+
+commit 62c3ae7c6ef215b1afa614abdf61acf077752207
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Tue Jan 27 18:03:10 2009 -0600
+
+    Standardize command usage messages with cmd_usage()
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+
+commit 84cde2bb409c07c6ef36a192d194359d4e9ccd70
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Tue Jan 27 18:03:09 2009 -0600
+
+    pcs440ep: Clean up led command definition
+
+    The pcs440ep's led command usage formatting is non-standard.  It
+    was made standard in preparation for larger command usage updates.
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+
+commit 9507e7867e04dc48c80ee333c2a9a5e70e887f62
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Tue Jan 27 18:03:08 2009 -0600
+
+    Clean up diufb command definitions
+
+    The diufb command usage formatting is non-standard.  It was
+    made standard in preparation for larger command usage updates.
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+
+commit 6450a8485836fc80615ae6de6a864c33369b44f5
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Wed Jan 28 00:29:26 2009 +0100
+
+    Update CHANGELOG, tiny coding style cleanup.
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit cf7e399fb35b3aea90a27d1df72f45f5d6156204
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Jan 27 16:12:21 2009 -0500
+
+    SATA: do not auto-initialize during boot
+
+    Rather than have the board code initialize SATA automatically during boot,
+    make the user manually run "sata init".  This brings the SATA subsystem in
+    line with common U-Boot policy.
+
+    Rather than having a dedicated weak function "is_sata_supported", people
+    can override sata_initialize() to do their weird board stuff.  Then they
+    can call the actual __sata_initialize().
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 50970839712dda35399e2fa83fe818df9354d618
+Author: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+Date:	Mon Jan 26 08:45:14 2009 -0500
+
+    part_efi: Fix partition size calculation due to inclusive ending LBA.
+
+    The ending LBA is inclusive. Hence, the partition size should be
+    ((ending-LBA + 1) - starting-LBA) to get the proper partition size.
+
+    This is confirmed against the results from the parted tool.
+    (e.g. use parted /dev/sda -s unit S print) and observe the size.
+
+    Signed-off-by: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+
+commit b5b004ad8a0ac6f98bd5708ec8b22fbddd1c1042
+Author: Tomasz Figa <tomasz.figa@gmail.com>
+Date:	Tue Dec 30 18:35:57 2008 +0100
+
+    jffs2: Fix zero sector_size when not using CONFIG_JFFS2_CMDLINE
+
+    This patch fixes a bug (?) introduced after inclusion of the new
+    JFFS2 code.
+
+    When not using CONFIG_JFFS2_CMDLINE, the code in cmd_jffs2.c doesn't
+    fill in part->sector_size (keeping it as 0), but a correct value is
+    needed by the code in jffs2_1pass.c. This causes all JFFS2 accesses
+    to be in the same place of the memory, what obviously means
+    impossibility to use the JFFS2 partition.
+
+    This problem is fixed in this patch by including sector size
+    calculation in non-CONFIG_JFFS2_CMDLINE mtdparts_init variant.
+
+    Signed-off-by: Tomasz Figa <tomasz.figa_at_gmail.com>
+
+commit ba69dc26a5fd606da49573bb2f15e756a34f3f98
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Dec 30 02:59:25 2008 -0500
+
+    saveenv: standardize enablement
+
+    Rather than special casing each environment type for enabling the saveenv
+    command, have them all behave the same.  This avoids bitrot as new env
+    sources are added/removed.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 2ac6985a7466a1c8a7aa8b2fa24d360925a82764
+Author: Andrew Dyer <adyer@righthandtech.com>
+Date:	Mon Dec 29 17:36:01 2008 -0600
+
+    soft_i2c.c add option for repeated start in i2c_read()
+
+    This patch adds a #define to optionally change the behaviour of
+    i2c_read() in soft_i2c.c to send an I2C repeated start instead of a
+    stop-start between sending the device address pointer write and
+    reading back the data.  The current behaviour is retained as the
+    default.
+
+    While most devices will work either way, I have a smart battery(*)
+    that requires repeated start, and someone at some point found a
+    device that required a stop-start.
+
+    (*) http://www.inspired-energy.com/Standard_Products/NL2054/NL2054%20Rev1.0%20Data%20Sheet.pdf
+
+    Signed-off-by: Andrew Dyer <adyer@righthandtech.com>
+
+commit 3429071700963ca2f944c51d695a7481af0cee33
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Tue Jan 27 22:07:14 2009 +0100
+
+    {delta,zylonite}/lowlevel_init.S: fix typo
+
+    Commit 9d803d8c mistakenly changed some constants
+    from 0x300 into 300 - this patch fixes it.
+
+    Pointed out by Tom Evans <tom@ceos.com.au>, see
+    http://article.gmane.org/gmane.comp.boot-loaders.u-boot/51992 for
+    details.
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit 1bc434373013af241835c14011ac3f291dccbf53
+Author: Stefan Althoefer <stefan.althoefer@web.de>
+Date:	Sat Dec 20 19:40:41 2008 +0100
+
+    drivers/net/e1000.c: missing terminator for supported devices
+
+    Signed-off-by: Stefan Althoefer <stefan.althoefer@web.de>
+
+commit 65f7d41031a70b1649b35020995c505edca91533
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Tue Jan 27 21:36:28 2009 +0100
+
+    fat.c: fix warning: array subscript is above array bounds
+
+    Fix based on suggestion by David Hawkins <dwh@ovro.caltech.edu>.
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit 107b801cf3fe39612d69d70581ebc3bf5e215554
+Author: Matthias Fuchs <matthias.fuchs@esd-electronics.com>
+Date:	Fri Jan 2 15:11:41 2009 +0100
+
+    Fix gunzip in case of insufficient output buffer
+
+    U-Boot's gunzip() function does not handle the return code
+    of zlib's inflate() function correctly. gunzip() is implemented
+    to uncompress all input data in one run. So the correct return
+    code for the good case is Z_STREAM_END. In case of insufficient
+    output buffer memory inflate returns Z_OK. For gunzip() this
+    is an error.
+
+    It also makes sense to me to call inflateEnd() also in case
+    of an error.
+
+    Signed-off-by: Matthias Fuchs <matthias.fuchs@esd-electronics.com>
+
+commit 2a61eff6a82f0d6e2335d968799b3fbeb3ff4d8e
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Jan 21 17:25:01 2009 +0100
+
+    MIPS: Add VCT board series support (Part 3/3)
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit ae691e5719c48f1d2826cb72722497d1d162765b
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Jan 21 17:24:49 2009 +0100
+
+    MIPS: Add VCT board series support (Part 2/3)
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 50752790bc9285c0c1c5235e88f3a4ef2eec1e72
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Jan 21 17:24:39 2009 +0100
+
+    MIPS: Add VCT board series support (Part 1/3)
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 03d3bfb00806b5441f1871c7408c1749863e0fdc
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Jan 21 17:20:20 2009 +0100
+
+    MIPS: Add flush_dcache_range() and invalidate_dcache_range()
+
+    This patch adds flush_/invalidate_dcache_range() to the MIPS architecture.
+    Those functions are needed for the upcoming dcache support for the USB
+    EHCI driver. I chose this API because those cache handling functions are
+    already present in the PPC architecture.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Shinya Kuribayashi <skuribay@ruby.dti.ne.jp>
+
+commit de832a99414ff06a4b2cdc9f5280b387da039834
+Author: Stefan Roese <sr@denx.de>
+Date:	Mon Jan 26 10:05:20 2009 +0100
+
+    nand_spl: Fix compile problem with board_nand_init() prototype
+
+    This patch removes the now obsolete and additionally wrongly defined
+    board_nand_init() prototype from nand_spl/nand_boot.c.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit e8eac437189430d8e04a5d254ed92c58bc534a79
+Author: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+Date:	Wed Jan 14 08:44:26 2009 -0500
+
+    CFI: Add geometry reversal for STMicro M29W320ET
+
+    Added flash_fixup_stm to fix geometry reversal on STMicro M29W320ET flash chip.
+
+    Modeled after flash_fixup_amd, this patch handles the geometry reversal
+    or erase sectors that exist for ST Micro (now Numonyx) M29W320ET flash.
+    Since I cannot test all STM's chips, the detection is implemented as
+    narrow as possible for now.
+
+    Signed-off-by: Richard Retanubun <RichardRetanubun@RuggedCom.com>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 0f8e851e897b535959a0781171910cd97f33c30c
+Author: Jens Gehrlein <sew_s@tqs.de>
+Date:	Tue Dec 16 17:25:55 2008 +0100
+
+    CFI: increase performance of function find_sector()
+
+    Tested on TQM5200S-BD with Samsung K8P2815UQB
+
+    Signed-off-by: Jens Gehrlein <sew_s@tqs.de>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit a7292871a79cc48d98e3a708dd3c3b81580db6ef
+Author: Jens Gehrlein <sew_s@tqs.de>
+Date:	Tue Dec 16 17:25:54 2008 +0100
+
+    CFI: avoid redundant function call in single word programming mode
+
+    The function find_sector() doesn't need to be called twice in
+    the case of AMD command set.
+    Tested on TQM5200S-BD with Samsung K8P2815UQB.
+
+    Signed-off-by: Jens Gehrlein <sew_s@tqs.de>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit c8901f46a71ec16e084e604596a09e23bfb0f6ac
+Author: Stefan Roese <sr@denx.de>
+Date:	Mon Jan 26 10:15:23 2009 +0100
+
+    ppc4xx: Remove compilation warning in gdppc440etc.c
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 91f33534728e6416d332ad2b53ad1d6fde57f7fc
+Author: Matthias Fuchs <matthias.fuchs@esd-electronics.com>
+Date:	Fri Jan 2 12:19:47 2009 +0100
+
+    ppc4xx: Remove CONFIG_SYS_IGNORE_405_UART_ERRATA_59 from config files
+
+    Lot's of 405 board config files use CONFIG_SYS_IGNORE_405_UART_ERRATA_59.
+    Either they define or undef it. Because it's not used in any source
+    files this patch removes any references to it.
+
+    Signed-off-by: Matthias Fuchs <matthias.fuchs@esd-electronics.com>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 89b8619aaeafc922ca0c3bb249872591050c8dcc
+Author: Dirk Eibach <eibach@gdsys.de>
+Date:	Tue Dec 9 13:12:40 2008 +0100
+
+    ppc4xx: Add GDsys PowerPC 440 ETX board support.
+
+    Board support for the Guntermann & Drunck PowerPC 440 ETX module.
+    Based on the AMCC Yosemite board support by Stefan Roese.
+
+    Signed-off-by: Dirk Eibach <eibach@gdsys.de>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 3943d2ff6cc40dd601a9feeb39eb6d3d5090ea6d
+Author: Dirk Eibach <eibach@gdsys.de>
+Date:	Tue Dec 9 11:00:07 2008 +0100
+
+    ppc4xx: Improve DDR autodetect
+
+    Added support for a second memory bank to DDR autodetection for 440
+    platforms.
+    Made hardcoded values configurable.
+
+    Signed-off-by: Dirk Eibach <eibach@gdsys.de>
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 71a040f4f556cca4d30f06805d82e717b3ef1020
+Author: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+Date:	Fri Nov 21 12:06:26 2008 +0900
+
+    sh: sh7763rdp: Update sh7763rdp config
+
+    Add CONFIG_NET_MULTI in config file, because sh_eth changed new newwork API.
+
+    Signed-off-by: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit ba705b5b1a97b47388ed48858bef6bf7b6bfcd56
+Author: Gary Jennejohn <garyj@denx.de>
+Date:	Thu Nov 20 12:28:38 2008 +0100
+
+    mgcoge make ether_scc.c work with CONFIG_NET_MULTI
+
+    This change is needed for mgcoge because it uses two ethernet drivers.
+
+    Add a check for the presence of the PIGGY board on mgcoge.	Without this
+    board networking cannot work and the initialization must be aborted.
+
+    Only allocate rtx once to prevent DPRAM exhaustion.
+
+    Initialize ether_scc.c and the keymile-specific HDLC driver (to be added
+    soon) in eth.c.
+
+    Signed-off-by: Gary Jennejohn <garyj@denx.de>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit bd3980cc095af1728b994cdd8bf1ac430b6289e6
+Author: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+Date:	Fri Nov 21 12:04:18 2008 +0900
+
+    sh: sh_eth: Change new network API
+
+    sh_eth used old network API. This patch changed new API.
+
+    Signed-off-by: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 890a02e8ee6b8c26a6e3e505e1a2d29cd73aa6f6
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Nov 12 13:31:02 2008 +0100
+
+    net: smc911x: Make register read/write functions weak
+
+    This patch changes the reg_read/_write to smc911x_reg_read/_write
+    and defines then as weak so that they can be overridden by board
+    specific version.
+
+    This will be used by the upcoming VCTH board support.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit 8b69b563039989885969d24465c56f8ac4c07c4c
+Author: Heiko Schocher <hs@denx.de>
+Date:	Thu Nov 20 09:57:14 2008 +0100
+
+    powerpc: net: support for the SMSC LAN8700 PHY
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit d5254f149da9e6cd649d887b042ce577ef3ba78d
+Author: Alessandro Rubini <rubini@unipv.it>
+Date:	Sat Jan 24 18:10:37 2009 +0100
+
+    Initial support for Nomadik 8815 development board
+
+    The NMDK8815 board is distributed by ST Microelectornics.
+    Other (proprietary) code must be run to unlock the CPU before
+    U-Boot runs. doc/README.nmdk8815 outlines the boot sequence.
+
+    This is the initial port, with basic infrastructure and
+    a working serial port.
+
+    Signed-off-by: Alessandro Rubini <rubini@unipv.it>
+    Acked-by: Andrea Gallo <andrea.gallo@stnwireless.com>
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 7d264c1ef267cfc8d928bc8577a7cc907f2f5e47
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Sun Dec 14 09:47:18 2008 +0100
+
+    OMAP3: Add I2C support
+
+    Add I2C support.
+
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit b1c3bf99fb477675d464aeadb5dd69d2cbc9dc7b
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Sun Dec 14 09:47:17 2008 +0100
+
+    OMAP3: Add MMC support
+
+    Add MMC support.
+
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit 12201a13547ec22ddcdae278e74465e54a3be60c
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Sun Dec 14 09:47:16 2008 +0100
+
+    OMAP3: Add NAND support
+
+    Add NAND support.
+
+    Signed-off-by: Nishanth Menon <nm@ti.com>
+    Signed-off-by: Syed Mohammed Khasim <khasim@ti.com>
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit 91eee546737ae21d930af479530997174c342b13
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Sun Dec 14 09:47:15 2008 +0100
+
+    OMAP3: Add common board, interrupt and system info
+
+    Add common board, interrupt and system info code.
+
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit 5ed3e8659e5373f6a229877ac506c0b00a054fb8
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Sun Dec 14 09:47:14 2008 +0100
+
+    OMAP3: Add common clock, memory and low level code
+
+    Add common clock, memory and low level code
+
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit 0b02b184003e6a5023e05d5f31de54db279b1431
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Sun Dec 14 09:47:13 2008 +0100
+
+    OMAP3: Add common cpu and start code
+
+    Add common cpu and start code.
+
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit a8b6450546cd507d331b8fde384791d84bde5651
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Sun Dec 14 09:47:12 2008 +0100
+
+    OMAP3: Add OMAP3, memory and function prototype headers
+
+    Add OMAP3, memory and function prototype header files for OMAP3.
+
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit 2c803210a464abbac35752ca1c737514360b4c32
+Author: Dirk Behme <dirk.behme@googlemail.com>
+Date:	Sun Dec 14 09:47:11 2008 +0100
+
+    OMAP3: Add pin mux, clock and cpu headers
+
+    Add pin mux, clock and cpu header files for OMAP3.
+
+    Signed-off-by: Dirk Behme <dirk.behme@googlemail.com>
+
+commit 685533646f4ff17a84ec9265cabb60af325b6e1f
+Author: Maxim Artamonov <scn1874@yandex.ru>
+Date:	Wed Dec 3 05:38:17 2008 +0300
+
+    bugfix for i.mx31 CCM_UPCTL reg
+
+    Signed-off-by: Maxim Artamonov <scn1874 at yandex.ru>
+
+commit 24113a44ed5cd3257a0237c3961e121812fca6db
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Tue Dec 30 03:15:38 2008 -0500
+
+    easylogo: add optional gzip support
+
+    Some images can be quite large, so add an option to compress the
+    image data with gzip in the U-Boot image. Then at runtime, the
+    board can decompress it with the normal zlib functions.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 7e4b9b4f6f43838fad3ad72c029a3d7fc7c7d48c
+Author: Bryan Wu <bryan.wu@analog.com>
+Date:	Fri Jan 2 20:47:45 2009 -0500
+
+    fat: fix unaligned errors
+
+    A couple of buffers in the fat code are declared as an array of bytes.
+    But it is then cast up to a structure with 16bit and 32bit members.
+    Since GCC assumes structure alignment here, we have to force the
+    buffers to be aligned according to the structure usage.
+
+    Signed-off-by: Bryan Wu <bryan.wu@analog.com>
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 68f8718df2ed4c2f43031407ccf6cfa81125dddc
+Author: Brad Bozarth <bflinux@yumbrad.com>
+Date:	Thu Jan 1 22:45:47 2009 -0500
+
+    spi flash: fix crash due to spi flash miscommunication
+
+    Higher spi flash layers expect to be given back a pointer that was
+    malloced so that it can free the result, but the lower layers return
+    a pointer that is in the middle of the malloced memory. Reorder the
+    members of the lower spi structures so that things work out.
+
+    Signed-off-by: Brad Bozarth <bflinux@yumbrad.com>
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Acked-by: Haavard Skinnemoen <haavard.skinnemoen@atmel.com>
+
+commit ce82ff05388b5ddafdf6082ef0776cce72c40b1c
+Author: Yuri Tikhonov <yur@emcraft.com>
+Date:	Sat Dec 20 14:54:21 2008 +0300
+
+    FPU POST: fix warnings when building with 2.18 binutils
+
+    When compile u-boot with the 2.18 binutils the following
+    warning messages for each object file in post/lib_ppc/fpu/ is
+    produced at the linking stage:
+
+    post/libpost.a(acc1.o) uses hard float, u-boot uses soft-float
+    ...
+
+    This is because of the fact that, in general, the soft-float and
+    hard-float ABIs are incompatible; the 2.18 binutils do checking
+    of the Tag_GNU_Power_ABI_FP attribute of the files to be linked, and
+    produce the worning like above if these are not compatible.
+
+    The incompatibility of ABIs is concerned only the float values:
+    e.g. the soft-float ABI assumes the float argument passing in the
+    pair of rX registers, and the hard-float ABI assumes passing of
+    the float argument in the fX register. When we don't pass the float
+    arguments between the functions compiled with different floatness,
+    then such an application will work correctly.
+    This is the case for the FPU POST: u-boot (compiled with soft-float)
+    doesn't pass to (and doesn't get from) the FPU POST functions any
+    floats; there are no functions exported from the post/lib_ppc/fpu/
+    objects which would work with float parameters/returns too. So, we
+    can reassure the linker not to worry about the difference in ABI
+    attributes of linking files just by setting the 'soft-float'
+    attribute for the objects in post/lib_ppc/fpu. And this patch does
+    this.
+
+    Also, to avoid passing both soft- and hard-float options in CFLAGS
+    when compiling the files from post/lib_ppc/fpu (which is OK, but
+    looks rather dirty) this patch removes the soft-float string from
+    CFLAGS in post/lib_ppc/fpu/Makefile.
+
+    Signed-off-by: Yuri Tikhonov <yur@emcraft.com>
+
+commit a7c9310457e85b4598abe5b304108edf11332e2f
+Author: Peter Tyser <ptyser@xes-inc.com>
+Date:	Wed Dec 17 16:36:22 2008 -0600
+
+    Add support for Maxim's DS4510 I2C device
+
+    Initial support for the DS4510, a CPU supervisor with
+    integrated EEPROM, SRAM, and 4 programmable non-volatile
+    GPIO pins. The CONFIG_DS4510 define enables support
+    for the device while the CONFIG_CMD_DS4510 define
+    enables the ds4510 command. The additional
+    CONFIG_DS4510_INFO, CONFIG_DS4510_MEM, and
+    CONFIG_DS4510_RST defines add additional sub-commands
+    to the ds4510 command when defined.
+
+    Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
+
+commit b6fc6fd49a84543e1324e1620b9f301ff7c1f27f
+Author: Dirk Eibach <eibach@gdsys.de>
+Date:	Tue Dec 16 14:51:56 2008 +0100
+
+    common: Iteration limit for memory test.
+
+    The iteration limit is passed to mtest as a fourth parameter:
+    [start [end [pattern [iterations]]]]
+    If no fourth parameter is supplied, there is no iteration limit and the
+    test will loop forever.
+
+    Signed-off-by: Dirk Eibach <eibach@gdsys.de>
+
+commit 97cae3a4c68d856374ccc70fd2c5f8714cc94f7d
+Author: Stefan Roese <sr@denx.de>
+Date:	Mon Dec 15 15:40:12 2008 +0100
+
+    serial: Rename driver vcth to vct to support other board variants
+
+    Moved driver vcth.c to vct.c to better reflect the VCT board series.
+    This driver is now used by the VCT platforms:
+
+    vct_premium
+    vct_platinum
+    vct_platinumsvc
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 36ede4d63e59c9277ec180b09c39b8bf46425ba2
+Author: Shinya Kuribayashi <skuribay@ruby.dti.ne.jp>
+Date:	Fri Dec 12 00:45:27 2008 +0900
+
+    nios: Move README.nios_CONFIG_SYS_NIOS_CPU to doc/ dir
+
+    Signed-off-by: Shinya Kuribayashi <skuribay@ruby.dti.ne.jp>
+
+commit c3284b030b1cd492b4f46c576aea01bef258599d
+Author: Peter Korsgaard <jacmet@sunsite.dk>
+Date:	Wed Dec 10 16:24:16 2008 +0100
+
+    common/main: support bootdelay=0 for CONFIG_AUTOBOOT_KEYED
+
+    Support bootdelay=0 in abortboot for the CONFIG_AUTOBOOT_KEYED case
+    similar to the CONFIG_ZERO_BOOTDELAY_CHECK support for the
+    !CONFIG_AUTOBOOT_KEYED case.
+
+    Do this by reversing the loop so we do at least one iteration before
+    checking for timeout.
+
+    Signed-off-by: Peter Korsgaard <jacmet@sunsite.dk>
+
+commit 94f9279f7bbdc01bbc7cf85aedf9b545943b94c3
+Author: Niklaus Giger <niklaus.giger@netstal.com>
+Date:	Mon Dec 8 17:24:08 2008 +0100
+
+    Added legacy flash ST Micro M29W040B
+
+commit 626d07348e5f9f302f4ea182161a89f7362a0488
+Author: Graeme Russ <graeme.russ@gmail.com>
+Date:	Mon Dec 8 20:04:51 2008 +1100
+
+    Fixed off-by-one errors in lib_m68k/interrupts.c
+
+    Signed-off-by: Graeme Russ <graeme.russ@gmail.com>
+
+commit a5989c42ae5e295f274a795c426c47819bbdbfda
+Author: Graeme Russ <graeme.russ@gmail.com>
+Date:	Sun Dec 7 10:29:05 2008 +1100
+
+    Removed all references to CONFIG_SYS_RESET_GENERIC
+
+    Generic i386 reset - #define made redundant by weak function
+
+    Signed-off-by: Graeme Russ <graeme.russ@gmail.com>
+
+commit 2b5360eb2bc0b741ae5cb3c84d35ccdd17667c8a
+Author: Graeme Russ <graeme.russ@gmail.com>
+Date:	Sun Dec 7 10:29:04 2008 +1100
+
+    Remove #ifdef CONFIG_SC520 in source code
+
+    CONFIG_SC520 is now used for conditional compile
+
+    Signed-off-by: Graeme Russ <graeme.russ@gmail.com>
+
+commit ead056bc206f6b7ee6dc98766678b64635ea20b8
+Author: Graeme Russ <graeme.russ@gmail.com>
+Date:	Sun Dec 7 10:29:03 2008 +1100
+
+    Added MMCR reset functionality
+
+    Reset function specific to AMD SC520 microcontroller - Is more of a
+    'hard reset' that the triple fault.
+
+    Requires CONFIG_SYS_RESET_SC520 to be defined in config
+
+    I would have liked to add this to a new file (cpu/i386/sc520/reset.c)
+    but ld requires that a object file in a library arhive MUST contain
+    at least one function which does not override a weak function (and is
+    called from outside the object file) in order for that object file to
+    be extracted from the archive. This would be the only function on the
+    new file, and hence, will never get linked in.
+
+    Signed-off-by: Graeme Russ <graeme.russ@gmail.com>
+
+commit 3f5f18d12d32ee0661bf51dfc55752c005230d6e
+Author: Graeme Russ <graeme.russ@gmail.com>
+Date:	Sun Dec 7 10:29:02 2008 +1100
+
+    Moved generic (triple fault) reset code
+
+    Moved from interrupts.c to cpu.c and made into a weak function to
+    allow vendor specific override
+
+    Vendor specific CPU reset (like the AMD SC520 MMCR reset) can now be
+    added to the vendor specific code without the need to remember to
+    #undef usage of the generic method and if you forget to include your
+    custom reset method, you will always get the default.
+
+    Signed-off-by: Graeme Russ <graeme.russ@gmail.com>
+
+commit 9933d609020c297788f53f334c8465fa7a99b10c
+Author: Graeme Russ <graeme.russ@gmail.com>
+Date:	Sun Dec 7 10:29:01 2008 +1100
+
+    Moved definition of set_vector() to new header file
+
+    This allows for future tidy ups and functionality that will require
+    set_vector ()
+
+    Signed-off-by: Graeme Russ <graeme.russ@gmail.com>
+
+commit 407976185e0dda2c90e89027121a1071b9c77bfb
+Author: Graeme Russ <graeme.russ@gmail.com>
+Date:	Sun Dec 7 10:29:00 2008 +1100
+
+    Moved sc520 specific code into new cpu/i386/sc520 folder
+
+    Signed-off-by: Graeme Russ <graeme.russ@gmail.com>
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit 85ffbbd51914925a542d8528be7f072e5ab02157
+Author: Graeme Russ <graeme.russ@gmail.com>
+Date:	Sun Dec 7 10:28:58 2008 +1100
+
+    Renamed cpu/i386/reset.S to resetvec.S
+
+    Brings i386 in line with other CPUs with a reset vector and frees up reset.c
+    for CPU reset functions
+
+    Signed-off-by: Graeme Russ <graeme.russ@gmail.com>
+
+commit a3f4c123f569474e80ea012b8db0de46afdb6443
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Sat Jan 24 01:01:49 2009 +0100
+
+    Makefile: keep lists sorted.
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit c620c01e96814558470698ed5cab1bf2f504d1b5
+Author: Graeme Russ <graeme.russ@gmail.com>
+Date:	Sun Dec 7 10:28:57 2008 +1100
+
+    Added initial eNET board support
+
+    Signed-off-by: Graeme Russ <graeme.russ@gmail.com>
+
+commit 0c0ccf401ee03a5008fc2c19b05a662bce1a1086
+Author: Gary Jennejohn <garyj@denx.de>
+Date:	Thu Nov 20 11:37:26 2008 +0100
+
+    POWERPC 82xx: add the SCC as an HDLC controller
+
+    Right now this is only used by keymile.
+
+    Signed-off-by: Gary Jennejohn <garyj@denx.de>
+
+commit 1e8f4e78ca393b3d8e86bd8055758dd465d9113f
+Author: Heiko Schocher <hs@denx.de>
+Date:	Thu Nov 20 09:59:09 2008 +0100
+
+    powerpc, keymile boards: extract identical config options
+
+    This patch extracts the identical config options for the
+    keymile boards mgcoge, mgsuvd and kmeter1 in a new
+    common config file keymile-common.h.
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+
+commit 210c8c00aad3328145204adab434bb7d70b06b75
+Author: Heiko Schocher <hs@denx.de>
+Date:	Fri Nov 21 08:29:40 2008 +0100
+
+    powerpc: keymile: Add a check for the PIGGY debug board
+
+    Check the presence of the PIGGY on the keymile boards mgcoge,
+    mgsuvd and kmeter1. If the PIGGY is not present, dont register
+    this Ethernet device.
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+    Acked-by: Ben Warren <biggerbadderben@gmail.com>
+
+commit de0443614af4d16675ab436665aeb11ddc9f7214
+Author: Heiko Schocher <hs@denx.de>
+Date:	Thu Nov 20 09:57:47 2008 +0100
+
+    powerpc: 83xx: add support for the kmeter1 board
+
+    This patch adds support for the kmeter1 board from Keymile,
+    based on a Freescale MPC8360 CPU.
+
+    - serial console on UART 1
+    - 256 MB DDR2 RAM
+    - 64 MB NOR Flash
+    - Ethernet RMII Mode over UCC4
+    - PHY SMSC LAN8700
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+
+commit 3feb647f3fd0881382c7a29f4cf280b66473ae0a
+Author: Sergei Poselenov <sposelenov@emcraft.com>
+Date:	Tue Nov 4 13:51:18 2008 +0100
+
+    Add a do_div() wrapper macro, lldiv().
+
+    Add a do_div() wrapper, lldiv(). The new inline function doesn't modify
+    the dividend and returns the result of division, so it is useful
+    in complex expressions, i.e. "return(a/b)" -> "return(lldiv(a,b))"
+
+    Signed-off-by: Sergei Poselenov <sposelenov@emcraft.com>
+
+commit 18af1c5f0f7402dc0d6a71b012c68025dd97cf72
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Fri Jan 23 14:22:14 2009 -0600
+
+    85xx: Add a 36-bit physical configuration for MPC8572DS
+
+    We move all IO addressed (CCSR, localbus, PCI) above the 4G boundary
+    to allow for larger memory sizes.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit c51fc5d53c4560abc4d0a6126c06fc68133d1528
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Fri Jan 23 14:22:13 2009 -0600
+
+    85xx: Handle eLBC difference w/36-bit physical
+
+    The eLBC only handles 32-bit physical address in systems with 36-bit
+    physical.  The previos generation of LBC handled 34-bit physical
+    address in 36-bit systems.	Added a new CONFIG option to convey
+    the difference between the LBC and eLBC.
+
+    Also added defines for XAM bits used in LBC for the extended 34-bit
+    support.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit 72a9414a8e21e9536822c7353bc08d21ce5ad53d
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Fri Jan 23 14:22:12 2009 -0600
+
+    85xx: Use BR_ADDR macro for NAND chipselects
+
+    Use the new BR_ADDR macro to properly setup the address field of the
+    localbus chipselects used by NAND.
+
+    This allows us to deal with 36-bit phys on these boards in the future.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit 2fc7eb0cfc608c9369001d57a0411af5e6a58f7c
+Author: Haiying Wang <Haiying.Wang@freescale.com>
+Date:	Thu Jan 15 11:58:35 2009 -0500
+
+    Add secondary CPUs processor frequency for e500 core
+
+    This patch updates e500 freqProcessor to array based on CONFIG_NUM_CPUS,
+    and prints each CPU's frequency separately. It also fixes up each CPU's
+    frequency in "clock-frequency" of fdt blob.
+
+    Signed-off-by: James Yang <James.Yang@freescale.com>
+    Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
+
+commit bf5b1f0c0d28ce062e1d368680632dfb099de692
+Author: Dave Liu <daveliu@freescale.com>
+Date:	Fri Nov 21 16:31:53 2008 +0800
+
+    85xx: enable the auto self refresh for wake up ARP
+
+    The wake up ARP feature need use the memory to process
+    wake up packet, we enable auto self refresh to support it.
+
+    Signed-off-by: Dave Liu <daveliu@freescale.com>
+    Acked-by: Andy Fleming <afleming@freescale.com>
+
+commit b4983e16d150ab7d039704c310aacbd2f4dc1e0f
+Author: Dave Liu <daveliu@freescale.com>
+Date:	Fri Nov 21 16:31:43 2008 +0800
+
+    fsl-ddr: use the 1T timing as default configuration
+
+    For light loaded system, we use the 1T timing to gain better
+    memory performance, but for some heavily loaded system,
+    you have to add the 2T timing options to board files.
+
+    Signed-off-by: Dave Liu <daveliu@freescale.com>
+    Acked-by: Andy Fleming <afleming@freescale.com>
+
+commit 22cca7e1cd54590e967c73558b07ffbdccd39504
+Author: Dave Liu <daveliu@freescale.com>
+Date:	Fri Nov 21 16:31:35 2008 +0800
+
+    fsl-ddr: make the self refresh idle threshold configurable
+
+    Some 85xx processors have the advanced power management feature,
+    such as wake up ARP, that needs enable the automatic self refresh.
+
+    If the DDR controller pass the SR_IT (self refresh idle threshold)
+    idle cycles, it will automatically enter self refresh. However,
+    anytime one transaction is issued to the DDR controller, it will
+    reset the counter and exit self refresh state.
+
+    Signed-off-by: Dave Liu <daveliu@freescale.com>
+    Acked-by: Andy Fleming <afleming@freescale.com>
+
+commit 22ff3d01348e0a2dc369b7efcbac30e4ce86d178
+Author: Dave Liu <daveliu@freescale.com>
+Date:	Fri Nov 21 16:31:29 2008 +0800
+
+    fsl-ddr: clean up the ddr code for DDR3 controller
+
+    - The DDR3 controller is expanding the bits for timing config
+    - Add the DDR3 32-bit bus mode support
+
+    Signed-off-by: Dave Liu <daveliu@freescale.com>
+    Acked-by: Andy Fleming <afleming@freescale.com>
+
+commit 80ee3ce6d7fe9441b4352d7cfaf6afc2507b1106
+Author: Dave Liu <daveliu@freescale.com>
+Date:	Fri Nov 21 16:31:22 2008 +0800
+
+    fsl-ddr: update the bit mask for DDR3 controller
+
+    According to the latest 8572 UM, the DDR3 controller
+    is expanding the bit mask, and we use the extend ACTTOPRE
+    mode when tRAS more than 19 MCLK.
+
+    Signed-off-by: Dave Liu <daveliu@freescale.com>
+
+commit aca5f018a8386b85469482ed9867e3e29a2437d0
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Tue Dec 2 16:08:40 2008 -0600
+
+    85xx: Introduce CONFIG_SYS_PCI*_IO_VIRT for FSL boards
+
+    Introduce a new define to seperate out the virtual address that PCI
+    IO space is at from the physical address.  In most situations these are
+    mapped 1:1.  However any code accessing the bus should use VIRT.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+    Acked-by: Andy Fleming <afleming@freescale.com>
+
+commit 5af0fdd81c3370c3a51421208fda568bdcbbec23
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Tue Dec 2 16:08:39 2008 -0600
+
+    85xx: Introduce CONFIG_SYS_PCI*_MEM_VIRT for FSL boards
+
+    Introduce a new define to seperate out the virtual address that PCI
+    memory is at from the physical address.  In most situations these are
+    mapped 1:1.  However any code accessing the bus should use VIRT.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+    Acked-by: Andy Fleming <afleming@freescale.com>
+
+commit a6e04c344ad1eefd47a75484441b385da815b8df
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Tue Dec 2 16:08:38 2008 -0600
+
+    85xx: Use CONFIG_SYS_{PCI*,RIO*}_MEM_PHYS for physical address on FSL boards
+
+    Use the _MEM_PHYS defines instead of _MEM_BUS for LAW and real address fields
+    of TLBs.  This is what we should have always been using from the start.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+    Acked-by: Andy Fleming <afleming@freescale.com>
+
+commit 5f91ef6acdbadec33e0192049e2b24a1d9692f1d
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Tue Dec 2 16:08:37 2008 -0600
+
+    85xx: Convert CONFIG_SYS_PCI*_IO_BASE to _IO_BUS for FSL boards
+
+    Use CONFIG_SYS_PCI*_IO_BUS for the bus relative address instead
+    of _IO_BASE so we are more explicit.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+
+commit 10795f42cb94e71bcb262b615084f69dd886399a
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Tue Dec 2 16:08:36 2008 -0600
+
+    85xx: Convert CONFIG_SYS_{PCI*,RIO*}_MEM_BASE to _MEM_BUS for FSL boards
+
+    Use CONFIG_SYS_{PCI,RIO}_MEM_BUS for the bus relative address instead
+    of _MEM_BASE so we are more explicit.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+    Acked-by: Andy Fleming <afleming@freescale.com>
+
+commit c953ddfd56b3ae3f28910fe3aed6de6968d1c9aa
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Tue Dec 2 14:19:34 2008 -0600
+
+    85xx: separate FLASH BASE virtual from physical address
+
+    Added a CONFIG_SYS_FLASH_BASE_PHYS for use as the physical address and
+    maintain CONFIG_SYS_FLASH_BASE as the virtual address of the flash.
+
+    This allows us to deal with 36-bit phys on these boards in the future.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+    Acked-by: Andy Fleming <afleming@freescale.com>
+
+commit 52b565f5ad23b682489055b187767d8bf1c2e444
+Author: Kumar Gala <galak@kernel.crashing.org>
+Date:	Tue Dec 2 14:19:33 2008 -0600
+
+    85xx: separate PIXIS virtual from physical address
+
+    Added a PIXIS_BASE_PHYS for use as the physical address and maintain
+    PIXIS_BASE as the virtual address of the PIXIS fpga registers.
+
+    This allows us to deal with 36-bit phys on these boards in the future.
+
+    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
+    Acked-by: Andy Fleming <afleming@freescale.com>
+
+commit 30837e5b21d5a742983581ab9ee3fac085311d19
+Author: Haiying Wang <Haiying.Wang@freescale.com>
+Date:	Tue Nov 11 08:52:09 2008 -0500
+
+    Add README file for MPC8572DS board
+
+    Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
+    Acked-by: Andy Fleming <afleming@freescale.com>
+
+commit 6dadc9195ad642cc662632f4d92f92d3d71e8bf2
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Mon Oct 20 16:15:04 2008 -0400
+
+    Blackfin: use common strmhz() in system output
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+
+commit 5bb907a4925397789c90d074f4f7e92ce6b39402
+Author: Ron Madrid <ron_madrid@sbcglobal.net>
+Date:	Thu Jan 22 15:05:24 2009 -0800
+
+    mpc83xx: New board support for SIMPC8313
+
+    This patch will create a new board, SIMPC8313, from Sheldon Instruments.  This
+    board boots from NAND devices and is configureable for either large or small
+    page devices.  The board supports non-soldered DDR2, one ethernet port, a
+    Marvell 88E1118 PHY, and PCI host support.	The board also has a FPGA connected
+    to the eLBC providing glue logic to a TMS320C67xx DSP.
+
+    Signed-off-by: Ron Madrid <ron_madrid@sbcglobal.net>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit d4bade8d77aa20e2846fa4accff0e7fa7961a134
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sun Jan 18 19:46:06 2009 -0500
+
+    nand: fixup printf modifiers to match types used
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit 389e6620e2271096df3316917528003627db4021
+Author: Schlaegl Manfred jun <manfred.schlaegl@gmx.at>
+Date:	Tue Jan 20 16:57:55 2009 +0100
+
+    nand read.jffs2 (nand_legacy) in common/cmd_nand.c
+
+    Error with CONFIG_NAND_LEGACY in common/cmd_nand.c:
+    With current code "nand read.jffs2s" (read and skip bad blocks) is always interpreted as
+    "nand read.jffs2" (read and fill bad blocks with 0xff). This is because ".jffs2" is
+    tested before ".jffs2s" and only the first two characters are compared.
+
+    Correction:
+    Test for ".jffs2s" first and compare the first 7 characters.
+
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit 6c869637fef31e66380f0ea1d49690a2e26ec0d7
+Author: Wolfgang Grandegger <wg@grandegger.com>
+Date:	Fri Jan 16 18:55:54 2009 +0100
+
+    NAND: rename NAND_MAX_CHIPS to CONFIG_SYS_NAND_MAX_CHIPS
+
+    This patch renames NAND_MAX_CHIPS to CONFIG_SYS_NAND_MAX_CHIPS and
+    changes the default from 8 to 1 for the legacy and the new MTD
+    NAND layer. This allows to remove all NAND_MAX_CHIPS definitions
+    in the board config files because none of the boards use multi
+    chip support (NAND_MAX_CHIPS > 1) so far. The bamboo and the DU440
+    define
+
+     #define NAND_MAX_CHIPS	     CONFIG_SYS_MAX_NAND_DEVICE
+
+    but that's bogus and did not work anyhow.
+
+    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit c70564e6b1bd08f3230182392238907f3531a87e
+Author: Dave Liu <daveliu@freescale.com>
+Date:	Tue Dec 2 11:48:51 2008 +0800
+
+    NAND: Fix cache and memory inconsistency issue
+
+    We load the secondary stage u-boot image from NAND to
+    system memory by nand_load, but we did not flush d-cache
+    to memory, nor invalidate i-cache before we jump to RAM.
+    When the system has cache enabled and the TLB/page attribute
+    of system memory is cacheable, it will cause issues.
+
+    - 83xx family is using the d-cache lock, so all of d-cache
+      access is cache-inhibited. so you can't see the issue.
+    - 85xx family is using d-cache, i-cache enable, partial
+      cache lock. you will see the issue.
+
+    This patch fixes the cache issue.
+
+    Signed-off-by: Dave Liu <daveliu@freescale.com>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit 50657c273278f74378e1ac39b41d612b92fdffa0
+Author: Nishanth Menon <menon.nishanth@gmail.com>
+Date:	Sat Dec 13 09:43:06 2008 -0600
+
+    NAND: Enable nand lock, unlock feature
+
+    Enable nand lock, unlock and status of lock feature.
+    Not every device and platform requires this, hence,
+    it is under define for CONFIG_CMD_NAND_LOCK_UNLOCK
+
+    Nand unlock and status operate on block boundary instead
+    of page boundary. Details in:
+    http://www.micron.com/products/partdetail?part=MT29C2G24MAKLAJG-6%20IT
+
+    Intial solution provided by Vikram Pandita <vikram.pandita@ti.com>
+    Includes preliminary suggestions from Scott Wood
+
+    Signed-off-by: Nishanth Menon <nm@ti.com>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit 69fb8be4fc07162fdf6edf04bdc7233b0e9a920e
+Author: Mike Frysinger <vapier@gentoo.org>
+Date:	Sat Dec 6 02:40:55 2008 -0500
+
+    NAND: move board_nand_init to nand.h
+
+    Rather than putting the function prototype for board_nand_init() in the one
+    place where it gets called, put it into nand.h so that every place that also
+    defines it gets the prototype.  Otherwise, errors can go silently unnoticed
+    such as using the wrong return value (void rather than int) when defining
+    the function.
+
+    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit 1ae39862044ebb1e682234b51f94421e3f871d6a
+Author: Stefan Roese <sr@denx.de>
+Date:	Tue Dec 2 11:06:47 2008 +0100
+
+    OneNAND: Additional sync with 2.6.27
+
+    - Add subpage write support
+    - Add onenand_oob_64/32 ecclayout
+
+    This has been missing and without it UBI has some incompatibilies issues
+    with the current (>= 2.6.27) Linux kernel version. vid_hdr_offset is
+    placed differently (2048 instead of 512) without this fix.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+
+commit 1714f51a2009baaecf3d4f6e3bd8c4e93a8d3f23
+Author: Kyungmin Park <kmpark@infradead.org>
+Date:	Thu Nov 13 15:14:33 2008 +0900
+
+    Add markbad function
+
+    Add missing markbad function
+    If not, it's hang when it entered the mtd->mark_bad().
+
+    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
+
+commit c438ea175d8d002c1063b7a94b0c0e26668d1ac9
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Nov 12 13:47:24 2008 +0100
+
+    OneNAND: Bad block aware read/write command support
+
+    Update OneNAND command to support bad block awareness.
+    Also change the OneNAND command style to better match the
+    NAND version.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
+
+commit 8cf11f3aa78673730e9ecbbe4b75213b53f212c8
+Author: Stefan Roese <sr@denx.de>
+Date:	Tue Nov 11 10:29:09 2008 +0100
+
+    OneNAND: Save version_id in onenand_chip struct
+
+    The version (ver_id) was not stored in the onenand_chip structure and
+    because of this the continuous locking scheme could be enabled on some
+    chips.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 4fca3310d611cc0f51d7295ef3557afbdbd91dc3
+Author: Stefan Roese <sr@denx.de>
+Date:	Tue Nov 11 10:28:53 2008 +0100
+
+    OneNAND: Fix compiler warnings
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 1ac5744e33ee0aa6d6ddab3b99f9e70953156e69
+Author: Dave Liu <daveliu@freescale.com>
+Date:	Tue Nov 4 14:55:06 2008 +0800
+
+    mpc83xx: enable eLBC NAND support for MPC8315ERDB board
+
+    Signed-off-by: Dave Liu <daveliu@freescale.com>
+
+commit ef0921d6b05aeb9034158f9bef5323d6da9c925e
+Author: Kyungmin Park <kmpark@infradead.org>
+Date:	Tue Nov 4 09:24:07 2008 +0900
+
+    Sync with 2.6.27
+
+    Sync with OneNAND kernel codes
+
+    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
+
+commit e7f325be9edeb84bb457301776bbac1f7257dafc
+Author: Michal Simek <monstr@monstr.eu>
+Date:	Mon Jan 5 13:35:31 2009 +0100
+
+    microblaze: Use cache functions (especially cache status)
+    in systems which are configured without flash
+
+commit e9b737deb2c30125362d20e24170617476026e94
+Author: Michal Simek <monstr@monstr.eu>
+Date:	Mon Jan 5 13:29:32 2009 +0100
+
+    microblaze: Add cache flush
+
+commit b4f8dda35bfad447b4106828232705b2e878d168
+Author: Michal Simek <monstr@monstr.eu>
+Date:	Mon Jan 5 13:28:40 2009 +0100
+
+    microblaze: Add bootup messages to board.c
+
+commit 330e55459bc9983341da6c1d5c7fe00a664436fe
+Author: Michal Simek <monstr@monstr.eu>
+Date:	Fri Dec 19 13:25:55 2008 +0100
+
+    microblaze: Change microblaze-generic config file
+
+    Signed-off-by: Michal Simek <monstr@monstr.eu>
+
+commit 52a822ed9c37a2ea0ed112a26d8ff5a6cb1c6f10
+Author: Michal Simek <monstr@monstr.eu>
+Date:	Fri Dec 19 13:14:05 2008 +0100
+
+    microblaze: Rename ml401 to microblaze-generic
+
+    Signed-off-by: Michal Simek <monstr@monstr.eu>
+
+commit 6677876181cc8772bca8a372479a500d160f3993
+Author: Scott Wood <scottwood@freescale.com>
+Date:	Tue Jan 20 11:56:11 2009 -0600
+
+    83xx: Use the proper sequence for updating IMMR.
+
+    This ensures that subsequent accesses properly hit the new window.
+
+    The dcbi during the NAND loop was accidentally working around this;
+    it's no longer necessary, as the cache is not enabled.
+
+    Reported-by: Suchit Lepcha <Suchit.Lepcha@freescale.com>
+    Signed-off-by: Scott Wood <scottwood@freescale.com>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit 8b34557c546e5e9f34ebf83c93413dad973d93df
+Author: Anton Vorontsov <avorontsov@ru.mvista.com>
+Date:	Thu Jan 8 04:26:19 2009 +0300
+
+    mpc83xx: Add PCI-E support for MPC837XEMDS boards
+
+    MPC837XEMDS boards can support PCI-E via "PCI-E riser card". The card
+    provides two PCI-E (x2) ports. Though, only one port can be used in x2
+    mode. Two ports can function simultaneously in x1 mode.
+
+    PCI-E x1/x2 modes can be switched via "pex_x2" environment variable.
+
+    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit 8f11e34b31a7be124a3239653f33af9510502045
+Author: Anton Vorontsov <avorontsov@ru.mvista.com>
+Date:	Thu Jan 8 04:26:17 2009 +0300
+
+    mpc83xx: Add PCI-E support for MPC8315ERDB boards
+
+    MPC8315ERDB boards features PCI-E x1 and Mini PCI-E x1 ports. Let's
+    support them.
+
+    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit fd6646c0b9ebe7e5afc4ae4c78097d9cd317a5e8
+Author: Anton Vorontsov <avorontsov@ru.mvista.com>
+Date:	Thu Jan 8 04:26:12 2009 +0300
+
+    mpc83xx: Add support for MPC83xx PCI-E controllers
+
+    This patch adds support for MPC83xx PCI-E controllers in Root Complex
+    mode.
+
+    The patch is based on Tony Li and Dave Liu work[1].
+
+    Though unlike the original patch, by default we don't register PCI-E
+    buses for use in U-Boot, we only configure the controllers for future
+    use in other OSes (Linux). This is done because we don't have enough
+    of spare BATs to map all the PCI-E regions.
+
+    To actually use PCI-E in U-Boot, users should explicitly define
+    CONFIG_83XX_GENERIC_PCIE_REGISTER_HOSES symbol in the board file. And
+    only then U-Boot will able to access PCI-E, but at the cost of disabled
+    address translation.
+
+    [1] http://lists.denx.de/pipermail/u-boot/2008-January/027630.html
+
+    Signed-off-by: Tony Li <tony.li@freescale.com>
+    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
+    Acked-by: Dave Liu <daveliu@freescale.com>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit 88ecf55cabd7aea28fe8093720e208f53ccfdcf5
+Author: Ira Snyder <iws@ovro.caltech.edu>
+Date:	Mon Jan 12 13:33:17 2009 -0800
+
+    MPC8349EMDS: do not setup unused PCI clock outputs in PCI agent mode
+
+    When running in PCI agent mode, the PCI_CLK_OUT signals are not used, so do
+    not enable them. See the MPC8349EA Reference Manual, Section 4.4.2
+    "Clocking in PCI Agent Mode".
+
+    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit 75f35209f702bb26826855ed8c8e4d108ab5f412
+Author: Ira Snyder <iws@ovro.caltech.edu>
+Date:	Mon Jan 12 13:32:26 2009 -0800
+
+    83xx: PCI agent mode fixes for multi-board systems
+
+    When running a system with 2 or more MPC8349EMDS boards in PCI agent mode,
+    the boards will lock up the PCI bus by scanning against each other.
+
+    The boards lock against each other by trying to access the PCI bus before
+    clearing their configuration lock bit. Both boards end up in a loop,
+    sending and receiving "Target Not Ready" messages forever.
+
+    When running in PCI agent mode, the scanning now takes place after the
+    boards have cleared their configuration lock bit.
+
+    Also, add a missing declaration to the mpc83xx.h header file, fixing a
+    build warning.
+
+    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit 455a46915b82896cc2070eb326d075555c2bc580
+Author: Ron Madrid <ron_madrid@sbcglobal.net>
+Date:	Fri Dec 12 13:12:45 2008 -0800
+
+    mpc83xx: Size optimization of start.S
+
+    Currently there are in excess of 100 bytes located at the beginning of the image
+    built by start.S that are not being utilized.  This patch moves a few functions
+    into this part of the image.  This will create a greater number of *available*
+    bytes that can be used by board specific code in NAND builds and will decrease
+    the size of the assembled code in other builds.
+
+    Signed-off-by: Ron Madrid <ron_madrid@sbcglobal.net>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit 72d15e705bc3983884105cb7755c7ba80e74a0a5
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Wed Jan 21 23:08:12 2009 +0100
+
+    Prepare v2009.01
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
 commit 635e5f8fc82365e6e9734b3132bc95135a6de679
 Author: Wolfgang Denk <wd@denx.de>
 Date:	Sun Jan 18 21:37:48 2009 +0100
@@ -725,6 +5698,20 @@
 
     Signed-off-by: Peter Tyser <ptyser@xes-inc.com>
 
+commit 92c78a3bbcb2ce508b4bf1c4a1e0940406a024bb
+Author: Haavard Skinnemoen <haavard.skinnemoen@atmel.com>
+Date:	Wed Dec 17 16:43:18 2008 +0100
+
+    avr32: Remove second definition of virt_to_phys()
+
+    The second definition introduced by 65e43a1063 conflicts with the
+    existing one.
+
+    Also, convert the existing definition to use phys_addr_t. The volatile
+    qualifier is still needed due to brain damage elsewhere.
+
+    Signed-off-by: Haavard Skinnemoen <haavard.skinnemoen@atmel.com>
+
 commit b616f2b545f73757669b37386f0b37bb61fc6797
 Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
 Date:	Mon Sep 8 22:27:18 2008 +0200
@@ -1316,6 +6303,15 @@
     Signed-off-by: Sonic Zhang <Sonic.Zhang@analog.com>
     Signed-off-by: Mike Frysinger <vapier@gentoo.org>
 
+commit 4cd8ed40615a7d741ef2f09ee53779ec6907b8a6
+Author: Ben Warren <biggerbadderben@gmail.com>
+Date:	Tue Dec 9 23:26:31 2008 -0800
+
+    Fix compile error in building MBX860T.
+    Bug was introduced in 9eb79bd8856bcab896ed5e1f1bca159807a124dd
+
+    Signed-off-by: Ben Warren <biggerbadderben@gmail.com>
+
 commit 97a24a78ee6f34b89b821cb70eda1cf34aa11d97
 Author: Jerry Van Baren <gvb.uboot@gmail.com>
 Date:	Mon Nov 24 08:15:02 2008 -0500
@@ -2357,6 +7353,32 @@
     Signed-off-by: Matthias Fuchs <matthias.fuchs@esd-electronics.com>
     Signed-off-by: Stefan Roese <sr@denx.de>
 
+commit 633639587e3596f0dbf5e6247dd3faf80b1d9063
+Author: Heiko Schocher <hs@denx.de>
+Date:	Thu Nov 20 09:59:09 2008 +0100
+
+    powerpc, keymile boards: extract identical config options
+
+    This patch extracts the identical config options for the
+    keymile boards mgcoge, mgsuvd and kmeter1 in a new
+    common config file keymile-common.h.
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit 9482a8e3d6ac766d90e5059dce777b1e4c868a30
+Author: Heiko Schocher <hs@denx.de>
+Date:	Fri Nov 21 08:29:40 2008 +0100
+
+    powerpc: keymile: Add a check for the PIGGY debug board
+
+    Check the presence of the PIGGY on the keymile boards mgcoge,
+    mgsuvd and kmeter1. If the PIGGY is not present, dont register
+    this Ethernet device.
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
 commit 58c696eed839af894e0265064669c402dc28b371
 Author: Wolfgang Denk <wd@xpert.denx.de>
 Date:	Mon Nov 24 21:50:59 2008 +0100
@@ -2631,6 +7653,24 @@
 
     Signed-off-by: Stelian Pop <stelian@popies.net>
 
+commit fed36ac5ae613773b6cd90e61e292c45440e10c8
+Author: Heiko Schocher <hs@denx.de>
+Date:	Thu Nov 20 09:57:47 2008 +0100
+
+    powerpc: 83xx: add support for the kmeter1 board
+
+    This patch adds support for the kmeter1 board from Keymile,
+    based on a Freescale MPC8360 CPU.
+
+    - serial console on UART 1
+    - 256 MB DDR2 RAM
+    - 64 MB NOR Flash
+    - Ethernet RMII Mode over UCC4
+    - PHY SMSC LAN8700
+
+    Signed-off-by: Heiko Schocher <hs@denx.de>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
 commit 25fb4eaaeab3f8866020818f4729d990dcc91cf0
 Author: Stefan Roese <sr@denx.de>
 Date:	Thu Nov 20 11:46:20 2008 +0100
diff -Naur u-boot-2009.01/common/cmd_ambapp.c u-boot/common/cmd_ambapp.c
--- u-boot-2009.01/common/cmd_ambapp.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_ambapp.c	2009-02-26 14:03:58.000000000 +0100
@@ -273,6 +273,6 @@
 }
 
 U_BOOT_CMD(ambapp, 1, 1, do_ambapp_print,
-	   "ambapp  - list AMBA Plug&Play information\n",
+	   "list AMBA Plug&Play information",
 	   "ambapp\n"
 	   "    - lists AMBA (AHB & APB) Plug&Play devices present on the system\n");
diff -Naur u-boot-2009.01/common/cmd_autoscript.c u-boot/common/cmd_autoscript.c
--- u-boot-2009.01/common/cmd_autoscript.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_autoscript.c	2009-02-26 14:03:58.000000000 +0100
@@ -230,7 +230,7 @@
 
 U_BOOT_CMD(
 	autoscr, 2, 0,	do_autoscript,
-	"autoscr - run script from memory\n",
+	"run script from memory",
 	"[addr] - run script starting at addr"
 	" - A valid autoscr header must be present\n"
 #if defined(CONFIG_FIT)
diff -Naur u-boot-2009.01/common/cmd_bdinfo.c u-boot/common/cmd_bdinfo.c
--- u-boot-2009.01/common/cmd_bdinfo.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_bdinfo.c	2009-02-26 14:03:58.000000000 +0100
@@ -283,6 +283,7 @@
 #if defined(CONFIG_SYS_MBAR)
 	print_num ("mbar",		bd->bi_mbar_base);
 #endif
+	print_str ("cpufreq",		strmhz(buf, bd->bi_intfreq));
 	print_str ("busfreq",		strmhz(buf, bd->bi_busfreq));
 #ifdef CONFIG_PCI
 	print_str ("pcifreq",		strmhz(buf, bd->bi_pcifreq));
@@ -322,24 +323,26 @@
 	puts ("\nip_addr     = ");
 	print_IPaddr (bd->bi_ip_addr);
 #endif
-	printf ("\nbaudrate    = %d bps\n", bd->bi_baudrate);
+	printf ("\nbaudrate    = %ld bps\n", bd->bi_baudrate);
 
 	return 0;
 }
 
 #elif defined(CONFIG_BLACKFIN)
+static void print_str(const char *, const char *);
 
 int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	int i;
 	bd_t *bd = gd->bd;
+	char buf[32];
 
 	printf("U-Boot      = %s\n", bd->bi_r_version);
 	printf("CPU         = %s\n", bd->bi_cpu);
 	printf("Board       = %s\n", bd->bi_board_name);
-	printf("VCO         = %lu MHz\n", bd->bi_vco / 1000000);
-	printf("CCLK        = %lu MHz\n", bd->bi_cclk / 1000000);
-	printf("SCLK        = %lu MHz\n", bd->bi_sclk / 1000000);
+	print_str("VCO",         strmhz(buf, bd->bi_vco));
+	print_str("CCLK",        strmhz(buf, bd->bi_cclk));
+	print_str("SCLK",        strmhz(buf, bd->bi_sclk));
 
 	print_num("boot_params", (ulong)bd->bi_boot_params);
 	print_num("memstart",    (ulong)bd->bi_memstart);
@@ -430,7 +433,7 @@
 }
 #endif
 
-#if defined(CONFIG_PPC) || defined(CONFIG_M68K)
+#if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_BLACKFIN)
 static void print_str(const char *name, const char *str)
 {
 	printf ("%-12s= %6s MHz\n", name, str);
@@ -442,6 +445,6 @@
 
 U_BOOT_CMD(
 	bdinfo,	1,	1,	do_bdinfo,
-	"bdinfo  - print Board Info structure\n",
+	"print Board Info structure",
 	NULL
 );
diff -Naur u-boot-2009.01/common/cmd_bedbug.c u-boot/common/cmd_bedbug.c
--- u-boot-2009.01/common/cmd_bedbug.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_bedbug.c	2009-02-26 14:03:58.000000000 +0100
@@ -85,7 +85,7 @@
 	len = dis_last_len;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -107,7 +107,7 @@
 }				/* do_bedbug_dis */
 
 U_BOOT_CMD (ds, 3, 1, do_bedbug_dis,
-	    "ds      - disassemble memory\n",
+	    "disassemble memory",
 	    "ds <address> [# instructions]\n");
 
 /* ======================================================================
@@ -126,7 +126,7 @@
 	int rcode = 0;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -160,7 +160,7 @@
 }				/* do_bedbug_asm */
 
 U_BOOT_CMD (as, 2, 0, do_bedbug_asm,
-	    "as      - assemble memory\n", "as <address>\n");
+	    "assemble memory", "as <address>\n");
 
 /* ======================================================================
  * Used to set a break point from the interpreter.  Simply calls into the
@@ -177,7 +177,7 @@
 }				/* do_bedbug_break */
 
 U_BOOT_CMD (break, 3, 0, do_bedbug_break,
-	    "break   - set or clear a breakpoint\n",
+	    "set or clear a breakpoint",
 	    " - Set or clear a breakpoint\n"
 	    "break <address> - Break at an address\n"
 	    "break off <bp#> - Disable breakpoint.\n"
@@ -277,7 +277,7 @@
 }				/* do_bedbug_continue */
 
 U_BOOT_CMD (continue, 1, 0, do_bedbug_continue,
-	    "continue- continue from a breakpoint\n",
+	    "continue from a breakpoint",
 	    " - continue from a breakpoint.\n");
 
 /* ======================================================================
@@ -308,7 +308,7 @@
 }				/* do_bedbug_step */
 
 U_BOOT_CMD (step, 1, 1, do_bedbug_step,
-	    "step    - single step execution.\n",
+	    "single step execution.",
 	    " - single step execution.\n");
 
 /* ======================================================================
@@ -339,7 +339,7 @@
 }				/* do_bedbug_next */
 
 U_BOOT_CMD (next, 1, 1, do_bedbug_next,
-	    "next    - single step execution, stepping over subroutines.\n",
+	    "single step execution, stepping over subroutines.",
 	    " - single step execution, stepping over subroutines.\n");
 
 /* ======================================================================
@@ -384,7 +384,7 @@
 }				/* do_bedbug_stack */
 
 U_BOOT_CMD (where, 1, 1, do_bedbug_stack,
-	    "where   - Print the running stack.\n",
+	    "Print the running stack.",
 	    " - Print the running stack.\n");
 
 /* ======================================================================
@@ -405,7 +405,7 @@
 }				/* do_bedbug_rdump */
 
 U_BOOT_CMD (rdump, 1, 1, do_bedbug_rdump,
-	    "rdump   - Show registers.\n", " - Show registers.\n");
+	    "Show registers.", " - Show registers.\n");
 /* ====================================================================== */
 
 
diff -Naur u-boot-2009.01/common/cmd_bmp.c u-boot/common/cmd_bmp.c
--- u-boot-2009.01/common/cmd_bmp.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_bmp.c	2009-02-26 14:03:58.000000000 +0100
@@ -120,7 +120,7 @@
 	        y = simple_strtoul(argv[4], NULL, 10);
 	        break;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -132,14 +132,14 @@
 	} else if (strncmp(argv[1],"display",1) == 0) {
 	    return (bmp_display(addr, x, y));
 	} else {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 }
 
 U_BOOT_CMD(
 	bmp,	5,	1,	do_bmp,
-	"bmp     - manipulate BMP image data\n",
+	"manipulate BMP image data",
 	"info <imageAddr>          - display image info\n"
 	"bmp display <imageAddr> [x y] - display image at x,y\n"
 );
diff -Naur u-boot-2009.01/common/cmd_boot.c u-boot/common/cmd_boot.c
--- u-boot-2009.01/common/cmd_boot.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_boot.c	2009-02-26 14:03:58.000000000 +0100
@@ -41,7 +41,7 @@
 	int     rcode = 0;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -64,7 +64,7 @@
 
 U_BOOT_CMD(
 	go, CONFIG_SYS_MAXARGS, 1,	do_go,
-	"go      - start application at address 'addr'\n",
+	"start application at address 'addr'",
 	"addr [arg ...]\n    - start application at address 'addr'\n"
 	"      passing 'arg' as arguments\n"
 );
@@ -73,6 +73,6 @@
 
 U_BOOT_CMD(
 	reset, 1, 0,	do_reset,
-	"reset   - Perform RESET of the CPU\n",
+	"Perform RESET of the CPU",
 	NULL
 );
diff -Naur u-boot-2009.01/common/cmd_bootldr.c u-boot/common/cmd_bootldr.c
--- u-boot-2009.01/common/cmd_bootldr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_bootldr.c	2009-02-26 14:03:58.000000000 +0100
@@ -16,6 +16,125 @@
 #include <asm/blackfin.h>
 #include <asm/mach-common/bits/bootrom.h>
 
+/* Simple sanity check on the specified address to make sure it contains
+ * an LDR image of some sort.
+ */
+static bool ldr_valid_signature(uint8_t *data)
+{
+#if defined(__ADSPBF561__)
+
+	/* BF56x has a 4 byte global header */
+	if (data[3] == 0xA0)
+		return true;
+
+#elif defined(__ADSPBF531__) || defined(__ADSPBF532__) || defined(__ADSPBF533__) || \
+      defined(__ADSPBF534__) || defined(__ADSPBF536__) || defined(__ADSPBF537__) || \
+      defined(__ADSPBF538__) || defined(__ADSPBF539__)
+
+	/* all the BF53x should start at this address mask */
+	uint32_t addr;
+	memmove(&addr, data, sizeof(addr));
+	if ((addr & 0xFF0FFF0F) == 0xFF000000)
+		return true;
+#else
+
+	/* everything newer has a magic byte */
+	uint32_t count;
+	memmove(&count, data + 8, sizeof(count));
+	if (data[3] == 0xAD && count == 0)
+		return true;
+
+#endif
+
+	return false;
+}
+
+/* If the Blackfin is new enough, the Blackfin on-chip ROM supports loading
+ * LDRs from random memory addresses.  So whenever possible, use that.  In
+ * the older cases (BF53x/BF561), parse the LDR format ourselves.
+ */
+#define ZEROFILL  0x0001
+#define RESVECT   0x0002
+#define INIT      0x0008
+#define IGNORE    0x0010
+#define FINAL     0x8000
+static void ldr_load(uint8_t *base_addr)
+{
+#if defined(__ADSPBF531__) || defined(__ADSPBF532__) || defined(__ADSPBF533__) || \
+  /*defined(__ADSPBF534__) || defined(__ADSPBF536__) || defined(__ADSPBF537__) ||*/\
+    defined(__ADSPBF538__) || defined(__ADSPBF539__) || defined(__ADSPBF561__)
+
+	uint32_t addr;
+	uint32_t count;
+	uint16_t flags;
+
+	/* the bf56x has a 4 byte global header ... but it is useless to
+	 * us when booting an LDR from a memory address, so skip it
+	 */
+# ifdef __ADSPBF561__
+	base_addr += 4;
+# endif
+
+	memmove(&flags, base_addr + 8, sizeof(flags));
+	bfin_write_EVT1(flags & RESVECT ? 0xFFA00000 : 0xFFA08000);
+
+	do {
+		/* block header may not be aligned */
+		memmove(&addr, base_addr, sizeof(addr));
+		memmove(&count, base_addr+4, sizeof(count));
+		memmove(&flags, base_addr+8, sizeof(flags));
+		base_addr += sizeof(addr) + sizeof(count) + sizeof(flags);
+
+		printf("loading to 0x%08x (0x%x bytes) flags: 0x%04x\n",
+			addr, count, flags);
+
+		if (!(flags & IGNORE)) {
+			if (flags & ZEROFILL)
+				memset((void *)addr, 0x00, count);
+			else
+				memcpy((void *)addr, base_addr, count);
+
+			if (flags & INIT) {
+				void (*init)(void) = (void *)addr;
+				init();
+			}
+		}
+
+		if (!(flags & ZEROFILL))
+			base_addr += count;
+	} while (!(flags & FINAL));
+
+#endif
+}
+
+/* For BF537, we use the _BOOTROM_BOOT_DXE_FLASH funky ROM function.
+ * For all other BF53x/BF56x, we just call the entry point.
+ * For everything else (newer), we use _BOOTROM_MEMBOOT ROM function.
+ */
+static void ldr_exec(void *addr)
+{
+#if defined(__ADSPBF534__) || defined(__ADSPBF536__) || defined(__ADSPBF537__)
+
+	/* restore EVT1 to reset value as this is what the bootrom uses as
+	 * the default entry point when booting the final block of LDRs
+	 */
+	bfin_write_EVT1(L1_INST_SRAM);
+	__asm__("call (%0);" : : "a"(_BOOTROM_MEMBOOT), "q7"(addr) : "RETS", "memory");
+
+#elif defined(__ADSPBF531__) || defined(__ADSPBF532__) || defined(__ADSPBF533__) || \
+      defined(__ADSPBF538__) || defined(__ADSPBF539__) || defined(__ADSPBF561__)
+
+	void (*ldr_entry)(void) = (void *)bfin_read_EVT1();
+	ldr_entry();
+
+#else
+
+	int32_t (*BOOTROM_MEM)(void *, int32_t, int32_t, void *) = (void *)_BOOTROM_MEMBOOT;
+	BOOTROM_MEM(addr, 0, 0, NULL);
+
+#endif
+}
+
 /*
  * the bootldr command loads an address, checks to see if there
  *   is a Boot stream that the on-chip BOOTROM can understand,
@@ -23,11 +142,9 @@
  *   to also add booting from SPI, or TWI, but this function does
  *   not currently support that.
  */
-
 int do_bootldr(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	void *addr;
-	uint32_t *data;
 
 	/* Get the address */
 	if (argc < 2)
@@ -36,22 +153,14 @@
 		addr = (void *)simple_strtoul(argv[1], NULL, 16);
 
 	/* Check if it is a LDR file */
-	data = addr;
-#if defined(__ADSPBF54x__) || defined(__ADSPBF52x__)
-	if ((*data & 0xFF000000) == 0xAD000000 && data[2] == 0x00000000) {
-#else
-	if (*data == 0xFF800060 || *data == 0xFF800040 || *data == 0xFF800020) {
-#endif
-		/* We want to boot from FLASH or SDRAM */
+	if (ldr_valid_signature(addr)) {
 		printf("## Booting ldr image at 0x%p ...\n", addr);
+		ldr_load(addr);
 
 		icache_disable();
 		dcache_disable();
 
-		__asm__(
-			"jump (%1);"
-			:
-			: "q7" (addr), "a" (_BOOTROM_MEMBOOT));
+		ldr_exec(addr);
 	} else
 		printf("## No ldr image at address 0x%p\n", addr);
 
@@ -59,6 +168,6 @@
 }
 
 U_BOOT_CMD(bootldr, 2, 0, do_bootldr,
-	"bootldr - boot ldr image from memory\n",
+	"boot ldr image from memory",
 	"[addr]\n"
 	"    - boot ldr image stored in memory\n");
diff -Naur u-boot-2009.01/common/cmd_bootm.c u-boot/common/cmd_bootm.c
--- u-boot-2009.01/common/cmd_bootm.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_bootm.c	2009-02-26 14:03:58.000000000 +0100
@@ -340,8 +340,10 @@
 		} else {
 			printf ("   Loading %s ... ", type_name);
 
-			memmove_wd ((void *)load,
-				   (void *)image_start, image_len, CHUNKSZ);
+			if (load != image_start) {
+				memmove_wd ((void *)load,
+						(void *)image_start, image_len, CHUNKSZ);
+			}
 		}
 		*load_end = load + image_len;
 		puts("OK\n");
@@ -350,7 +352,7 @@
 		printf ("   Uncompressing %s ... ", type_name);
 		if (gunzip ((void *)load, unc_len,
 					(uchar *)image_start, &image_len) != 0) {
-			puts ("GUNZIP: uncompress or overwrite error "
+			puts ("GUNZIP: uncompress, out-of-mem or overwrite error "
 				"- must RESET board to recover\n");
 			if (boot_progress)
 				show_boot_progress (-6);
@@ -454,13 +456,13 @@
 	}
 	/* Unrecognized command */
 	else {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
 	if (images.state >= state) {
 		printf ("Trying to execute a command out of order\n");
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -913,7 +915,7 @@
 
 U_BOOT_CMD(
 	bootm,	CONFIG_SYS_MAXARGS,	1,	do_bootm,
-	"bootm   - boot application image from memory\n",
+	"boot application image from memory",
 	"[addr [arg ...]]\n    - boot application image stored in memory\n"
 	"\tpassing arguments 'arg ...'; when booting a Linux kernel,\n"
 	"\t'arg' can be the address of an initrd image\n"
@@ -970,14 +972,14 @@
 
 U_BOOT_CMD(
 	boot,	1,	1,	do_bootd,
-	"boot    - boot default, i.e., run 'bootcmd'\n",
+	"boot default, i.e., run 'bootcmd'",
 	NULL
 );
 
 /* keep old command name "bootd" for backward compatibility */
 U_BOOT_CMD(
 	bootd, 1,	1,	do_bootd,
-	"bootd   - boot default, i.e., run 'bootcmd'\n",
+	"boot default, i.e., run 'bootcmd'",
 	NULL
 );
 
@@ -1062,7 +1064,7 @@
 
 U_BOOT_CMD(
 	iminfo,	CONFIG_SYS_MAXARGS,	1,	do_iminfo,
-	"iminfo  - print header information for application image\n",
+	"print header information for application image",
 	"addr [addr ...]\n"
 	"    - print header information for application image starting at\n"
 	"      address 'addr' in memory; this includes verification of the\n"
@@ -1130,7 +1132,7 @@
 
 U_BOOT_CMD(
 	imls,	1,		1,	do_imls,
-	"imls    - list all images found in flash\n",
+	"list all images found in flash",
 	"\n"
 	"    - Prints information about all images found at sector\n"
 	"      boundaries in flash.\n"
diff -Naur u-boot-2009.01/common/cmd_cache.c u-boot/common/cmd_cache.c
--- u-boot-2009.01/common/cmd_cache.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_cache.c	2009-02-26 14:03:58.000000000 +0100
@@ -37,7 +37,7 @@
 	case 2:			/* on / off	*/
 		switch (on_off(argv[1])) {
 #if 0	/* prevented by varargs handling; FALLTROUGH is harmless, too */
-		default: printf ("Usage:\n%s\n", cmdtp->usage);
+		default: cmd_usage(cmdtp);
 			return;
 #endif
 		case 0:	icache_disable();
@@ -51,7 +51,7 @@
 			icache_status() ? "ON" : "OFF");
 		return 0;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	return 0;
@@ -63,7 +63,7 @@
 	case 2:			/* on / off	*/
 		switch (on_off(argv[1])) {
 #if 0	/* prevented by varargs handling; FALLTROUGH is harmless, too */
-		default: printf ("Usage:\n%s\n", cmdtp->usage);
+		default: cmd_usage(cmdtp);
 			return;
 #endif
 		case 0:	dcache_disable();
@@ -77,7 +77,7 @@
 			dcache_status() ? "ON" : "OFF");
 		return 0;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	return 0;
@@ -97,14 +97,14 @@
 
 U_BOOT_CMD(
 	icache,   2,   1,     do_icache,
-	"icache  - enable or disable instruction cache\n",
+	"enable or disable instruction cache",
 	"[on, off]\n"
 	"    - enable or disable instruction cache\n"
 );
 
 U_BOOT_CMD(
 	dcache,   2,   1,     do_dcache,
-	"dcache  - enable or disable data cache\n",
+	"enable or disable data cache",
 	"[on, off]\n"
 	"    - enable or disable data (writethrough) cache\n"
 );
diff -Naur u-boot-2009.01/common/cmd_console.c u-boot/common/cmd_console.c
--- u-boot-2009.01/common/cmd_console.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_console.c	2009-02-26 14:03:58.000000000 +0100
@@ -65,6 +65,6 @@
 
 U_BOOT_CMD(
 	coninfo,	3,	1,	do_coninfo,
-	"coninfo - print console devices and information\n",
+	"print console devices and information",
 	""
 );
diff -Naur u-boot-2009.01/common/cmd_cplbinfo.c u-boot/common/cmd_cplbinfo.c
--- u-boot-2009.01/common/cmd_cplbinfo.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_cplbinfo.c	2009-02-26 14:03:58.000000000 +0100
@@ -26,11 +26,11 @@
  */
 static void show_cplb_table(uint32_t *addr, uint32_t *data)
 {
-	size_t i;
+	int i;
 	printf("      Address     Data   Size  Valid  Locked\n");
 	for (i = 1; i <= 16; ++i) {
 		printf(" %2i 0x%p  0x%05X   %s     %c      %c\n",
-			i, *addr, *data,
+			i, (void *)*addr, *data,
 			cplb_page_size(*data),
 			(*data & CPLB_VALID ? 'Y' : 'N'),
 			(*data & CPLB_LOCK ? 'Y' : 'N'));
@@ -54,6 +54,6 @@
 }
 
 U_BOOT_CMD(cplbinfo, 1, 0, do_cplbinfo,
-	"cplbinfo- display current CPLB tables\n",
+	"display current CPLB tables",
 	"\n"
 	"    - display current CPLB tables\n");
diff -Naur u-boot-2009.01/common/cmd_date.c u-boot/common/cmd_date.c
--- u-boot-2009.01/common/cmd_date.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_date.c	2009-02-26 14:03:58.000000000 +0100
@@ -89,7 +89,7 @@
 
 		break;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		rcode = 1;
 	}
 
@@ -214,7 +214,7 @@
 
 U_BOOT_CMD(
 	date,	2,	1,	do_date,
-	"date    - get/set/reset date & time\n",
+	"get/set/reset date & time",
 	"[MMDDhhmm[[CC]YY][.ss]]\ndate reset\n"
 	"  - without arguments: print date & time\n"
 	"  - with numeric argument: set the system date & time\n"
diff -Naur u-boot-2009.01/common/cmd_dcr.c u-boot/common/cmd_dcr.c
--- u-boot-2009.01/common/cmd_dcr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_dcr.c	2009-02-26 14:03:58.000000000 +0100
@@ -45,7 +45,7 @@
 
 	/* Validate arguments */
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -74,7 +74,7 @@
 
 	/* Validate arguments */
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -121,7 +121,7 @@
 
 	/* Validate arguments */
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -177,7 +177,7 @@
 
 	/* Validate arguments */
 	if (argc < 4) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -223,23 +223,23 @@
 
 U_BOOT_CMD(
 	getdcr,	2,	1,	do_getdcr,
-	"getdcr  - Get an AMCC PPC 4xx DCR's value\n",
+	"Get an AMCC PPC 4xx DCR's value",
 	"dcrn - return a DCR's value.\n"
 );
 U_BOOT_CMD(
 	setdcr,	2,	1,	do_setdcr,
-	"setdcr  - Set an AMCC PPC 4xx DCR's value\n",
+	"Set an AMCC PPC 4xx DCR's value",
 	"dcrn - set a DCR's value.\n"
 );
 
 U_BOOT_CMD(
 	getidcr,	3,	1,	do_getidcr,
-	"getidcr - Get a register value via indirect DCR addressing\n",
+	"Get a register value via indirect DCR addressing",
 	"adr_dcrn[.dat_dcrn] offset - write offset to adr_dcrn, read value from dat_dcrn.\n"
 );
 
 U_BOOT_CMD(
 	setidcr,	4,	1,	do_setidcr,
-	"setidcr - Set a register value via indirect DCR addressing\n",
+	"Set a register value via indirect DCR addressing",
 	"adr_dcrn[.dat_dcrn] offset value - write offset to adr_dcrn, write value to dat_dcrn.\n"
 );
diff -Naur u-boot-2009.01/common/cmd_df.c u-boot/common/cmd_df.c
--- u-boot-2009.01/common/cmd_df.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_df.c	2009-02-26 14:03:58.000000000 +0100
@@ -27,11 +27,11 @@
 	}
 
 usage:
-	printf("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
 U_BOOT_CMD(
 	sf,	2,	1,	do_serial_flash,
-	"sf	- Serial flash sub-system\n",
+	"Serial flash sub-system",
 	"probe [bus:]cs		- init flash device on given SPI bus and CS\n")
diff -Naur u-boot-2009.01/common/cmd_diag.c u-boot/common/cmd_diag.c
--- u-boot-2009.01/common/cmd_diag.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_diag.c	2009-02-26 14:03:58.000000000 +0100
@@ -66,7 +66,7 @@
 
 U_BOOT_CMD(
 	diag,	CONFIG_SYS_MAXARGS,	0,	do_diag,
-	"diag    - perform board diagnostics\n",
+	"perform board diagnostics",
 	     "    - print list of available tests\n"
 	"diag [test1 [test2]]\n"
 	"         - print information about specified tests\n"
diff -Naur u-boot-2009.01/common/cmd_display.c u-boot/common/cmd_display.c
--- u-boot-2009.01/common/cmd_display.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_display.c	2009-02-26 14:03:58.000000000 +0100
@@ -71,7 +71,7 @@
 
 U_BOOT_CMD(
 	display,	CONFIG_SYS_MAXARGS,	1,	do_display,
-	"display- display string on dot matrix display\n",
+	"display string on dot matrix display",
 	"[<string>]\n"
 	"    - with <string> argument: display <string> on dot matrix display\n"
 	"    - without arguments: clear dot matrix display\n"
diff -Naur u-boot-2009.01/common/cmd_doc.c u-boot/common/cmd_doc.c
--- u-boot-2009.01/common/cmd_doc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_doc.c	2009-02-26 14:03:58.000000000 +0100
@@ -96,7 +96,7 @@
     switch (argc) {
     case 0:
     case 1:
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
     case 2:
 	if (strcmp(argv[1],"info") == 0) {
@@ -121,7 +121,7 @@
 		doc_print(&doc_dev_desc[curr_device]);
 		return 0;
 	}
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
     case 3:
 	if (strcmp(argv[1],"device") == 0) {
@@ -146,7 +146,7 @@
 		return 0;
 	}
 
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
     default:
 	/* at least 4 args */
@@ -182,7 +182,7 @@
 
 		return ret;
 	} else {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		rcode = 1;
 	}
 
@@ -191,7 +191,7 @@
 }
 U_BOOT_CMD(
 	doc,	5,	1,	do_doc,
-	"doc     - Disk-On-Chip sub-system\n",
+	"Disk-On-Chip sub-system",
 	"info  - show available DOC devices\n"
 	"doc device [dev] - show or set current device\n"
 	"doc read  addr off size\n"
@@ -235,7 +235,7 @@
 		offset = simple_strtoul(argv[3], NULL, 16);
 		break;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		show_boot_progress (-35);
 		return 1;
 	}
@@ -337,7 +337,7 @@
 
 U_BOOT_CMD(
 	docboot,	4,	1,	do_docboot,
-	"docboot - boot from DOC device\n",
+	"boot from DOC device",
 	"loadAddr dev\n"
 );
 
diff -Naur u-boot-2009.01/common/cmd_dtt.c u-boot/common/cmd_dtt.c
--- u-boot-2009.01/common/cmd_dtt.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_dtt.c	2009-02-26 14:03:58.000000000 +0100
@@ -55,6 +55,6 @@
 
 U_BOOT_CMD(
 	  dtt,	1,	1,	do_dtt,
-	  "dtt     - Digital Thermometer and Thermostat\n",
+	  "Digital Thermometer and Thermostat",
 	  "        - Read temperature from digital thermometer and thermostat.\n"
 );
diff -Naur u-boot-2009.01/common/cmd_eeprom.c u-boot/common/cmd_eeprom.c
--- u-boot-2009.01/common/cmd_eeprom.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_eeprom.c	2009-02-26 14:03:58.000000000 +0100
@@ -104,7 +104,7 @@
 		}
 	}
 
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 #endif
@@ -425,7 +425,7 @@
 #ifdef CONFIG_SYS_I2C_MULTI_EEPROMS
 U_BOOT_CMD(
 	eeprom,	6,	1,	do_eeprom,
-	"eeprom  - EEPROM sub-system\n",
+	"EEPROM sub-system",
 	"read  devaddr addr off cnt\n"
 	"eeprom write devaddr addr off cnt\n"
 	"       - read/write `cnt' bytes from `devaddr` EEPROM at offset `off'\n"
@@ -433,7 +433,7 @@
 #else /* One EEPROM */
 U_BOOT_CMD(
 	eeprom,	5,	1,	do_eeprom,
-	"eeprom  - EEPROM sub-system\n",
+	"EEPROM sub-system",
 	"read  addr off cnt\n"
 	"eeprom write addr off cnt\n"
 	"       - read/write `cnt' bytes at EEPROM offset `off'\n"
diff -Naur u-boot-2009.01/common/cmd_elf.c u-boot/common/cmd_elf.c
--- u-boot-2009.01/common/cmd_elf.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_elf.c	2009-02-26 14:03:58.000000000 +0100
@@ -310,12 +310,12 @@
 /* ====================================================================== */
 U_BOOT_CMD(
 	bootelf,      2,      0,      do_bootelf,
-	"bootelf - Boot from an ELF image in memory\n",
+	"Boot from an ELF image in memory",
 	" [address] - load address of ELF image.\n"
 );
 
 U_BOOT_CMD(
 	bootvx,      2,      0,      do_bootvx,
-	"bootvx  - Boot vxWorks from an ELF image\n",
+	"Boot vxWorks from an ELF image",
 	" [address] - load address of vxWorks ELF image.\n"
 );
diff -Naur u-boot-2009.01/common/cmd_ext2.c u-boot/common/cmd_ext2.c
--- u-boot-2009.01/common/cmd_ext2.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_ext2.c	2009-02-26 14:03:58.000000000 +0100
@@ -66,7 +66,7 @@
 	int part_length;
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return(1);
 	}
 	dev = (int)simple_strtoul (argv[2], &ep, 16);
@@ -116,7 +116,7 @@
 
 U_BOOT_CMD(
 	ext2ls,	4,	1,	do_ext2ls,
-	"ext2ls  - list files in a directory (default /)\n",
+	"list files in a directory (default /)",
 	"<interface> <dev[:part]> [directory]\n"
 	"    - list files from 'dev' on 'interface' in a 'directory'\n"
 );
@@ -164,7 +164,7 @@
 		break;
 
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return(1);
 	}
 
@@ -252,7 +252,7 @@
 
 U_BOOT_CMD(
 	ext2load,	6,	0,	do_ext2load,
-	"ext2load- load binary file from a Ext2 filesystem\n",
+	"load binary file from a Ext2 filesystem",
 	"<interface> <dev[:part]> [addr] [filename] [bytes]\n"
 	"    - load binary file 'filename' from 'dev' on 'interface'\n"
 	"      to address 'addr' from ext2 filesystem\n"
diff -Naur u-boot-2009.01/common/cmd_fat.c u-boot/common/cmd_fat.c
--- u-boot-2009.01/common/cmd_fat.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_fat.c	2009-02-26 14:03:58.000000000 +0100
@@ -88,7 +88,7 @@
 
 U_BOOT_CMD(
 	fatload,	6,	0,	do_fat_fsload,
-	"fatload - load binary file from a dos filesystem\n",
+	"load binary file from a dos filesystem",
 	"<interface> <dev[:part]>  <addr> <filename> [bytes]\n"
 	"    - load binary file 'filename' from 'dev' on 'interface'\n"
 	"      to address 'addr' from dos filesystem\n"
@@ -136,7 +136,7 @@
 
 U_BOOT_CMD(
 	fatls,	4,	1,	do_fat_ls,
-	"fatls   - list files in a directory (default /)\n",
+	"list files in a directory (default /)",
 	"<interface> <dev[:part]> [directory]\n"
 	"    - list files from 'dev' on 'interface' in a 'directory'\n"
 );
@@ -174,7 +174,7 @@
 
 U_BOOT_CMD(
 	fatinfo,	3,	1,	do_fat_fsinfo,
-	"fatinfo - print information about filesystem\n",
+	"print information about filesystem",
 	"<interface> <dev[:part]>\n"
 	"    - print information about filesystem from 'dev' on 'interface'\n"
 );
diff -Naur u-boot-2009.01/common/cmd_fdc.c u-boot/common/cmd_fdc.c
--- u-boot-2009.01/common/cmd_fdc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_fdc.c	2009-02-26 14:03:58.000000000 +0100
@@ -801,7 +801,7 @@
 		boot_drive=simple_strtoul(argv[2], NULL, 10);
 		break;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	/* setup FDC and scan for drives  */
@@ -902,7 +902,7 @@
 
 U_BOOT_CMD(
 	fdcboot,	3,	1,	do_fdcboot,
-	"fdcboot - boot from floppy device\n",
+	"boot from floppy device",
 	"loadAddr drive\n"
 );
 #endif
diff -Naur u-boot-2009.01/common/cmd_fdos.c u-boot/common/cmd_fdos.c
--- u-boot-2009.01/common/cmd_fdos.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_fdos.c	2009-02-26 14:03:58.000000000 +0100
@@ -73,7 +73,7 @@
 	name = argv [2];
 	break;
     default:
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	break;
     }
 
@@ -142,12 +142,12 @@
 
 U_BOOT_CMD(
 	fdosboot,	3,	0,	do_fdosboot,
-	"fdosboot- boot from a dos floppy file\n",
+	"boot from a dos floppy file",
 	"[loadAddr] [filename]\n"
 );
 
 U_BOOT_CMD(
 	fdosls,	2,	0,	do_fdosls,
-	"fdosls  - list files in a directory\n",
+	"list files in a directory",
 	"[directory]\n"
 );
diff -Naur u-boot-2009.01/common/cmd_fdt.c u-boot/common/cmd_fdt.c
--- u-boot-2009.01/common/cmd_fdt.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_fdt.c	2009-02-26 14:03:58.000000000 +0100
@@ -66,7 +66,7 @@
 int do_fdt (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -125,7 +125,7 @@
 		int  err;
 
 		if (argc < 4) {
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			return 1;
 		}
 
@@ -179,7 +179,7 @@
 		 * Parameters: Node path, new node to be appended to the path.
 		 */
 		if (argc < 4) {
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			return 1;
 		}
 
@@ -217,7 +217,7 @@
 		 * Parameters: Node path, property, optional value.
 		 */
 		if (argc < 4) {
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			return 1;
 		}
 
@@ -427,7 +427,7 @@
 			}
 		} else {
 			/* Unrecognized command */
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			return 1;
 		}
 	}
@@ -441,7 +441,7 @@
 		unsigned long initrd_start = 0, initrd_end = 0;
 
 		if ((argc != 2) && (argc != 4)) {
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			return 1;
 		}
 
@@ -459,7 +459,7 @@
 	}
 	else {
 		/* Unrecognized command */
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -819,7 +819,7 @@
 
 U_BOOT_CMD(
 	fdt,	255,	0,	do_fdt,
-	"fdt     - flattened device tree utility commands\n",
+	"flattened device tree utility commands",
 	    "addr   <addr> [<length>]        - Set the fdt location to <addr>\n"
 #ifdef CONFIG_OF_BOARD_SETUP
 	"fdt boardsetup                      - Do board-specific set up\n"
diff -Naur u-boot-2009.01/common/cmd_flash.c u-boot/common/cmd_flash.c
--- u-boot-2009.01/common/cmd_flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -333,7 +333,7 @@
 	int rcode = 0;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -384,7 +384,7 @@
 #endif
 
 	if (argc != 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -407,7 +407,7 @@
 	}
 
 	if (addr_first >= addr_last) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -481,7 +481,7 @@
 #endif
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -490,7 +490,7 @@
 	} else if (strcmp(argv[1], "on") == 0) {
 		p = 1;
 	} else {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -591,7 +591,7 @@
 #endif
 
 	if (argc != 4) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -633,7 +633,7 @@
 	}
 
 	if (addr_first >= addr_last) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	rcode = flash_sect_protect (p, addr_first, addr_last);
@@ -710,14 +710,14 @@
 
 U_BOOT_CMD(
 	flinfo,    2,    1,    do_flinfo,
-	"flinfo  - print FLASH memory information\n",
+	"print FLASH memory information",
 	"\n    - print information for all FLASH memory banks\n"
 	"flinfo N\n    - print information for FLASH memory bank # N\n"
 );
 
 U_BOOT_CMD(
 	erase,   3,   0,  do_flerase,
-	"erase   - erase FLASH memory\n",
+	"erase FLASH memory",
 	"start end\n"
 	"    - erase FLASH from addr 'start' to addr 'end'\n"
 	"erase start +len\n"
@@ -731,7 +731,7 @@
 
 U_BOOT_CMD(
 	protect,  4,  0,   do_protect,
-	"protect - enable or disable FLASH write protection\n",
+	"enable or disable FLASH write protection",
 	"on  start end\n"
 	"    - protect FLASH from addr 'start' to addr 'end'\n"
 	"protect on start +len\n"
diff -Naur u-boot-2009.01/common/cmd_fpga.c u-boot/common/cmd_fpga.c
--- u-boot-2009.01/common/cmd_fpga.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_fpga.c	2009-02-26 14:03:58.000000000 +0100
@@ -320,7 +320,7 @@
 
 static void fpga_usage (cmd_tbl_t * cmdtp)
 {
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 }
 
 /*
@@ -350,7 +350,7 @@
 }
 
 U_BOOT_CMD (fpga, 6, 1, do_fpga,
-	    "fpga    - loadable FPGA image support\n",
+	    "loadable FPGA image support",
 	    "fpga [operation type] [device number] [image address] [image size]\n"
 	    "fpga operations:\n"
 	    "\tinfo\tlist known device information\n"
diff -Naur u-boot-2009.01/common/cmd_i2c.c u-boot/common/cmd_i2c.c
--- u-boot-2009.01/common/cmd_i2c.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_i2c.c	2009-02-26 14:03:58.000000000 +0100
@@ -159,7 +159,7 @@
 	length = i2c_dp_last_length;
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -184,7 +184,7 @@
 			if (argv[2][j] == '.') {
 				alen = argv[2][j+1] - '0';
 				if (alen > 4) {
-					printf ("Usage:\n%s\n", cmdtp->usage);
+					cmd_usage(cmdtp);
 					return 1;
 				}
 				break;
@@ -269,7 +269,7 @@
 	int	j;
 
 	if ((argc < 4) || (argc > 5)) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -287,7 +287,7 @@
 		if (argv[2][j] == '.') {
 			alen = argv[2][j+1] - '0';
 			if (alen > 4) {
-				printf ("Usage:\n%s\n", cmdtp->usage);
+				cmd_usage(cmdtp);
 				return 1;
 			}
 			break;
@@ -355,7 +355,7 @@
 	int	j;
 
 	if (argc < 4) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -373,7 +373,7 @@
 		if (argv[2][j] == '.') {
 			alen = argv[2][j+1] - '0';
 			if (alen > 4) {
-				printf ("Usage:\n%s\n", cmdtp->usage);
+				cmd_usage(cmdtp);
 				return 1;
 			}
 			break;
@@ -427,7 +427,7 @@
 	extern char console_buffer[];
 
 	if (argc != 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -463,7 +463,7 @@
 			if (argv[2][j] == '.') {
 				alen = argv[2][j+1] - '0';
 				if (alen > 4) {
-					printf ("Usage:\n%s\n", cmdtp->usage);
+					cmd_usage(cmdtp);
 					return 1;
 				}
 				break;
@@ -601,7 +601,7 @@
 	int	j;
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -619,7 +619,7 @@
 		if (argv[2][j] == '.') {
 			alen = argv[2][j+1] - '0';
 			if (alen > 4) {
-				printf ("Usage:\n%s\n", cmdtp->usage);
+				cmd_usage(cmdtp);
 				return 1;
 			}
 			break;
@@ -764,7 +764,7 @@
 	};
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	/*
@@ -1293,7 +1293,7 @@
 		return do_sdram(cmdtp, flag, --argc, ++argv);
 #endif
 	else
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 	return 0;
 }
 #endif  /* CONFIG_I2C_CMD_TREE */
@@ -1303,7 +1303,7 @@
 #if defined(CONFIG_I2C_CMD_TREE)
 U_BOOT_CMD(
 	i2c, 6, 1, do_i2c,
-	"i2c     - I2C sub-system\n",
+	"I2C sub-system",
 #if defined(CONFIG_I2C_MUX)
 	"bus [muxtype:muxaddr:muxchannel] - add a new bus reached over muxes.\n"
 #endif  /* CONFIG_I2C_MUX */
@@ -1326,37 +1326,37 @@
 #endif /* CONFIG_I2C_CMD_TREE */
 U_BOOT_CMD(
 	imd,	4,	1,	do_i2c_md,		\
-	"imd     - i2c memory display\n",				\
+	"i2c memory display",				\
 	"chip address[.0, .1, .2] [# of objects]\n    - i2c memory display\n" \
 );
 
 U_BOOT_CMD(
 	imm,	3,	1,	do_i2c_mm,
-	"imm     - i2c memory modify (auto-incrementing)\n",
+	"i2c memory modify (auto-incrementing)",
 	"chip address[.0, .1, .2]\n"
 	"    - memory modify, auto increment address\n"
 );
 U_BOOT_CMD(
 	inm,	3,	1,	do_i2c_nm,
-	"inm     - memory modify (constant address)\n",
+	"memory modify (constant address)",
 	"chip address[.0, .1, .2]\n    - memory modify, read and keep address\n"
 );
 
 U_BOOT_CMD(
 	imw,	5,	1,	do_i2c_mw,
-	"imw     - memory write (fill)\n",
+	"memory write (fill)",
 	"chip address[.0, .1, .2] value [count]\n    - memory write (fill)\n"
 );
 
 U_BOOT_CMD(
 	icrc32,	5,	1,	do_i2c_crc,
-	"icrc32  - checksum calculation\n",
+	"checksum calculation",
 	"chip address[.0, .1, .2] count\n    - compute CRC32 checksum\n"
 );
 
 U_BOOT_CMD(
 	iprobe,	1,	1,	do_i2c_probe,
-	"iprobe  - probe to discover valid I2C chip addresses\n",
+	"probe to discover valid I2C chip addresses",
 	"\n    -discover valid I2C chip addresses\n"
 );
 
@@ -1365,7 +1365,7 @@
  */
 U_BOOT_CMD(
 	iloop,	5,	1,	do_i2c_loop,
-	"iloop   - infinite loop on address range\n",
+	"infinite loop on address range",
 	"chip address[.0, .1, .2] [# of objects]\n"
 	"    - loop, reading a set of addresses\n"
 );
@@ -1373,7 +1373,7 @@
 #if defined(CONFIG_CMD_SDRAM)
 U_BOOT_CMD(
 	isdram,	2,	1,	do_sdram,
-	"isdram  - print SDRAM configuration information\n",
+	"print SDRAM configuration information",
 	"chip\n    - print SDRAM configuration information\n"
 	"      (valid chip values 50..57)\n"
 );
diff -Naur u-boot-2009.01/common/cmd_ide.c u-boot/common/cmd_ide.c
--- u-boot-2009.01/common/cmd_ide.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_ide.c	2009-02-26 14:03:58.000000000 +0100
@@ -45,6 +45,10 @@
 #include <mpc5xxx.h>
 #endif
 
+#ifdef CONFIG_MPC512X
+#include <mpc512x.h>
+#endif
+
 #include <ide.h>
 #include <ata.h>
 
@@ -188,7 +192,7 @@
     switch (argc) {
     case 0:
     case 1:
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
     case 2:
 	if (strncmp(argv[1],"res",3) == 0) {
@@ -238,7 +242,7 @@
 		}
 		return rcode;
 	}
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
     case 3:
 	if (strncmp(argv[1],"dev",3) == 0) {
@@ -287,7 +291,7 @@
 #endif
 	}
 
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
     default:
 	/* at least 4 args */
@@ -347,7 +351,7 @@
 			return 1;
 		}
 	} else {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		rcode = 1;
 	}
 
@@ -383,7 +387,7 @@
 		boot_device = argv[2];
 		break;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		show_boot_progress (-42);
 		return 1;
 	}
@@ -2140,7 +2144,7 @@
 
 U_BOOT_CMD(
 	ide,  5,  1,  do_ide,
-	"ide     - IDE sub-system\n",
+	"IDE sub-system",
 	"reset - reset IDE controller\n"
 	"ide info  - show available IDE devices\n"
 	"ide device [dev] - show or set current device\n"
@@ -2153,6 +2157,6 @@
 
 U_BOOT_CMD(
 	diskboot,	3,	1,	do_diskboot,
-	"diskboot- boot from IDE device\n",
+	"boot from IDE device",
 	"loadAddr dev:part\n"
 );
diff -Naur u-boot-2009.01/common/cmd_immap.c u-boot/common/cmd_immap.c
--- u-boot-2009.01/common/cmd_immap.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_immap.c	2009-02-26 14:03:58.000000000 +0100
@@ -614,105 +614,105 @@
 
 U_BOOT_CMD(
 	siuinfo,	1,	1,	do_siuinfo,
-	"siuinfo - print System Interface Unit (SIU) registers\n",
+	"print System Interface Unit (SIU) registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	memcinfo,	1,	1,	do_memcinfo,
-	"memcinfo- print Memory Controller registers\n",
+	"print Memory Controller registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	sitinfo,	1,	1,	do_sitinfo,
-	"sitinfo - print System Integration Timers (SIT) registers\n",
+	"print System Integration Timers (SIT) registers",
 	NULL
 );
 
 #ifdef CONFIG_8260
 U_BOOT_CMD(
 	icinfo,	1,	1,	do_icinfo,
-	"icinfo  - print Interrupt Controller registers\n",
+	"print Interrupt Controller registers",
 	NULL
 );
 #endif
 
 U_BOOT_CMD(
 	carinfo,	1,	1,	do_carinfo,
-	"carinfo - print Clocks and Reset registers\n",
+	"print Clocks and Reset registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	iopinfo,	1,	1,	do_iopinfo,
-	"iopinfo - print I/O Port registers\n",
+	"print I/O Port registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	iopset,	5,	0,	do_iopset,
-	"iopset  - set I/O Port registers\n",
+	"set I/O Port registers",
 	"PORT PIN CMD VALUE\nPORT: A-D, PIN: 0-31, CMD: [dat|dir|odr|sor], VALUE: 0|1"
 );
 
 U_BOOT_CMD(
 	dmainfo,	1,	1,	do_dmainfo,
-	"dmainfo - print SDMA/IDMA registers\n",
+	"print SDMA/IDMA registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	fccinfo,	1,	1,	do_fccinfo,
-	"fccinfo - print FCC registers\n",
+	"print FCC registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	brginfo,	1,	1,	do_brginfo,
-	"brginfo - print Baud Rate Generator (BRG) registers\n",
+	"print Baud Rate Generator (BRG) registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	i2cinfo,	1,	1,	do_i2cinfo,
-	"i2cinfo - print I2C registers\n",
+	"print I2C registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	sccinfo,	1,	1,	do_sccinfo,
-	"sccinfo - print SCC registers\n",
+	"print SCC registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	smcinfo,	1,	1,	do_smcinfo,
-	"smcinfo - print SMC registers\n",
+	"print SMC registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	spiinfo,	1,	1,	do_spiinfo,
-	"spiinfo - print Serial Peripheral Interface (SPI) registers\n",
+	"print Serial Peripheral Interface (SPI) registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	muxinfo,	1,	1,	do_muxinfo,
-	"muxinfo - print CPM Multiplexing registers\n",
+	"print CPM Multiplexing registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	siinfo,	1,	1,	do_siinfo,
-	"siinfo  - print Serial Interface (SI) registers\n",
+	"print Serial Interface (SI) registers",
 	NULL
 );
 
 U_BOOT_CMD(
 	mccinfo,	1,	1,	do_mccinfo,
-	"mccinfo - print MCC registers\n",
+	"print MCC registers",
 	NULL
 );
 
diff -Naur u-boot-2009.01/common/cmd_irq.c u-boot/common/cmd_irq.c
--- u-boot-2009.01/common/cmd_irq.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_irq.c	2009-02-26 14:03:58.000000000 +0100
@@ -28,7 +28,7 @@
 {
 
 	if (argc != 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -44,7 +44,7 @@
 
 U_BOOT_CMD(
 	interrupts, 5, 0, do_interrupts,
-	"interrupts - enable or disable interrupts\n",
+	"enable or disable interrupts",
 	"[on, off]\n"
 	"    - enable or disable interrupts\n"
 );
diff -Naur u-boot-2009.01/common/cmd_itest.c u-boot/common/cmd_itest.c
--- u-boot-2009.01/common/cmd_itest.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_itest.c	2009-02-26 14:03:58.000000000 +0100
@@ -161,7 +161,7 @@
 
 	/* Validate arguments */
 	if ((argc != 4)){
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -190,6 +190,6 @@
 
 U_BOOT_CMD(
 	itest, 4, 0, do_itest,
-	"itest\t- return true/false on integer compare\n",
+	"return true/false on integer compare",
 	"[.b, .w, .l, .s] [*]value1 <op> [*]value2\n"
 );
diff -Naur u-boot-2009.01/common/cmd_jffs2.c u-boot/common/cmd_jffs2.c
--- u-boot-2009.01/common/cmd_jffs2.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_jffs2.c	2009-02-26 14:03:58.000000000 +0100
@@ -1778,6 +1778,96 @@
  */
 
 /**
+ * Calculate sector size.
+ *
+ * @return sector size
+ */
+static inline u32 get_part_sector_size_nand(struct mtdids *id)
+{
+#if defined(CONFIG_JFFS2_NAND) && defined(CONFIG_CMD_NAND)
+#if defined(CONFIG_NAND_LEGACY)
+	extern struct nand_chip nand_dev_desc[CONFIG_SYS_MAX_NAND_DEVICE];
+
+	return nand_dev_desc[id->num].erasesize;
+#else
+	nand_info_t *nand;
+
+	nand = &nand_info[id->num];
+
+	return nand->erasesize;
+#endif
+#else
+	BUG();
+	return 0;
+#endif
+}
+
+static inline u32 get_part_sector_size_nor(struct mtdids *id, struct part_info *part)
+{
+#if defined(CONFIG_CMD_FLASH)
+	extern flash_info_t flash_info[];
+
+	u32 end_phys, start_phys, sector_size = 0, size = 0;
+	int i;
+	flash_info_t *flash;
+
+	flash = &flash_info[id->num];
+
+	start_phys = flash->start[0] + part->offset;
+	end_phys = start_phys + part->size;
+
+	for (i = 0; i < flash->sector_count; i++) {
+		if (flash->start[i] >= end_phys)
+			break;
+
+		if (flash->start[i] >= start_phys) {
+			if (i == flash->sector_count - 1) {
+				size = flash->start[0] + flash->size - flash->start[i];
+			} else {
+				size = flash->start[i+1] - flash->start[i];
+			}
+
+			if (sector_size < size)
+				sector_size = size;
+		}
+	}
+
+	return sector_size;
+#else
+	BUG();
+	return 0;
+#endif
+}
+
+static inline u32 get_part_sector_size_onenand(void)
+{
+#if defined(CONFIG_CMD_ONENAND)
+	struct mtd_info *mtd;
+
+	mtd = &onenand_mtd;
+
+	return mtd->erasesize;
+#else
+	BUG();
+	return 0;
+#endif
+}
+
+static inline u32 get_part_sector_size(struct mtdids *id, struct part_info *part)
+{
+	if (id->type == MTD_DEV_TYPE_NAND)
+		return get_part_sector_size_nand(id);
+	else if (id->type == MTD_DEV_TYPE_NOR)
+		return get_part_sector_size_nor(id, part);
+	else if (id->type == MTD_DEV_TYPE_ONENAND)
+		return get_part_sector_size_onenand();
+	else
+		DEBUGF("Error: Unknown device type.\n");
+
+	return 0;
+}
+
+/**
  * Parse and initialize global mtdids mapping and create global
  * device/partition list.
  *
@@ -1846,6 +1936,8 @@
 		part->offset = 0x00000000;
 #endif
 
+		part->sector_size = get_part_sector_size(id, part);
+
 		part->dev = current_dev;
 		INIT_LIST_HEAD(&part->link);
 
@@ -2197,7 +2289,7 @@
 		return delete_partition(argv[2]);
 	}
 
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 #endif /* #ifdef CONFIG_JFFS2_CMDLINE */
@@ -2205,35 +2297,35 @@
 /***************************************************/
 U_BOOT_CMD(
 	fsload,	3,	0,	do_jffs2_fsload,
-	"fsload\t- load binary file from a filesystem image\n",
+	"load binary file from a filesystem image",
 	"[ off ] [ filename ]\n"
 	"    - load binary file from flash bank\n"
 	"      with offset 'off'\n"
 );
 U_BOOT_CMD(
 	ls,	2,	1,	do_jffs2_ls,
-	"ls\t- list files in a directory (default /)\n",
+	"list files in a directory (default /)",
 	"[ directory ]\n"
 	"    - list files in a directory.\n"
 );
 
 U_BOOT_CMD(
 	fsinfo,	1,	1,	do_jffs2_fsinfo,
-	"fsinfo\t- print information about filesystems\n",
+	"print information about filesystems",
 	"    - print information about filesystems\n"
 );
 
 #ifdef CONFIG_JFFS2_CMDLINE
 U_BOOT_CMD(
 	chpart,	2,	0,	do_jffs2_chpart,
-	"chpart\t- change active partition\n",
+	"change active partition",
 	"part-id\n"
 	"    - change active partition (e.g. part-id = nand0,1)\n"
 );
 
 U_BOOT_CMD(
 	mtdparts,	6,	0,	do_jffs2_mtdparts,
-	"mtdparts- define flash/nand partitions\n",
+	"define flash/nand partitions",
 	"\n"
 	"    - list partition table\n"
 	"mtdparts delall\n"
diff -Naur u-boot-2009.01/common/cmd_license.c u-boot/common/cmd_license.c
--- u-boot-2009.01/common/cmd_license.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_license.c	2009-02-26 14:03:58.000000000 +0100
@@ -53,7 +53,7 @@
 }
 
 U_BOOT_CMD(license, 1, 1, do_license,
-	   "license - print GPL license text\n",
+	   "print GPL license text",
 	   NULL);
 
 #endif /* CONFIG_CMD_LICENSE */
diff -Naur u-boot-2009.01/common/cmd_load.c u-boot/common/cmd_load.c
--- u-boot-2009.01/common/cmd_load.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_load.c	2009-02-26 14:03:58.000000000 +0100
@@ -1045,7 +1045,7 @@
 #ifdef	CONFIG_SYS_LOADS_BAUD_CHANGE
 U_BOOT_CMD(
 	loads, 3, 0,	do_load_serial,
-	"loads   - load S-Record file over serial line\n",
+	"load S-Record file over serial line",
 	"[ off ] [ baud ]\n"
 	"    - load S-Record file over serial line"
 	" with offset 'off' and baudrate 'baud'\n"
@@ -1054,7 +1054,7 @@
 #else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
 U_BOOT_CMD(
 	loads, 2, 0,	do_load_serial,
-	"loads   - load S-Record file over serial line\n",
+	"load S-Record file over serial line",
 	"[ off ]\n"
 	"    - load S-Record file over serial line with offset 'off'\n"
 );
@@ -1069,7 +1069,7 @@
 #ifdef	CONFIG_SYS_LOADS_BAUD_CHANGE
 U_BOOT_CMD(
 	saves, 4, 0,	do_save_serial,
-	"saves   - save S-Record file over serial line\n",
+	"save S-Record file over serial line",
 	"[ off ] [size] [ baud ]\n"
 	"    - save S-Record file over serial line"
 	" with offset 'off', size 'size' and baudrate 'baud'\n"
@@ -1077,7 +1077,7 @@
 #else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
 U_BOOT_CMD(
 	saves, 3, 0,	do_save_serial,
-	"saves   - save S-Record file over serial line\n",
+	"save S-Record file over serial line",
 	"[ off ] [size]\n"
 	"    - save S-Record file over serial line with offset 'off' and size 'size'\n"
 );
@@ -1089,7 +1089,7 @@
 #if defined(CONFIG_CMD_LOADB)
 U_BOOT_CMD(
 	loadb, 3, 0,	do_load_serial_bin,
-	"loadb   - load binary file over serial line (kermit mode)\n",
+	"load binary file over serial line (kermit mode)",
 	"[ off ] [ baud ]\n"
 	"    - load binary file over serial line"
 	" with offset 'off' and baudrate 'baud'\n"
@@ -1097,7 +1097,7 @@
 
 U_BOOT_CMD(
 	loady, 3, 0,	do_load_serial_bin,
-	"loady   - load binary file over serial line (ymodem mode)\n",
+	"load binary file over serial line (ymodem mode)",
 	"[ off ] [ baud ]\n"
 	"    - load binary file over serial line"
 	" with offset 'off' and baudrate 'baud'\n"
@@ -1119,7 +1119,7 @@
 			if (strcmp(argv[1], "on") == 0)
 				hwflow_onoff(1);
 			else
-				printf("Usage: %s\n", cmdtp->usage);
+				cmd_usage(cmdtp);
 	}
 	printf("RTS/CTS hardware flow control: %s\n", hwflow_onoff(0) ? "on" : "off");
 	return 0;
@@ -1129,7 +1129,7 @@
 
 U_BOOT_CMD(
 	hwflow, 2, 0,	do_hwflow,
-	"hwflow  - turn the harwdare flow control on/off\n",
+	"turn the harwdare flow control on/off",
 	"[on|off]\n - change RTS/CTS hardware flow control over serial line\n"
 );
 
diff -Naur u-boot-2009.01/common/cmd_log.c u-boot/common/cmd_log.c
--- u-boot-2009.01/common/cmd_log.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_log.c	2009-02-26 14:03:58.000000000 +0100
@@ -241,18 +241,18 @@
 			}
 			return 0;
 		}
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 }
 
 U_BOOT_CMD(
 	log,     255,	1,	do_log,
-	"log     - manipulate logbuffer\n",
+	"manipulate logbuffer",
 	"info   - show pointer details\n"
 	"log reset  - clear contents\n"
 	"log show   - show contents\n"
diff -Naur u-boot-2009.01/common/cmd_mac.c u-boot/common/cmd_mac.c
--- u-boot-2009.01/common/cmd_mac.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_mac.c	2009-02-26 14:03:58.000000000 +0100
@@ -28,7 +28,7 @@
 
 U_BOOT_CMD(
 	mac, 3, 1,  do_mac,
-	"mac     - display and program the system ID and MAC addresses in EEPROM\n",
+	"display and program the system ID and MAC addresses in EEPROM",
 	"[read|save|id|num|errata|date|ports|0|1|2|3|4|5|6|7]\n"
 	"read\n"
 	"    - show content of EEPROM\n"
diff -Naur u-boot-2009.01/common/cmd_mem.c u-boot/common/cmd_mem.c
--- u-boot-2009.01/common/cmd_mem.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_mem.c	2009-02-26 14:03:58.000000000 +0100
@@ -29,9 +29,6 @@
 
 #include <common.h>
 #include <command.h>
-#if defined(CONFIG_CMD_MMC)
-#include <mmc.h>
-#endif
 #ifdef CONFIG_HAS_DATAFLASH
 #include <dataflash.h>
 #endif
@@ -77,7 +74,7 @@
 	length = dp_last_length;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -173,7 +170,7 @@
 	int	size;
 
 	if ((argc < 3) || (argc > 4)) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -217,7 +214,7 @@
 	ulong count;
 
 	if (argc < 4) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -246,7 +243,7 @@
 	ulong count;
 
 	if (argc < 4) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -277,7 +274,7 @@
 	int     rcode = 0;
 
 	if (argc != 4) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -361,7 +358,7 @@
 	int	size;
 
 	if (argc != 4) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -404,46 +401,6 @@
 	}
 #endif
 
-#if defined(CONFIG_CMD_MMC)
-	if (mmc2info(dest)) {
-		int rc;
-
-		puts ("Copy to MMC... ");
-		switch (rc = mmc_write ((uchar *)addr, dest, count*size)) {
-		case 0:
-			putc ('\n');
-			return 1;
-		case -1:
-			puts ("failed\n");
-			return 1;
-		default:
-			printf ("%s[%d] FIXME: rc=%d\n",__FILE__,__LINE__,rc);
-			return 1;
-		}
-		puts ("done\n");
-		return 0;
-	}
-
-	if (mmc2info(addr)) {
-		int rc;
-
-		puts ("Copy from MMC... ");
-		switch (rc = mmc_read (addr, (uchar *)dest, count*size)) {
-		case 0:
-			putc ('\n');
-			return 1;
-		case -1:
-			puts ("failed\n");
-			return 1;
-		default:
-			printf ("%s[%d] FIXME: rc=%d\n",__FILE__,__LINE__,rc);
-			return 1;
-		}
-		puts ("done\n");
-		return 0;
-	}
-#endif
-
 #ifdef CONFIG_HAS_DATAFLASH
 	/* Check if we are copying from RAM or Flash to DataFlash */
 	if (addr_dataflash(dest) && !addr_dataflash(addr)){
@@ -525,7 +482,7 @@
 	volatile u_char	*cp;
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -596,7 +553,7 @@
 	volatile u_char	*cp;
 
 	if (argc < 4) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -672,6 +629,8 @@
 	ulong	val;
 	ulong	readback;
 	int     rcode = 0;
+	int iterations = 1;
+	int iteration_limit;
 
 #if defined(CONFIG_SYS_ALT_MEMTEST)
 	vu_long	len;
@@ -687,7 +646,6 @@
 	vu_long *dummy = 0;	/* yes, this is address 0x0, not NULL */
 #endif
 	int	j;
-	int iterations = 1;
 
 	static const ulong bitpattern[] = {
 		0x00000001,	/* single bit */
@@ -704,23 +662,25 @@
 	ulong	pattern;
 #endif
 
-	if (argc > 1) {
+	if (argc > 1)
 		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
-	} else {
+	else
 		start = (ulong *)CONFIG_SYS_MEMTEST_START;
-	}
 
-	if (argc > 2) {
+	if (argc > 2)
 		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
-	} else {
+	else
 		end = (ulong *)(CONFIG_SYS_MEMTEST_END);
-	}
 
-	if (argc > 3) {
+	if (argc > 3)
 		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
-	} else {
+	else
 		pattern = 0;
-	}
+
+	if (argc > 4)
+		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
+	else
+		iteration_limit = 0;
 
 #if defined(CONFIG_SYS_ALT_MEMTEST)
 	printf ("Testing %08x ... %08x:\n", (uint)start, (uint)end);
@@ -733,8 +693,15 @@
 			return 1;
 		}
 
+
+		if (iteration_limit && iterations > iteration_limit) {
+			printf("Tested %d iteration(s) without errors.\n",
+				iterations-1);
+			return 0;
+		}
+
 		printf("Iteration: %6d\r", iterations);
-		PRINTF("Iteration: %6d\n", iterations);
+		PRINTF("\n");
 		iterations++;
 
 		/*
@@ -926,6 +893,13 @@
 			return 1;
 		}
 
+		if (iteration_limit && iterations > iteration_limit) {
+			printf("Tested %d iteration(s) without errors.\n",
+				iterations-1);
+			return 0;
+		}
+		++iterations;
+
 		printf ("\rPattern %08lX  Writing..."
 			"%12s"
 			"\b\b\b\b\b\b\b\b\b\b",
@@ -984,7 +958,7 @@
 	extern char console_buffer[];
 
 	if (argc != 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -1089,7 +1063,7 @@
 	ulong *ptr;
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -1125,7 +1099,7 @@
 
 	if (argc < 3) {
   usage:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -1185,7 +1159,7 @@
 			dst = simple_strtoul(argv[2], NULL, 16);
 			break;
 		default:
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			return 1;
 	}
 
@@ -1197,39 +1171,39 @@
 /**************************************************/
 U_BOOT_CMD(
 	md,	3,	1,	do_mem_md,
-	"md	- memory display\n",
+	"memory display",
 	"[.b, .w, .l] address [# of objects]\n	  - memory display\n"
 );
 
 
 U_BOOT_CMD(
 	mm,	2,	1,	do_mem_mm,
-	"mm	- memory modify (auto-incrementing)\n",
+	"memory modify (auto-incrementing)",
 	"[.b, .w, .l] address\n" "    - memory modify, auto increment address\n"
 );
 
 
 U_BOOT_CMD(
 	nm,	2,	1,	do_mem_nm,
-	"nm	- memory modify (constant address)\n",
+	"memory modify (constant address)",
 	"[.b, .w, .l] address\n    - memory modify, read and keep address\n"
 );
 
 U_BOOT_CMD(
 	mw,	4,	1,	do_mem_mw,
-	"mw	- memory write (fill)\n",
+	"memory write (fill)",
 	"[.b, .w, .l] address value [count]\n	- write memory\n"
 );
 
 U_BOOT_CMD(
 	cp,	4,	1,	do_mem_cp,
-	"cp	- memory copy\n",
+	"memory copy",
 	"[.b, .w, .l] source target count\n    - copy memory\n"
 );
 
 U_BOOT_CMD(
 	cmp,	4,	1,	do_mem_cmp,
-	"cmp	- memory compare\n",
+	"memory compare",
 	"[.b, .w, .l] addr1 addr2 count\n    - compare memory\n"
 );
 
@@ -1237,7 +1211,7 @@
 
 U_BOOT_CMD(
 	crc32,	4,	1,	do_mem_crc,
-	"crc32	- checksum calculation\n",
+	"checksum calculation",
 	"address count [addr]\n    - compute CRC32 checksum [save at addr]\n"
 );
 
@@ -1245,7 +1219,7 @@
 
 U_BOOT_CMD(
 	crc32,	5,	1,	do_mem_crc,
-	"crc32	- checksum calculation\n",
+	"checksum calculation",
 	"address count [addr]\n    - compute CRC32 checksum [save at addr]\n"
 	"-v address count crc\n    - verify crc of memory area\n"
 );
@@ -1254,14 +1228,14 @@
 
 U_BOOT_CMD(
 	base,	2,	1,	do_mem_base,
-	"base	- print or set address offset\n",
+	"print or set address offset",
 	"\n    - print address offset for memory commands\n"
 	"base off\n    - set address offset for memory commands to 'off'\n"
 );
 
 U_BOOT_CMD(
 	loop,	3,	1,	do_mem_loop,
-	"loop	- infinite loop on address range\n",
+	"infinite loop on address range",
 	"[.b, .w, .l] address number_of_objects\n"
 	"    - loop on a set of addresses\n"
 );
@@ -1269,29 +1243,29 @@
 #ifdef CONFIG_LOOPW
 U_BOOT_CMD(
 	loopw,	4,	1,	do_mem_loopw,
-	"loopw	- infinite write loop on address range\n",
+	"infinite write loop on address range",
 	"[.b, .w, .l] address number_of_objects data_to_write\n"
 	"    - loop on a set of addresses\n"
 );
 #endif /* CONFIG_LOOPW */
 
 U_BOOT_CMD(
-	mtest,	4,	1,	do_mem_mtest,
-	"mtest	- simple RAM test\n",
-	"[start [end [pattern]]]\n"
+	mtest,	5,	1,	do_mem_mtest,
+	"simple RAM test",
+	"[start [end [pattern [iterations]]]]\n"
 	"    - simple RAM read/write test\n"
 );
 
 #ifdef CONFIG_MX_CYCLIC
 U_BOOT_CMD(
 	mdc,	4,	1,	do_mem_mdc,
-	"mdc	- memory display cyclic\n",
+	"memory display cyclic",
 	"[.b, .w, .l] address count delay(ms)\n    - memory display cyclic\n"
 );
 
 U_BOOT_CMD(
 	mwc,	4,	1,	do_mem_mwc,
-	"mwc	- memory write cyclic\n",
+	"memory write cyclic",
 	"[.b, .w, .l] address value delay(ms)\n    - memory write cyclic\n"
 );
 #endif /* CONFIG_MX_CYCLIC */
@@ -1299,7 +1273,7 @@
 #ifdef CONFIG_CMD_UNZIP
 U_BOOT_CMD(
 	unzip,	4,	1,	do_unzip,
-	"unzip - unzip a memory region\n",
+	"unzip a memory region",
 	"srcaddr dstaddr [dstsize]\n"
 );
 #endif /* CONFIG_CMD_UNZIP */
diff -Naur u-boot-2009.01/common/cmd_mfsl.c u-boot/common/cmd_mfsl.c
--- u-boot-2009.01/common/cmd_mfsl.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_mfsl.c	2009-02-26 14:03:58.000000000 +0100
@@ -38,7 +38,7 @@
 	unsigned int blocking;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -46,7 +46,7 @@
 	blocking = (unsigned int)simple_strtoul (argv[2], NULL, 16);
 	if (fslnum < 0 || fslnum >= XILINX_FSL_NUMBER) {
 		puts ("Bad number of FSL\n");
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -196,7 +196,7 @@
 	unsigned int blocking;
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -204,7 +204,7 @@
 	num = (unsigned int)simple_strtoul (argv[2], NULL, 16);
 	blocking = (unsigned int)simple_strtoul (argv[3], NULL, 16);
 	if (fslnum < 0 || fslnum >= XILINX_FSL_NUMBER) {
-		printf ("Bad number of FSL\nUsage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -354,7 +354,7 @@
 	unsigned int val = 0;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	reg = (unsigned int)simple_strtoul (argv[1], NULL, 16);
@@ -389,7 +389,7 @@
 /***************************************************/
 
 U_BOOT_CMD (frd, 3, 1, do_frd,
-		"frd     - read data from FSL\n",
+		"read data from FSL",
 		"- [fslnum [0|1|2|3]]\n"
 		" 0 - non blocking data read\n"
 		" 1 - non blocking control read\n"
@@ -398,7 +398,7 @@
 
 
 U_BOOT_CMD (fwr, 4, 1, do_fwr,
-		"fwr     - write data to FSL\n",
+		"write data to FSL",
 		"- [fslnum [0|1|2|3]]\n"
 		" 0 - non blocking data write\n"
 		" 1 - non blocking control write\n"
@@ -406,7 +406,7 @@
 		" 3 - blocking control write\n");
 
 U_BOOT_CMD (rspr, 3, 1, do_rspr,
-		"rspr    - read/write special purpose register\n",
+		"read/write special purpose register",
 		"- reg_num [write value] read/write special purpose register\n"
 		" 1 - MSR - Machine status register\n"
 		" 3 - EAR - Exception address register\n"
diff -Naur u-boot-2009.01/common/cmd_mii.c u-boot/common/cmd_mii.c
--- u-boot-2009.01/common/cmd_mii.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_mii.c	2009-02-26 14:03:58.000000000 +0100
@@ -302,7 +302,7 @@
 	char		*devname;
 
 	if (argc < 2) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -431,7 +431,7 @@
 		else
 			miiphy_set_current_dev (argv[2]);
 	} else {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -453,7 +453,7 @@
 
 U_BOOT_CMD(
 	mii,	5,	1,	do_mii,
-	"mii     - MII utility commands\n",
+	"MII utility commands",
 	"device                     - list available devices\n"
 	"mii device <devname>           - set current device\n"
 	"mii info   <addr>              - display MII PHY info\n"
diff -Naur u-boot-2009.01/common/cmd_misc.c u-boot/common/cmd_misc.c
--- u-boot-2009.01/common/cmd_misc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_misc.c	2009-02-26 14:03:58.000000000 +0100
@@ -33,7 +33,7 @@
 	ulong delay;
 
 	if (argc != 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -55,14 +55,14 @@
 
 U_BOOT_CMD(
 	irqinfo,    1,    1,     do_irqinfo,
-	"irqinfo - print information about IRQs\n",
+	"print information about IRQs",
 	NULL
 );
 #endif
 
 U_BOOT_CMD(
 	sleep ,    2,    1,     do_sleep,
-	"sleep   - delay execution for some time\n",
+	"delay execution for some time",
 	"N\n"
 	"    - delay execution for N seconds (N is _decimal_ !!!)\n"
 );
diff -Naur u-boot-2009.01/common/cmd_mmc.c u-boot/common/cmd_mmc.c
--- u-boot-2009.01/common/cmd_mmc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_mmc.c	2009-02-26 14:03:58.000000000 +0100
@@ -25,9 +25,10 @@
 #include <command.h>
 #include <mmc.h>
 
+#ifndef CONFIG_GENERIC_MMC
 int do_mmc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	if (mmc_init (1) != 0) {
+	if (mmc_legacy_init (1) != 0) {
 		printf ("No MMC card found\n");
 		return 1;
 	}
@@ -36,6 +37,138 @@
 
 U_BOOT_CMD(
 	mmcinit,	1,	0,	do_mmc,
-	"mmcinit - init mmc card\n",
+	"init mmc card",
 	NULL
 );
+#else /* !CONFIG_GENERIC_MMC */
+
+static void print_mmcinfo(struct mmc *mmc)
+{
+	printf("Device: %s\n", mmc->name);
+	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
+	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
+	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
+			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
+			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
+
+	printf("Tran Speed: %d\n", mmc->tran_speed);
+	printf("Rd Block Len: %d\n", mmc->read_bl_len);
+
+	printf("%s version %d.%d\n", IS_SD(mmc) ? "SD" : "MMC",
+			(mmc->version >> 4) & 0xf, mmc->version & 0xf);
+
+	printf("High Capacity: %s\n", mmc->high_capacity ? "Yes" : "No");
+	printf("Capacity: %lld\n", mmc->capacity);
+
+	printf("Bus Width: %d-bit\n", mmc->bus_width);
+}
+
+int do_mmcinfo (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	struct mmc *mmc;
+	int dev_num;
+
+	if (argc < 2)
+		dev_num = 0;
+	else
+		dev_num = simple_strtoul(argv[1], NULL, 0);
+
+	mmc = find_mmc_device(dev_num);
+
+	if (mmc) {
+		mmc_init(mmc);
+
+		print_mmcinfo(mmc);
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(mmcinfo, 2, 0, do_mmcinfo, "mmcinfo <dev num>-- display MMC info\n",
+		NULL);
+
+int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int rc = 0;
+
+	switch (argc) {
+	case 3:
+		if (strcmp(argv[1], "rescan") == 0) {
+			int dev = simple_strtoul(argv[2], NULL, 10);
+			struct mmc *mmc = find_mmc_device(dev);
+
+			mmc_init(mmc);
+
+			return 0;
+		}
+
+	case 0:
+	case 1:
+	case 4:
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+
+	case 2:
+		if (!strcmp(argv[1], "list")) {
+			print_mmc_devices('\n');
+			return 0;
+		}
+		return 1;
+	default: /* at least 5 args */
+		if (strcmp(argv[1], "read") == 0) {
+			int dev = simple_strtoul(argv[2], NULL, 10);
+			void *addr = (void *)simple_strtoul(argv[3], NULL, 16);
+			u32 cnt = simple_strtoul(argv[5], NULL, 16);
+			u32 n;
+			u32 blk = simple_strtoul(argv[4], NULL, 16);
+			struct mmc *mmc = find_mmc_device(dev);
+
+			printf("\nMMC read: dev # %d, block # %d, count %d ... ",
+				dev, blk, cnt);
+
+			mmc_init(mmc);
+
+			n = mmc->block_dev.block_read(dev, blk, cnt, addr);
+
+			/* flush cache after read */
+			flush_cache((ulong)addr, cnt * 512); /* FIXME */
+
+			printf("%d blocks read: %s\n",
+				n, (n==cnt) ? "OK" : "ERROR");
+			return (n == cnt) ? 0 : 1;
+		} else if (strcmp(argv[1], "write") == 0) {
+			int dev = simple_strtoul(argv[2], NULL, 10);
+			void *addr = (void *)simple_strtoul(argv[3], NULL, 16);
+			u32 cnt = simple_strtoul(argv[5], NULL, 16);
+			u32 n;
+			struct mmc *mmc = find_mmc_device(dev);
+
+			int blk = simple_strtoul(argv[4], NULL, 16);
+
+			printf("\nMMC write: dev # %d, block # %d, count %d ... ",
+				dev, blk, cnt);
+
+			mmc_init(mmc);
+
+			n = mmc->block_dev.block_write(dev, blk, cnt, addr);
+
+			printf("%d blocks written: %s\n",
+				n, (n == cnt) ? "OK" : "ERROR");
+			return (n == cnt) ? 0 : 1;
+		} else {
+			printf("Usage:\n%s\n", cmdtp->usage);
+			rc = 1;
+		}
+
+		return rc;
+	}
+}
+
+U_BOOT_CMD(
+	mmc, 6, 1, do_mmcops,
+	"mmc	- MMC sub system\n",
+	"mmc read <device num> addr blk# cnt\n"
+	"mmc write <device num> addr blk# cnt\n"
+	"mmc rescan <device num>\n"
+	"mmc list - lists available devices\n");
+#endif
diff -Naur u-boot-2009.01/common/cmd_mp.c u-boot/common/cmd_mp.c
--- u-boot-2009.01/common/cmd_mp.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_mp.c	2009-02-26 14:03:58.000000000 +0100
@@ -29,7 +29,7 @@
 	unsigned long cpuid;
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -47,7 +47,7 @@
 		} else if (strncmp(argv[2], "status", 6) == 0) {
 			cpu_status(cpuid);
 		} else {
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			return 1;
 		}
 		return 0;
@@ -55,12 +55,12 @@
 
 	/* 4 or greater, make sure its release */
 	if (strncmp(argv[2], "release", 7) != 0) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
 	if (cpu_release(cpuid, argc - 3, argv + 3)) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -83,7 +83,7 @@
 
 U_BOOT_CMD(
 	cpu, CONFIG_SYS_MAXARGS, 1, cpu_cmd,
-	"cpu     - Multiprocessor CPU boot manipulation and release\n",
+	"Multiprocessor CPU boot manipulation and release",
 	    "<num> reset                 - Reset cpu <num>\n"
 	"cpu <num> status                - Status of cpu <num>\n"
 	"cpu <num> release <addr> [args] - Release cpu <num> at <addr> with [args]\n"
diff -Naur u-boot-2009.01/common/cmd_nand.c u-boot/common/cmd_nand.c
--- u-boot-2009.01/common/cmd_nand.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_nand.c	2009-03-11 10:41:22.000000000 +0100
@@ -160,10 +160,51 @@
 	if (*size == nand->size)
 		puts("whole chip\n");
 	else
-		printf("offset 0x%lx, size 0x%x\n", *off, *size);
+		printf("offset 0x%lx, size 0x%zx\n", *off, *size);
 	return 0;
 }
 
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+static void print_status(ulong start, ulong end, ulong erasesize, int status)
+{
+	printf("%08lx - %08lx: %08lx blocks %s%s%s\n",
+		start,
+		end - 1,
+		(end - start) / erasesize,
+		((status & NAND_LOCK_STATUS_TIGHT) ?  "TIGHT " : ""),
+		((status & NAND_LOCK_STATUS_LOCK) ?  "LOCK " : ""),
+		((status & NAND_LOCK_STATUS_UNLOCK) ?  "UNLOCK " : ""));
+}
+
+static void do_nand_status(nand_info_t *nand)
+{
+	ulong block_start = 0;
+	ulong off;
+	int last_status = -1;
+
+	struct nand_chip *nand_chip = nand->priv;
+	/* check the WP bit */
+	nand_chip->cmdfunc(nand, NAND_CMD_STATUS, -1, -1);
+	printf("device is %swrite protected\n",
+		(nand_chip->read_byte(nand) & 0x80 ?
+		"NOT " : ""));
+
+	for (off = 0; off < nand->size; off += nand->erasesize) {
+		int s = nand_get_lock_status(nand, off);
+
+		/* print message only if status has changed */
+		if (s != last_status && off != 0) {
+			print_status(block_start, off, nand->erasesize,
+					last_status);
+			block_start = off;
+		}
+		last_status = s;
+	}
+	/* Print the last block info */
+	print_status(block_start, off, nand->erasesize, last_status);
+}
+#endif
+
 int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
 	int i, dev, ret = 0;
@@ -233,7 +274,8 @@
 	    strncmp(cmd, "dump", 4) != 0 &&
 	    strncmp(cmd, "read", 4) != 0 && strncmp(cmd, "write", 5) != 0 &&
 	    strcmp(cmd, "scrub") != 0 && strcmp(cmd, "markbad") != 0 &&
-	    strcmp(cmd, "biterr") != 0 &&
+	    strcmp(cmd, "biterr") != 0 && 
+	    strcmp(cmd, "peek") != 0 && 
 	    strcmp(cmd, "lock") != 0 && strcmp(cmd, "unlock") != 0 )
 		goto usage;
 
@@ -318,6 +360,32 @@
 
 	}
 
+	// syntax: nand peek offset (OOB-Data is inlined! compute page-addr*2)
+	if (strncmp(cmd, "peek", 4) == 0) {
+		uint8_t buf[256];
+		int i;
+		struct nand_chip *chip = nand->priv;
+		if (argc < 3)
+			goto usage;
+
+		off = (int) simple_strtoul(argv[2], NULL, 16);
+		chip->cmdfunc(nand, NAND_CMD_READ0, 0, off >> 12);
+		chip->cmdfunc(nand, NAND_CMD_RNDOUT, off & 0x0FFF, -1);
+		chip->read_buf(nand, buf, 256);
+		printf("data @ %08lx:\n", off);
+		for(i=0;i<256;i+=16)
+			printf("\t %02x %02x %02x %02x %02x %02x %02x %02x"
+				 " %02x %02x %02x %02x %02x %02x %02x %02x\n",
+				buf[i+0], buf[i+1], buf[i+2], buf[i+3],
+				buf[i+4], buf[i+5], buf[i+6], buf[i+7],
+				buf[i+8], buf[i+9], buf[i+10], buf[i+11],
+				buf[i+12], buf[i+13], buf[i+14], buf[i+15]);
+		return 1;
+	}
+
+
+
+
 	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
 		int read;
 
@@ -357,7 +425,7 @@
 			return 1;
 		}
 
-		printf(" %d bytes %s: %s\n", size,
+		printf(" %zu bytes %s: %s\n", size,
 		       read ? "read" : "written", ret ? "ERROR" : "OK");
 
 		return ret == 0 ? 0 : 1;
@@ -383,8 +451,9 @@
 		return 1;
 	}
 
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
 	if (strcmp(cmd, "lock") == 0) {
-		int tight  = 0;
+		int tight = 0;
 		int status = 0;
 		if (argc == 3) {
 			if (!strcmp("tight", argv[2]))
@@ -392,44 +461,8 @@
 			if (!strcmp("status", argv[2]))
 				status = 1;
 		}
-/*
- * ! BROKEN !
- *
- * TODO: must be implemented and tested by someone with HW
- */
-#if 0
 		if (status) {
-			ulong block_start = 0;
-			ulong off;
-			int last_status = -1;
-
-			struct nand_chip *nand_chip = nand->priv;
-			/* check the WP bit */
-			nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
-			printf("device is %swrite protected\n",
-			       (nand_chip->read_byte(nand) & 0x80 ?
-			       "NOT " : ""));
-
-			for (off = 0; off < nand->size; off += nand->writesize) {
-				int s = nand_get_lock_status(nand, off);
-
-				/* print message only if status has changed
-				 * or at end of chip
-				 */
-				if (off == nand->size - nand->writesize
-				    || (s != last_status && off != 0))	{
-
-					printf("%08lx - %08lx: %8d pages %s%s%s\n",
-					       block_start,
-					       off-1,
-					       (off-block_start)/nand->writesize,
-					       ((last_status & NAND_LOCK_STATUS_TIGHT) ? "TIGHT " : ""),
-					       ((last_status & NAND_LOCK_STATUS_LOCK) ? "LOCK " : ""),
-					       ((last_status & NAND_LOCK_STATUS_UNLOCK) ? "UNLOCK " : ""));
-				}
-
-				last_status = s;
-			}
+			do_nand_status(nand);
 		} else {
 			if (!nand_lock(nand, tight)) {
 				puts("NAND flash successfully locked\n");
@@ -438,7 +471,6 @@
 				return 1;
 			}
 		}
-#endif
 		return 0;
 	}
 
@@ -446,12 +478,6 @@
 		if (arg_off_size(argc - 2, argv + 2, nand, &off, &size) < 0)
 			return 1;
 
-/*
- * ! BROKEN !
- *
- * TODO: must be implemented and tested by someone with HW
- */
-#if 0
 		if (!nand_unlock(nand, off, size)) {
 			puts("NAND flash successfully unlocked\n");
 		} else {
@@ -459,17 +485,17 @@
 			     "write and erase will probably fail\n");
 			return 1;
 		}
-#endif
 		return 0;
 	}
+#endif
 
 usage:
-	printf("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
 U_BOOT_CMD(nand, 5, 1, do_nand,
-	   "nand    - NAND sub-system\n",
+	   "NAND sub-system",
 	   "info - show available NAND devices\n"
 	   "nand device [dev] - show or set current device\n"
 	   "nand read - addr off|partition size\n"
@@ -480,12 +506,16 @@
 	   "    offset 'off' (entire device if not specified)\n"
 	   "nand bad - show bad blocks\n"
 	   "nand dump[.oob] off - dump page\n"
+	   "nand peek off - dump some part of flash at a random address\n"
 	   "nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n"
 	   "nand markbad off - mark bad block at offset (UNSAFE)\n"
 	   "nand biterr off - make a bit error at offset (UNSAFE)\n"
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
 	   "nand lock [tight] [status]\n"
 	   "    bring nand to lock state or display locked pages\n"
-	   "nand unlock [offset] [size] - unlock section\n");
+	   "nand unlock [offset] [size] - unlock section\n"
+#endif
+);
 
 static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
 			   ulong offset, ulong addr, char *cmd)
@@ -636,7 +666,7 @@
 #if defined(CONFIG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
 usage:
 #endif
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		show_boot_progress(-53);
 		return 1;
 	}
@@ -662,7 +692,7 @@
 }
 
 U_BOOT_CMD(nboot, 4, 1, do_nandboot,
-	"nboot   - boot from NAND device\n",
+	"boot from NAND device",
 	"[partition] | [[[loadAddr] dev] offset]\n");
 
 #endif
@@ -749,7 +779,7 @@
 	switch (argc) {
 	case 0:
 	case 1:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	case 2:
 		if (strcmp (argv[1], "info") == 0) {
@@ -787,7 +817,7 @@
 			return 0;
 
 		}
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	case 3:
 		if (strcmp (argv[1], "device") == 0) {
@@ -826,7 +856,7 @@
 			return ret;
 		}
 
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	default:
 		/* at least 4 args */
@@ -854,13 +884,12 @@
 							      (u_char *) addr);
 				}
 				return ret;
-			} else if (cmdtail && !strncmp (cmdtail, ".jffs2", 2))
-				cmd |= NANDRW_JFFS2;	/* skip bad blocks */
-			else if (cmdtail && !strncmp (cmdtail, ".jffs2s", 2)) {
+			} else if (cmdtail && !strncmp (cmdtail, ".jffs2s", 7)) {
 				cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
 				if (cmd & NANDRW_READ)
 					cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
-			}
+			} else if (cmdtail && !strncmp (cmdtail, ".jffs2", 2))
+				cmd |= NANDRW_JFFS2;	/* skip bad blocks */
 #ifdef SXNI855T
 			/* need ".e" same as ".j" for compatibility with older units */
 			else if (cmdtail && !strcmp (cmdtail, ".e"))
@@ -876,7 +905,7 @@
 			}
 #endif /* CONFIG_SYS_NAND_SKIP_BAD_DOT_I */
 			else if (cmdtail) {
-				printf ("Usage:\n%s\n", cmdtp->usage);
+				cmd_usage(cmdtp);
 				return 1;
 			}
 
@@ -912,7 +941,7 @@
 
 			return ret;
 		} else {
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			rcode = 1;
 		}
 
@@ -922,7 +951,7 @@
 
 U_BOOT_CMD(
 	nand,	5,	1,	do_nand,
-	"nand    - legacy NAND sub-system\n",
+	"legacy NAND sub-system",
 	"info  - show available NAND devices\n"
 	"nand device [dev] - show or set current device\n"
 	"nand read[.jffs2[s]]  addr off size\n"
@@ -969,7 +998,7 @@
 		offset = simple_strtoul(argv[3], NULL, 16);
 		break;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		show_boot_progress (-53);
 		return 1;
 	}
@@ -1071,7 +1100,7 @@
 
 U_BOOT_CMD(
 	nboot,	4,	1,	do_nandboot,
-	"nboot   - boot from NAND device\n",
+	"boot from NAND device",
 	"loadAddr dev\n"
 );
 
diff -Naur u-boot-2009.01/common/cmd_net.c u-boot/common/cmd_net.c
--- u-boot-2009.01/common/cmd_net.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_net.c	2009-02-27 13:07:59.000000000 +0100
@@ -39,7 +39,7 @@
 
 U_BOOT_CMD(
 	bootp,	3,	1,	do_bootp,
-	"bootp\t- boot image via network using BOOTP/TFTP protocol\n",
+	"boot image via network using BOOTP/TFTP protocol",
 	"[loadAddress] [[hostIPaddr:]bootfilename]\n"
 );
 
@@ -50,7 +50,7 @@
 
 U_BOOT_CMD(
 	tftpboot,	3,	1,	do_tftpb,
-	"tftpboot- boot image via network using TFTP protocol\n",
+	"boot image via network using TFTP protocol",
 	"[loadAddress] [[hostIPaddr:]bootfilename]\n"
 );
 
@@ -61,7 +61,7 @@
 
 U_BOOT_CMD(
 	rarpboot,	3,	1,	do_rarpb,
-	"rarpboot- boot image via network using RARP/TFTP protocol\n",
+	"boot image via network using RARP/TFTP protocol",
 	"[loadAddress] [[hostIPaddr:]bootfilename]\n"
 );
 
@@ -73,7 +73,7 @@
 
 U_BOOT_CMD(
 	dhcp,	3,	1,	do_dhcp,
-	"dhcp\t- boot image via network using DHCP/TFTP protocol\n",
+	"boot image via network using DHCP/TFTP protocol",
 	"[loadAddress] [[hostIPaddr:]bootfilename]\n"
 );
 #endif
@@ -86,7 +86,7 @@
 
 U_BOOT_CMD(
 	nfs,	3,	1,	do_nfs,
-	"nfs\t- boot image via network using NFS protocol\n",
+	"boot image via network using NFS protocol",
 	"[loadAddress] [[hostIPaddr:]bootfilename]\n"
 );
 #endif
@@ -186,7 +186,7 @@
 
 		break;
 
-	default: printf ("Usage:\n%s\n", cmdtp->usage);
+	default: cmd_usage(cmdtp);
 		show_boot_progress (-80);
 		return 1;
 	}
@@ -251,7 +251,7 @@
 
 	NetPingIP = string_to_ip(argv[1]);
 	if (NetPingIP == 0) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return -1;
 	}
 
@@ -267,7 +267,7 @@
 
 U_BOOT_CMD(
 	ping,	2,	1,	do_ping,
-	"ping\t- send ICMP ECHO_REQUEST to network host\n",
+	"send ICMP ECHO_REQUEST to network host",
 	"pingAddress\n"
 );
 #endif
@@ -311,7 +311,7 @@
 
 U_BOOT_CMD(
 	cdp,	1,	1,	do_cdp,
-	"cdp\t- Perform CDP network configuration\n",
+	"Perform CDP network configuration",
 );
 #endif
 
@@ -348,7 +348,7 @@
 
 U_BOOT_CMD(
 	sntp,	2,	1,	do_sntp,
-	"sntp\t- synchronize RTC via network\n",
+	"synchronize RTC via network",
 	"[NTP server IP]\n"
 );
 #endif
diff -Naur u-boot-2009.01/common/cmd_nvedit.c u-boot/common/cmd_nvedit.c
--- u-boot-2009.01/common/cmd_nvedit.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_nvedit.c	2009-02-26 14:03:58.000000000 +0100
@@ -408,7 +408,7 @@
 int do_setenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -434,13 +434,13 @@
 	local_args[3] = NULL;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	/* Check the syntax */
 	switch (argc) {
 	case 1:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 
 	case 2:		/* askenv envname */
@@ -546,11 +546,8 @@
 	return (-1);
 }
 
-#if ((defined(CONFIG_ENV_IS_IN_NVRAM) || defined(CONFIG_ENV_IS_IN_EEPROM) \
-    || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_FLASH)) \
-    || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_NAND)) \
-    || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_ONENAND))) \
-    && !defined(CONFIG_ENV_IS_NOWHERE))
+#if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)
+
 int do_saveenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	extern char * env_name_spec;
@@ -560,6 +557,12 @@
 	return (saveenv() ? 1 : 0);
 }
 
+U_BOOT_CMD(
+	saveenv, 1, 0,	do_saveenv,
+	"save environment variables to persistent storage",
+	NULL
+);
+
 #endif
 
 
@@ -587,7 +590,7 @@
 
 U_BOOT_CMD(
 	printenv, CONFIG_SYS_MAXARGS, 1,	do_printenv,
-	"printenv- print environment variables\n",
+	"print environment variables",
 	"\n    - print values of all environment variables\n"
 	"printenv name ...\n"
 	"    - print value of environment variable 'name'\n"
@@ -595,31 +598,18 @@
 
 U_BOOT_CMD(
 	setenv, CONFIG_SYS_MAXARGS, 0,	do_setenv,
-	"setenv  - set environment variables\n",
+	"set environment variables",
 	"name value ...\n"
 	"    - set environment variable 'name' to 'value ...'\n"
 	"setenv name\n"
 	"    - delete environment variable 'name'\n"
 );
 
-#if ((defined(CONFIG_ENV_IS_IN_NVRAM) || defined(CONFIG_ENV_IS_IN_EEPROM) \
-    || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_FLASH)) \
-    || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_NAND)) \
-    || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_ONENAND))) \
-    && !defined(CONFIG_ENV_IS_NOWHERE))
-U_BOOT_CMD(
-	saveenv, 1, 0,	do_saveenv,
-	"saveenv - save environment variables to persistent storage\n",
-	NULL
-);
-
-#endif
-
 #if defined(CONFIG_CMD_ASKENV)
 
 U_BOOT_CMD(
 	askenv,	CONFIG_SYS_MAXARGS,	1,	do_askenv,
-	"askenv  - get environment variables from stdin\n",
+	"get environment variables from stdin",
 	"name [message] [size]\n"
 	"    - get environment variable 'name' from stdin (max 'size' chars)\n"
 	"askenv name\n"
@@ -636,7 +626,7 @@
 int do_run (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
 U_BOOT_CMD(
 	run,	CONFIG_SYS_MAXARGS,	1,	do_run,
-	"run     - run commands in an environment variable\n",
+	"run commands in an environment variable",
 	"var [...]\n"
 	"    - run the commands in the environment variable(s) 'var'\n"
 );
diff -Naur u-boot-2009.01/common/cmd_onenand.c u-boot/common/cmd_onenand.c
--- u-boot-2009.01/common/cmd_onenand.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_onenand.c	2009-02-26 14:03:58.000000000 +0100
@@ -1,7 +1,7 @@
 /*
  *  U-Boot command for OneNAND support
  *
- *  Copyright (C) 2005-2007 Samsung Electronics
+ *  Copyright (C) 2005-2008 Samsung Electronics
  *  Kyungmin Park <kyungmin.park@samsung.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -11,6 +11,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <malloc.h>
 
 #include <linux/mtd/compat.h>
 #include <linux/mtd/mtd.h>
@@ -18,159 +19,468 @@
 
 #include <asm/io.h>
 
-extern struct mtd_info onenand_mtd;
-extern struct onenand_chip onenand_chip;
+static struct mtd_info *mtd;
+
+static loff_t next_ofs;
+static loff_t skip_ofs;
+
+static inline int str2long(char *p, ulong *num)
+{
+	char *endptr;
+
+	*num = simple_strtoul(p, &endptr, 16);
+	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+}
+
+static int arg_off_size(int argc, char *argv[], ulong *off, size_t *size)
+{
+	if (argc >= 1) {
+		if (!(str2long(argv[0], off))) {
+			printf("'%s' is not a number\n", argv[0]);
+			return -1;
+		}
+	} else {
+		*off = 0;
+	}
+
+	if (argc >= 2) {
+		if (!(str2long(argv[1], (ulong *)size))) {
+			printf("'%s' is not a number\n", argv[1]);
+			return -1;
+		}
+	} else {
+		*size = mtd->size - *off;
+	}
+
+	if ((*off + *size) > mtd->size) {
+		printf("total chip size (0x%x) exceeded!\n", mtd->size);
+		return -1;
+	}
+
+	if (*size == mtd->size)
+		puts("whole chip\n");
+	else
+		printf("offset 0x%lx, size 0x%x\n", *off, *size);
+
+	return 0;
+}
+
+static int onenand_block_read(loff_t from, size_t len,
+			      size_t *retlen, u_char *buf, int oob)
+{
+	struct onenand_chip *this = mtd->priv;
+	int blocks = (int) len >> this->erase_shift;
+	int blocksize = (1 << this->erase_shift);
+	loff_t ofs = from;
+	struct mtd_oob_ops ops = {
+		.retlen		= 0,
+	};
+	int ret;
+
+	if (oob)
+		ops.ooblen = blocksize;
+	else
+		ops.len = blocksize;
+
+	while (blocks) {
+		ret = mtd->block_isbad(mtd, ofs);
+		if (ret) {
+			printk("Bad blocks %d at 0x%x\n",
+			       (u32)(ofs >> this->erase_shift), (u32)ofs);
+			ofs += blocksize;
+			continue;
+		}
+
+		if (oob)
+			ops.oobbuf = buf;
+		else
+			ops.datbuf = buf;
+
+		ops.retlen = 0;
+		ret = mtd->read_oob(mtd, ofs, &ops);
+		if (ret) {
+			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
+			ofs += blocksize;
+			continue;
+		}
+		ofs += blocksize;
+		buf += blocksize;
+		blocks--;
+		*retlen += ops.retlen;
+	}
+
+	return 0;
+}
+
+static int onenand_block_write(loff_t to, size_t len,
+			       size_t *retlen, const u_char * buf)
+{
+	struct onenand_chip *this = mtd->priv;
+	int blocks = len >> this->erase_shift;
+	int blocksize = (1 << this->erase_shift);
+	loff_t ofs;
+	size_t _retlen = 0;
+	int ret;
+
+	if (to == next_ofs) {
+		next_ofs = to + len;
+		to += skip_ofs;
+	} else {
+		next_ofs = to + len;
+		skip_ofs = 0;
+	}
+	ofs = to;
+
+	while (blocks) {
+		ret = mtd->block_isbad(mtd, ofs);
+		if (ret) {
+			printk("Bad blocks %d at 0x%x\n",
+			       (u32)(ofs >> this->erase_shift), (u32)ofs);
+			skip_ofs += blocksize;
+			goto next;
+		}
+
+		ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
+		if (ret) {
+			printk("Write failed 0x%x, %d", (u32)ofs, ret);
+			skip_ofs += blocksize;
+			goto next;
+		}
+
+		buf += blocksize;
+		blocks--;
+		*retlen += _retlen;
+next:
+		ofs += blocksize;
+	}
+
+	return 0;
+}
+
+static int onenand_block_erase(u32 start, u32 size, int force)
+{
+	struct onenand_chip *this = mtd->priv;
+	struct erase_info instr = {
+		.callback	= NULL,
+	};
+	loff_t ofs;
+	int ret;
+	int blocksize = 1 << this->erase_shift;
+
+	for (ofs = start; ofs < (start + size); ofs += blocksize) {
+		ret = mtd->block_isbad(mtd, ofs);
+		if (ret && !force) {
+			printf("Skip erase bad block %d at 0x%x\n",
+			       (u32)(ofs >> this->erase_shift), (u32)ofs);
+			continue;
+		}
+
+		instr.addr = ofs;
+		instr.len = blocksize;
+		instr.priv = force;
+		instr.mtd = mtd;
+		ret = mtd->erase(mtd, &instr);
+		if (ret) {
+			printf("erase failed block %d at 0x%x\n",
+			       (u32)(ofs >> this->erase_shift), (u32)ofs);
+			continue;
+		}
+	}
+
+	return 0;
+}
+
+static int onenand_block_test(u32 start, u32 size)
+{
+	struct onenand_chip *this = mtd->priv;
+	struct erase_info instr = {
+		.callback	= NULL,
+		.priv		= 0,
+	};
+
+	int blocks;
+	loff_t ofs;
+	int blocksize = 1 << this->erase_shift;
+	int start_block, end_block;
+	size_t retlen;
+	u_char *buf;
+	u_char *verify_buf;
+	int ret;
+
+	buf = malloc(blocksize);
+	if (!buf) {
+		printf("Not enough malloc space available!\n");
+		return -1;
+	}
+
+	verify_buf = malloc(blocksize);
+	if (!verify_buf) {
+		printf("Not enough malloc space available!\n");
+		return -1;
+	}
+
+	start_block = start >> this->erase_shift;
+	end_block = (start + size) >> this->erase_shift;
+
+	/* Protect boot-loader from badblock testing */
+	if (start_block < 2)
+		start_block = 2;
+
+	if (end_block > (mtd->size >> this->erase_shift))
+		end_block = mtd->size >> this->erase_shift;
+
+	blocks = start_block;
+	ofs = start;
+	while (blocks < end_block) {
+		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);
+
+		ret = mtd->block_isbad(mtd, ofs);
+		if (ret) {
+			printf("Skip erase bad block %d at 0x%x\n",
+			       (u32)(ofs >> this->erase_shift), (u32)ofs);
+			goto next;
+		}
+
+		instr.addr = ofs;
+		instr.len = blocksize;
+		ret = mtd->erase(mtd, &instr);
+		if (ret) {
+			printk("Erase failed 0x%x, %d\n", (u32)ofs, ret);
+			goto next;
+		}
+
+		ret = mtd->write(mtd, ofs, blocksize, &retlen, buf);
+		if (ret) {
+			printk("Write failed 0x%x, %d\n", (u32)ofs, ret);
+			goto next;
+		}
+
+		ret = mtd->read(mtd, ofs, blocksize, &retlen, verify_buf);
+		if (ret) {
+			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
+			goto next;
+		}
+
+		if (memcmp(buf, verify_buf, blocksize))
+			printk("\nRead/Write test failed at 0x%x\n", (u32)ofs);
+
+next:
+		ofs += blocksize;
+		blocks++;
+	}
+	printf("...Done\n");
+
+	free(buf);
+	free(verify_buf);
+
+	return 0;
+}
+
+static int onenand_dump(struct mtd_info *mtd, ulong off, int only_oob)
+{
+	int i;
+	u_char *datbuf, *oobbuf, *p;
+	struct mtd_oob_ops ops;
+	loff_t addr;
+
+	datbuf = malloc(mtd->writesize + mtd->oobsize);
+	oobbuf = malloc(mtd->oobsize);
+	if (!datbuf || !oobbuf) {
+		puts("No memory for page buffer\n");
+		return 1;
+	}
+	off &= ~(mtd->writesize - 1);
+	addr = (loff_t) off;
+	memset(&ops, 0, sizeof(ops));
+	ops.datbuf = datbuf;
+	ops.oobbuf = oobbuf; /* must exist, but oob data will be appended to ops.datbuf */
+	ops.len = mtd->writesize;
+	ops.ooblen = mtd->oobsize;
+	ops.retlen = 0;
+	i = mtd->read_oob(mtd, addr, &ops);
+	if (i < 0) {
+		printf("Error (%d) reading page %08lx\n", i, off);
+		free(datbuf);
+		free(oobbuf);
+		return 1;
+	}
+	printf("Page %08lx dump:\n", off);
+	i = mtd->writesize >> 4;
+	p = datbuf;
+
+	while (i--) {
+		if (!only_oob)
+			printf("\t%02x %02x %02x %02x %02x %02x %02x %02x"
+			       "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
+			       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+			       p[8], p[9], p[10], p[11], p[12], p[13], p[14],
+			       p[15]);
+		p += 16;
+	}
+	puts("OOB:\n");
+	i = mtd->oobsize >> 3;
+	while (i--) {
+		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
+		       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+		p += 8;
+	}
+	free(datbuf);
+	free(oobbuf);
+
+	return 0;
+}
 
 int do_onenand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
-	int ret = 0;
+	struct onenand_chip *this;
+	int blocksize;
+	ulong addr, ofs;
+	size_t len, retlen = 0;
+	int ret;
+	char *cmd, *s;
+
+	mtd = &onenand_mtd;
+	this = mtd->priv;
+	blocksize = (1 << this->erase_shift);
+
+	cmd = argv[1];
 
 	switch (argc) {
 	case 0:
 	case 1:
-		printf("Usage:\n%s\n", cmdtp->usage);
-		return 1;
+		goto usage;
 
 	case 2:
-		if (strncmp(argv[1], "open", 4) == 0) {
-			onenand_init();
+		if (strcmp(cmd, "info") == 0) {
+			printf("%s\n", mtd->name);
 			return 0;
 		}
-		printf("%s\n", onenand_mtd.name);
-		return 0;
 
-	default:
-		/* At least 4 args */
-		if (strncmp(argv[1], "erase", 5) == 0) {
-			struct erase_info instr = {
-				.callback	= NULL,
-			};
-			ulong start, end;
-			ulong block;
-			char *endtail;
-
-			if (strncmp(argv[2], "block", 5) == 0) {
-				start = simple_strtoul(argv[3], NULL, 10);
-				endtail = strchr(argv[3], '-');
-				end = simple_strtoul(endtail + 1, NULL, 10);
-			} else {
-				start = simple_strtoul(argv[2], NULL, 10);
-				end = simple_strtoul(argv[3], NULL, 10);
-
-				start >>= onenand_chip.erase_shift;
-				end >>= onenand_chip.erase_shift;
-				/* Don't include the end block */
-				end--;
+		if (strcmp(cmd, "bad") == 0) {
+			/* Currently only one OneNAND device is supported */
+			printf("\nDevice %d bad blocks:\n", 0);
+			for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
+				if (mtd->block_isbad(mtd, ofs))
+					printf("  %08x\n", (u32)ofs);
 			}
 
-			if (!end || end < 0)
-				end = start;
+			return 0;
+		}
 
-			printf("Erase block from %lu to %lu\n", start, end);
+	default:
+		/* At least 4 args */
 
-			for (block = start; block <= end; block++) {
-				instr.addr = block << onenand_chip.erase_shift;
-				instr.len = 1 << onenand_chip.erase_shift;
-				ret = onenand_erase(&onenand_mtd, &instr);
-				if (ret) {
-					printf("erase failed %lu\n", block);
-					break;
-				}
-			}
+		/*
+		 * Syntax is:
+		 *   0       1     2       3    4
+		 *   onenand erase [force] [off size]
+		 */
+		if ((strcmp(cmd, "erase") == 0) || (strcmp(cmd, "test") == 0)) {
+			int force = argc > 2 && !strcmp("force", argv[2]);
+			int o = force ? 3 : 2;
+			int erase;
+
+			erase = strcmp(cmd, "erase") == 0; /* 1 = erase, 0 = test */
+			printf("\nOneNAND %s: ", erase ? "erase" : "test");
+
+			/* skip first two or three arguments, look for offset and size */
+			if (arg_off_size(argc - o, argv + o, &ofs, &len) != 0)
+				return 1;
+
+			if (erase)
+				ret = onenand_block_erase(ofs, len, force);
+			else
+				ret = onenand_block_test(ofs, len);
 
-			return 0;
+			printf("%s\n", ret ? "ERROR" : "OK");
+
+			return ret == 0 ? 0 : 1;
 		}
 
-		if (strncmp(argv[1], "read", 4) == 0) {
-			ulong addr = simple_strtoul(argv[2], NULL, 16);
-			ulong ofs = simple_strtoul(argv[3], NULL, 16);
-			size_t len = simple_strtoul(argv[4], NULL, 16);
-			int oob = strncmp(argv[1], "read.oob", 8) ? 0 : 1;
-			struct mtd_oob_ops ops;
-
-			ops.mode = MTD_OOB_PLACE;
-
-			if (oob) {
-				ops.len = 0;
-				ops.datbuf = NULL;
-				ops.ooblen = len;
-				ops.oobbuf = (u_char *) addr;
+		if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
+			int read;
+			int oob = 0;
+
+			if (argc < 4)
+				goto usage;
+
+			addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+
+			read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
+			printf("\nOneNAND %s: ", read ? "read" : "write");
+			if (arg_off_size(argc - 3, argv + 3, &ofs, &len) != 0)
+				return 1;
+
+			s = strchr(cmd, '.');
+			if ((s != NULL) && (!strcmp(s, ".oob")))
+				oob = 1;
+
+			if (read) {
+				ret = onenand_block_read(ofs, len, &retlen,
+							 (u8 *)addr, oob);
 			} else {
-				ops.len = len;
-				ops.datbuf = (u_char *) addr;
-				ops.ooblen = 0;
-				ops.oobbuf = NULL;
+				ret = onenand_block_write(ofs, len, &retlen,
+							  (u8 *)addr);
 			}
-			ops.retlen = ops.oobretlen = 0;
-
-			onenand_mtd.read_oob(&onenand_mtd, ofs, &ops);
-			printf("Done\n");
-
-			return 0;
-		}
 
-		if (strncmp(argv[1], "write", 5) == 0) {
-			ulong addr = simple_strtoul(argv[2], NULL, 16);
-			ulong ofs = simple_strtoul(argv[3], NULL, 16);
-			size_t len = simple_strtoul(argv[4], NULL, 16);
-			size_t retlen = 0;
-
-			onenand_write(&onenand_mtd, ofs, len, &retlen,
-				      (u_char *) addr);
-			printf("Done\n");
+			printf(" %d bytes %s: %s\n", retlen,
+			       read ? "read" : "written", ret ? "ERROR" : "OK");
 
-			return 0;
+			return ret == 0 ? 0 : 1;
 		}
 
-		if (strncmp(argv[1], "block", 5) == 0) {
-			ulong addr = simple_strtoul(argv[2], NULL, 16);
-			ulong block = simple_strtoul(argv[3], NULL, 10);
-			ulong page = simple_strtoul(argv[4], NULL, 10);
-			size_t len = simple_strtol(argv[5], NULL, 10);
-			ulong ofs;
-			int oob = strncmp(argv[1], "block.oob", 9) ? 0 : 1;
-			struct mtd_oob_ops ops;
-
-			ops.mode = MTD_OOB_PLACE;
-
-
-			ofs = block << onenand_chip.erase_shift;
-			if (page)
-				ofs += page << onenand_chip.page_shift;
-
-			if (!len) {
-				if (oob)
-					ops.ooblen = 64;
-				else
-					ops.len = 512;
-			}
+		if (strcmp(cmd, "markbad") == 0) {
+			addr = (ulong)simple_strtoul(argv[2], NULL, 16);
 
-			if (oob) {
-				ops.datbuf = NULL;
-				ops.oobbuf = (u_char *) addr;
+			int ret = mtd->block_markbad(mtd, addr);
+			if (ret == 0) {
+				printf("block 0x%08lx successfully marked as bad\n",
+						(ulong) addr);
+				return 0;
 			} else {
-				ops.datbuf = (u_char *) addr;
-				ops.oobbuf = NULL;
+				printf("block 0x%08lx NOT marked as bad! ERROR %d\n",
+						(ulong) addr, ret);
 			}
-			ops.retlen = ops.oobretlen = 0;
+			return 1;
+		}
 
-			onenand_read_oob(&onenand_mtd, ofs, &ops);
-			return 0;
+		if (strncmp(cmd, "dump", 4) == 0) {
+			if (argc < 3)
+				goto usage;
+
+			s = strchr(cmd, '.');
+			ofs = (int)simple_strtoul(argv[2], NULL, 16);
+
+			if (s != NULL && strcmp(s, ".oob") == 0)
+				ret = onenand_dump(mtd, ofs, 1);
+			else
+				ret = onenand_dump(mtd, ofs, 0);
+
+			return ret == 0 ? 1 : 0;
 		}
 
 		break;
 	}
 
 	return 0;
+
+usage:
+	cmd_usage(cmdtp);
+	return 1;
 }
 
 U_BOOT_CMD(
 	onenand,	6,	1,	do_onenand,
-	"onenand - OneNAND sub-system\n",
-	"info   - show available OneNAND devices\n"
-	"onenand read[.oob] addr ofs len - read data at ofs with len to addr\n"
-	"onenand write addr ofs len - write data at ofs with len from addr\n"
-	"onenand erase saddr eaddr - erase block start addr to end addr\n"
-	"onenand block[.oob] addr block [page] [len] - "
-		"read data with (block [, page]) to addr"
+	"OneNAND sub-system",
+	"info - show available OneNAND devices\n"
+	"onenand bad - show bad blocks\n"
+	"onenand read[.oob] addr off size\n"
+	"onenand write[.oob] addr off size\n"
+	"    read/write 'size' bytes starting at offset 'off'\n"
+	"    to/from memory address 'addr', skipping bad blocks.\n"
+	"onenand erase [force] [off size] - erase 'size' bytes from\n"
+	"onenand test [off size] - test 'size' bytes from\n"
+	"    offset 'off' (entire device if not specified)\n"
+	"onenand dump[.oob] off - dump page\n"
+	"onenand markbad off - mark bad block at offset (UNSAFE)\n"
 );
diff -Naur u-boot-2009.01/common/cmd_otp.c u-boot/common/cmd_otp.c
--- u-boot-2009.01/common/cmd_otp.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_otp.c	2009-02-26 14:03:58.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under the GPL-2 or later.
  */
 
-/* There are 512 128-bit "pages" (0x000 to 0x1FF).
+/* There are 512 128-bit "pages" (0x000 through 0x1FF).
  * The pages are accessable as 64-bit "halfpages" (an upper and lower half).
  * The pages are not part of the memory map.  There is an OTP controller which
  * handles scanning in/out of bits.  While access is done through OTP MMRs,
@@ -17,8 +17,6 @@
 #include <common.h>
 #include <command.h>
 
-#ifdef CONFIG_CMD_OTP
-
 #include <asm/blackfin.h>
 #include <asm/mach-common/bits/otp.h>
 
@@ -40,30 +38,87 @@
 
 #define lowup(x) ((x) % 2 ? "upper" : "lower")
 
-int do_otp(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+static int check_voltage(void)
+{
+	/* Make sure voltage limits are within datasheet spec */
+	uint16_t vr_ctl = bfin_read_VR_CTL();
+
+#ifdef __ADSPBF54x__
+	/* 0.9V <= VDDINT <= 1.1V */
+	if ((vr_ctl & 0xc) && (vr_ctl & 0xc0) == 0xc0)
+		return 1;
+#else
+	/* for the parts w/out qualification yet */
+	(void)vr_ctl;
+#endif
+
+	return 0;
+}
+
+static void set_otp_timing(bool write)
 {
-	bool force = false;
-	if (!strcmp(argv[1], "--force")) {
-		force = true;
-		argv[1] = argv[0];
-		argv++;
-		--argc;
+	static uint32_t timing;
+	if (!timing) {
+		uint32_t tp1, tp2, tp3;
+		/* OTP_TP1 = 1000 / sclk_period (in nanoseconds)
+		 * OTP_TP1 = 1000 / (1 / get_sclk() * 10^9)
+		 * OTP_TP1 = (1000 * get_sclk()) / 10^9
+		 * OTP_TP1 = get_sclk() / 10^6
+		 */
+		tp1 = get_sclk() / 1000000;
+		/* OTP_TP2 = 400 / (2 * sclk_period)
+		 * OTP_TP2 = 400 / (2 * 1 / get_sclk() * 10^9)
+		 * OTP_TP2 = (400 * get_sclk()) / (2 * 10^9)
+		 * OTP_TP2 = (2 * get_sclk()) / 10^7
+		 */
+		tp2 = (2 * get_sclk() / 10000000) << 8;
+		/* OTP_TP3 = magic constant */
+		tp3 = (0x1401) << 15;
+		timing = tp1 | tp2 | tp3;
 	}
 
+	bfrom_OtpCommand(OTP_INIT, write ? timing : timing & ~(-1 << 15));
+}
+
+int do_otp(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	uint32_t ret, base_flags;
+	bool prompt_user, force_read;
 	uint32_t (*otp_func)(uint32_t page, uint32_t flags, uint64_t *page_content);
-	if (!strcmp(argv[1], "read"))
-		otp_func = otp_read;
-	else if (!strcmp(argv[1], "write"))
-		otp_func = otp_write;
-	else {
+
+	if (argc < 4) {
  usage:
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
+	prompt_user = false;
+	base_flags = 0;
+	if (!strcmp(argv[1], "read"))
+		otp_func = bfrom_OtpRead;
+	else if (!strcmp(argv[1], "dump")) {
+		otp_func = bfrom_OtpRead;
+		force_read = true;
+	} else if (!strcmp(argv[1], "write")) {
+		otp_func = bfrom_OtpWrite;
+		base_flags = OTP_CHECK_FOR_PREV_WRITE;
+		if (!strcmp(argv[2], "--force")) {
+			argv[2] = argv[1];
+			argv++;
+			--argc;
+		} else
+			prompt_user = false;
+	} else if (!strcmp(argv[1], "lock")) {
+		if (argc != 4)
+			goto usage;
+		otp_func = bfrom_OtpWrite;
+		base_flags = OTP_LOCK;
+	} else
+		goto usage;
+
 	uint64_t *addr = (uint64_t *)simple_strtoul(argv[2], NULL, 16);
 	uint32_t page = simple_strtoul(argv[3], NULL, 16);
-	uint32_t flags, ret;
+	uint32_t flags;
 	size_t i, count;
 	ulong half;
 
@@ -81,14 +136,21 @@
 	} else
 		half = 0;
 
+	/* "otp lock" has slightly different semantics */
+	if (base_flags & OTP_LOCK) {
+		count = page;
+		page = (uint32_t)addr;
+		addr = NULL;
+	}
+
 	/* do to the nature of OTP, make sure users are sure */
-	if (!force && otp_func == otp_write) {
+	if (prompt_user) {
 		printf(
 			"Writing one time programmable memory\n"
 			"Make sure your operating voltages and temperature are within spec\n"
 			"   source address:  0x%p\n"
-			"   OTP destination: %s page 0x%03X - %s page 0x%03X\n"
-			"   number to write: %ld halfpages\n"
+			"   OTP destination: %s page 0x%03X - %s page 0x%03lX\n"
+			"   number to write: %lu halfpages\n"
 			" type \"YES\" (no quotes) to confirm: ",
 			addr,
 			lowup(half), page,
@@ -111,30 +173,42 @@
 				}
 			}
 		}
-
-		/* Only supported in newer silicon ... enable writing */
-#if (0)
-		otp_command(OTP_INIT, ...);
-#else
-		*pOTP_TIMING = 0x32149485;
-#endif
 	}
 
-	printf("OTP memory %s: addr 0x%08lx  page 0x%03X  count %ld ... ",
+	printf("OTP memory %s: addr 0x%p  page 0x%03X  count %zu ... ",
 		argv[1], addr, page, count);
 
+	set_otp_timing(otp_func == bfrom_OtpWrite);
+	if (otp_func == bfrom_OtpWrite && check_voltage()) {
+		puts("ERROR: VDDINT voltage is out of spec for writing\n");
+		return -1;
+	}
+
+	/* Do the actual reading/writing stuff */
 	ret = 0;
 	for (i = half; i < count + half; ++i) {
-		flags = (i % 2) ? OTP_UPPER_HALF : OTP_LOWER_HALF;
+		flags = base_flags | (i % 2 ? OTP_UPPER_HALF : OTP_LOWER_HALF);
+ try_again:
 		ret = otp_func(page, flags, addr);
-		if (ret & 0x1)
-			break;
-		else if (ret)
+		if (ret & OTP_MASTER_ERROR) {
+			if (force_read) {
+				if (flags & OTP_NO_ECC)
+					break;
+				else
+					flags |= OTP_NO_ECC;
+				puts("E");
+				goto try_again;
+			} else
+				break;
+		} else if (ret)
 			puts("W");
 		else
 			puts(".");
-		++addr;
-		if (i % 2)
+		if (!(base_flags & OTP_LOCK)) {
+			++addr;
+			if (i % 2)
+				++page;
+		} else
 			++page;
 	}
 	if (ret & 0x1)
@@ -143,21 +217,20 @@
 	else
 		puts(" done\n");
 
-	if (otp_func == otp_write)
-		/* Only supported in newer silicon ... disable writing */
-#if (0)
-		otp_command(OTP_INIT, ...);
-#else
-		*pOTP_TIMING = 0x1485;
-#endif
+	/* Make sure we disable writing */
+	set_otp_timing(false);
+	bfrom_OtpCommand(OTP_CLOSE, 0);
 
 	return ret;
 }
 
-U_BOOT_CMD(otp, 6, 0, do_otp,
-	"otp - One-Time-Programmable sub-system\n",
+U_BOOT_CMD(otp, 7, 0, do_otp,
+	"One-Time-Programmable sub-system\n",
 	"read <addr> <page> [count] [half]\n"
+	" - read 'count' half-pages starting at 'page' (offset 'half') to 'addr'\n"
+	"otp dump <addr> <page> [count] [half]\n"
+	" - like 'otp read', but skip read errors\n"
 	"otp write [--force] <addr> <page> [count] [half]\n"
-	"    - read/write 'count' half-pages starting at page 'page' (offset 'half')\n");
-
-#endif
+	" - write 'count' half-pages starting at 'page' (offset 'half') from 'addr'\n"
+	"otp lock <page> <count>\n"
+	" - lock 'count' pages starting at 'page'\n");
diff -Naur u-boot-2009.01/common/cmd_pci.c u-boot/common/cmd_pci.c
--- u-boot-2009.01/common/cmd_pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -534,7 +534,7 @@
 
 	return 1;
  usage:
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
@@ -543,7 +543,7 @@
 
 U_BOOT_CMD(
 	pci,	5,	1,	do_pci,
-	"pci     - list and access PCI Configuration Space\n",
+	"list and access PCI Configuration Space",
 	"[bus] [long]\n"
 	"    - short or long list of PCI devices on bus 'bus'\n"
 	"pci header b.d.f\n"
diff -Naur u-boot-2009.01/common/cmd_pcmcia.c u-boot/common/cmd_pcmcia.c
--- u-boot-2009.01/common/cmd_pcmcia.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_pcmcia.c	2009-02-26 14:03:58.000000000 +0100
@@ -88,7 +88,7 @@
 
 U_BOOT_CMD(
 	pinit,	2,	0,	do_pinit,
-	"pinit   - PCMCIA sub-system\n",
+	"PCMCIA sub-system",
 	"on  - power on PCMCIA socket\n"
 			"pinit off - power off PCMCIA socket\n"
 	  );
diff -Naur u-boot-2009.01/common/cmd_portio.c u-boot/common/cmd_portio.c
--- u-boot-2009.01/common/cmd_portio.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_portio.c	2009-02-26 14:03:58.000000000 +0100
@@ -44,7 +44,7 @@
 	uint value = out_last_value;
 
 	if (argc != 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -93,7 +93,7 @@
 
 U_BOOT_CMD(
 	out,	3,	1,	do_portio_out,
-	"out     - write datum to IO port\n",
+	"write datum to IO port",
 	"[.b, .w, .l] port value\n    - output to IO port\n"
 );
 
@@ -103,7 +103,7 @@
 	uint size = in_last_size;
 
 	if (argc != 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -157,7 +157,7 @@
 
 U_BOOT_CMD(
 	in,	2,	1,	do_portio_in,
-	"in      - read data from an IO port\n",
+	"read data from an IO port",
 	"[.b, .w, .l] port\n"
 	"    - read datum from IO port\n"
 );
diff -Naur u-boot-2009.01/common/cmd_reginfo.c u-boot/common/cmd_reginfo.c
--- u-boot-2009.01/common/cmd_reginfo.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_reginfo.c	2009-02-26 14:03:58.000000000 +0100
@@ -382,6 +382,6 @@
 #if defined(CONFIG_CMD_REGINFO)
 U_BOOT_CMD(
 	reginfo,	2,	1,	do_reginfo,
-	"reginfo - print register information\n",
+	"print register information",
 );
 #endif
diff -Naur u-boot-2009.01/common/cmd_reiser.c u-boot/common/cmd_reiser.c
--- u-boot-2009.01/common/cmd_reiser.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_reiser.c	2009-02-26 14:03:58.000000000 +0100
@@ -57,7 +57,7 @@
 	int part_length;
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	dev = (int)simple_strtoul (argv[2], &ep, 16);
@@ -102,7 +102,7 @@
 
 U_BOOT_CMD(
 	reiserls,	4,	1,	do_reiserls,
-	"reiserls- list files in a directory (default /)\n",
+	"list files in a directory (default /)",
 	"<interface> <dev[:part]> [directory]\n"
 	"    - list files from 'dev' on 'interface' in a 'directory'\n"
 );
@@ -150,7 +150,7 @@
 		break;
 
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -232,7 +232,7 @@
 
 U_BOOT_CMD(
 	reiserload,	6,	0,	do_reiserload,
-	"reiserload- load binary file from a Reiser filesystem\n",
+	"load binary file from a Reiser filesystem",
 	"<interface> <dev[:part]> [addr] [filename] [bytes]\n"
 	"    - load binary file 'filename' from 'dev' on 'interface'\n"
 	"      to address 'addr' from dos filesystem\n"
diff -Naur u-boot-2009.01/common/cmd_sata.c u-boot/common/cmd_sata.c
--- u-boot-2009.01/common/cmd_sata.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_sata.c	2009-02-26 14:03:58.000000000 +0100
@@ -31,7 +31,7 @@
 int curr_device = -1;
 block_dev_desc_t sata_dev_desc[CONFIG_SYS_SATA_MAX_DEVICE];
 
-int sata_initialize(void)
+int __sata_initialize(void)
 {
 	int rc;
 	int i;
@@ -55,6 +55,7 @@
 	curr_device = 0;
 	return rc;
 }
+int sata_initialize(void) __attribute__((weak,alias("__sata_initialize")));
 
 block_dev_desc_t *sata_get_dev(int dev)
 {
@@ -65,10 +66,18 @@
 {
 	int rc = 0;
 
+	if (argc == 2 && strcmp(argv[1], "init") == 0)
+		return sata_initialize();
+
+	/* If the user has not yet run `sata init`, do it now */
+	if (curr_device == -1)
+		if (sata_initialize())
+			return 1;
+
 	switch (argc) {
 	case 0:
 	case 1:
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	case 2:
 		if (strncmp(argv[1],"inf", 3) == 0) {
@@ -106,7 +115,7 @@
 			}
 			return rc;
 		}
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	case 3:
 		if (strncmp(argv[1], "dev", 3) == 0) {
@@ -138,7 +147,7 @@
 			}
 			return rc;
 		}
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 
 	default: /* at least 4 args */
@@ -175,7 +184,7 @@
 				n, (n == cnt) ? "OK" : "ERROR");
 			return (n == cnt) ? 0 : 1;
 		} else {
-			printf("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			rc = 1;
 		}
 
@@ -185,7 +194,8 @@
 
 U_BOOT_CMD(
 	sata, 5, 1, do_sata,
-	"sata	- SATA sub system\n",
+	"SATA sub system",
+	"sata init - init SATA sub system\n"
 	"sata info - show available SATA devices\n"
 	"sata device [dev] - show or set current device\n"
 	"sata part [dev] - print partition table\n"
diff -Naur u-boot-2009.01/common/cmd_scsi.c u-boot/common/cmd_scsi.c
--- u-boot-2009.01/common/cmd_scsi.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_scsi.c	2009-02-26 14:03:58.000000000 +0100
@@ -229,7 +229,7 @@
 		boot_device = argv[2];
 		break;
 	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -346,7 +346,7 @@
 {
 	switch (argc) {
     case 0:
-    case 1:	printf ("Usage:\n%s\n", cmdtp->usage);	return 1;
+    case 1:	cmd_usage(cmdtp);	return 1;
     case 2:
 			if (strncmp(argv[1],"res",3) == 0) {
 				printf("\nReset SCSI\n");
@@ -392,7 +392,7 @@
 					printf("\nno SCSI devices available\n");
 				return 1;
 			}
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			return 1;
 	case 3:
 			if (strncmp(argv[1],"dev",3) == 0) {
@@ -421,7 +421,7 @@
 				}
 				return 1;
 			}
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			return 1;
     default:
 			/* at least 4 args */
@@ -437,7 +437,7 @@
 				return 0;
 			}
 	} /* switch */
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
@@ -616,7 +616,7 @@
 
 U_BOOT_CMD(
 	scsi, 5, 1, do_scsi,
-	"scsi    - SCSI sub-system\n",
+	"SCSI sub-system",
 	"reset - reset SCSI controller\n"
 	"scsi info  - show available SCSI devices\n"
 	"scsi scan  - (re-)scan SCSI bus\n"
@@ -628,6 +628,6 @@
 
 U_BOOT_CMD(
 	scsiboot, 3, 1, do_scsiboot,
-	"scsiboot- boot from SCSI device\n",
+	"boot from SCSI device",
 	"loadAddr dev:part\n"
 );
diff -Naur u-boot-2009.01/common/cmd_setexpr.c u-boot/common/cmd_setexpr.c
--- u-boot-2009.01/common/cmd_setexpr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_setexpr.c	2009-02-26 14:03:58.000000000 +0100
@@ -35,7 +35,7 @@
 
 	/* Validate arguments */
 	if ((argc != 5) || (strlen(argv[3]) != 1)) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -63,7 +63,7 @@
 
 U_BOOT_CMD(
 	setexpr, 5, 0, do_setexpr,
-	"setexpr - set environment variable as the result of eval expression\n",
+	"set environment variable as the result of eval expression",
 	"name value1 <op> value2\n"
 	"    - set environment variable 'name' to the result of the evaluated\n"
 	"      express specified by <op>.  <op> can be &, |, ^, +, -, *, /, %\n"
diff -Naur u-boot-2009.01/common/cmd_sf.c u-boot/common/cmd_sf.c
--- u-boot-2009.01/common/cmd_sf.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_sf.c	2009-02-26 14:03:58.000000000 +0100
@@ -175,13 +175,13 @@
 		return do_spi_flash_erase(argc - 1, argv + 1);
 
 usage:
-	printf("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
 U_BOOT_CMD(
 	sf,	5,	1,	do_spi_flash,
-	"sf	- SPI flash sub-system\n",
+	"SPI flash sub-system",
 	"probe [bus:]cs [hz] [mode]	- init flash device on given SPI bus\n"
 	"				  and chip select\n"
 	"sf read addr offset len 	- read `len' bytes starting at\n"
diff -Naur u-boot-2009.01/common/cmd_spi.c u-boot/common/cmd_spi.c
--- u-boot-2009.01/common/cmd_spi.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_spi.c	2009-02-26 14:03:58.000000000 +0100
@@ -138,7 +138,7 @@
 
 U_BOOT_CMD(
 	sspi,	5,	1,	do_spi,
-	"sspi    - SPI utility commands\n",
+	"SPI utility commands",
 	"<device> <bit_len> <dout> - Send <bit_len> bits from <dout> out the SPI\n"
 	"<device>  - Identifies the chip select of the device\n"
 	"<bit_len> - Number of bits to send (base 10)\n"
diff -Naur u-boot-2009.01/common/cmd_strings.c u-boot/common/cmd_strings.c
--- u-boot-2009.01/common/cmd_strings.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_strings.c	2009-02-26 14:03:58.000000000 +0100
@@ -15,7 +15,7 @@
 int do_strings(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc == 1) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -41,6 +41,6 @@
 }
 
 U_BOOT_CMD(strings, 3, 1, do_strings,
-	"strings - display strings\n",
+	"display strings",
 	"<addr> [byte count]\n"
 	"    - display strings at <addr> for at least [byte count] or first double NUL\n");
diff -Naur u-boot-2009.01/common/cmd_terminal.c u-boot/common/cmd_terminal.c
--- u-boot-2009.01/common/cmd_terminal.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_terminal.c	2009-02-26 14:03:58.000000000 +0100
@@ -87,6 +87,6 @@
 
 U_BOOT_CMD(
 	terminal,	3,	1,	do_terminal,
-	"terminal - start terminal emulator\n",
+	"start terminal emulator",
 	""
 );
diff -Naur u-boot-2009.01/common/cmd_ubi.c u-boot/common/cmd_ubi.c
--- u-boot-2009.01/common/cmd_ubi.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_ubi.c	2009-02-26 14:03:58.000000000 +0100
@@ -441,7 +441,7 @@
 	int err = 0;
 
 	if (argc < 2) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -459,7 +459,7 @@
 		}
 
 		if (argc < 4) {
-			printf("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			return 1;
 		}
 
@@ -600,7 +600,7 @@
 }
 
 U_BOOT_CMD(ubi, 6, 1, do_ubi,
-	"ubi      - ubi commands\n",
+	"ubi commands",
 	"part [nand|nor|onenand] [part]"
 		" - Show or set current partition\n"
 	"ubi info [l[ayout]]"
diff -Naur u-boot-2009.01/common/cmd_universe.c u-boot/common/cmd_universe.c
--- u-boot-2009.01/common/cmd_universe.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_universe.c	2009-02-26 14:03:58.000000000 +0100
@@ -364,7 +364,7 @@
 
 U_BOOT_CMD(
 	universe,	8,	1,	do_universe,
-	"universe- initialize and configure Turndra Universe\n",
+	"initialize and configure Turndra Universe",
 	"init\n"
 	"    - initialize universe\n"
 	"universe vme [vme_addr] [pci_addr] [size] [vam] [pms]\n"
diff -Naur u-boot-2009.01/common/cmd_usb.c u-boot/common/cmd_usb.c
--- u-boot-2009.01/common/cmd_usb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_usb.c	2009-02-26 14:03:58.000000000 +0100
@@ -264,6 +264,16 @@
 	printf("\n");
 }
 
+static inline char *portspeed(int speed)
+{
+	if (speed == USB_SPEED_HIGH)
+		return "480 Mb/s";
+	else if (speed == USB_SPEED_LOW)
+		return "1.5 Mb/s";
+	else
+		return "12 Mb/s";
+}
+
 /* shows the device tree recursively */
 void usb_show_tree_graph(struct usb_device *dev, char *pre)
 {
@@ -310,7 +320,7 @@
 	pre[index] = 0;
 	printf(" %s (%s, %dmA)\n", usb_get_class_desc(
 					dev->config.if_desc[0].bInterfaceClass),
-					dev->slow ? "1.5MBit/s" : "12MBit/s",
+					portspeed(dev->speed),
 					dev->config.MaxPower * 2);
 	if (strlen(dev->mf) || strlen(dev->prod) || strlen(dev->serial))
 		printf(" %s  %s %s %s\n", pre, dev->mf, dev->prod, dev->serial);
@@ -366,7 +376,7 @@
 		boot_device = argv[2];
 		break;
 	default:
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -659,14 +669,14 @@
 		return 0;
 	}
 #endif /* CONFIG_USB_STORAGE */
-	printf("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
 #ifdef CONFIG_USB_STORAGE
 U_BOOT_CMD(
 	usb,	5,	1,	do_usb,
-	"usb     - USB sub-system\n",
+	"USB sub-system",
 	"reset - reset (rescan) USB controller\n"
 	"usb stop [f]  - stop USB [f]=force stop\n"
 	"usb tree  - show USB device tree\n"
@@ -682,14 +692,14 @@
 
 U_BOOT_CMD(
 	usbboot,	3,	1,	do_usbboot,
-	"usbboot - boot from USB device\n",
+	"boot from USB device",
 	"loadAddr dev:part\n"
 );
 
 #else
 U_BOOT_CMD(
 	usb,	5,	1,	do_usb,
-	"usb     - USB sub-system\n",
+	"USB sub-system",
 	"reset - reset (rescan) USB controller\n"
 	"usb  tree  - show USB device tree\n"
 	"usb  info [dev] - show available USB devices\n"
diff -Naur u-boot-2009.01/common/cmd_vfd.c u-boot/common/cmd_vfd.c
--- u-boot-2009.01/common/cmd_vfd.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_vfd.c	2009-02-26 14:03:58.000000000 +0100
@@ -50,7 +50,7 @@
 	ulong bitmap;
 
 	if (argc != 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -67,7 +67,7 @@
 
 U_BOOT_CMD(
 	vfd,	2,	0,	do_vfd,
-	"vfd     - load a bitmap to the VFDs on TRAB\n",
+	"load a bitmap to the VFDs on TRAB",
 	"/N\n"
 	"    - load bitmap N to the VFDs (N is _decimal_ !!!)\n"
 	"vfd ADDR\n"
diff -Naur u-boot-2009.01/common/cmd_ximg.c u-boot/common/cmd_ximg.c
--- u-boot-2009.01/common/cmd_ximg.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_ximg.c	2009-02-26 14:03:58.000000000 +0100
@@ -180,7 +180,7 @@
 }
 
 U_BOOT_CMD(imxtract, 4, 1, do_imgextract,
-	   "imxtract- extract a part of a multi-image\n",
+	   "extract a part of a multi-image",
 	   "addr part [dest]\n"
 	   "    - extract <part> from legacy image at <addr> and copy to <dest>\n"
 #if defined(CONFIG_FIT)
diff -Naur u-boot-2009.01/common/cmd_yaffs2.c u-boot/common/cmd_yaffs2.c
--- u-boot-2009.01/common/cmd_yaffs2.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/cmd_yaffs2.c	2009-02-26 14:03:58.000000000 +0100
@@ -142,72 +142,72 @@
 
 U_BOOT_CMD(
     ymount, 3,  0,  do_ymount,
-    "ymount\t- mount yaffs\n",
+    "mount yaffs",
     "\n"
 );
 
 U_BOOT_CMD(
     yumount, 3,  0,  do_yumount,
-    "yumount\t- unmount yaffs\n",
+    "unmount yaffs",
     "\n"
 );
 
 U_BOOT_CMD(
     yls,    4,  0,  do_yls,
-    "yls\t- yaffs ls\n",
+    "yaffs ls",
     "[-l] name\n"
 );
 
 U_BOOT_CMD(
     yrd,    2,  0,  do_yrd,
-    "yrd\t- read file from yaffs\n",
+    "read file from yaffs",
     "filename\n"
 );
 
 U_BOOT_CMD(
     ywr,    4,  0,  do_ywr,
-    "ywr\t- write file to yaffs\n",
+    "write file to yaffs",
     "filename value num_vlues\n"
 );
 
 U_BOOT_CMD(
     yrdm,   3,  0,  do_yrdm,
-    "yrdm\t- read file to memory from yaffs\n",
+    "read file to memory from yaffs",
     "filename offset\n"
 );
 
 U_BOOT_CMD(
     ywrm,   4,  0,  do_ywrm,
-    "ywrm\t- write file from memory to yaffs\n",
+    "write file from memory to yaffs",
     "filename offset size\n"
 );
 
 U_BOOT_CMD(
     ymkdir, 2,  0,  do_ymkdir,
-    "ymkdir\t- YAFFS mkdir\n",
+    "YAFFS mkdir",
     "dirname\n"
 );
 
 U_BOOT_CMD(
     yrmdir, 2,  0,  do_yrmdir,
-    "yrmdir\t- YAFFS rmdir\n",
+    "YAFFS rmdir",
     "dirname\n"
 );
 
 U_BOOT_CMD(
     yrm,    2,  0,  do_yrm,
-    "yrm\t- YAFFS rm\n",
+    "YAFFS rm",
     "path\n"
 );
 
 U_BOOT_CMD(
     ymv,    4,  0,  do_ymv,
-    "ymv\t- YAFFS mv\n",
+    "YAFFS mv",
     "oldPath newPath\n"
 );
 
 U_BOOT_CMD(
     ydump,  2,  0,  do_ydump,
-    "ydump\t- YAFFS device struct\n",
+    "YAFFS device struct",
     "dirname\n"
 );
diff -Naur u-boot-2009.01/common/command.c u-boot/common/command.c
--- u-boot-2009.01/common/command.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/command.c	2009-02-26 14:03:58.000000000 +0100
@@ -38,7 +38,7 @@
 
 U_BOOT_CMD(
 	version,	1,		1,	do_version,
-	"version - print monitor version\n",
+	"print monitor version",
 	NULL
 );
 
@@ -71,7 +71,7 @@
 
 U_BOOT_CMD(
 	echo,	CONFIG_SYS_MAXARGS,	1,	do_echo,
-	"echo    - echo args to console\n",
+	"echo args to console",
 	"[args..]\n"
 	"    - echo args to console; \\c suppresses newline\n"
 );
@@ -203,7 +203,7 @@
 
 U_BOOT_CMD(
 	test,	CONFIG_SYS_MAXARGS,	1,	do_test,
-	"test    - minimal test like /bin/sh\n",
+	"minimal test like /bin/sh",
 	"[args..]\n"
 	"    - test functionality\n"
 );
@@ -222,7 +222,7 @@
 
 U_BOOT_CMD(
 	exit,	2,	1,	do_exit,
-	"exit    - exit script\n",
+	"exit script",
 	"    - exit functionality\n"
 );
 
@@ -277,7 +277,8 @@
 				return 1;
 			if (usage == NULL)
 				continue;
-			puts (usage);
+			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
+			       cmd_array[i]->name, usage);
 		}
 		return 0;
 	}
@@ -299,7 +300,7 @@
 			putc ('\n');
 #else	/* no long help available */
 			if (cmdtp->usage)
-				puts (cmdtp->usage);
+				printf ("%s - %s\n", cmdtp->name, cmdtp->usage);
 #endif	/* CONFIG_SYS_LONGHELP */
 		} else {
 			printf ("Unknown command '%s' - try 'help'"
@@ -315,7 +316,7 @@
 
 U_BOOT_CMD(
 	help,	CONFIG_SYS_MAXARGS,	1,	do_help,
-	"help    - print online help\n",
+	"print online help",
 	"[command ...]\n"
 	"    - show help information (for 'command')\n"
 	"'help' prints online help for the monitor commands.\n\n"
@@ -328,13 +329,13 @@
 #ifdef  CONFIG_SYS_LONGHELP
 cmd_tbl_t __u_boot_cmd_question_mark Struct_Section = {
 	"?",	CONFIG_SYS_MAXARGS,	1,	do_help,
-	"?       - alias for 'help'\n",
+	"alias for 'help'",
 	NULL
 };
 #else
 cmd_tbl_t __u_boot_cmd_question_mark Struct_Section = {
 	"?",	CONFIG_SYS_MAXARGS,	1,	do_help,
-	"?       - alias for 'help'\n"
+	"alias for 'help'"
 };
 #endif /* CONFIG_SYS_LONGHELP */
 
@@ -379,6 +380,11 @@
 	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
 }
 
+void cmd_usage(cmd_tbl_t *cmdtp)
+{
+	printf("Usage:\n%s - %s\n\n", cmdtp->name, cmdtp->usage);
+}
+
 #ifdef CONFIG_AUTO_COMPLETE
 
 int var_complete(int argc, char *argv[], char last_char, int maxv, char *cmdv[])
diff -Naur u-boot-2009.01/common/console.c u-boot/common/console.c
--- u-boot-2009.01/common/console.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/console.c	2009-02-26 14:03:58.000000000 +0100
@@ -40,15 +40,15 @@
  * environment are used
  */
 #ifdef CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
-extern int overwrite_console (void);
-#define OVERWRITE_CONSOLE overwrite_console ()
+extern int overwrite_console(void);
+#define OVERWRITE_CONSOLE overwrite_console()
 #else
 #define OVERWRITE_CONSOLE 0
 #endif /* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE */
 
 #endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */
 
-static int console_setfile (int file, device_t * dev)
+static int console_setfile(int file, device_t * dev)
 {
 	int error = 0;
 
@@ -61,7 +61,7 @@
 	case stderr:
 		/* Start new device */
 		if (dev->start) {
-			error = dev->start ();
+			error = dev->start();
 			/* If it's not started dont use it */
 			if (error < 0)
 				break;
@@ -106,7 +106,7 @@
  * only from fgetc() which assures it.
  * No attempt is made to demultiplex multiple input sources.
  */
-static int iomux_getc(void)
+static int console_getc(int file)
 {
 	unsigned char ret;
 
@@ -116,7 +116,7 @@
 	return ret;
 }
 
-static int iomux_tstc(int file)
+static int console_tstc(int file)
 {
 	int i, ret;
 	device_t *dev;
@@ -138,7 +138,7 @@
 	return 0;
 }
 
-static void iomux_putc(int file, const char c)
+static void console_putc(int file, const char c)
 {
 	int i;
 	device_t *dev;
@@ -150,7 +150,7 @@
 	}
 }
 
-static void iomux_puts(int file, const char *s)
+static void console_puts(int file, const char *s)
 {
 	int i;
 	device_t *dev;
@@ -161,28 +161,68 @@
 			dev->puts(s);
 	}
 }
+
+static inline void console_printdevs(int file)
+{
+	iomux_printdevs(file);
+}
+
+static inline void console_doenv(int file, device_t *dev)
+{
+	iomux_doenv(file, dev->name);
+}
+#else
+static inline int console_getc(int file)
+{
+	return stdio_devices[file]->getc();
+}
+
+static inline int console_tstc(int file)
+{
+	return stdio_devices[file]->tstc();
+}
+
+static inline void console_putc(int file, const char c)
+{
+	stdio_devices[file]->putc(c);
+}
+
+static inline void console_puts(int file, const char *s)
+{
+	stdio_devices[file]->puts(s);
+}
+
+static inline void console_printdevs(int file)
+{
+	printf("%s\n", stdio_devices[file]->name);
+}
+
+static inline void console_doenv(int file, device_t *dev)
+{
+	console_setfile(file, dev);
+}
 #endif /* defined(CONFIG_CONSOLE_MUX) */
 
 /** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************/
 
-void serial_printf (const char *fmt, ...)
+void serial_printf(const char *fmt, ...)
 {
 	va_list args;
 	uint i;
 	char printbuffer[CONFIG_SYS_PBSIZE];
 
-	va_start (args, fmt);
+	va_start(args, fmt);
 
 	/* For this to work, printbuffer must be larger than
 	 * anything we ever want to print.
 	 */
-	i = vsprintf (printbuffer, fmt, args);
-	va_end (args);
+	i = vsprintf(printbuffer, fmt, args);
+	va_end(args);
 
-	serial_puts (printbuffer);
+	serial_puts(printbuffer);
 }
 
-int fgetc (int file)
+int fgetc(int file)
 {
 	if (file < MAX_FILES) {
 #if defined(CONFIG_CONSOLE_MUX)
@@ -195,8 +235,8 @@
 			 * check for that first.
 			 */
 			if (tstcdev != NULL)
-				return iomux_getc();
-			iomux_tstc(file);
+				return console_getc(file);
+			console_tstc(file);
 #ifdef CONFIG_WATCHDOG
 			/*
 			 * If the watchdog must be rate-limited then it should
@@ -206,66 +246,54 @@
 #endif
 		}
 #else
-		return stdio_devices[file]->getc ();
+		return console_getc(file);
 #endif
 	}
 
 	return -1;
 }
 
-int ftstc (int file)
+int ftstc(int file)
 {
 	if (file < MAX_FILES)
-#if defined(CONFIG_CONSOLE_MUX)
-		return iomux_tstc(file);
-#else
-		return stdio_devices[file]->tstc ();
-#endif
+		return console_tstc(file);
 
 	return -1;
 }
 
-void fputc (int file, const char c)
+void fputc(int file, const char c)
 {
 	if (file < MAX_FILES)
-#if defined(CONFIG_CONSOLE_MUX)
-		iomux_putc(file, c);
-#else
-		stdio_devices[file]->putc (c);
-#endif
+		console_putc(file, c);
 }
 
-void fputs (int file, const char *s)
+void fputs(int file, const char *s)
 {
 	if (file < MAX_FILES)
-#if defined(CONFIG_CONSOLE_MUX)
-		iomux_puts(file, s);
-#else
-		stdio_devices[file]->puts (s);
-#endif
+		console_puts(file, s);
 }
 
-void fprintf (int file, const char *fmt, ...)
+void fprintf(int file, const char *fmt, ...)
 {
 	va_list args;
 	uint i;
 	char printbuffer[CONFIG_SYS_PBSIZE];
 
-	va_start (args, fmt);
+	va_start(args, fmt);
 
 	/* For this to work, printbuffer must be larger than
 	 * anything we ever want to print.
 	 */
-	i = vsprintf (printbuffer, fmt, args);
-	va_end (args);
+	i = vsprintf(printbuffer, fmt, args);
+	va_end(args);
 
 	/* Send to desired file */
-	fputs (file, printbuffer);
+	fputs(file, printbuffer);
 }
 
 /** U-Boot INITIAL CONSOLE-COMPATIBLE FUNCTION *****************************/
 
-int getc (void)
+int getc(void)
 {
 #ifdef CONFIG_DISABLE_CONSOLE
 	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
@@ -274,14 +302,14 @@
 
 	if (gd->flags & GD_FLG_DEVINIT) {
 		/* Get from the standard input */
-		return fgetc (stdin);
+		return fgetc(stdin);
 	}
 
 	/* Send directly to the handler */
-	return serial_getc ();
+	return serial_getc();
 }
 
-int tstc (void)
+int tstc(void)
 {
 #ifdef CONFIG_DISABLE_CONSOLE
 	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
@@ -290,14 +318,14 @@
 
 	if (gd->flags & GD_FLG_DEVINIT) {
 		/* Test the standard input */
-		return ftstc (stdin);
+		return ftstc(stdin);
 	}
 
 	/* Send directly to the handler */
-	return serial_tstc ();
+	return serial_tstc();
 }
 
-void putc (const char c)
+void putc(const char c)
 {
 #ifdef CONFIG_SILENT_CONSOLE
 	if (gd->flags & GD_FLG_SILENT)
@@ -311,14 +339,14 @@
 
 	if (gd->flags & GD_FLG_DEVINIT) {
 		/* Send to the standard output */
-		fputc (stdout, c);
+		fputc(stdout, c);
 	} else {
 		/* Send directly to the handler */
-		serial_putc (c);
+		serial_putc(c);
 	}
 }
 
-void puts (const char *s)
+void puts(const char *s)
 {
 #ifdef CONFIG_SILENT_CONSOLE
 	if (gd->flags & GD_FLG_SILENT)
@@ -332,32 +360,32 @@
 
 	if (gd->flags & GD_FLG_DEVINIT) {
 		/* Send to the standard output */
-		fputs (stdout, s);
+		fputs(stdout, s);
 	} else {
 		/* Send directly to the handler */
-		serial_puts (s);
+		serial_puts(s);
 	}
 }
 
-void printf (const char *fmt, ...)
+void printf(const char *fmt, ...)
 {
 	va_list args;
 	uint i;
 	char printbuffer[CONFIG_SYS_PBSIZE];
 
-	va_start (args, fmt);
+	va_start(args, fmt);
 
 	/* For this to work, printbuffer must be larger than
 	 * anything we ever want to print.
 	 */
-	i = vsprintf (printbuffer, fmt, args);
-	va_end (args);
+	i = vsprintf(printbuffer, fmt, args);
+	va_end(args);
 
 	/* Print the string */
-	puts (printbuffer);
+	puts(printbuffer);
 }
 
-void vprintf (const char *fmt, va_list args)
+void vprintf(const char *fmt, va_list args)
 {
 	uint i;
 	char printbuffer[CONFIG_SYS_PBSIZE];
@@ -365,20 +393,20 @@
 	/* For this to work, printbuffer must be larger than
 	 * anything we ever want to print.
 	 */
-	i = vsprintf (printbuffer, fmt, args);
+	i = vsprintf(printbuffer, fmt, args);
 
 	/* Print the string */
-	puts (printbuffer);
+	puts(printbuffer);
 }
 
 /* test if ctrl-c was pressed */
 static int ctrlc_disabled = 0;	/* see disable_ctrl() */
 static int ctrlc_was_pressed = 0;
-int ctrlc (void)
+int ctrlc(void)
 {
 	if (!ctrlc_disabled && gd->have_console) {
-		if (tstc ()) {
-			switch (getc ()) {
+		if (tstc()) {
+			switch (getc()) {
 			case 0x03:		/* ^C - Control C */
 				ctrlc_was_pressed = 1;
 				return 1;
@@ -393,7 +421,7 @@
 /* pass 1 to disable ctrlc() checking, 0 to enable.
  * returns previous state
  */
-int disable_ctrlc (int disable)
+int disable_ctrlc(int disable)
 {
 	int prev = ctrlc_disabled;	/* save previous state */
 
@@ -406,7 +434,7 @@
 	return ctrlc_was_pressed;
 }
 
-void clear_ctrlc (void)
+void clear_ctrlc(void)
 {
 	ctrlc_was_pressed = 0;
 }
@@ -434,7 +462,8 @@
 	i = vsprintf(printbuffer, fmt, args);
 	va_end(args);
 
-	if ((screen + sizeof(screen) - 1 - cursor) < strlen(printbuffer)+1) {
+	if ((screen + sizeof(screen) - 1 - cursor)
+	    < strlen(printbuffer) + 1) {
 		memset(screen, 0, sizeof(screen));
 		cursor = screen;
 	}
@@ -450,19 +479,19 @@
 
 /** U-Boot INIT FUNCTIONS *************************************************/
 
-device_t *search_device (int flags, char *name)
+device_t *search_device(int flags, char *name)
 {
 	device_t *dev;
 
 	dev = device_get_by_name(name);
 
-	if(dev && (dev->flags & flags))
+	if (dev && (dev->flags & flags))
 		return dev;
 
 	return NULL;
 }
 
-int console_assign (int file, char *devname)
+int console_assign(int file, char *devname)
 {
 	int flag;
 	device_t *dev;
@@ -484,14 +513,14 @@
 
 	dev = search_device(flag, devname);
 
-	if(dev)
-		return console_setfile (file, dev);
+	if (dev)
+		return console_setfile(file, dev);
 
 	return -1;
 }
 
 /* Called before relocation - use serial functions */
-int console_init_f (void)
+int console_init_f(void)
 {
 	gd->have_console = 1;
 
@@ -500,12 +529,12 @@
 		gd->flags |= GD_FLG_SILENT;
 #endif
 
-	return (0);
+	return 0;
 }
 
 #ifdef CONFIG_SYS_CONSOLE_IS_IN_ENV
 /* Called after the relocation - use desired console functions */
-int console_init_r (void)
+int console_init_r(void)
 {
 	char *stdinname, *stdoutname, *stderrname;
 	device_t *inputdev = NULL, *outputdev = NULL, *errdev = NULL;
@@ -525,14 +554,14 @@
 
 	/* stdin stdout and stderr are in environment */
 	/* scan for it */
-	stdinname  = getenv ("stdin");
-	stdoutname = getenv ("stdout");
-	stderrname = getenv ("stderr");
+	stdinname  = getenv("stdin");
+	stdoutname = getenv("stdout");
+	stderrname = getenv("stderr");
 
 	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
-		inputdev  = search_device (DEV_FLAGS_INPUT,  stdinname);
-		outputdev = search_device (DEV_FLAGS_OUTPUT, stdoutname);
-		errdev    = search_device (DEV_FLAGS_OUTPUT, stderrname);
+		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
+		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
+		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
 #ifdef CONFIG_CONSOLE_MUX
 		iomux_err = iomux_doenv(stdin, stdinname);
 		iomux_err += iomux_doenv(stdout, stdoutname);
@@ -544,38 +573,26 @@
 	}
 	/* if the devices are overwritten or not found, use default device */
 	if (inputdev == NULL) {
-		inputdev  = search_device (DEV_FLAGS_INPUT,  "serial");
+		inputdev  = search_device(DEV_FLAGS_INPUT,  "serial");
 	}
 	if (outputdev == NULL) {
-		outputdev = search_device (DEV_FLAGS_OUTPUT, "serial");
+		outputdev = search_device(DEV_FLAGS_OUTPUT, "serial");
 	}
 	if (errdev == NULL) {
-		errdev    = search_device (DEV_FLAGS_OUTPUT, "serial");
+		errdev    = search_device(DEV_FLAGS_OUTPUT, "serial");
 	}
 	/* Initializes output console first */
 	if (outputdev != NULL) {
-#ifdef CONFIG_CONSOLE_MUX
 		/* need to set a console if not done above. */
-		iomux_doenv(stdout, outputdev->name);
-#else
-		console_setfile (stdout, outputdev);
-#endif
+		console_doenv(stdout, outputdev);
 	}
 	if (errdev != NULL) {
-#ifdef CONFIG_CONSOLE_MUX
 		/* need to set a console if not done above. */
-		iomux_doenv(stderr, errdev->name);
-#else
-		console_setfile (stderr, errdev);
-#endif
+		console_doenv(stderr, errdev);
 	}
 	if (inputdev != NULL) {
-#ifdef CONFIG_CONSOLE_MUX
 		/* need to set a console if not done above. */
-		iomux_doenv(stdin, inputdev->name);
-#else
-		console_setfile (stdin, inputdev);
-#endif
+		console_doenv(stdin, inputdev);
 	}
 
 #ifdef CONFIG_CONSOLE_MUX
@@ -586,59 +603,47 @@
 
 #ifndef CONFIG_SYS_CONSOLE_INFO_QUIET
 	/* Print information */
-	puts ("In:    ");
+	puts("In:    ");
 	if (stdio_devices[stdin] == NULL) {
-		puts ("No input devices available!\n");
+		puts("No input devices available!\n");
 	} else {
-#ifdef CONFIG_CONSOLE_MUX
-		iomux_printdevs(stdin);
-#else
-		printf ("%s\n", stdio_devices[stdin]->name);
-#endif
+		console_printdevs(stdin);
 	}
 
-	puts ("Out:   ");
+	puts("Out:   ");
 	if (stdio_devices[stdout] == NULL) {
-		puts ("No output devices available!\n");
+		puts("No output devices available!\n");
 	} else {
-#ifdef CONFIG_CONSOLE_MUX
-		iomux_printdevs(stdout);
-#else
-		printf ("%s\n", stdio_devices[stdout]->name);
-#endif
+		console_printdevs(stdout);
 	}
 
-	puts ("Err:   ");
+	puts("Err:   ");
 	if (stdio_devices[stderr] == NULL) {
-		puts ("No error devices available!\n");
+		puts("No error devices available!\n");
 	} else {
-#ifdef CONFIG_CONSOLE_MUX
-		iomux_printdevs(stderr);
-#else
-		printf ("%s\n", stdio_devices[stderr]->name);
-#endif
+		console_printdevs(stderr);
 	}
 #endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */
 
 #ifdef CONFIG_SYS_CONSOLE_ENV_OVERWRITE
 	/* set the environment variables (will overwrite previous env settings) */
 	for (i = 0; i < 3; i++) {
-		setenv (stdio_names[i], stdio_devices[i]->name);
+		setenv(stdio_names[i], stdio_devices[i]->name);
 	}
 #endif /* CONFIG_SYS_CONSOLE_ENV_OVERWRITE */
 
 #if 0
 	/* If nothing usable installed, use only the initial console */
 	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
-		return (0);
+		return 0;
 #endif
-	return (0);
+	return 0;
 }
 
 #else /* CONFIG_SYS_CONSOLE_IS_IN_ENV */
 
 /* Called after the relocation - use desired console functions */
-int console_init_r (void)
+int console_init_r(void)
 {
 	device_t *inputdev = NULL, *outputdev = NULL;
 	int i;
@@ -647,8 +652,10 @@
 	device_t *dev;
 
 #ifdef CONFIG_SPLASH_SCREEN
-	/* suppress all output if splash screen is enabled and we have
-	   a bmp to display                                            */
+	/*
+	 * suppress all output if splash screen is enabled and we have
+	 * a bmp to display
+	 */
 	if (getenv("splashimage") != NULL)
 		gd->flags |= GD_FLG_SILENT;
 #endif
@@ -669,8 +676,8 @@
 
 	/* Initializes output console first */
 	if (outputdev != NULL) {
-		console_setfile (stdout, outputdev);
-		console_setfile (stderr, outputdev);
+		console_setfile(stdout, outputdev);
+		console_setfile(stderr, outputdev);
 #ifdef CONFIG_CONSOLE_MUX
 		console_devices[stdout][0] = outputdev;
 		console_devices[stderr][0] = outputdev;
@@ -679,7 +686,7 @@
 
 	/* Initializes input console */
 	if (inputdev != NULL) {
-		console_setfile (stdin, inputdev);
+		console_setfile(stdin, inputdev);
 #ifdef CONFIG_CONSOLE_MUX
 		console_devices[stdin][0] = inputdev;
 #endif
@@ -689,40 +696,40 @@
 
 #ifndef CONFIG_SYS_CONSOLE_INFO_QUIET
 	/* Print information */
-	puts ("In:    ");
+	puts("In:    ");
 	if (stdio_devices[stdin] == NULL) {
-		puts ("No input devices available!\n");
+		puts("No input devices available!\n");
 	} else {
-		printf ("%s\n", stdio_devices[stdin]->name);
+		printf("%s\n", stdio_devices[stdin]->name);
 	}
 
-	puts ("Out:   ");
+	puts("Out:   ");
 	if (stdio_devices[stdout] == NULL) {
-		puts ("No output devices available!\n");
+		puts("No output devices available!\n");
 	} else {
-		printf ("%s\n", stdio_devices[stdout]->name);
+		printf("%s\n", stdio_devices[stdout]->name);
 	}
 
-	puts ("Err:   ");
+	puts("Err:   ");
 	if (stdio_devices[stderr] == NULL) {
-		puts ("No error devices available!\n");
+		puts("No error devices available!\n");
 	} else {
-		printf ("%s\n", stdio_devices[stderr]->name);
+		printf("%s\n", stdio_devices[stderr]->name);
 	}
 #endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */
 
 	/* Setting environment variables */
 	for (i = 0; i < 3; i++) {
-		setenv (stdio_names[i], stdio_devices[i]->name);
+		setenv(stdio_names[i], stdio_devices[i]->name);
 	}
 
 #if 0
 	/* If nothing usable installed, use only the initial console */
 	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
-		return (0);
+		return 0;
 #endif
 
-	return (0);
+	return 0;
 }
 
 #endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */
diff -Naur u-boot-2009.01/common/devices.c u-boot/common/devices.c
--- u-boot-2009.01/common/devices.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/devices.c	2009-02-26 14:03:58.000000000 +0100
@@ -215,6 +215,9 @@
 	/* Initialize the list */
 	INIT_LIST_HEAD(&(devs.list));
 
+#ifdef CONFIG_ARM_DCC_MULTI
+	drv_arm_dcc_init ();
+#endif
 #if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
 	i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
 #endif
@@ -240,6 +243,9 @@
 #ifdef CONFIG_NETCONSOLE
 	drv_nc_init ();
 #endif
+#ifdef CONFIG_JTAG_CONSOLE
+	drv_jtag_console_init ();
+#endif
 
 	return (0);
 }
diff -Naur u-boot-2009.01/common/env_flash.c u-boot/common/env_flash.c
--- u-boot-2009.01/common/env_flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/env_flash.c	2009-03-09 10:48:07.000000000 +0100
@@ -24,7 +24,7 @@
  * MA 02111-1307 USA
  */
 
-/* #define DEBUG */
+#define DEBUG
 
 #include <common.h>
 #include <command.h>
@@ -34,10 +34,10 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#if defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_FLASH)
+#if defined(CONFIG_CMD_SAVEENV) && defined(CONFIG_CMD_FLASH)
 #define CMD_SAVEENV
 #elif defined(CONFIG_ENV_ADDR_REDUND)
-#error Cannot use CONFIG_ENV_ADDR_REDUND without CONFIG_CMD_ENV & CONFIG_CMD_FLASH
+#error Cannot use CONFIG_ENV_ADDR_REDUND without CONFIG_CMD_SAVEENV & CONFIG_CMD_FLASH
 #endif
 
 #if defined(CONFIG_ENV_SIZE_REDUND) && (CONFIG_ENV_SIZE_REDUND < CONFIG_ENV_SIZE)
@@ -331,8 +331,14 @@
 
 #endif /* CONFIG_ENV_ADDR_REDUND */
 
+#include <asm/io.h>
+#include <asm/cacheflush.h>
 void env_relocate_spec (void)
 {
+	int i;
+	char c;
+	uint16_t w, *srcp, *dstp;
+	unsigned long flags;
 #if !defined(ENV_IS_EMBEDDED) || defined(CONFIG_ENV_ADDR_REDUND)
 #ifdef CONFIG_ENV_ADDR_REDUND
 	if (gd->env_addr != (ulong)&(flash_addr->data)) {
@@ -376,7 +382,45 @@
 		      "reading environment; recovered successfully\n\n");
 #endif /* CONFIG_ENV_ADDR_REDUND */
 #ifdef CMD_SAVEENV
-	memcpy (env_ptr, (void*)flash_addr, CONFIG_ENV_SIZE);
+	memcpy (env_ptr, uncached((void*)flash_addr), CONFIG_ENV_SIZE/2);
+	
+	//writew(0xf0f0, CONFIG_SYS_FLASH_BASE);
+#if 0
+	for(i=0; (i<CONFIG_ENV_SIZE) && ((i<6) || (((char *)(flash_addr))[i-1] != '\0') || (((char *)(flash_addr))[i-2] != '\0')); i++) {
+		c = *(char *)(uncached((char *)(flash_addr) + i));
+		((char *)(env_ptr))[i] = c;
+#if 1
+		if(i % 0x100 == 0) printf("\n0x%p: ", flash_addr + i);
+		if(c == '\0')
+			putc('\n');
+		else
+			putc(c);
+#endif
+	}
+	printf("Copying environment from %p to %p (%i bytes)\n", (void *) flash_addr, env_ptr, CONFIG_ENV_SIZE);
+#else
+#if 0
+	srcp = (uint16_t *)flash_addr;
+	dstp = (uint16_t *)env_ptr;
+	flags = disable_interrupts();
+
+	dcache_flush_unlocked();
+
+	for(i=0; (i<(CONFIG_ENV_SIZE/2)) && ((i < 2) || (srcp[i] != 0)); i++) {
+		if((i%0x1000) == 0) printf("\n%p: ", &(srcp[i]));
+		w = readw(&(srcp[i]));
+		dstp[i] = w;
+		c = (w>>8);
+		if(c == '\0') putc('\n'); else putc(c);
+		c = w & 0x00FF;
+		if(c == '\0') putc('\n'); else putc(c);
+	}
+
+	if(flags)
+		enable_interrupts();
+
+#endif
+#endif
 #endif
 #endif /* ! ENV_IS_EMBEDDED || CONFIG_ENV_ADDR_REDUND */
 }
diff -Naur u-boot-2009.01/common/env_nand.c u-boot/common/env_nand.c
--- u-boot-2009.01/common/env_nand.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/env_nand.c	2009-02-26 14:03:58.000000000 +0100
@@ -39,10 +39,10 @@
 #include <malloc.h>
 #include <nand.h>
 
-#if defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_NAND)
+#if defined(CONFIG_CMD_SAVEENV) && defined(CONFIG_CMD_NAND)
 #define CMD_SAVEENV
 #elif defined(CONFIG_ENV_OFFSET_REDUND)
-#error Cannot use CONFIG_ENV_OFFSET_REDUND without CONFIG_CMD_ENV & CONFIG_CMD_NAND
+#error Cannot use CONFIG_ENV_OFFSET_REDUND without CONFIG_CMD_SAVEENV & CONFIG_CMD_NAND
 #endif
 
 #if defined(CONFIG_ENV_SIZE_REDUND) && (CONFIG_ENV_SIZE_REDUND != CONFIG_ENV_SIZE)
@@ -304,9 +304,11 @@
 	crc1_ok = (crc32(0, tmp_env1->data, ENV_SIZE) == tmp_env1->crc);
 	crc2_ok = (crc32(0, tmp_env2->data, ENV_SIZE) == tmp_env2->crc);
 
-	if(!crc1_ok && !crc2_ok)
+	if(!crc1_ok && !crc2_ok) {
+		free(tmp_env1);
+		free(tmp_env2);
 		return use_default();
-	else if(crc1_ok && !crc2_ok)
+	} else if(crc1_ok && !crc2_ok)
 		gd->env_valid = 1;
 	else if(!crc1_ok && crc2_ok)
 		gd->env_valid = 2;
diff -Naur u-boot-2009.01/common/fdt_support.c u-boot/common/fdt_support.c
--- u-boot-2009.01/common/fdt_support.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/fdt_support.c	2009-02-26 14:03:58.000000000 +0100
@@ -646,8 +646,8 @@
 	for (r = 0; r < hose->region_count; r++) {
 		u64 bus_start, phys_start, size;
 
-		/* skip if !PCI_REGION_MEMORY */
-		if (!(hose->regions[r].flags & PCI_REGION_MEMORY))
+		/* skip if !PCI_REGION_SYS_MEMORY */
+		if (!(hose->regions[r].flags & PCI_REGION_SYS_MEMORY))
 			continue;
 
 		bus_start = (u64)hose->regions[r].bus_start;
diff -Naur u-boot-2009.01/common/hush.c u-boot/common/hush.c
--- u-boot-2009.01/common/hush.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/hush.c	2009-02-26 14:03:58.000000000 +0100
@@ -96,7 +96,6 @@
 /*cmd_boot.c*/
 extern int do_bootd (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);      /* do_bootd */
 #endif
-#ifdef CONFIG_SYS_HUSH_PARSER
 #ifndef __U_BOOT__
 #include <ctype.h>     /* isalpha, isdigit */
 #include <unistd.h>    /* getpid */
@@ -1696,7 +1695,7 @@
 #endif
 				/* found - check max args */
 				if ((child->argc - i) > cmdtp->maxargs) {
-					printf ("Usage:\n%s\n", cmdtp->usage);
+					cmd_usage(cmdtp);
 					return -1;
 				}
 #endif
@@ -3625,12 +3624,11 @@
 
 U_BOOT_CMD(
 	showvar, CONFIG_SYS_MAXARGS, 1,	do_showvar,
-	"showvar- print local hushshell variables\n",
+	"print local hushshell variables",
 	"\n    - print values of all hushshell variables\n"
 	"showvar name ...\n"
 	"    - print value of hushshell variable 'name'\n"
 );
 
 #endif
-#endif /* CONFIG_SYS_HUSH_PARSER */
 /****************************************************************************/
diff -Naur u-boot-2009.01/common/kgdb.c u-boot/common/kgdb.c
--- u-boot-2009.01/common/kgdb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/kgdb.c	2009-02-26 14:03:58.000000000 +0100
@@ -92,8 +92,6 @@
 #include <kgdb.h>
 #include <command.h>
 
-#if defined(CONFIG_CMD_KGDB)
-
 #undef KGDB_DEBUG
 
 /*
@@ -575,7 +573,7 @@
 
 U_BOOT_CMD(
 	kgdb, CONFIG_SYS_MAXARGS, 1,	do_kgdb,
-	"kgdb    - enter gdb remote debug mode\n",
+	"enter gdb remote debug mode",
 	"[arg0 arg1 .. argN]\n"
 	"    - executes a breakpoint so that kgdb mode is\n"
 	"      entered via the exception handler. To return\n"
@@ -587,8 +585,3 @@
 	"      program if it is executed (see the \"hello_world\"\n"
 	"      example program in the U-Boot examples directory)."
 );
-#else
-
-int kgdb_not_configured = 1;
-
-#endif
diff -Naur u-boot-2009.01/common/lcd.c u-boot/common/lcd.c
--- u-boot-2009.01/common/lcd.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/lcd.c	2009-02-26 14:03:58.000000000 +0100
@@ -187,7 +187,7 @@
 			return;
 
 	case '\t':	/* Tab (8 chars alignment) */
-			console_col |=  8;
+			console_col +=  8;
 			console_col &= ~7;
 
 			if (console_col >= CONSOLE_COLS) {
@@ -426,7 +426,7 @@
 
 U_BOOT_CMD(
 	cls,	1,	1,	lcd_clear,
-	"cls     - clear screen\n",
+	"clear screen",
 	NULL
 );
 
diff -Naur u-boot-2009.01/common/main.c u-boot/common/main.c
--- u-boot-2009.01/common/main.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/main.c	2009-02-26 14:03:58.000000000 +0100
@@ -158,7 +158,19 @@
 	/* In order to keep up with incoming data, check timeout only
 	 * when catch up.
 	 */
-	while (!abort && get_ticks() <= etime) {
+	do {
+		if (tstc()) {
+			if (presskey_len < presskey_max) {
+				presskey [presskey_len ++] = getc();
+			}
+			else {
+				for (i = 0; i < presskey_max - 1; i ++)
+					presskey [i] = presskey [i + 1];
+
+				presskey [i] = getc();
+			}
+		}
+
 		for (i = 0; i < sizeof(delaykey) / sizeof(delaykey[0]); i ++) {
 			if (delaykey[i].len > 0 &&
 			    presskey_len >= delaykey[i].len &&
@@ -178,19 +190,8 @@
 				abort = 1;
 			}
 		}
+	} while (!abort && get_ticks() <= etime);
 
-		if (tstc()) {
-			if (presskey_len < presskey_max) {
-				presskey [presskey_len ++] = getc();
-			}
-			else {
-				for (i = 0; i < presskey_max - 1; i ++)
-					presskey [i] = presskey [i + 1];
-
-				presskey [i] = getc();
-			}
-		}
-	}
 #  if DEBUG_BOOTKEYS
 	if (!abort)
 		puts("key timeout\n");
@@ -1370,7 +1371,7 @@
 
 		/* found - check max args */
 		if (argc > cmdtp->maxargs) {
-			printf ("Usage:\n%s\n", cmdtp->usage);
+			cmd_usage(cmdtp);
 			rc = -1;
 			continue;
 		}
@@ -1414,7 +1415,7 @@
 	int i;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
diff -Naur u-boot-2009.01/common/Makefile u-boot/common/Makefile
--- u-boot-2009.01/common/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/Makefile	2009-02-27 11:20:52.000000000 +0100
@@ -35,11 +35,11 @@
 COBJS-y += devices.o
 COBJS-y += dlmalloc.o
 COBJS-y += exports.o
-COBJS-y += hush.o
+COBJS-$(CONFIG_SYS_HUSH_PARSER) += hush.o
 COBJS-y += image.o
 COBJS-y += memsize.o
 COBJS-y += s_record.o
-COBJS-y += serial.o
+COBJS-$(CONFIG_SERIAL_MULTI) += serial.o
 COBJS-y += xyzModem.o
 
 # core command
@@ -144,7 +144,7 @@
 COBJS-$(CONFIG_CMD_DOC) += docecc.o
 COBJS-$(CONFIG_CONSOLE_MUX) += iomux.o
 COBJS-y += flash.o
-COBJS-y += kgdb.o
+COBJS-$(CONFIG_CMD_KGDB) += kgdb.o
 COBJS-$(CONFIG_LCD) += lcd.o
 COBJS-$(CONFIG_LYNXKDI) += lynxkdi.o
 COBJS-$(CONFIG_UPDATE_TFTP) += update.o
diff -Naur u-boot-2009.01/common/serial.c u-boot/common/serial.c
--- u-boot-2009.01/common/serial.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/serial.c	2009-02-26 14:03:58.000000000 +0100
@@ -27,8 +27,6 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#if defined(CONFIG_SERIAL_MULTI)
-
 static struct serial_device *serial_devices = NULL;
 static struct serial_device *serial_current = NULL;
 
@@ -255,5 +253,3 @@
 
 	serial_current->puts (s);
 }
-
-#endif /* CONFIG_SERIAL_MULTI */
diff -Naur u-boot-2009.01/common/usb.c u-boot/common/usb.c
--- u-boot-2009.01/common/usb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/usb.c	2009-02-26 14:03:58.000000000 +0100
@@ -681,7 +681,7 @@
 		err = usb_string_sub(dev, 0, 0, tbuf);
 		if (err < 0) {
 			USB_PRINTF("error getting string descriptor 0 " \
-				   "(error=%x)\n", dev->status);
+				   "(error=%lx)\n", dev->status);
 			return -1;
 		} else if (tbuf[0] < 4) {
 			USB_PRINTF("string descriptor 0 too short\n");
@@ -939,8 +939,10 @@
 	dev_index = 0;
 	/* device 0 is always present (root hub, so let it analyze) */
 	dev = usb_alloc_new_device();
-	usb_new_device(dev);
-	printf("%d USB Device(s) found\n", dev_index);
+	if (usb_new_device(dev))
+		printf("No USB Device found\n");
+	else
+		printf("%d USB Device(s) found\n", dev_index);
 	/* insert "driver" if possible */
 #ifdef CONFIG_USB_KEYBOARD
 	drv_usb_kbd_init();
@@ -1041,6 +1043,16 @@
 
 #define MAX_TRIES 5
 
+static inline char *portspeed(int portstatus)
+{
+	if (portstatus & (1 << USB_PORT_FEAT_HIGHSPEED))
+		return "480 Mb/s";
+	else if (portstatus & (1 << USB_PORT_FEAT_LOWSPEED))
+		return "1.5 Mb/s";
+	else
+		return "12 Mb/s";
+}
+
 static int hub_port_reset(struct usb_device *dev, int port,
 			unsigned short *portstat)
 {
@@ -1061,10 +1073,11 @@
 		}
 		portstatus = le16_to_cpu(portsts.wPortStatus);
 		portchange = le16_to_cpu(portsts.wPortChange);
+
 		USB_HUB_PRINTF("portstatus %x, change %x, %s\n",
 				portstatus, portchange,
-				portstatus&(1<<USB_PORT_FEAT_LOWSPEED) ? \
-						"Low Speed" : "High Speed");
+				portspeed(portstatus));
+
 		USB_HUB_PRINTF("STAT_C_CONNECTION = %d STAT_CONNECTION = %d" \
 			       "  USB_PORT_STAT_ENABLE %d\n",
 			(portchange & USB_PORT_STAT_C_CONNECTION) ? 1 : 0,
@@ -1109,9 +1122,7 @@
 	portstatus = le16_to_cpu(portsts.wPortStatus);
 	portchange = le16_to_cpu(portsts.wPortChange);
 	USB_HUB_PRINTF("portstatus %x, change %x, %s\n",
-			portstatus, portchange,
-			portstatus&(1 << USB_PORT_FEAT_LOWSPEED) ? \
-						"Low Speed" : "High Speed");
+			portstatus, portchange, portspeed(portstatus));
 
 	/* Clear the connection change status */
 	usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_C_CONNECTION);
@@ -1136,7 +1147,13 @@
 
 	/* Allocate a new device struct for it */
 	usb = usb_alloc_new_device();
-	usb->slow = (portstatus & USB_PORT_STAT_LOW_SPEED) ? 1 : 0;
+
+	if (portstatus & USB_PORT_STAT_HIGH_SPEED)
+		usb->speed = USB_SPEED_HIGH;
+	else if (portstatus & USB_PORT_STAT_LOW_SPEED)
+		usb->speed = USB_SPEED_LOW;
+	else
+		usb->speed = USB_SPEED_FULL;
 
 	dev->children[port] = usb;
 	usb->parent = dev;
diff -Naur u-boot-2009.01/common/usb_kbd.c u-boot/common/usb_kbd.c
--- u-boot-2009.01/common/usb_kbd.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/usb_kbd.c	2009-02-26 14:03:58.000000000 +0100
@@ -183,6 +183,7 @@
 				usb_kbd_dev.puts = NULL;
 				usb_kbd_dev.getc = usb_kbd_getc;
 				usb_kbd_dev.tstc = usb_kbd_testc;
+				usb_kbd_dev.priv = (void *)dev;
 				error = device_register (&usb_kbd_dev);
 				if(error==0) {
 					/* check if this is the standard input device */
diff -Naur u-boot-2009.01/common/usb_storage.c u-boot/common/usb_storage.c
--- u-boot-2009.01/common/usb_storage.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/common/usb_storage.c	2009-02-26 14:03:58.000000000 +0100
@@ -45,8 +45,6 @@
  * New Note:
  * Support for USB Mass Storage Devices (BBB) has been added. It has
  * only been tested with USB memory sticks.
- * Nota bene: if you are using the BBB support with a little-endian
- * CPU then you MUST define LITTLEENDIAN in the configuration file!
  */
 
 
@@ -63,9 +61,9 @@
 #undef BBB_XPORT_TRACE
 
 #ifdef	USB_STOR_DEBUG
-#define USB_STOR_PRINTF(fmt,args...)	printf (fmt ,##args)
+#define USB_STOR_PRINTF(fmt, args...)	printf(fmt , ##args)
 #else
-#define USB_STOR_PRINTF(fmt,args...)
+#define USB_STOR_PRINTF(fmt, args...)
 #endif
 
 #include <scsi.h>
@@ -110,7 +108,7 @@
 	__u8		CBWCDB[CBWCDBLENGTH];
 } umass_bbb_cbw_t;
 #define UMASS_BBB_CBW_SIZE	31
-static __u32 CBWTag = 0;
+static __u32 CBWTag;
 
 /* Command Status Wrapper */
 typedef struct {
@@ -126,34 +124,35 @@
 #define UMASS_BBB_CSW_SIZE	13
 
 #define USB_MAX_STOR_DEV 5
-static int usb_max_devs = 0; /* number of highest available usb device */
+static int usb_max_devs; /* number of highest available usb device */
 
 static block_dev_desc_t usb_dev_desc[USB_MAX_STOR_DEV];
 
 struct us_data;
-typedef int (*trans_cmnd)(ccb*, struct us_data*);
-typedef int (*trans_reset)(struct us_data*);
+typedef int (*trans_cmnd)(ccb *cb, struct us_data *data);
+typedef int (*trans_reset)(struct us_data *data);
 
 struct us_data {
-	struct usb_device	*pusb_dev;	 /* this usb_device */
-	unsigned int		flags;		 /* from filter initially */
-	unsigned char		ifnum;		 /* interface number */
-	unsigned char		ep_in;		 /* in endpoint */
-	unsigned char		ep_out;		 /* out ....... */
-	unsigned char		ep_int;		 /* interrupt . */
-	unsigned char		subclass;	 /* as in overview */
-	unsigned char		protocol;	 /* .............. */
-	unsigned char		attention_done;	 /* force attn on first cmd */
-	unsigned short	ip_data;	 /* interrupt data */
-	int							action;		 /* what to do */
-	int							ip_wanted; /* needed */
-	int							*irq_handle;	 /* for USB int requests */
-	unsigned int		irqpipe;	 /* pipe for release_irq */
-	unsigned char		irqmaxp;	/* max packed for irq Pipe */
-	unsigned char	irqinterval; /* Intervall for IRQ Pipe */
-	ccb							*srb;		 /* current srb */
-	trans_reset			transport_reset; /* reset routine */
-	trans_cmnd			transport; /* transport routine */
+	struct usb_device *pusb_dev;	 /* this usb_device */
+
+	unsigned int	flags;			/* from filter initially */
+	unsigned char	ifnum;			/* interface number */
+	unsigned char	ep_in;			/* in endpoint */
+	unsigned char	ep_out;			/* out ....... */
+	unsigned char	ep_int;			/* interrupt . */
+	unsigned char	subclass;		/* as in overview */
+	unsigned char	protocol;		/* .............. */
+	unsigned char	attention_done;		/* force attn on first cmd */
+	unsigned short	ip_data;		/* interrupt data */
+	int		action;			/* what to do */
+	int		ip_wanted;		/* needed */
+	int		*irq_handle;		/* for USB int requests */
+	unsigned int	irqpipe;	 	/* pipe for release_irq */
+	unsigned char	irqmaxp;		/* max packed for irq Pipe */
+	unsigned char	irqinterval;		/* Intervall for IRQ Pipe */
+	ccb		*srb;			/* current srb */
+	trans_reset	transport_reset;	/* reset routine */
+	trans_cmnd	transport;		/* transport routine */
 };
 
 static struct us_data usb_stor[USB_MAX_STOR_DEV];
@@ -163,10 +162,12 @@
 #define USB_STOR_TRANSPORT_FAILED -1
 #define USB_STOR_TRANSPORT_ERROR  -2
 
-
-int usb_stor_get_info(struct usb_device *dev, struct us_data *us, block_dev_desc_t *dev_desc);
-int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,struct us_data *ss);
-unsigned long usb_stor_read(int device, unsigned long blknr, unsigned long blkcnt, void *buffer);
+int usb_stor_get_info(struct usb_device *dev, struct us_data *us,
+		      block_dev_desc_t *dev_desc);
+int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
+		      struct us_data *ss);
+unsigned long usb_stor_read(int device, unsigned long blknr,
+			    unsigned long blkcnt, void *buffer);
 struct usb_device * usb_get_dev_index(int index);
 void uhci_show_temp_int_td(void);
 
@@ -181,7 +182,7 @@
 	printf(".");
 }
 
-/*********************************************************************************
+/*******************************************************************************
  * show info on storage devices; 'usb start/init' must be invoked earlier
  * as we only retrieve structures populated during devices initialization
  */
@@ -191,7 +192,7 @@
 
 	if (usb_max_devs > 0) {
 		for (i = 0; i < usb_max_devs; i++) {
-			printf ("  Device %d: ", i);
+			printf("  Device %d: ", i);
 			dev_print(&usb_dev_desc[i]);
 		}
 		return 0;
@@ -201,7 +202,7 @@
 	return 1;
 }
 
-/*********************************************************************************
+/*******************************************************************************
  * scan the usb and reports device info
  * to the user if mode = 1
  * returns current device or -1 if no
@@ -214,67 +215,69 @@
 	/* GJ */
 	memset(usb_stor_buf, 0, sizeof(usb_stor_buf));
 
-	if(mode==1) {
+	if (mode == 1)
 		printf("       scanning bus for storage devices... ");
-	}
+
 	usb_disable_asynch(1); /* asynch transfer not allowed */
 
-	for(i=0;i<USB_MAX_STOR_DEV;i++) {
-		memset(&usb_dev_desc[i],0,sizeof(block_dev_desc_t));
-		usb_dev_desc[i].target=0xff;
-		usb_dev_desc[i].if_type=IF_TYPE_USB;
-		usb_dev_desc[i].dev=i;
-		usb_dev_desc[i].part_type=PART_TYPE_UNKNOWN;
-		usb_dev_desc[i].block_read=usb_stor_read;
+	for (i = 0; i < USB_MAX_STOR_DEV; i++) {
+		memset(&usb_dev_desc[i], 0, sizeof(block_dev_desc_t));
+		usb_dev_desc[i].target = 0xff;
+		usb_dev_desc[i].if_type = IF_TYPE_USB;
+		usb_dev_desc[i].dev = i;
+		usb_dev_desc[i].part_type = PART_TYPE_UNKNOWN;
+		usb_dev_desc[i].block_read = usb_stor_read;
 	}
 
-	usb_max_devs=0;
-	for(i=0;i<USB_MAX_DEVICE;i++) {
-		dev=usb_get_dev_index(i); /* get device */
-		USB_STOR_PRINTF("i=%d\n",i);
-		if(dev==NULL) {
+	usb_max_devs = 0;
+	for (i = 0; i < USB_MAX_DEVICE; i++) {
+		dev = usb_get_dev_index(i); /* get device */
+		USB_STOR_PRINTF("i=%d\n", i);
+		if (dev == NULL)
 			break; /* no more devices avaiable */
-		}
-		if(usb_storage_probe(dev,0,&usb_stor[usb_max_devs])) { /* ok, it is a storage devices */
-			/* get info and fill it in */
-			if(usb_stor_get_info(dev, &usb_stor[usb_max_devs], &usb_dev_desc[usb_max_devs]))
+
+		if (usb_storage_probe(dev, 0, &usb_stor[usb_max_devs])) {
+			/* ok, it is a storage devices
+			 * get info and fill it in
+			 */
+			if (usb_stor_get_info(dev, &usb_stor[usb_max_devs],
+						&usb_dev_desc[usb_max_devs]))
 				usb_max_devs++;
-		} /* if storage device */
-		if(usb_max_devs==USB_MAX_STOR_DEV) {
-			printf("max USB Storage Device reached: %d stopping\n",usb_max_devs);
+		}
+		/* if storage device */
+		if (usb_max_devs == USB_MAX_STOR_DEV) {
+			printf("max USB Storage Device reached: %d stopping\n",
+				usb_max_devs);
 			break;
 		}
 	} /* for */
 
 	usb_disable_asynch(0); /* asynch transfer allowed */
 	printf("%d Storage Device(s) found\n", usb_max_devs);
-	if(usb_max_devs>0)
+	if (usb_max_devs > 0)
 		return 0;
-	else
-		return-1;
+	return -1;
 }
 
 static int usb_stor_irq(struct usb_device *dev)
 {
 	struct us_data *us;
-	us=(struct us_data *)dev->privptr;
+	us = (struct us_data *)dev->privptr;
 
-	if(us->ip_wanted) {
-		us->ip_wanted=0;
-	}
+	if (us->ip_wanted)
+		us->ip_wanted = 0;
 	return 0;
 }
 
 
 #ifdef	USB_STOR_DEBUG
 
-static void usb_show_srb(ccb * pccb)
+static void usb_show_srb(ccb *pccb)
 {
 	int i;
-	printf("SRB: len %d datalen 0x%lX\n ",pccb->cmdlen,pccb->datalen);
-	for(i=0;i<12;i++) {
-		printf("%02X ",pccb->cmd[i]);
-	}
+	printf("SRB: len %d datalen 0x%lX\n ", pccb->cmdlen, pccb->datalen);
+	for (i = 0; i < 12; i++)
+		printf("%02X ", pccb->cmd[i]);
 	printf("\n");
 }
 
@@ -322,11 +325,14 @@
 			USB_STOR_PRINTF("Bulk xfer 0x%x(%d) try #%d\n",
 				  (unsigned int)buf, this_xfer, 11 - maxtry);
 			result = usb_bulk_msg(us->pusb_dev, pipe, buf,
-					      this_xfer, &partial, USB_CNTL_TIMEOUT*5);
+					      this_xfer, &partial,
+					      USB_CNTL_TIMEOUT * 5);
 			USB_STOR_PRINTF("bulk_msg returned %d xferred %d/%d\n",
 				  result, partial, this_xfer);
-			if(us->pusb_dev->status!=0) {
-				/* if we stall, we need to clear it before we go on */
+			if (us->pusb_dev->status != 0) {
+				/* if we stall, we need to clear it before
+				 * we go on
+				 */
 #ifdef USB_STOR_DEBUG
 				display_int_status(us->pusb_dev->status);
 #endif
@@ -334,9 +340,9 @@
 					USB_STOR_PRINTF("stalled ->clearing endpoint halt for pipe 0x%x\n", pipe);
 					stat = us->pusb_dev->status;
 					usb_clear_halt(us->pusb_dev, pipe);
-					us->pusb_dev->status=stat;
-					if(this_xfer == partial) {
-						USB_STOR_PRINTF("bulk transferred with error %X, but data ok\n",us->pusb_dev->status);
+					us->pusb_dev->status = stat;
+					if (this_xfer == partial) {
+						USB_STOR_PRINTF("bulk transferred with error %X, but data ok\n", us->pusb_dev->status);
 						return 0;
 					}
 					else
@@ -346,12 +352,15 @@
 					USB_STOR_PRINTF("Device NAKed bulk_msg\n");
 					return result;
 				}
-				if(this_xfer == partial) {
-					USB_STOR_PRINTF("bulk transferred with error %d, but data ok\n",us->pusb_dev->status);
+				USB_STOR_PRINTF("bulk transferred with error");
+				if (this_xfer == partial) {
+					USB_STOR_PRINTF(" %d, but data ok\n",
+							us->pusb_dev->status);
 					return 0;
 				}
 				/* if our try counter reaches 0, bail out */
-				USB_STOR_PRINTF("bulk transferred with error %d, data %d\n",us->pusb_dev->status,partial);
+					USB_STOR_PRINTF(" %d, data %d\n",
+						us->pusb_dev->status, partial);
 				if (!maxtry--)
 						return result;
 			}
@@ -359,7 +368,7 @@
 			this_xfer -= partial;
 			buf += partial;
 			/* continue until this transfer is done */
-		} while ( this_xfer );
+		} while (this_xfer);
 	}
 
 	/* if we get here, we're done and successful */
@@ -386,29 +395,33 @@
 	 * This comment stolen from FreeBSD's /sys/dev/usb/umass.c.
 	 */
 	USB_STOR_PRINTF("BBB_reset\n");
-	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev,0),
-				 US_BBB_RESET, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
-				 0, us->ifnum, 0, 0, USB_CNTL_TIMEOUT*5);
+	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev, 0),
+				 US_BBB_RESET,
+				 USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+				 0, us->ifnum, 0, 0, USB_CNTL_TIMEOUT * 5);
 
-	if((result < 0) && (us->pusb_dev->status & USB_ST_STALLED))
-	{
+	if ((result < 0) && (us->pusb_dev->status & USB_ST_STALLED)) {
 		USB_STOR_PRINTF("RESET:stall\n");
 		return -1;
 	}
 
 	/* long wait for reset */
 	wait_ms(150);
-	USB_STOR_PRINTF("BBB_reset result %d: status %X reset\n",result,us->pusb_dev->status);
+	USB_STOR_PRINTF("BBB_reset result %d: status %X reset\n", result,
+			us->pusb_dev->status);
 	pipe = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
 	result = usb_clear_halt(us->pusb_dev, pipe);
 	/* long wait for reset */
 	wait_ms(150);
-	USB_STOR_PRINTF("BBB_reset result %d: status %X clearing IN endpoint\n",result,us->pusb_dev->status);
+	USB_STOR_PRINTF("BBB_reset result %d: status %X clearing IN endpoint\n",
+			result, us->pusb_dev->status);
 	/* long wait for reset */
 	pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
 	result = usb_clear_halt(us->pusb_dev, pipe);
 	wait_ms(150);
-	USB_STOR_PRINTF("BBB_reset result %d: status %X clearing OUT endpoint\n",result,us->pusb_dev->status);
+	USB_STOR_PRINTF("BBB_reset result %d: status %X"
+			" clearing OUT endpoint\n", result,
+			us->pusb_dev->status);
 	USB_STOR_PRINTF("BBB_reset done\n");
 	return 0;
 }
@@ -423,16 +436,20 @@
 	int result;
 
 	USB_STOR_PRINTF("CB_reset\n");
-	memset(cmd, 0xFF, sizeof(cmd));
+	memset(cmd, 0xff, sizeof(cmd));
 	cmd[0] = SCSI_SEND_DIAG;
 	cmd[1] = 4;
-	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev,0),
-				 US_CBI_ADSC, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
-				 0, us->ifnum, cmd, sizeof(cmd), USB_CNTL_TIMEOUT*5);
+	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev, 0),
+				 US_CBI_ADSC,
+				 USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+				 0, us->ifnum, cmd, sizeof(cmd),
+				 USB_CNTL_TIMEOUT * 5);
 
 	/* long wait for reset */
 	wait_ms(1500);
-	USB_STOR_PRINTF("CB_reset result %d: status %X clearing endpoint halt\n",result,us->pusb_dev->status);
+	USB_STOR_PRINTF("CB_reset result %d: status %X"
+			" clearing endpoint halt\n", result,
+			us->pusb_dev->status);
 	usb_clear_halt(us->pusb_dev, usb_rcvbulkpipe(us->pusb_dev, us->ep_in));
 	usb_clear_halt(us->pusb_dev, usb_rcvbulkpipe(us->pusb_dev, us->ep_out));
 
@@ -455,9 +472,11 @@
 	dir_in = US_DIRECTION(srb->cmd[0]);
 
 #ifdef BBB_COMDAT_TRACE
-	printf("dir %d lun %d cmdlen %d cmd %p datalen %d pdata %p\n", dir_in, srb->lun, srb->cmdlen, srb->cmd, srb->datalen, srb->pdata);
+	printf("dir %d lun %d cmdlen %d cmd %p datalen %d pdata %p\n",
+		dir_in, srb->lun, srb->cmdlen, srb->cmd, srb->datalen,
+		srb->pdata);
 	if (srb->cmdlen) {
-		for(result = 0;result < srb->cmdlen;result++)
+		for (result = 0; result < srb->cmdlen; result++)
 			printf("cmd[%d] %#x ", result, srb->cmd[result]);
 		printf("\n");
 	}
@@ -474,13 +493,14 @@
 	cbw.dCBWSignature = cpu_to_le32(CBWSIGNATURE);
 	cbw.dCBWTag = cpu_to_le32(CBWTag++);
 	cbw.dCBWDataTransferLength = cpu_to_le32(srb->datalen);
-	cbw.bCBWFlags = (dir_in? CBWFLAGS_IN : CBWFLAGS_OUT);
+	cbw.bCBWFlags = (dir_in ? CBWFLAGS_IN : CBWFLAGS_OUT);
 	cbw.bCBWLUN = srb->lun;
 	cbw.bCDBLength = srb->cmdlen;
 	/* copy the command data into the CBW command data buffer */
 	/* DST SRC LEN!!! */
 	memcpy(cbw.CBWCDB, srb->cmd, srb->cmdlen);
-	result = usb_bulk_msg(us->pusb_dev, pipe, &cbw, UMASS_BBB_CBW_SIZE, &actlen, USB_CNTL_TIMEOUT*5);
+	result = usb_bulk_msg(us->pusb_dev, pipe, &cbw, UMASS_BBB_CBW_SIZE,
+			      &actlen, USB_CNTL_TIMEOUT * 5);
 	if (result < 0)
 		USB_STOR_PRINTF("usb_stor_BBB_comdat:usb_bulk_msg error\n");
 	return result;
@@ -492,46 +512,61 @@
 int usb_stor_CB_comdat(ccb *srb, struct us_data *us)
 {
 	int result = 0;
-	int dir_in,retry;
+	int dir_in, retry;
 	unsigned int pipe;
 	unsigned long status;
 
-	retry=5;
-		dir_in=US_DIRECTION(srb->cmd[0]);
+	retry = 5;
+	dir_in = US_DIRECTION(srb->cmd[0]);
 
-		if(dir_in)
-			pipe=usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
-		else
-			pipe=usb_sndbulkpipe(us->pusb_dev, us->ep_out);
-	while(retry--) {
-		USB_STOR_PRINTF("CBI gets a command: Try %d\n",5-retry);
+	if (dir_in)
+		pipe = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
+	else
+		pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
+
+	while (retry--) {
+		USB_STOR_PRINTF("CBI gets a command: Try %d\n", 5 - retry);
 #ifdef USB_STOR_DEBUG
 		usb_show_srb(srb);
 #endif
 		/* let's send the command via the control pipe */
-		result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev,0),
-					 US_CBI_ADSC, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+		result = usb_control_msg(us->pusb_dev,
+					 usb_sndctrlpipe(us->pusb_dev , 0),
+					 US_CBI_ADSC,
+					 USB_TYPE_CLASS | USB_RECIP_INTERFACE,
 					 0, us->ifnum,
-					 srb->cmd, srb->cmdlen, USB_CNTL_TIMEOUT*5);
-		USB_STOR_PRINTF("CB_transport: control msg returned %d, status %X\n",result,us->pusb_dev->status);
+					 srb->cmd, srb->cmdlen,
+					 USB_CNTL_TIMEOUT * 5);
+		USB_STOR_PRINTF("CB_transport: control msg returned %d,"
+				" status %X\n", result, us->pusb_dev->status);
 		/* check the return code for the command */
 		if (result < 0) {
-			if(us->pusb_dev->status & USB_ST_STALLED) {
-				status=us->pusb_dev->status;
-				USB_STOR_PRINTF(" stall during command found, clear pipe\n");
-				usb_clear_halt(us->pusb_dev,  usb_sndctrlpipe(us->pusb_dev,0));
-				us->pusb_dev->status=status;
+			if (us->pusb_dev->status & USB_ST_STALLED) {
+				status = us->pusb_dev->status;
+				USB_STOR_PRINTF(" stall during command found,"
+						" clear pipe\n");
+				usb_clear_halt(us->pusb_dev,
+					      usb_sndctrlpipe(us->pusb_dev, 0));
+				us->pusb_dev->status = status;
 			}
-			USB_STOR_PRINTF(" error during command %02X Stat = %X\n",srb->cmd[0],us->pusb_dev->status);
+			USB_STOR_PRINTF(" error during command %02X"
+					" Stat = %X\n", srb->cmd[0],
+					us->pusb_dev->status);
 			return result;
 		}
 		/* transfer the data payload for this command, if one exists*/
 
-		USB_STOR_PRINTF("CB_transport: control msg returned %d, direction is %s to go 0x%lx\n",result,dir_in ? "IN" : "OUT",srb->datalen);
+		USB_STOR_PRINTF("CB_transport: control msg returned %d,"
+				" direction is %s to go 0x%lx\n", result,
+				dir_in ? "IN" : "OUT", srb->datalen);
 		if (srb->datalen) {
-			result = us_one_transfer(us, pipe, (char *)srb->pdata,srb->datalen);
-			USB_STOR_PRINTF("CBI attempted to transfer data, result is %d status %lX, len %d\n", result,us->pusb_dev->status,us->pusb_dev->act_len);
-			if(!(us->pusb_dev->status & USB_ST_NAK_REC))
+			result = us_one_transfer(us, pipe, (char *)srb->pdata,
+						 srb->datalen);
+			USB_STOR_PRINTF("CBI attempted to transfer data,"
+					" result is %d status %lX, len %d\n",
+					result, us->pusb_dev->status,
+					us->pusb_dev->act_len);
+			if (!(us->pusb_dev->status & USB_ST_NAK_REC))
 				break;
 		} /* if (srb->datalen) */
 		else
@@ -543,21 +578,21 @@
 }
 
 
-int usb_stor_CBI_get_status (ccb * srb, struct us_data *us)
+int usb_stor_CBI_get_status(ccb *srb, struct us_data *us)
 {
 	int timeout;
 
 	us->ip_wanted = 1;
-	submit_int_msg (us->pusb_dev, us->irqpipe,
+	submit_int_msg(us->pusb_dev, us->irqpipe,
 			(void *) &us->ip_data, us->irqmaxp, us->irqinterval);
 	timeout = 1000;
 	while (timeout--) {
 		if ((volatile int *) us->ip_wanted == 0)
 			break;
-		wait_ms (10);
+		wait_ms(10);
 	}
 	if (us->ip_wanted) {
-		printf ("	Did not get interrupt on CBI\n");
+		printf("	Did not get interrupt on CBI\n");
 		us->ip_wanted = 0;
 		return USB_STOR_TRANSPORT_ERROR;
 	}
@@ -596,9 +631,9 @@
 	int result;
 
 	/* ENDPOINT_HALT = 0, so set value to 0 */
-	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev,0),
+	result = usb_control_msg(us->pusb_dev, usb_sndctrlpipe(us->pusb_dev, 0),
 				USB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,
-				0, endpt, 0, 0, USB_CNTL_TIMEOUT*5);
+				0, endpt, 0, 0, USB_CNTL_TIMEOUT * 5);
 	return result;
 }
 
@@ -638,12 +673,14 @@
 		pipe = pipein;
 	else
 		pipe = pipeout;
-	result = usb_bulk_msg(us->pusb_dev, pipe, srb->pdata, srb->datalen, &data_actlen, USB_CNTL_TIMEOUT*5);
+	result = usb_bulk_msg(us->pusb_dev, pipe, srb->pdata, srb->datalen,
+			      &data_actlen, USB_CNTL_TIMEOUT * 5);
 	/* special handling of STALL in DATA phase */
-	if((result < 0) && (us->pusb_dev->status & USB_ST_STALLED)) {
+	if ((result < 0) && (us->pusb_dev->status & USB_ST_STALLED)) {
 		USB_STOR_PRINTF("DATA:stall\n");
 		/* clear the STALL on the endpoint */
-		result = usb_stor_BBB_clear_endpt_stall(us, dir_in? us->ep_in : us->ep_out);
+		result = usb_stor_BBB_clear_endpt_stall(us,
+					dir_in ? us->ep_in : us->ep_out);
 		if (result >= 0)
 			/* continue on to STATUS phase */
 			goto st;
@@ -660,15 +697,16 @@
 	printf("\n");
 #endif
 	/* STATUS phase + error handling */
-   st:
+st:
 	retry = 0;
-   again:
+again:
 	USB_STOR_PRINTF("STATUS phase\n");
 	result = usb_bulk_msg(us->pusb_dev, pipein, &csw, UMASS_BBB_CSW_SIZE,
 				&actlen, USB_CNTL_TIMEOUT*5);
 
 	/* special handling of STALL in STATUS phase */
-	if((result < 0) && (retry < 1) && (us->pusb_dev->status & USB_ST_STALLED)) {
+	if ((result < 0) && (retry < 1) &&
+	    (us->pusb_dev->status & USB_ST_STALLED)) {
 		USB_STOR_PRINTF("STATUS:stall\n");
 		/* clear the STALL on the endpoint */
 		result = usb_stor_BBB_clear_endpt_stall(us, us->ep_in);
@@ -722,32 +760,33 @@
 
 int usb_stor_CB_transport(ccb *srb, struct us_data *us)
 {
-	int result,status;
+	int result, status;
 	ccb *psrb;
 	ccb reqsrb;
-	int retry,notready;
+	int retry, notready;
 
 	psrb = &reqsrb;
-	status=USB_STOR_TRANSPORT_GOOD;
-	retry=0;
-	notready=0;
+	status = USB_STOR_TRANSPORT_GOOD;
+	retry = 0;
+	notready = 0;
 	/* issue the command */
 do_retry:
-	result=usb_stor_CB_comdat(srb,us);
-	USB_STOR_PRINTF("command / Data returned %d, status %X\n",result,us->pusb_dev->status);
+	result = usb_stor_CB_comdat(srb, us);
+	USB_STOR_PRINTF("command / Data returned %d, status %X\n",
+			result, us->pusb_dev->status);
 	/* if this is an CBI Protocol, get IRQ */
-	if(us->protocol==US_PR_CBI) {
-		status=usb_stor_CBI_get_status(srb,us);
+	if (us->protocol == US_PR_CBI) {
+		status = usb_stor_CBI_get_status(srb, us);
 		/* if the status is error, report it */
-		if(status==USB_STOR_TRANSPORT_ERROR) {
+		if (status == USB_STOR_TRANSPORT_ERROR) {
 			USB_STOR_PRINTF(" USB CBI Command Error\n");
 			return status;
 		}
-		srb->sense_buf[12]=(unsigned char)(us->ip_data>>8);
-		srb->sense_buf[13]=(unsigned char)(us->ip_data&0xff);
-		if(!us->ip_data) {
-		/* if the status is good, report it */
-			if(status==USB_STOR_TRANSPORT_GOOD) {
+		srb->sense_buf[12] = (unsigned char)(us->ip_data >> 8);
+		srb->sense_buf[13] = (unsigned char)(us->ip_data & 0xff);
+		if (!us->ip_data) {
+			/* if the status is good, report it */
+			if (status == USB_STOR_TRANSPORT_GOOD) {
 				USB_STOR_PRINTF(" USB CBI Command Good\n");
 				return status;
 			}
@@ -755,51 +794,62 @@
 	}
 	/* do we have to issue an auto request? */
 	/* HERE we have to check the result */
-	if((result<0) && !(us->pusb_dev->status & USB_ST_STALLED)) {
-		USB_STOR_PRINTF("ERROR %X\n",us->pusb_dev->status);
+	if ((result < 0) && !(us->pusb_dev->status & USB_ST_STALLED)) {
+		USB_STOR_PRINTF("ERROR %X\n", us->pusb_dev->status);
 		us->transport_reset(us);
 		return USB_STOR_TRANSPORT_ERROR;
 	}
-	if((us->protocol==US_PR_CBI) &&
-			((srb->cmd[0]==SCSI_REQ_SENSE) ||
-			(srb->cmd[0]==SCSI_INQUIRY))) { /* do not issue an autorequest after request sense */
+	if ((us->protocol == US_PR_CBI) &&
+	    ((srb->cmd[0] == SCSI_REQ_SENSE) ||
+	    (srb->cmd[0] == SCSI_INQUIRY))) {
+		/* do not issue an autorequest after request sense */
 		USB_STOR_PRINTF("No auto request and good\n");
 		return USB_STOR_TRANSPORT_GOOD;
 	}
 	/* issue an request_sense */
-	memset(&psrb->cmd[0],0,12);
-	psrb->cmd[0]=SCSI_REQ_SENSE;
-	psrb->cmd[1]=srb->lun<<5;
-	psrb->cmd[4]=18;
-	psrb->datalen=18;
+	memset(&psrb->cmd[0], 0, 12);
+	psrb->cmd[0] = SCSI_REQ_SENSE;
+	psrb->cmd[1] = srb->lun << 5;
+	psrb->cmd[4] = 18;
+	psrb->datalen = 18;
 	psrb->pdata = &srb->sense_buf[0];
-	psrb->cmdlen=12;
+	psrb->cmdlen = 12;
 	/* issue the command */
-	result=usb_stor_CB_comdat(psrb,us);
-	USB_STOR_PRINTF("auto request returned %d\n",result);
+	result = usb_stor_CB_comdat(psrb, us);
+	USB_STOR_PRINTF("auto request returned %d\n", result);
 	/* if this is an CBI Protocol, get IRQ */
-	if(us->protocol==US_PR_CBI) {
-		status=usb_stor_CBI_get_status(psrb,us);
-	}
-	if((result<0)&&!(us->pusb_dev->status & USB_ST_STALLED)) {
-		USB_STOR_PRINTF(" AUTO REQUEST ERROR %d\n",us->pusb_dev->status);
+	if (us->protocol == US_PR_CBI)
+		status = usb_stor_CBI_get_status(psrb, us);
+
+	if ((result < 0) && !(us->pusb_dev->status & USB_ST_STALLED)) {
+		USB_STOR_PRINTF(" AUTO REQUEST ERROR %d\n",
+				us->pusb_dev->status);
 		return USB_STOR_TRANSPORT_ERROR;
 	}
-	USB_STOR_PRINTF("autorequest returned 0x%02X 0x%02X 0x%02X 0x%02X\n",srb->sense_buf[0],srb->sense_buf[2],srb->sense_buf[12],srb->sense_buf[13]);
+	USB_STOR_PRINTF("autorequest returned 0x%02X 0x%02X 0x%02X 0x%02X\n",
+			srb->sense_buf[0], srb->sense_buf[2],
+			srb->sense_buf[12], srb->sense_buf[13]);
 	/* Check the auto request result */
-	if((srb->sense_buf[2]==0) &&
-		 (srb->sense_buf[12]==0) &&
-		 (srb->sense_buf[13]==0)) /* ok, no sense */
+	if ((srb->sense_buf[2] == 0) &&
+	    (srb->sense_buf[12] == 0) &&
+	    (srb->sense_buf[13] == 0)) {
+		/* ok, no sense */
 		return USB_STOR_TRANSPORT_GOOD;
+	}
+
 	/* Check the auto request result */
-	switch(srb->sense_buf[2]) {
-	case 0x01: /* Recovered Error */
+	switch (srb->sense_buf[2]) {
+	case 0x01:
+		/* Recovered Error */
 		return USB_STOR_TRANSPORT_GOOD;
 		break;
-	case 0x02: /* Not Ready */
-		if(notready++ > USB_TRANSPORT_NOT_READY_RETRY) {
-			printf("cmd 0x%02X returned 0x%02X 0x%02X 0x%02X 0x%02X (NOT READY)\n",
-				srb->cmd[0],srb->sense_buf[0],srb->sense_buf[2],srb->sense_buf[12],srb->sense_buf[13]);
+	case 0x02:
+		/* Not Ready */
+		if (notready++ > USB_TRANSPORT_NOT_READY_RETRY) {
+			printf("cmd 0x%02X returned 0x%02X 0x%02X 0x%02X"
+			       " 0x%02X (NOT READY)\n", srb->cmd[0],
+				srb->sense_buf[0], srb->sense_buf[2],
+				srb->sense_buf[12], srb->sense_buf[13]);
 			return USB_STOR_TRANSPORT_FAILED;
 		} else {
 			wait_ms(100);
@@ -807,113 +857,111 @@
 		}
 		break;
 	default:
-		if(retry++ > USB_TRANSPORT_UNKNOWN_RETRY) {
-			printf("cmd 0x%02X returned 0x%02X 0x%02X 0x%02X 0x%02X\n",
-				srb->cmd[0],srb->sense_buf[0],srb->sense_buf[2],srb->sense_buf[12],srb->sense_buf[13]);
+		if (retry++ > USB_TRANSPORT_UNKNOWN_RETRY) {
+			printf("cmd 0x%02X returned 0x%02X 0x%02X 0x%02X"
+			       " 0x%02X\n", srb->cmd[0], srb->sense_buf[0],
+				srb->sense_buf[2], srb->sense_buf[12],
+				srb->sense_buf[13]);
 			return USB_STOR_TRANSPORT_FAILED;
-		} else {
+		} else
 			goto do_retry;
-		}
 		break;
 	}
 	return USB_STOR_TRANSPORT_FAILED;
 }
 
 
-static int usb_inquiry(ccb *srb,struct us_data *ss)
+static int usb_inquiry(ccb *srb, struct us_data *ss)
 {
-	int retry,i;
-	retry=5;
+	int retry, i;
+	retry = 5;
 	do {
-		memset(&srb->cmd[0],0,12);
-		srb->cmd[0]=SCSI_INQUIRY;
-		srb->cmd[1]=srb->lun<<5;
-		srb->cmd[4]=36;
-		srb->datalen=36;
-		srb->cmdlen=12;
-		i=ss->transport(srb,ss);
-		USB_STOR_PRINTF("inquiry returns %d\n",i);
-		if(i==0)
+		memset(&srb->cmd[0], 0, 12);
+		srb->cmd[0] = SCSI_INQUIRY;
+		srb->cmd[4] = 36;
+		srb->datalen = 36;
+		srb->cmdlen = 12;
+		i = ss->transport(srb, ss);
+		USB_STOR_PRINTF("inquiry returns %d\n", i);
+		if (i == 0)
 			break;
-	} while(retry--);
+	} while (retry--);
 
-	if(!retry) {
+	if (!retry) {
 		printf("error in inquiry\n");
 		return -1;
 	}
 	return 0;
 }
 
-static int usb_request_sense(ccb *srb,struct us_data *ss)
+static int usb_request_sense(ccb *srb, struct us_data *ss)
 {
 	char *ptr;
 
-	ptr=(char *)srb->pdata;
-	memset(&srb->cmd[0],0,12);
-	srb->cmd[0]=SCSI_REQ_SENSE;
-	srb->cmd[1]=srb->lun<<5;
-	srb->cmd[4]=18;
-	srb->datalen=18;
+	ptr = (char *)srb->pdata;
+	memset(&srb->cmd[0], 0, 12);
+	srb->cmd[0] = SCSI_REQ_SENSE;
+	srb->cmd[4] = 18;
+	srb->datalen = 18;
 	srb->pdata = &srb->sense_buf[0];
-	srb->cmdlen=12;
-	ss->transport(srb,ss);
-	USB_STOR_PRINTF("Request Sense returned %02X %02X %02X\n",srb->sense_buf[2],srb->sense_buf[12],srb->sense_buf[13]);
-	srb->pdata=(uchar *)ptr;
+	srb->cmdlen = 12;
+	ss->transport(srb, ss);
+	USB_STOR_PRINTF("Request Sense returned %02X %02X %02X\n",
+			srb->sense_buf[2], srb->sense_buf[12],
+			srb->sense_buf[13]);
+	srb->pdata = (uchar *)ptr;
 	return 0;
 }
 
-static int usb_test_unit_ready(ccb *srb,struct us_data *ss)
+static int usb_test_unit_ready(ccb *srb, struct us_data *ss)
 {
 	int retries = 10;
 
 	do {
-		memset(&srb->cmd[0],0,12);
-		srb->cmd[0]=SCSI_TST_U_RDY;
-		srb->cmd[1]=srb->lun<<5;
-		srb->datalen=0;
-		srb->cmdlen=12;
-		if(ss->transport(srb,ss)==USB_STOR_TRANSPORT_GOOD) {
+		memset(&srb->cmd[0], 0, 12);
+		srb->cmd[0] = SCSI_TST_U_RDY;
+		srb->datalen = 0;
+		srb->cmdlen = 12;
+		if (ss->transport(srb, ss) == USB_STOR_TRANSPORT_GOOD)
 			return 0;
-		}
-		usb_request_sense (srb, ss);
-		wait_ms (100);
-	} while(retries--);
+		usb_request_sense(srb, ss);
+		wait_ms(100);
+	} while (retries--);
 
 	return -1;
 }
 
-static int usb_read_capacity(ccb *srb,struct us_data *ss)
+static int usb_read_capacity(ccb *srb, struct us_data *ss)
 {
 	int retry;
-	retry = 3; /* retries */
+	/* XXX retries */
+	retry = 3;
 	do {
-		memset(&srb->cmd[0],0,12);
-		srb->cmd[0]=SCSI_RD_CAPAC;
-		srb->cmd[1]=srb->lun<<5;
-		srb->datalen=8;
-		srb->cmdlen=12;
-		if(ss->transport(srb,ss)==USB_STOR_TRANSPORT_GOOD) {
+		memset(&srb->cmd[0], 0, 12);
+		srb->cmd[0] = SCSI_RD_CAPAC;
+		srb->datalen = 8;
+		srb->cmdlen = 12;
+		if (ss->transport(srb, ss) == USB_STOR_TRANSPORT_GOOD)
 			return 0;
-		}
-	} while(retry--);
+	} while (retry--);
 
 	return -1;
 }
 
-static int usb_read_10(ccb *srb,struct us_data *ss, unsigned long start, unsigned short blocks)
+static int usb_read_10(ccb *srb, struct us_data *ss, unsigned long start,
+		       unsigned short blocks)
 {
-	memset(&srb->cmd[0],0,12);
-	srb->cmd[0]=SCSI_READ10;
-	srb->cmd[1]=srb->lun<<5;
-	srb->cmd[2]=((unsigned char) (start>>24))&0xff;
-	srb->cmd[3]=((unsigned char) (start>>16))&0xff;
-	srb->cmd[4]=((unsigned char) (start>>8))&0xff;
-	srb->cmd[5]=((unsigned char) (start))&0xff;
-	srb->cmd[7]=((unsigned char) (blocks>>8))&0xff;
-	srb->cmd[8]=(unsigned char) blocks & 0xff;
-	srb->cmdlen=12;
-	USB_STOR_PRINTF("read10: start %lx blocks %x\n",start,blocks);
-	return ss->transport(srb,ss);
+	memset(&srb->cmd[0], 0, 12);
+	srb->cmd[0] = SCSI_READ10;
+	srb->cmd[2] = ((unsigned char) (start >> 24)) & 0xff;
+	srb->cmd[3] = ((unsigned char) (start >> 16)) & 0xff;
+	srb->cmd[4] = ((unsigned char) (start >> 8)) & 0xff;
+	srb->cmd[5] = ((unsigned char) (start)) & 0xff;
+	srb->cmd[7] = ((unsigned char) (blocks >> 8)) & 0xff;
+	srb->cmd[8] = (unsigned char) blocks & 0xff;
+	srb->cmdlen = 12;
+	USB_STOR_PRINTF("read10: start %lx blocks %x\n", start, blocks);
+	return ss->transport(srb, ss);
 }
 
 
@@ -933,85 +981,94 @@
 	const unsigned char max_vendor_len = 40;
 	const unsigned char max_product_len = 20;
 	if (descriptor.idVendor == 0x0424 && descriptor.idProduct == 0x223a) {
-		strncpy ((char *)vendor, "SMSC", max_vendor_len);
-		strncpy ((char *)product, "Flash Media Cntrller", max_product_len);
+		strncpy((char *)vendor, "SMSC", max_vendor_len);
+		strncpy((char *)product, "Flash Media Cntrller",
+			max_product_len);
 	}
 }
 #endif /* CONFIG_USB_BIN_FIXUP */
 
 #define USB_MAX_READ_BLK 20
 
-unsigned long usb_stor_read(int device, unsigned long blknr, unsigned long blkcnt, void *buffer)
+unsigned long usb_stor_read(int device, unsigned long blknr,
+			    unsigned long blkcnt, void *buffer)
 {
-	unsigned long start,blks, buf_addr;
+	unsigned long start, blks, buf_addr;
 	unsigned short smallblks;
 	struct usb_device *dev;
-	int retry,i;
+	int retry, i;
 	ccb *srb = &usb_ccb;
 
 	if (blkcnt == 0)
 		return 0;
 
 	device &= 0xff;
-	/* Setup  device
-	 */
-	USB_STOR_PRINTF("\nusb_read: dev %d \n",device);
-	dev=NULL;
-	for(i=0;i<USB_MAX_DEVICE;i++) {
-		dev=usb_get_dev_index(i);
-		if(dev==NULL) {
+	/* Setup  device */
+	USB_STOR_PRINTF("\nusb_read: dev %d \n", device);
+	dev = NULL;
+	for (i = 0; i < USB_MAX_DEVICE; i++) {
+		dev = usb_get_dev_index(i);
+		if (dev == NULL)
 			return 0;
-		}
-		if(dev->devnum==usb_dev_desc[device].target)
+		if (dev->devnum == usb_dev_desc[device].target)
 			break;
 	}
 
 	usb_disable_asynch(1); /* asynch transfer not allowed */
-	srb->lun=usb_dev_desc[device].lun;
-	buf_addr=(unsigned long)buffer;
-	start=blknr;
-	blks=blkcnt;
-	if(usb_test_unit_ready(srb,(struct us_data *)dev->privptr)) {
-		printf("Device NOT ready\n   Request Sense returned %02X %02X %02X\n",
-			srb->sense_buf[2],srb->sense_buf[12],srb->sense_buf[13]);
+	srb->lun = usb_dev_desc[device].lun;
+	buf_addr = (unsigned long)buffer;
+	start = blknr;
+	blks = blkcnt;
+	if (usb_test_unit_ready(srb, (struct us_data *)dev->privptr)) {
+		printf("Device NOT ready\n   Request Sense returned %02X %02X"
+		       " %02X\n", srb->sense_buf[2], srb->sense_buf[12],
+		       srb->sense_buf[13]);
 		return 0;
 	}
-	USB_STOR_PRINTF("\nusb_read: dev %d startblk %lx, blccnt %lx buffer %lx\n",device,start,blks, buf_addr);
+
+	USB_STOR_PRINTF("\nusb_read: dev %d startblk %lx, blccnt %lx"
+			" buffer %lx\n", device, start, blks, buf_addr);
+
 	do {
-		retry=2;
-		srb->pdata=(unsigned char *)buf_addr;
-		if(blks>USB_MAX_READ_BLK) {
-			smallblks=USB_MAX_READ_BLK;
-		} else {
-			smallblks=(unsigned short) blks;
-		}
+		/* XXX need some comment here */
+		retry = 2;
+		srb->pdata = (unsigned char *)buf_addr;
+		if (blks > USB_MAX_READ_BLK)
+			smallblks = USB_MAX_READ_BLK;
+		else
+			smallblks = (unsigned short) blks;
 retry_it:
-		if(smallblks==USB_MAX_READ_BLK)
+		if (smallblks == USB_MAX_READ_BLK)
 			usb_show_progress();
-		srb->datalen=usb_dev_desc[device].blksz * smallblks;
-		srb->pdata=(unsigned char *)buf_addr;
-		if(usb_read_10(srb,(struct us_data *)dev->privptr, start, smallblks)) {
+		srb->datalen = usb_dev_desc[device].blksz * smallblks;
+		srb->pdata = (unsigned char *)buf_addr;
+		if (usb_read_10(srb, (struct us_data *)dev->privptr, start,
+		    smallblks)) {
 			USB_STOR_PRINTF("Read ERROR\n");
-			usb_request_sense(srb,(struct us_data *)dev->privptr);
-			if(retry--)
+			usb_request_sense(srb, (struct us_data *)dev->privptr);
+			if (retry--)
 				goto retry_it;
-			blkcnt-=blks;
+			blkcnt -= blks;
 			break;
 		}
-		start+=smallblks;
-		blks-=smallblks;
-		buf_addr+=srb->datalen;
-	} while(blks!=0);
-	USB_STOR_PRINTF("usb_read: end startblk %lx, blccnt %x buffer %lx\n",start,smallblks,buf_addr);
+		start += smallblks;
+		blks -= smallblks;
+		buf_addr += srb->datalen;
+	} while (blks != 0);
+
+	USB_STOR_PRINTF("usb_read: end startblk %lx, blccnt %x buffer %lx\n",
+			start, smallblks, buf_addr);
+
 	usb_disable_asynch(0); /* asynch transfer allowed */
-	if(blkcnt>=USB_MAX_READ_BLK)
+	if (blkcnt >= USB_MAX_READ_BLK)
 		printf("\n");
-	return(blkcnt);
+	return blkcnt;
 }
 
 
 /* Probe to see if a new device is actually a Storage device */
-int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,struct us_data *ss)
+int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,
+		      struct us_data *ss)
 {
 	struct usb_interface_descriptor *iface;
 	int i;
@@ -1025,8 +1082,11 @@
 
 #if 0
 	/* this is the place to patch some storage devices */
-	USB_STOR_PRINTF("iVendor %X iProduct %X\n",dev->descriptor.idVendor,dev->descriptor.idProduct);
-	if ((dev->descriptor.idVendor) == 0x066b && (dev->descriptor.idProduct) == 0x0103) {
+	USB_STOR_PRINTF("iVendor %X iProduct %X\n", dev->descriptor.idVendor,
+			dev->descriptor.idProduct);
+
+	if ((dev->descriptor.idVendor) == 0x066b &&
+	    (dev->descriptor.idProduct) == 0x0103) {
 		USB_STOR_PRINTF("patched for E-USB\n");
 		protocol = US_PR_CB;
 		subclass = US_SC_UFI;	    /* an assumption */
@@ -1095,19 +1155,20 @@
 	 */
 	for (i = 0; i < iface->bNumEndpoints; i++) {
 		/* is it an BULK endpoint? */
-		if ((iface->ep_desc[i].bmAttributes &  USB_ENDPOINT_XFERTYPE_MASK)
-		    == USB_ENDPOINT_XFER_BULK) {
+		if ((iface->ep_desc[i].bmAttributes &
+		     USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK) {
 			if (iface->ep_desc[i].bEndpointAddress & USB_DIR_IN)
 				ss->ep_in = iface->ep_desc[i].bEndpointAddress &
 					USB_ENDPOINT_NUMBER_MASK;
 			else
-				ss->ep_out = iface->ep_desc[i].bEndpointAddress &
+				ss->ep_out =
+					iface->ep_desc[i].bEndpointAddress &
 					USB_ENDPOINT_NUMBER_MASK;
 		}
 
 		/* is it an interrupt endpoint? */
-		if ((iface->ep_desc[i].bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
-		    == USB_ENDPOINT_XFER_INT) {
+		if ((iface->ep_desc[i].bmAttributes &
+		    USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT) {
 			ss->ep_int = iface->ep_desc[i].bEndpointAddress &
 				USB_ENDPOINT_NUMBER_MASK;
 			ss->irqinterval = iface->ep_desc[i].bInterval;
@@ -1130,26 +1191,28 @@
 	 */
 	if (ss->subclass != US_SC_UFI && ss->subclass != US_SC_SCSI &&
 	    ss->subclass != US_SC_8070) {
-		printf("Sorry, protocol %d not yet supported.\n",ss->subclass);
+		printf("Sorry, protocol %d not yet supported.\n", ss->subclass);
 		return 0;
 	}
-	if(ss->ep_int) { /* we had found an interrupt endpoint, prepare irq pipe */
-		/* set up the IRQ pipe and handler */
-
+	if (ss->ep_int) {
+		/* we had found an interrupt endpoint, prepare irq pipe
+		 * set up the IRQ pipe and handler
+		 */
 		ss->irqinterval = (ss->irqinterval > 0) ? ss->irqinterval : 255;
 		ss->irqpipe = usb_rcvintpipe(ss->pusb_dev, ss->ep_int);
 		ss->irqmaxp = usb_maxpacket(dev, ss->irqpipe);
-		dev->irq_handle=usb_stor_irq;
+		dev->irq_handle = usb_stor_irq;
 	}
-	dev->privptr=(void *)ss;
+	dev->privptr = (void *)ss;
 	return 1;
 }
 
-int usb_stor_get_info(struct usb_device *dev,struct us_data *ss,block_dev_desc_t *dev_desc)
+int usb_stor_get_info(struct usb_device *dev, struct us_data *ss,
+		      block_dev_desc_t *dev_desc)
 {
-	unsigned char perq,modi;
+	unsigned char perq, modi;
 	unsigned long cap[2];
-	unsigned long *capacity,*blksz;
+	unsigned long *capacity, *blksz;
 	ccb *pccb = &usb_ccb;
 
 	/* for some reasons a couple of devices would not survive this reset */
@@ -1157,7 +1220,6 @@
 	    /* Sony USM256E */
 	    (dev->descriptor.idVendor == 0x054c &&
 	     dev->descriptor.idProduct == 0x019e)
-
 	    ||
 	    /* USB007 Mini-USB2 Flash Drive */
 	    (dev->descriptor.idVendor == 0x066f &&
@@ -1166,6 +1228,13 @@
 	    /* SanDisk Corporation Cruzer Micro 20044318410546613953 */
 	    (dev->descriptor.idVendor == 0x0781 &&
 	     dev->descriptor.idProduct == 0x5151)
+	    ||
+	    /*
+	     * SanDisk Corporation U3 Cruzer Micro 1/4GB
+	     * Flash Drive 000016244373FFB4
+	     */
+	    (dev->descriptor.idVendor == 0x0781 &&
+	     dev->descriptor.idProduct == 0x5406)
 	    )
 		USB_STOR_PRINTF("usb_stor_get_info: skipping RESET..\n");
 	else
@@ -1175,17 +1244,20 @@
 
 	dev_desc->target = dev->devnum;
 	pccb->lun = dev_desc->lun;
-	USB_STOR_PRINTF(" address %d\n",dev_desc->target);
+	USB_STOR_PRINTF(" address %d\n", dev_desc->target);
 
-	if(usb_inquiry(pccb,ss))
+	if (usb_inquiry(pccb, ss))
 		return -1;
 
 	perq = usb_stor_buf[0];
 	modi = usb_stor_buf[1];
-	if((perq & 0x1f) == 0x1f) {
-		return 0; /* skip unknown devices */
+
+	if ((perq & 0x1f) == 0x1f) {
+		/* skip unknown devices */
+		return 0;
 	}
-	if((modi&0x80) == 0x80) {/* drive is removable */
+	if ((modi&0x80) == 0x80) {
+		/* drive is removable */
 		dev_desc->removable = 1;
 	}
 	memcpy(&dev_desc->vendor[0], &usb_stor_buf[8], 8);
@@ -1195,29 +1267,34 @@
 	dev_desc->product[16] = 0;
 	dev_desc->revision[4] = 0;
 #ifdef CONFIG_USB_BIN_FIXUP
-	usb_bin_fixup(dev->descriptor, (uchar *)dev_desc->vendor, (uchar *)dev_desc->product);
+	usb_bin_fixup(dev->descriptor, (uchar *)dev_desc->vendor,
+		      (uchar *)dev_desc->product);
 #endif /* CONFIG_USB_BIN_FIXUP */
-	USB_STOR_PRINTF("ISO Vers %X, Response Data %X\n",usb_stor_buf[2],usb_stor_buf[3]);
-	if(usb_test_unit_ready(pccb,ss)) {
-		printf("Device NOT ready\n   Request Sense returned %02X %02X %02X\n",pccb->sense_buf[2],pccb->sense_buf[12],pccb->sense_buf[13]);
-		if(dev_desc->removable == 1) {
+	USB_STOR_PRINTF("ISO Vers %X, Response Data %X\n", usb_stor_buf[2],
+			usb_stor_buf[3]);
+	if (usb_test_unit_ready(pccb, ss)) {
+		printf("Device NOT ready\n"
+		       "   Request Sense returned %02X %02X %02X\n",
+		       pccb->sense_buf[2], pccb->sense_buf[12],
+		       pccb->sense_buf[13]);
+		if (dev_desc->removable == 1) {
 			dev_desc->type = perq;
 			return 1;
 		}
-		else
-			return 0;
+		return 0;
 	}
 	pccb->pdata = (unsigned char *)&cap[0];
-	memset(pccb->pdata,0,8);
-	if(usb_read_capacity(pccb,ss) != 0) {
+	memset(pccb->pdata, 0, 8);
+	if (usb_read_capacity(pccb, ss) != 0) {
 		printf("READ_CAP ERROR\n");
 		cap[0] = 2880;
 		cap[1] = 0x200;
 	}
-	USB_STOR_PRINTF("Read Capacity returns: 0x%lx, 0x%lx\n",cap[0],cap[1]);
+	USB_STOR_PRINTF("Read Capacity returns: 0x%lx, 0x%lx\n", cap[0],
+			cap[1]);
 #if 0
-	if(cap[0]>(0x200000 * 10)) /* greater than 10 GByte */
-		cap[0]>>=16;
+	if (cap[0] > (0x200000 * 10)) /* greater than 10 GByte */
+		cap[0] >>= 16;
 #endif
 	cap[0] = cpu_to_be32(cap[0]);
 	cap[1] = cpu_to_be32(cap[1]);
@@ -1226,15 +1303,16 @@
 	cap[0] += 1;
 	capacity = &cap[0];
 	blksz = &cap[1];
-	USB_STOR_PRINTF("Capacity = 0x%lx, blocksz = 0x%lx\n",*capacity,*blksz);
+	USB_STOR_PRINTF("Capacity = 0x%lx, blocksz = 0x%lx\n",
+			*capacity, *blksz);
 	dev_desc->lba = *capacity;
 	dev_desc->blksz = *blksz;
 	dev_desc->type = perq;
-	USB_STOR_PRINTF(" address %d\n",dev_desc->target);
-	USB_STOR_PRINTF("partype: %d\n",dev_desc->part_type);
+	USB_STOR_PRINTF(" address %d\n", dev_desc->target);
+	USB_STOR_PRINTF("partype: %d\n", dev_desc->part_type);
 
 	init_part(dev_desc);
 
-	USB_STOR_PRINTF("partype: %d\n",dev_desc->part_type);
+	USB_STOR_PRINTF("partype: %d\n", dev_desc->part_type);
 	return 1;
 }
diff -Naur u-boot-2009.01/cpu/arm720t/lpc2292/mmc.c u-boot/cpu/arm720t/lpc2292/mmc.c
--- u-boot-2009.01/cpu/arm720t/lpc2292/mmc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/arm720t/lpc2292/mmc.c	2009-02-26 14:03:58.000000000 +0100
@@ -93,12 +93,12 @@
 	return 0;
 }
 
-int mmc_init(int verbose)
+int mmc_legacy_init(int verbose)
 {
 	int ret = -ENODEV;
 
 	if (verbose)
-		printf("mmc_init\n");
+		printf("mmc_legacy_init\n");
 
 	spi_init();
 	/* this meeds to be done twice */
@@ -128,30 +128,4 @@
 	return ret;
 }
 
-int mmc_write(uchar * src, ulong dst, int size)
-{
-#ifdef MMC_DEBUG
-	printf("mmc_write: src=%p, dst=%lu, size=%u\n", src, dst, size);
-#endif
-	/* Since mmc2info always returns 0 this function will never be called */
-	return 0;
-}
-
-int mmc_read(ulong src, uchar * dst, int size)
-{
-#ifdef MMC_DEBUG
-	printf("mmc_read: src=%lu, dst=%p, size=%u\n", src, dst, size);
-#endif
-	/* Since mmc2info always returns 0 this function will never be called */
-	return 0;
-}
-
-int mmc2info(ulong addr)
-{
-	/* This function is used by cmd_cp to determine if source or destination
-	 address resides on MMC-card or not. We do not support copy to and from
-	 MMC-card so we always return 0. */
-	return 0;
-}
-
 #endif /* CONFIG_MMC */
diff -Naur u-boot-2009.01/cpu/arm920t/s3c24x0/usb_ohci.c u-boot/cpu/arm920t/s3c24x0/usb_ohci.c
--- u-boot-2009.01/cpu/arm920t/s3c24x0/usb_ohci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/arm920t/s3c24x0/usb_ohci.c	2009-02-26 14:03:58.000000000 +0100
@@ -29,9 +29,7 @@
  */
 /*
  * IMPORTANT NOTES
- * 1 - you MUST define LITTLEENDIAN in the configuration file for the
- *     board or this driver will NOT work!
- * 2 - this driver is intended for use with USB Mass Storage Devices
+ * 1 - this driver is intended for use with USB Mass Storage Devices
  *     (BBB) ONLY. There is NO support for Interrupt or Isochronous pipes!
  */
 
diff -Naur u-boot-2009.01/cpu/arm926ejs/nomadik/Makefile u-boot/cpu/arm926ejs/nomadik/Makefile
--- u-boot-2009.01/cpu/arm926ejs/nomadik/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm926ejs/nomadik/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,46 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= timer.o
+SOBJS	= reset.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS)) $(addprefix $(obj),$(SOBJS))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/cpu/arm926ejs/nomadik/reset.S u-boot/cpu/arm926ejs/nomadik/reset.S
--- u-boot-2009.01/cpu/arm926ejs/nomadik/reset.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm926ejs/nomadik/reset.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,25 @@
+#include <config.h>
+/*
+ * Processor reset for Nomadik
+ */
+
+	.align 5
+.globl reset_cpu
+reset_cpu:
+#if defined CONFIG_NOMADIK_8815
+	ldr	r0, =NOMADIK_SRC_BASE
+	ldr	r1, =0x1
+	str	r1, [r0, #0x18]
+#else
+	ldr	r1, rstctl1	/* get clkm1 reset ctl */
+	mov	r3, #0x0
+	strh	r3, [r1]	/* clear it */
+	mov	r3, #0x8
+	strh	r3, [r1]	/* force dsp+arm reset */
+#endif
+
+_loop_forever:
+	b	_loop_forever
+
+rstctl1:
+	.word 0xfffece10
diff -Naur u-boot-2009.01/cpu/arm926ejs/nomadik/timer.c u-boot/cpu/arm926ejs/nomadik/timer.c
--- u-boot-2009.01/cpu/arm926ejs/nomadik/timer.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm926ejs/nomadik/timer.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,183 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments <www.ti.com>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002-2004
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * (C) Copyright 2004
+ * Philippe Robin, ARM Ltd. <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <arm926ejs.h>
+
+#define TIMER_LOAD_VAL 0xffffffff
+
+/* macro to read the 32 bit timer */
+#define READ_TIMER readl(CONFIG_SYS_TIMERBASE + 20)
+
+static ulong timestamp;
+static ulong lastdec;
+
+/* nothing really to do with interrupts, just starts up a counter. */
+int timer_init(void)
+{
+	/* Load timer with initial value */
+	writel(TIMER_LOAD_VAL, CONFIG_SYS_TIMERBASE + 16);
+
+	/*
+	 * Set timer to be enabled, free-running, no interrupts, 256 divider,
+	 * 32-bit, wrap-mode
+	 */
+	writel(0x8a, CONFIG_SYS_TIMERBASE + 24);
+
+	/* init the timestamp and lastdec value */
+	reset_timer_masked();
+
+	return 0;
+}
+
+/*
+ * timer without interrupts
+ */
+void reset_timer(void)
+{
+	reset_timer_masked();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked() - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+void udelay(unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	if (usec >= 1000) {
+		/* if "big" number, spread normalization to seconds */
+		tmo = usec / 1000;	/* start to normalize */
+		tmo *= CONFIG_SYS_HZ;	/* find number of "ticks" */
+		tmo /= 1000;		/* finish normalize. */
+	} else {
+		/* small number, don't kill it prior to HZ multiply */
+		tmo = usec * CONFIG_SYS_HZ;
+		tmo /= (1000 * 1000);
+	}
+
+	tmp = get_timer(0);		/* get current timestamp */
+	if ((tmo + tmp + 1) < tmp)	/* will roll time stamp? */
+		reset_timer_masked();	/* reset to 0, set lastdec value */
+	else
+		tmo += tmp;
+
+	while (get_timer_masked() < tmo)
+		/* nothing */ ;
+}
+
+void reset_timer_masked(void)
+{
+	/* reset time */
+	lastdec = READ_TIMER;	/* capure current decrementer value time */
+	timestamp = 0;		/* start "advancing" time stamp from 0 */
+}
+
+ulong get_timer_masked(void)
+{
+	ulong now = READ_TIMER;		/* current tick value */
+
+	if (lastdec >= now) {		/* normal mode (non roll) */
+		/* move stamp fordward */
+		timestamp += lastdec - now;
+	} else {
+		/*
+		 * An overflow is expected.
+		 * nts = ts + ld + (TLV - now)
+		 * ts=old stamp, ld=time that passed before passing through -1
+		 * (TLV-now) amount of time after passing though -1
+		 * nts = new "advancing time stamp"...it could also roll
+		 */
+		timestamp += lastdec + TIMER_LOAD_VAL - now;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+/* waits specified delay value and resets timestamp */
+void udelay_masked(unsigned long usec)
+{
+	ulong tmo;
+
+	if (usec >= 1000) {
+		/* if "big" number, spread normalization to seconds */
+		tmo = usec / 1000;	/* start to normalize */
+		tmo *= CONFIG_SYS_HZ;	/* find number of "ticks" */
+		tmo /= 1000;		/* finish normalize. */
+	} else {
+		/* else small number, don't kill it prior to HZ multiply */
+		tmo = usec * CONFIG_SYS_HZ;
+		tmo /= (1000*1000);
+	}
+
+	reset_timer_masked();
+	/* set "advancing" timestamp to 0, set lastdec vaule */
+
+	while (get_timer_masked() < tmo)
+		/* nothing */ ;
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	ulong tbclk;
+
+	tbclk = CONFIG_SYS_HZ;
+	return tbclk;
+}
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/config.mk u-boot/cpu/arm_cortexa8/config.mk
--- u-boot-2009.01/cpu/arm_cortexa8/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,36 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+PLATFORM_RELFLAGS += -fno-strict-aliasing -fno-common -ffixed-r8 \
+		     -msoft-float
+
+# Make ARMv5 to allow more compilers to work, even though its v7a.
+PLATFORM_CPPFLAGS += -march=armv5
+# =========================================================================
+#
+# Supply options according to compiler version
+#
+# =========================================================================
+PLATFORM_CPPFLAGS +=$(call cc-option)
+PLATFORM_CPPFLAGS +=$(call cc-option,-mno-thumb-interwork,)
+PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,\
+		    $(call cc-option,-malignment-traps,))
\ Kein Zeilenumbruch am Dateiende.
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/cpu.c u-boot/cpu/arm_cortexa8/cpu.c
--- u-boot-2009.01/cpu/arm_cortexa8/cpu.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/cpu.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,240 @@
+/*
+ * (C) Copyright 2008 Texas Insturments
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * CPU specific code
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/sys_proto.h>
+
+#ifdef CONFIG_USE_IRQ
+DECLARE_GLOBAL_DATA_PTR;
+#endif
+
+#ifndef CONFIG_L2_OFF
+void l2cache_disable(void);
+#endif
+
+static void cache_flush(void);
+
+/* read co-processor 15, register #1 (control register) */
+static unsigned long read_p15_c1(void)
+{
+	unsigned long value;
+
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 0\
+			     @ read control reg\n":"=r"(value)
+			     ::"memory");
+	return value;
+}
+
+/* write to co-processor 15, register #1 (control register) */
+static void write_p15_c1(unsigned long value)
+{
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 0\
+			     @ write it back\n"::"r"(value)
+			     : "memory");
+
+	read_p15_c1();
+}
+
+static void cp_delay(void)
+{
+	/* Many OMAP regs need at least 2 nops */
+	asm("nop");
+	asm("nop");
+}
+
+/* See also ARM Ref. Man. */
+#define C1_MMU		(1<<0)	/* mmu off/on */
+#define C1_ALIGN	(1<<1)	/* alignment faults off/on */
+#define C1_DC		(1<<2)	/* dcache off/on */
+#define C1_WB		(1<<3)	/* merging write buffer on/off */
+#define C1_BIG_ENDIAN	(1<<7)	/* big endian off/on */
+#define C1_SYS_PROT	(1<<8)	/* system protection */
+#define C1_ROM_PROT	(1<<9)	/* ROM protection */
+#define C1_IC		(1<<12)	/* icache off/on */
+#define C1_HIGH_VECTORS	(1<<13)	/* location of vectors: low/high addresses */
+#define RESERVED_1	(0xf << 3)	/* must be 111b for R/W */
+
+int cpu_init(void)
+{
+	/*
+	 * setup up stacks if necessary
+	 */
+#ifdef CONFIG_USE_IRQ
+	IRQ_STACK_START =
+	    _armboot_start - CONFIG_SYS_MALLOC_LEN - CONFIG_SYS_GBL_DATA_SIZE - 4;
+	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
+#endif
+	return 0;
+}
+
+int cleanup_before_linux(void)
+{
+	unsigned int i;
+
+	/*
+	 * this function is called just before we call linux
+	 * it prepares the processor for linux
+	 *
+	 * we turn off caches etc ...
+	 */
+	disable_interrupts();
+
+	/* turn off I/D-cache */
+	icache_disable();
+	dcache_disable();
+
+	/* invalidate I-cache */
+	cache_flush();
+
+#ifndef CONFIG_L2_OFF
+	/* turn off L2 cache */
+	l2cache_disable();
+	/* invalidate L2 cache also */
+	v7_flush_dcache_all(get_device_type());
+#endif
+	i = 0;
+	/* mem barrier to sync up things */
+	asm("mcr p15, 0, %0, c7, c10, 4": :"r"(i));
+
+#ifndef CONFIG_L2_OFF
+	l2cache_enable();
+#endif
+
+	return 0;
+}
+
+int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	disable_interrupts();
+	reset_cpu(0);
+
+	/* NOTREACHED */
+	return 0;
+}
+
+void icache_enable(void)
+{
+	ulong reg;
+
+	reg = read_p15_c1();	/* get control reg. */
+	cp_delay();
+	write_p15_c1(reg | C1_IC);
+}
+
+void icache_disable(void)
+{
+	ulong reg;
+
+	reg = read_p15_c1();
+	cp_delay();
+	write_p15_c1(reg & ~C1_IC);
+}
+
+void dcache_disable (void)
+{
+	ulong reg;
+
+	reg = read_p15_c1 ();
+	cp_delay ();
+	write_p15_c1 (reg & ~C1_DC);
+}
+
+void l2cache_enable()
+{
+	unsigned long i;
+	volatile unsigned int j;
+
+	/* ES2 onwards we can disable/enable L2 ourselves */
+	if (get_cpu_rev() == CPU_3430_ES2) {
+		__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+		__asm__ __volatile__("orr %0, %0, #0x2":"=r"(i));
+		__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1":"=r"(i));
+	} else {
+		/* Save r0, r12 and restore them after usage */
+		__asm__ __volatile__("mov %0, r12":"=r"(j));
+		__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+		/*
+		 * GP Device ROM code API usage here
+		 * r12 = AUXCR Write function and r0 value
+		 */
+		__asm__ __volatile__("mov r12, #0x3");
+		__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+		__asm__ __volatile__("orr r0, r0, #0x2");
+		/* SMI instruction to call ROM Code API */
+		__asm__ __volatile__(".word 0xE1600070");
+		__asm__ __volatile__("mov r0, %0":"=r"(i));
+		__asm__ __volatile__("mov r12, %0":"=r"(j));
+	}
+
+}
+
+void l2cache_disable()
+{
+	unsigned long i;
+	volatile unsigned int j;
+
+	/* ES2 onwards we can disable/enable L2 ourselves */
+	if (get_cpu_rev() == CPU_3430_ES2) {
+		__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+		__asm__ __volatile__("bic %0, %0, #0x2":"=r"(i));
+		__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1":"=r"(i));
+	} else {
+		/* Save r0, r12 and restore them after usage */
+		__asm__ __volatile__("mov %0, r12":"=r"(j));
+		__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+		/*
+		 * GP Device ROM code API usage here
+		 * r12 = AUXCR Write function and r0 value
+		 */
+		__asm__ __volatile__("mov r12, #0x3");
+		__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+		__asm__ __volatile__("bic r0, r0, #0x2");
+		/* SMI instruction to call ROM Code API */
+		__asm__ __volatile__(".word 0xE1600070");
+		__asm__ __volatile__("mov r0, %0":"=r"(i));
+		__asm__ __volatile__("mov r12, %0":"=r"(j));
+	}
+}
+
+int icache_status(void)
+{
+	return (read_p15_c1() & C1_IC) != 0;
+}
+
+static void cache_flush(void)
+{
+	asm ("mcr p15, 0, %0, c7, c5, 0": :"r" (0));
+}
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/Makefile u-boot/cpu/arm_cortexa8/Makefile
--- u-boot-2009.01/cpu/arm_cortexa8/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(CPU).a
+
+START	:= start.o
+COBJS	:= cpu.o
+
+SRCS	:= $(START:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(START) $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
\ Kein Zeilenumbruch am Dateiende.
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/omap3/board.c u-boot/cpu/arm_cortexa8/omap3/board.c
--- u-boot-2009.01/cpu/arm_cortexa8/omap3/board.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/omap3/board.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,344 @@
+/*
+ *
+ * Common board functions for OMAP3 based boards.
+ *
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Author :
+ *      Sunil Kumar <sunilsaini05@gmail.com>
+ *      Shashi Ranjan <shashiranjanmca05@gmail.com>
+ *
+ * Derived from Beagle Board and 3430 SDP code by
+ *      Richard Woodruff <r-woodruff2@ti.com>
+ *      Syed Mohammed Khasim <khasim@ti.com>
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/mem.h>
+
+extern omap3_sysinfo sysinfo;
+
+/******************************************************************************
+ * Routine: delay
+ * Description: spinning delay to use before udelay works
+ *****************************************************************************/
+static inline void delay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
+			  "bne 1b":"=r" (loops):"0"(loops));
+}
+
+/******************************************************************************
+ * Routine: secure_unlock
+ * Description: Setup security registers for access
+ *              (GP Device only)
+ *****************************************************************************/
+void secure_unlock_mem(void)
+{
+	pm_t *pm_rt_ape_base = (pm_t *)PM_RT_APE_BASE_ADDR_ARM;
+	pm_t *pm_gpmc_base = (pm_t *)PM_GPMC_BASE_ADDR_ARM;
+	pm_t *pm_ocm_ram_base = (pm_t *)PM_OCM_RAM_BASE_ADDR_ARM;
+	pm_t *pm_iva2_base = (pm_t *)PM_IVA2_BASE_ADDR_ARM;
+	sms_t *sms_base = (sms_t *)OMAP34XX_SMS_BASE;
+
+	/* Protection Module Register Target APE (PM_RT) */
+	writel(UNLOCK_1, &pm_rt_ape_base->req_info_permission_1);
+	writel(UNLOCK_1, &pm_rt_ape_base->read_permission_0);
+	writel(UNLOCK_1, &pm_rt_ape_base->wirte_permission_0);
+	writel(UNLOCK_2, &pm_rt_ape_base->addr_match_1);
+
+	writel(UNLOCK_3, &pm_gpmc_base->req_info_permission_0);
+	writel(UNLOCK_3, &pm_gpmc_base->read_permission_0);
+	writel(UNLOCK_3, &pm_gpmc_base->wirte_permission_0);
+
+	writel(UNLOCK_3, &pm_ocm_ram_base->req_info_permission_0);
+	writel(UNLOCK_3, &pm_ocm_ram_base->read_permission_0);
+	writel(UNLOCK_3, &pm_ocm_ram_base->wirte_permission_0);
+	writel(UNLOCK_2, &pm_ocm_ram_base->addr_match_2);
+
+	/* IVA Changes */
+	writel(UNLOCK_3, &pm_iva2_base->req_info_permission_0);
+	writel(UNLOCK_3, &pm_iva2_base->read_permission_0);
+	writel(UNLOCK_3, &pm_iva2_base->wirte_permission_0);
+
+	/* SDRC region 0 public */
+	writel(UNLOCK_1, &sms_base->rg_att0);
+}
+
+/******************************************************************************
+ * Routine: secureworld_exit()
+ * Description: If chip is EMU and boot type is external
+ *		configure secure registers and exit secure world
+ *              general use.
+ *****************************************************************************/
+void secureworld_exit()
+{
+	unsigned long i;
+
+	/* configrue non-secure access control register */
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c1, 2":"=r"(i));
+	/* enabling co-processor CP10 and CP11 accesses in NS world */
+	__asm__ __volatile__("orr %0, %0, #0xC00":"=r"(i));
+	/*
+	 * allow allocation of locked TLBs and L2 lines in NS world
+	 * allow use of PLE registers in NS world also
+	 */
+	__asm__ __volatile__("orr %0, %0, #0x70000":"=r"(i));
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c1, 2":"=r"(i));
+
+	/* Enable ASA in ACR register */
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+	__asm__ __volatile__("orr %0, %0, #0x10":"=r"(i));
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1":"=r"(i));
+
+	/* Exiting secure world */
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c1, 0":"=r"(i));
+	__asm__ __volatile__("orr %0, %0, #0x31":"=r"(i));
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c1, 0":"=r"(i));
+}
+
+/******************************************************************************
+ * Routine: setup_auxcr()
+ * Description: Write to AuxCR desired value using SMI.
+ *              general use.
+ *****************************************************************************/
+void setup_auxcr()
+{
+	unsigned long i;
+	volatile unsigned int j;
+	/* Save r0, r12 and restore them after usage */
+	__asm__ __volatile__("mov %0, r12":"=r"(j));
+	__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+	/*
+	 * GP Device ROM code API usage here
+	 * r12 = AUXCR Write function and r0 value
+	 */
+	__asm__ __volatile__("mov r12, #0x3");
+	__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+	/* Enabling ASA */
+	__asm__ __volatile__("orr r0, r0, #0x10");
+	/* Enable L1NEON */
+	__asm__ __volatile__("orr r0, r0, #1 << 5");
+	/* SMI instruction to call ROM Code API */
+	__asm__ __volatile__(".word 0xE1600070");
+	__asm__ __volatile__("mov r0, %0":"=r"(i));
+	__asm__ __volatile__("mov r12, %0":"=r"(j));
+}
+
+/******************************************************************************
+ * Routine: try_unlock_sram()
+ * Description: If chip is GP/EMU(special) type, unlock the SRAM for
+ *              general use.
+ *****************************************************************************/
+void try_unlock_memory()
+{
+	int mode;
+	int in_sdram = is_running_in_sdram();
+
+	/*
+	 * if GP device unlock device SRAM for general use
+	 * secure code breaks for Secure/Emulation device - HS/E/T
+	 */
+	mode = get_device_type();
+	if (mode == GP_DEVICE)
+		secure_unlock_mem();
+
+	/*
+	 * If device is EMU and boot is XIP external booting
+	 * Unlock firewalls and disable L2 and put chip
+	 * out of secure world
+	 *
+	 * Assuming memories are unlocked by the demon who put us in SDRAM
+	 */
+	if ((mode <= EMU_DEVICE) && (get_boot_type() == 0x1F)
+	    && (!in_sdram)) {
+		secure_unlock_mem();
+		secureworld_exit();
+	}
+
+	return;
+}
+
+/******************************************************************************
+ * Routine: s_init
+ * Description: Does early system init of muxing and clocks.
+ *              - Called path is with SRAM stack.
+ *****************************************************************************/
+void s_init(void)
+{
+	int in_sdram = is_running_in_sdram();
+
+	watchdog_init();
+
+	try_unlock_memory();
+
+	/*
+	 * Right now flushing at low MPU speed.
+	 * Need to move after clock init
+	 */
+	v7_flush_dcache_all(get_device_type());
+#ifndef CONFIG_ICACHE_OFF
+	icache_enable();
+#endif
+
+#ifdef CONFIG_L2_OFF
+	l2cache_disable();
+#else
+	l2cache_enable();
+#endif
+	/*
+	 * Writing to AuxCR in U-boot using SMI for GP DEV
+	 * Currently SMI in Kernel on ES2 devices seems to have an issue
+	 * Once that is resolved, we can postpone this config to kernel
+	 */
+	if (get_device_type() == GP_DEVICE)
+		setup_auxcr();
+
+	set_muxconf_regs();
+	delay(100);
+
+	prcm_init();
+
+	per_clocks_enable();
+
+	if (!in_sdram)
+		sdrc_init();
+}
+
+/******************************************************************************
+ * Routine: wait_for_command_complete
+ * Description: Wait for posting to finish on watchdog
+ *****************************************************************************/
+void wait_for_command_complete(watchdog_t *wd_base)
+{
+	int pending = 1;
+	do {
+		pending = readl(&wd_base->wwps);
+	} while (pending);
+}
+
+/******************************************************************************
+ * Routine: watchdog_init
+ * Description: Shut down watch dogs
+ *****************************************************************************/
+void watchdog_init(void)
+{
+	watchdog_t *wd2_base = (watchdog_t *)WD2_BASE;
+	prcm_t *prcm_base = (prcm_t *)PRCM_BASE;
+
+	/*
+	 * There are 3 watch dogs WD1=Secure, WD2=MPU, WD3=IVA. WD1 is
+	 * either taken care of by ROM (HS/EMU) or not accessible (GP).
+	 * We need to take care of WD2-MPU or take a PRCM reset. WD3
+	 * should not be running and does not generate a PRCM reset.
+	 */
+
+	sr32(&prcm_base->fclken_wkup, 5, 1, 1);
+	sr32(&prcm_base->iclken_wkup, 5, 1, 1);
+	wait_on_value(ST_WDT2, 0x20, &prcm_base->idlest_wkup, 5);
+
+	writel(WD_UNLOCK1, &wd2_base->wspr);
+	wait_for_command_complete(wd2_base);
+	writel(WD_UNLOCK2, &wd2_base->wspr);
+}
+
+/******************************************************************************
+ * Routine: dram_init
+ * Description: sets uboots idea of sdram size
+ *****************************************************************************/
+int dram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	unsigned int size0 = 0, size1 = 0;
+	u32 btype;
+
+	btype = get_board_type();
+
+	display_board_info(btype);
+
+	/*
+	 * If a second bank of DDR is attached to CS1 this is
+	 * where it can be started.  Early init code will init
+	 * memory on CS0.
+	 */
+	if ((sysinfo.mtype == DDR_COMBO) || (sysinfo.mtype == DDR_STACKED)) {
+		do_sdrc_init(CS1, NOT_EARLY);
+		make_cs1_contiguous();
+	}
+
+	size0 = get_sdr_cs_size(CS0);
+	size1 = get_sdr_cs_size(CS1);
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = size0;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_1 + get_sdr_cs_offset(CS1);
+	gd->bd->bi_dram[1].size = size1;
+
+	return 0;
+}
+
+/******************************************************************************
+ * Dummy function to handle errors for EABI incompatibility
+ *****************************************************************************/
+void raise(void)
+{
+}
+
+/******************************************************************************
+ * Dummy function to handle errors for EABI incompatibility
+ *****************************************************************************/
+void abort(void)
+{
+}
+
+#ifdef CONFIG_NAND_OMAP_GPMC
+/******************************************************************************
+ * OMAP3 specific command to switch between NAND HW and SW ecc
+ *****************************************************************************/
+static int do_switch_ecc(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	if (argc != 2)
+		goto usage;
+	if (strncmp(argv[1], "hw", 2) == 0)
+		omap_nand_switch_ecc(1);
+	else if (strncmp(argv[1], "sw", 2) == 0)
+		omap_nand_switch_ecc(0);
+	else
+		goto usage;
+
+	return 0;
+
+usage:
+	printf ("Usage: nandecc %s\n", cmdtp->help);
+	return 1;
+}
+
+U_BOOT_CMD(
+	nandecc, 2, 1,	do_switch_ecc,
+	"nandecc - switch OMAP3 NAND ECC calculation algorithm\n",
+	"[hw/sw] - Switch between NAND hardware (hw) or software (sw) ecc algorithm\n"
+	);
+
+#endif /* CONFIG_NAND_OMAP_GPMC */
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/omap3/clock.c u-boot/cpu/arm_cortexa8/omap3/clock.c
--- u-boot-2009.01/cpu/arm_cortexa8/omap3/clock.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/omap3/clock.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,381 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Author :
+ *      Manikandan Pillai <mani.pillai@ti.com>
+ *
+ * Derived from Beagle Board and OMAP3 SDP code by
+ *      Richard Woodruff <r-woodruff2@ti.com>
+ *      Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clocks.h>
+#include <asm/arch/clocks_omap3.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/sys_proto.h>
+#include <environment.h>
+#include <command.h>
+
+/******************************************************************************
+ * get_sys_clk_speed() - determine reference oscillator speed
+ *                       based on known 32kHz clock and gptimer.
+ *****************************************************************************/
+u32 get_osc_clk_speed(void)
+{
+	u32 start, cstart, cend, cdiff, val;
+	prcm_t *prcm_base = (prcm_t *)PRCM_BASE;
+	prm_t *prm_base = (prm_t *)PRM_BASE;
+	gptimer_t *gpt1_base = (gptimer_t *)OMAP34XX_GPT1;
+	s32ktimer_t *s32k_base = (s32ktimer_t *)SYNC_32KTIMER_BASE;
+
+	val = readl(&prm_base->clksrc_ctrl);
+
+	/* If SYS_CLK is being divided by 2, remove for now */
+	val = (val & (~SYSCLKDIV_2)) | SYSCLKDIV_1;
+	writel(val, &prm_base->clksrc_ctrl);
+
+	/* enable timer2 */
+	val = readl(&prcm_base->clksel_wkup) | CLKSEL_GPT1;
+
+	/* select sys_clk for GPT1 */
+	writel(val, &prcm_base->clksel_wkup);
+
+	/* Enable I and F Clocks for GPT1 */
+	val = readl(&prcm_base->iclken_wkup) | EN_GPT1 | EN_32KSYNC;
+	writel(val, &prcm_base->iclken_wkup);
+	val = readl(&prcm_base->fclken_wkup) | EN_GPT1;
+	writel(val, &prcm_base->fclken_wkup);
+
+	writel(0, &gpt1_base->tldr);		/* start counting at 0 */
+	writel(GPT_EN, &gpt1_base->tclr);	/* enable clock */
+
+	/* enable 32kHz source, determine sys_clk via gauging */
+
+	/* start time in 20 cycles */
+	start = 20 + readl(&s32k_base->s32k_cr);
+
+	/* dead loop till start time */
+	while (readl(&s32k_base->s32k_cr) < start);
+
+	/* get start sys_clk count */
+	cstart = readl(&gpt1_base->tcrr);
+
+	/* wait for 40 cycles */
+	while (readl(&s32k_base->s32k_cr) < (start + 20)) ;
+	cend = readl(&gpt1_base->tcrr);		/* get end sys_clk count */
+	cdiff = cend - cstart;			/* get elapsed ticks */
+
+	/* based on number of ticks assign speed */
+	if (cdiff > 19000)
+		return S38_4M;
+	else if (cdiff > 15200)
+		return S26M;
+	else if (cdiff > 13000)
+		return S24M;
+	else if (cdiff > 9000)
+		return S19_2M;
+	else if (cdiff > 7600)
+		return S13M;
+	else
+		return S12M;
+}
+
+/******************************************************************************
+ * get_sys_clkin_sel() - returns the sys_clkin_sel field value based on
+ *                       input oscillator clock frequency.
+ *****************************************************************************/
+void get_sys_clkin_sel(u32 osc_clk, u32 *sys_clkin_sel)
+{
+	switch(osc_clk) {
+	case S38_4M:
+		*sys_clkin_sel = 4;
+		break;
+	case S26M:
+		*sys_clkin_sel = 3;
+		break;
+	case S19_2M:
+		*sys_clkin_sel = 2;
+		break;
+	case S13M:
+		*sys_clkin_sel = 1;
+		break;
+	case S12M:
+	default:
+		*sys_clkin_sel = 0;
+	}
+}
+
+/******************************************************************************
+ * prcm_init() - inits clocks for PRCM as defined in clocks.h
+ *               called from SRAM, or Flash (using temp SRAM stack).
+ *****************************************************************************/
+void prcm_init(void)
+{
+	void (*f_lock_pll) (u32, u32, u32, u32);
+	int xip_safe, p0, p1, p2, p3;
+	u32 osc_clk = 0, sys_clkin_sel;
+	u32 clk_index, sil_index;
+	prm_t *prm_base = (prm_t *)PRM_BASE;
+	prcm_t *prcm_base = (prcm_t *)PRCM_BASE;
+	dpll_param *dpll_param_p;
+
+	f_lock_pll = (void *) ((u32) &_end_vect - (u32) &_start +
+				SRAM_VECT_CODE);
+
+	xip_safe = is_running_in_sram();
+
+	/*
+	 * Gauge the input clock speed and find out the sys_clkin_sel
+	 * value corresponding to the input clock.
+	 */
+	osc_clk = get_osc_clk_speed();
+	get_sys_clkin_sel(osc_clk, &sys_clkin_sel);
+
+	/* set input crystal speed */
+	sr32(&prm_base->clksel, 0, 3, sys_clkin_sel);
+
+	/* If the input clock is greater than 19.2M always divide/2 */
+	if (sys_clkin_sel > 2) {
+		/* input clock divider */
+		sr32(&prm_base->clksrc_ctrl, 6, 2, 2);
+		clk_index = sys_clkin_sel / 2;
+	} else {
+		/* input clock divider */
+		sr32(&prm_base->clksrc_ctrl, 6, 2, 1);
+		clk_index = sys_clkin_sel;
+	}
+
+	/*
+	 * The DPLL tables are defined according to sysclk value and
+	 * silicon revision. The clk_index value will be used to get
+	 * the values for that input sysclk from the DPLL param table
+	 * and sil_index will get the values for that SysClk for the
+	 * appropriate silicon rev.
+	 */
+	sil_index = get_cpu_rev() - 1;
+
+	/* Unlock MPU DPLL (slows things down, and needed later) */
+	sr32(&prcm_base->clken_pll_mpu, 0, 3, PLL_LOW_POWER_BYPASS);
+	wait_on_value(ST_MPU_CLK, 0, &prcm_base->idlest_pll_mpu, LDELAY);
+
+	/* Getting the base address of Core DPLL param table */
+	dpll_param_p = (dpll_param *) get_core_dpll_param();
+
+	/* Moving it to the right sysclk and ES rev base */
+	dpll_param_p = dpll_param_p + 3 * clk_index + sil_index;
+	if (xip_safe) {
+		/*
+		 * CORE DPLL
+		 * sr32(CM_CLKSEL2_EMU) set override to work when asleep
+		 */
+		sr32(&prcm_base->clken_pll, 0, 3, PLL_FAST_RELOCK_BYPASS);
+		wait_on_value(ST_CORE_CLK, 0, &prcm_base->idlest_ckgen,
+				LDELAY);
+
+		/*
+		 * For OMAP3 ES1.0 Errata 1.50, default value directly doesn't
+		 * work. write another value and then default value.
+		 */
+
+		/* m3x2 */
+		sr32(&prcm_base->clksel1_emu, 16, 5, CORE_M3X2 + 1);
+		/* m3x2 */
+		sr32(&prcm_base->clksel1_emu, 16, 5, CORE_M3X2);
+		/* Set M2 */
+		sr32(&prcm_base->clksel1_pll, 27, 2, dpll_param_p->m2);
+		/* Set M */
+		sr32(&prcm_base->clksel1_pll, 16, 11, dpll_param_p->m);
+		/* Set N */
+		sr32(&prcm_base->clksel1_pll, 8, 7, dpll_param_p->n);
+		/* 96M Src */
+		sr32(&prcm_base->clksel1_pll, 6, 1, 0);
+		/* ssi */
+		sr32(&prcm_base->clksel_core, 8, 4, CORE_SSI_DIV);
+		/* fsusb */
+		sr32(&prcm_base->clksel_core, 4, 2, CORE_FUSB_DIV);
+		/* l4 */
+		sr32(&prcm_base->clksel_core, 2, 2, CORE_L4_DIV);
+		/* l3 */
+		sr32(&prcm_base->clksel_core, 0, 2, CORE_L3_DIV);
+		/* gfx */
+		sr32(&prcm_base->clksel_gfx, 0, 3, GFX_DIV);
+		/* reset mgr */
+		sr32(&prcm_base->clksel_wkup, 1, 2, WKUP_RSM);
+		/* FREQSEL */
+		sr32(&prcm_base->clken_pll, 4, 4, dpll_param_p->fsel);
+		/* lock mode */
+		sr32(&prcm_base->clken_pll, 0, 3, PLL_LOCK);
+
+		wait_on_value(ST_CORE_CLK, 1, &prcm_base->idlest_ckgen,
+				LDELAY);
+	} else if (is_running_in_flash()) {
+		/*
+		 * if running from flash, jump to small relocated code
+		 * area in SRAM.
+		 */
+		p0 = readl(&prcm_base->clken_pll);
+		sr32(&p0, 0, 3, PLL_FAST_RELOCK_BYPASS);
+		sr32(&p0, 4, 4, dpll_param_p->fsel);	/* FREQSEL */
+
+		p1 = readl(&prcm_base->clksel1_pll);
+		sr32(&p1, 27, 2, dpll_param_p->m2);	/* Set M2 */
+		sr32(&p1, 16, 11, dpll_param_p->m);	/* Set M */
+		sr32(&p1, 8, 7, dpll_param_p->n);		/* Set N */
+		sr32(&p1, 6, 1, 0);	/* set source for 96M */
+
+		p2 = readl(&prcm_base->clksel_core);
+		sr32(&p2, 8, 4, CORE_SSI_DIV);	/* ssi */
+		sr32(&p2, 4, 2, CORE_FUSB_DIV);	/* fsusb */
+		sr32(&p2, 2, 2, CORE_L4_DIV);	/* l4 */
+		sr32(&p2, 0, 2, CORE_L3_DIV);	/* l3 */
+
+		p3 = (u32)&prcm_base->idlest_ckgen;
+
+		(*f_lock_pll) (p0, p1, p2, p3);
+	}
+
+	/* PER DPLL */
+	sr32(&prcm_base->clken_pll, 16, 3, PLL_STOP);
+	wait_on_value(ST_PERIPH_CLK, 0, &prcm_base->idlest_ckgen, LDELAY);
+
+	/* Getting the base address to PER DPLL param table */
+
+	/* Set N */
+	dpll_param_p = (dpll_param *) get_per_dpll_param();
+
+	/* Moving it to the right sysclk base */
+	dpll_param_p = dpll_param_p + clk_index;
+
+	/*
+	 * Errata 1.50 Workaround for OMAP3 ES1.0 only
+	 * If using default divisors, write default divisor + 1
+	 * and then the actual divisor value
+	 */
+	sr32(&prcm_base->clksel1_emu, 24, 5, PER_M6X2 + 1);	/* set M6 */
+	sr32(&prcm_base->clksel1_emu, 24, 5, PER_M6X2);		/* set M6 */
+	sr32(&prcm_base->clksel_cam, 0, 5, PER_M5X2 + 1);	/* set M5 */
+	sr32(&prcm_base->clksel_cam, 0, 5, PER_M5X2);		/* set M5 */
+	sr32(&prcm_base->clksel_dss, 0, 5, PER_M4X2 + 1);	/* set M4 */
+	sr32(&prcm_base->clksel_dss, 0, 5, PER_M4X2);		/* set M4 */
+	sr32(&prcm_base->clksel_dss, 8, 5, PER_M3X2 + 1);	/* set M3 */
+	sr32(&prcm_base->clksel_dss, 8, 5, PER_M3X2);		/* set M3 */
+	sr32(&prcm_base->clksel3_pll, 0, 5, dpll_param_p->m2 + 1); /* set M2 */
+	sr32(&prcm_base->clksel3_pll, 0, 5, dpll_param_p->m2);	/* set M2 */
+	/* Workaround end */
+
+	sr32(&prcm_base->clksel2_pll, 8, 11, dpll_param_p->m);	/* set m */
+	sr32(&prcm_base->clksel2_pll, 0, 7, dpll_param_p->n);	/* set n */
+	sr32(&prcm_base->clken_pll, 20, 4, dpll_param_p->fsel);	/* FREQSEL */
+	sr32(&prcm_base->clken_pll, 16, 3, PLL_LOCK);		/* lock mode */
+	wait_on_value(ST_PERIPH_CLK, 2, &prcm_base->idlest_ckgen, LDELAY);
+
+	/* Getting the base address to MPU DPLL param table */
+	dpll_param_p = (dpll_param *) get_mpu_dpll_param();
+
+	/* Moving it to the right sysclk and ES rev base */
+	dpll_param_p = dpll_param_p + 3 * clk_index + sil_index;
+
+	/* MPU DPLL (unlocked already) */
+
+	/* Set M2 */
+	sr32(&prcm_base->clksel2_pll_mpu, 0, 5, dpll_param_p->m2);
+	/* Set M */
+	sr32(&prcm_base->clksel1_pll_mpu, 8, 11, dpll_param_p->m);
+	/* Set N */
+	sr32(&prcm_base->clksel1_pll_mpu, 0, 7, dpll_param_p->n);
+	/* FREQSEL */
+	sr32(&prcm_base->clken_pll_mpu, 4, 4, dpll_param_p->fsel);
+	/* lock mode */
+	sr32(&prcm_base->clken_pll_mpu, 0, 3, PLL_LOCK);
+	wait_on_value(ST_MPU_CLK, 1, &prcm_base->idlest_pll_mpu, LDELAY);
+
+	/* Getting the base address to IVA DPLL param table */
+	dpll_param_p = (dpll_param *) get_iva_dpll_param();
+
+	/* Moving it to the right sysclk and ES rev base */
+	dpll_param_p = dpll_param_p + 3 * clk_index + sil_index;
+
+	/* IVA DPLL (set to 12*20=240MHz) */
+	sr32(&prcm_base->clken_pll_iva2, 0, 3, PLL_STOP);
+	wait_on_value(ST_IVA2_CLK, 0, &prcm_base->idlest_pll_iva2, LDELAY);
+	/* set M2 */
+	sr32(&prcm_base->clksel2_pll_iva2, 0, 5, dpll_param_p->m2);
+	/* set M */
+	sr32(&prcm_base->clksel1_pll_iva2, 8, 11, dpll_param_p->m);
+	/* set N */
+	sr32(&prcm_base->clksel1_pll_iva2, 0, 7, dpll_param_p->n);
+	/* FREQSEL */
+	sr32(&prcm_base->clken_pll_iva2, 4, 4, dpll_param_p->fsel);
+	/* lock mode */
+	sr32(&prcm_base->clken_pll_iva2, 0, 3, PLL_LOCK);
+	wait_on_value(ST_IVA2_CLK, 1, &prcm_base->idlest_pll_iva2, LDELAY);
+
+	/* Set up GPTimers to sys_clk source only */
+	sr32(&prcm_base->clksel_per, 0, 8, 0xff);
+	sr32(&prcm_base->clksel_wkup, 0, 1, 1);
+
+	sdelay(5000);
+}
+
+/******************************************************************************
+ * peripheral_enable() - Enable the clks & power for perifs (GPT2, UART1,...)
+ *****************************************************************************/
+void per_clocks_enable(void)
+{
+	prcm_t *prcm_base = (prcm_t *)PRCM_BASE;
+
+	/* Enable GP2 timer. */
+	sr32(&prcm_base->clksel_per, 0, 1, 0x1);	/* GPT2 = sys clk */
+	sr32(&prcm_base->iclken_per, 3, 1, 0x1);	/* ICKen GPT2 */
+	sr32(&prcm_base->fclken_per, 3, 1, 0x1);	/* FCKen GPT2 */
+
+#ifdef CONFIG_SYS_NS16550
+	/* Enable UART1 clocks */
+	sr32(&prcm_base->fclken1_core, 13, 1, 0x1);
+	sr32(&prcm_base->iclken1_core, 13, 1, 0x1);
+
+	/* UART 3 Clocks */
+	sr32(&prcm_base->fclken_per, 11, 1, 0x1);
+	sr32(&prcm_base->iclken_per, 11, 1, 0x1);
+#endif
+#ifdef CONFIG_DRIVER_OMAP34XX_I2C
+	/* Turn on all 3 I2C clocks */
+	sr32(&prcm_base->fclken1_core, 15, 3, 0x7);
+	sr32(&prcm_base->iclken1_core, 15, 3, 0x7);	/* I2C1,2,3 = on */
+#endif
+	/* Enable the ICLK for 32K Sync Timer as its used in udelay */
+	sr32(&prcm_base->iclken_wkup, 2, 1, 0x1);
+
+	sr32(&prcm_base->fclken_iva2, 0, 32, FCK_IVA2_ON);
+	sr32(&prcm_base->fclken1_core, 0, 32, FCK_CORE1_ON);
+	sr32(&prcm_base->iclken1_core, 0, 32, ICK_CORE1_ON);
+	sr32(&prcm_base->iclken2_core, 0, 32, ICK_CORE2_ON);
+	sr32(&prcm_base->fclken_wkup, 0, 32, FCK_WKUP_ON);
+	sr32(&prcm_base->iclken_wkup, 0, 32, ICK_WKUP_ON);
+	sr32(&prcm_base->fclken_dss, 0, 32, FCK_DSS_ON);
+	sr32(&prcm_base->iclken_dss, 0, 32, ICK_DSS_ON);
+	sr32(&prcm_base->fclken_cam, 0, 32, FCK_CAM_ON);
+	sr32(&prcm_base->iclken_cam, 0, 32, ICK_CAM_ON);
+	sr32(&prcm_base->fclken_per, 0, 32, FCK_PER_ON);
+	sr32(&prcm_base->iclken_per, 0, 32, ICK_PER_ON);
+
+	sdelay(1000);
+}
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/omap3/config.mk u-boot/cpu/arm_cortexa8/omap3/config.mk
--- u-boot-2009.01/cpu/arm_cortexa8/omap3/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/omap3/config.mk	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,36 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+PLATFORM_RELFLAGS += -fno-strict-aliasing -fno-common -ffixed-r8 \
+		     -msoft-float
+
+# Make ARMv5 to allow more compilers to work, even though its v7a.
+PLATFORM_CPPFLAGS += -march=armv5
+# =========================================================================
+#
+# Supply options according to compiler version
+#
+# =========================================================================
+PLATFORM_CPPFLAGS +=$(call cc-option)
+PLATFORM_CPPFLAGS +=$(call cc-option,-mno-thumb-interwork,)
+PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,\
+		    $(call cc-option,-malignment-traps,))
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/omap3/interrupts.c u-boot/cpu/arm_cortexa8/omap3/interrupts.c
--- u-boot-2009.01/cpu/arm_cortexa8/omap3/interrupts.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/omap3/interrupts.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,297 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments
+ *
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Moahmmed Khasim <khasim@ti.com>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/proc-armv/ptrace.h>
+
+#define TIMER_LOAD_VAL 0
+
+#ifdef CONFIG_USE_IRQ
+/* enable IRQ interrupts */
+void enable_interrupts(void)
+{
+	unsigned long temp;
+	__asm__ __volatile__("mrs %0, cpsr\n"
+			     "bic %0, %0, #0x80\n" "msr cpsr_c, %0":"=r"(temp)
+			     ::"memory");
+}
+
+/*
+ * disable IRQ/FIQ interrupts
+ * returns true if interrupts had been enabled before we disabled them
+ */
+int disable_interrupts(void)
+{
+	unsigned long old, temp;
+	__asm__ __volatile__("mrs %0, cpsr\n"
+			     "orr %1, %0, #0xc0\n"
+			     "msr cpsr_c, %1":"=r"(old), "=r"(temp)
+			     ::"memory");
+	return (old & 0x80) == 0;
+}
+#else
+void enable_interrupts(void)
+{
+	return;
+}
+int disable_interrupts(void)
+{
+	return 0;
+}
+#endif
+
+void bad_mode(void)
+{
+	panic("Resetting CPU ...\n");
+	reset_cpu(0);
+}
+
+void show_regs(struct pt_regs *regs)
+{
+	unsigned long flags;
+	const char *processor_modes[] = {
+		"USER_26", "FIQ_26", "IRQ_26", "SVC_26",
+		"UK4_26", "UK5_26", "UK6_26", "UK7_26",
+		"UK8_26", "UK9_26", "UK10_26", "UK11_26",
+		"UK12_26", "UK13_26", "UK14_26", "UK15_26",
+		"USER_32", "FIQ_32", "IRQ_32", "SVC_32",
+		"UK4_32", "UK5_32", "UK6_32", "ABT_32",
+		"UK8_32", "UK9_32", "UK10_32", "UND_32",
+		"UK12_32", "UK13_32", "UK14_32", "SYS_32",
+	};
+
+	flags = condition_codes(regs);
+
+	printf("pc : [<%08lx>]    lr : [<%08lx>]\n"
+		"sp : %08lx  ip : %08lx  fp : %08lx\n",
+		instruction_pointer(regs),
+		regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
+	printf("r10: %08lx  r9 : %08lx  r8 : %08lx\n",
+		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
+	printf("r7 : %08lx  r6 : %08lx  r5 : %08lx  r4 : %08lx\n",
+		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
+	printf("r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\n",
+		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
+	printf("Flags: %c%c%c%c",
+		flags & CC_N_BIT ? 'N' : 'n',
+		flags & CC_Z_BIT ? 'Z' : 'z',
+		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
+	printf("  IRQs %s  FIQs %s  Mode %s%s\n",
+		interrupts_enabled(regs) ? "on" : "off",
+		fast_interrupts_enabled(regs) ? "on" : "off",
+		processor_modes[processor_mode(regs)],
+		thumb_mode(regs) ? " (T)" : "");
+}
+
+void do_undefined_instruction(struct pt_regs *pt_regs)
+{
+	printf("undefined instruction\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_software_interrupt(struct pt_regs *pt_regs)
+{
+	printf("software interrupt\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_prefetch_abort(struct pt_regs *pt_regs)
+{
+	printf("prefetch abort\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_data_abort(struct pt_regs *pt_regs)
+{
+	printf("data abort\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_not_used(struct pt_regs *pt_regs)
+{
+	printf("not used\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_fiq(struct pt_regs *pt_regs)
+{
+	printf("fast interrupt request\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+void do_irq(struct pt_regs *pt_regs)
+{
+	printf("interrupt request\n");
+	show_regs(pt_regs);
+	bad_mode();
+}
+
+
+static ulong timestamp;
+static ulong lastinc;
+static gptimer_t *timer_base = (gptimer_t *)CONFIG_SYS_TIMERBASE;
+
+/* nothing really to do with interrupts, just starts up a counter. */
+int interrupt_init(void)
+{
+	/* start the counter ticking up, reload value on overflow */
+	writel(TIMER_LOAD_VAL, &timer_base->tldr);
+	/* enable timer */
+	writel((CONFIG_SYS_PVT << 2) | TCLR_PRE | TCLR_AR | TCLR_ST,
+		&timer_base->tclr);
+
+	reset_timer_masked();	/* init the timestamp and lastinc value */
+
+	return 0;
+}
+
+/*
+ * timer without interrupts
+ */
+void reset_timer(void)
+{
+	reset_timer_masked();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked() - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+void udelay(unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	/* if "big" number, spread normalization to seconds */
+	if (usec >= 1000) {
+		/* if "big" number, spread normalization to seconds */
+		tmo = usec / 1000;
+		/* find number of "ticks" to wait to achieve target */
+		tmo *= CONFIG_SYS_HZ;
+		tmo /= 1000;	/* finish normalize. */
+	} else {/* else small number, don't kill it prior to HZ multiply */
+		tmo = usec * CONFIG_SYS_HZ;
+		tmo /= (1000 * 1000);
+	}
+
+	tmp = get_timer(0);	/* get current timestamp */
+	/* if setting this forward will roll time stamp */
+	if ((tmo + tmp + 1) < tmp)
+		/* reset "advancing" timestamp to 0, set lastinc value */
+		reset_timer_masked();
+	else
+		tmo += tmp;	/* else, set advancing stamp wake up time */
+	while (get_timer_masked() < tmo)	/* loop till event */
+		 /*NOP*/;
+}
+
+void reset_timer_masked(void)
+{
+	/* reset time, capture current incrementer value time */
+	lastinc = readl(&timer_base->tcrr);
+	timestamp = 0;		/* start "advancing" time stamp from 0 */
+}
+
+ulong get_timer_masked(void)
+{
+	ulong now = readl(&timer_base->tcrr); /* current tick value */
+
+	if (now >= lastinc)	/* normal mode (non roll) */
+		/* move stamp fordward with absoulte diff ticks */
+		timestamp += (now - lastinc);
+	else	/* we have rollover of incrementer */
+		timestamp += (0xFFFFFFFF - lastinc) + now;
+	lastinc = now;
+	return timestamp;
+}
+
+/* waits specified delay value and resets timestamp */
+void udelay_masked(unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	/* if "big" number, spread normalization to seconds */
+	if (usec >= 1000) {
+		/* start to normalize for usec to ticks per sec */
+		tmo = usec / 1000;
+		/* find number of "ticks" to wait to achieve target */
+		tmo *= CONFIG_SYS_HZ;
+		tmo /= 1000;	/* finish normalize. */
+	} else {		/* else small number, */
+				/* don't kill it prior to HZ multiply */
+		tmo = usec * CONFIG_SYS_HZ;
+		tmo /= (1000 * 1000);
+	}
+	endtime = get_timer_masked() + tmo;
+
+	do {
+		ulong now = get_timer_masked();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	ulong tbclk;
+	tbclk = CONFIG_SYS_HZ;
+	return tbclk;
+}
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/omap3/lowlevel_init.S u-boot/cpu/arm_cortexa8/omap3/lowlevel_init.S
--- u-boot-2009.01/cpu/arm_cortexa8/omap3/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/omap3/lowlevel_init.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,361 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Initial Code by:
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/clocks_omap3.h>
+
+_TEXT_BASE:
+	.word	TEXT_BASE	/* sdram load addr from config.mk */
+
+#if !defined(CONFIG_SYS_NAND_BOOT) && !defined(CONFIG_SYS_NAND_BOOT)
+/**************************************************************************
+ * cpy_clk_code: relocates clock code into SRAM where its safer to execute
+ * R1 = SRAM destination address.
+ *************************************************************************/
+.global cpy_clk_code
+ cpy_clk_code:
+	/* Copy DPLL code into SRAM */
+	adr	r0, go_to_speed		/* get addr of clock setting code */
+	mov	r2, #384		/* r2 size to copy (div by 32 bytes) */
+	mov	r1, r1			/* r1 <- dest address (passed in) */
+	add	r2, r2, r0		/* r2 <- source end address */
+next2:
+	ldmia	r0!, {r3 - r10}		/* copy from source address [r0] */
+	stmia	r1!, {r3 - r10}		/* copy to   target address [r1] */
+	cmp	r0, r2			/* until source end address [r2] */
+	bne	next2
+	mov	pc, lr			/* back to caller */
+
+/* ***************************************************************************
+ *  go_to_speed: -Moves to bypass, -Commits clock dividers, -puts dpll at speed
+ *               -executed from SRAM.
+ *  R0 = CM_CLKEN_PLL-bypass value
+ *  R1 = CM_CLKSEL1_PLL-m, n, and divider values
+ *  R2 = CM_CLKSEL_CORE-divider values
+ *  R3 = CM_IDLEST_CKGEN - addr dpll lock wait
+ *
+ *  Note: If core unlocks/relocks and SDRAM is running fast already it gets
+ *        confused.  A reset of the controller gets it back.  Taking away its
+ *        L3 when its not in self refresh seems bad for it.  Normally, this
+ *	  code runs from flash before SDR is init so that should be ok.
+ ****************************************************************************/
+.global go_to_speed
+ go_to_speed:
+	stmfd sp!, {r4 - r6}
+
+	/* move into fast relock bypass */
+	ldr	r4, pll_ctl_add
+	str	r0, [r4]
+wait1:
+	ldr	r5, [r3]		/* get status */
+	and	r5, r5, #0x1		/* isolate core status */
+	cmp	r5, #0x1		/* still locked? */
+	beq	wait1			/* if lock, loop */
+
+	/* set new dpll dividers _after_ in bypass */
+	ldr	r5, pll_div_add1
+	str	r1, [r5]		/* set m, n, m2 */
+	ldr	r5, pll_div_add2
+	str	r2, [r5]		/* set l3/l4/.. dividers*/
+	ldr	r5, pll_div_add3	/* wkup */
+	ldr	r2, pll_div_val3	/* rsm val */
+	str	r2, [r5]
+	ldr	r5, pll_div_add4	/* gfx */
+	ldr	r2, pll_div_val4
+	str	r2, [r5]
+	ldr	r5, pll_div_add5	/* emu */
+	ldr	r2, pll_div_val5
+	str	r2, [r5]
+
+	/* now prepare GPMC (flash) for new dpll speed */
+	/* flash needs to be stable when we jump back to it */
+	ldr	r5, flash_cfg3_addr
+	ldr	r2, flash_cfg3_val
+	str	r2, [r5]
+	ldr	r5, flash_cfg4_addr
+	ldr	r2, flash_cfg4_val
+	str	r2, [r5]
+	ldr	r5, flash_cfg5_addr
+	ldr	r2, flash_cfg5_val
+	str	r2, [r5]
+	ldr	r5, flash_cfg1_addr
+	ldr	r2, [r5]
+	orr	r2, r2, #0x3		/* up gpmc divider */
+	str	r2, [r5]
+
+	/* lock DPLL3 and wait a bit */
+	orr	r0, r0, #0x7	/* set up for lock mode */
+	str	r0, [r4]	/* lock */
+	nop			/* ARM slow at this point working at sys_clk */
+	nop
+	nop
+	nop
+wait2:
+	ldr	r5, [r3]	/* get status */
+	and	r5, r5, #0x1	/* isolate core status */
+	cmp	r5, #0x1	/* still locked? */
+	bne	wait2		/* if lock, loop */
+	nop
+	nop
+	nop
+	nop
+	ldmfd	sp!, {r4 - r6}
+	mov	pc, lr		/* back to caller, locked */
+
+_go_to_speed: .word go_to_speed
+
+/* these constants need to be close for PIC code */
+/* The Nor has to be in the Flash Base CS0 for this condition to happen */
+flash_cfg1_addr:
+	.word (GPMC_CONFIG_CS0 + GPMC_CONFIG1)
+flash_cfg3_addr:
+	.word (GPMC_CONFIG_CS0 + GPMC_CONFIG3)
+flash_cfg3_val:
+	.word STNOR_GPMC_CONFIG3
+flash_cfg4_addr:
+	.word (GPMC_CONFIG_CS0 + GPMC_CONFIG4)
+flash_cfg4_val:
+	.word STNOR_GPMC_CONFIG4
+flash_cfg5_val:
+	.word STNOR_GPMC_CONFIG5
+flash_cfg5_addr:
+	.word (GPMC_CONFIG_CS0 + GPMC_CONFIG5)
+pll_ctl_add:
+	.word CM_CLKEN_PLL
+pll_div_add1:
+	.word CM_CLKSEL1_PLL
+pll_div_add2:
+	.word CM_CLKSEL_CORE
+pll_div_add3:
+	.word CM_CLKSEL_WKUP
+pll_div_val3:
+	.word (WKUP_RSM << 1)
+pll_div_add4:
+	.word CM_CLKSEL_GFX
+pll_div_val4:
+	.word (GFX_DIV << 0)
+pll_div_add5:
+	.word CM_CLKSEL1_EMU
+pll_div_val5:
+	.word CLSEL1_EMU_VAL
+
+#endif
+
+.globl lowlevel_init
+lowlevel_init:
+	ldr	sp, SRAM_STACK
+	str	ip, [sp]	/* stash old link register */
+	mov	ip, lr		/* save link reg across call */
+	bl	s_init		/* go setup pll, mux, memory */
+	ldr	ip, [sp]	/* restore save ip */
+	mov	lr, ip		/* restore link reg */
+
+	/* back to arch calling code */
+	mov	pc, lr
+
+	/* the literal pools origin */
+	.ltorg
+
+REG_CONTROL_STATUS:
+	.word CONTROL_STATUS
+SRAM_STACK:
+	.word LOW_LEVEL_SRAM_STACK
+
+/* DPLL(1-4) PARAM TABLES */
+
+/*
+ * Each of the tables has M, N, FREQSEL, M2 values defined for nominal
+ * OPP (1.2V). The fields are defined according to dpll_param struct (clock.c).
+ * The values are defined for all possible sysclk and for ES1 and ES2.
+ */
+
+mpu_dpll_param:
+/* 12MHz */
+/* ES1 */
+.word MPU_M_12_ES1, MPU_N_12_ES1, MPU_FSEL_12_ES1, MPU_M2_12_ES1
+/* ES2 */
+.word MPU_M_12_ES2, MPU_N_12_ES2, MPU_FSEL_12_ES2, MPU_M2_ES2
+/* 3410 */
+.word MPU_M_12, MPU_N_12, MPU_FSEL_12, MPU_M2_12
+
+/* 13MHz */
+/* ES1 */
+.word MPU_M_13_ES1, MPU_N_13_ES1, MPU_FSEL_13_ES1, MPU_M2_13_ES1
+/* ES2 */
+.word MPU_M_13_ES2, MPU_N_13_ES2, MPU_FSEL_13_ES2, MPU_M2_13_ES2
+/* 3410 */
+.word MPU_M_13, MPU_N_13, MPU_FSEL_13, MPU_M2_13
+
+/* 19.2MHz */
+/* ES1 */
+.word MPU_M_19P2_ES1, MPU_N_19P2_ES1, MPU_FSEL_19P2_ES1, MPU_M2_19P2_ES1
+/* ES2 */
+.word MPU_M_19P2_ES2, MPU_N_19P2_ES2, MPU_FSEL_19P2_ES2, MPU_M2_19P2_ES2
+/* 3410 */
+.word MPU_M_19P2, MPU_N_19P2, MPU_FSEL_19P2, MPU_M2_19P2
+
+/* 26MHz */
+/* ES1 */
+.word MPU_M_26_ES1, MPU_N_26_ES1, MPU_FSEL_26_ES1, MPU_M2_26_ES1
+/* ES2 */
+.word MPU_M_26_ES2, MPU_N_26_ES2, MPU_FSEL_26_ES2, MPU_M2_26_ES2
+/* 3410 */
+.word MPU_M_26, MPU_N_26, MPU_FSEL_26, MPU_M2_26
+
+/* 38.4MHz */
+/* ES1 */
+.word MPU_M_38P4_ES1, MPU_N_38P4_ES1, MPU_FSEL_38P4_ES1, MPU_M2_38P4_ES1
+/* ES2 */
+.word MPU_M_38P4_ES2, MPU_N_38P4_ES2, MPU_FSEL_38P4_ES2, MPU_M2_38P4_ES2
+/* 3410 */
+.word MPU_M_38P4, MPU_N_38P4, MPU_FSEL_38P4, MPU_M2_38P4
+
+
+.globl get_mpu_dpll_param
+get_mpu_dpll_param:
+	adr	r0, mpu_dpll_param
+	mov	pc, lr
+
+iva_dpll_param:
+/* 12MHz */
+/* ES1 */
+.word IVA_M_12_ES1, IVA_N_12_ES1, IVA_FSEL_12_ES1, IVA_M2_12_ES1
+/* ES2 */
+.word IVA_M_12_ES2, IVA_N_12_ES2, IVA_FSEL_12_ES2, IVA_M2_12_ES2
+/* 3410 */
+.word IVA_M_12, IVA_N_12, IVA_FSEL_12, IVA_M2_12
+
+/* 13MHz */
+/* ES1 */
+.word IVA_M_13_ES1, IVA_N_13_ES1, IVA_FSEL_13_ES1, IVA_M2_13_ES1
+/* ES2 */
+.word IVA_M_13_ES2, IVA_N_13_ES2,  IVA_FSEL_13_ES2, IVA_M2_13_ES2
+/* 3410 */
+.word IVA_M_13, IVA_N_13, IVA_FSEL_13, IVA_M2_13
+
+/* 19.2MHz */
+/* ES1 */
+.word IVA_M_19P2_ES1, IVA_N_19P2_ES1, IVA_FSEL_19P2_ES1, IVA_M2_19P2_ES1
+/* ES2 */
+.word IVA_M_19P2_ES2, IVA_N_19P2_ES2, IVA_FSEL_19P2_ES2, IVA_M2_19P2_ES2
+/* 3410 */
+.word IVA_M_19P2, IVA_N_19P2, IVA_FSEL_19P2, IVA_M2_19P2
+
+/* 26MHz */
+/* ES1 */
+.word IVA_M_26_ES1, IVA_N_26_ES1, IVA_FSEL_26_ES1, IVA_M2_26_ES1
+/* ES2 */
+.word IVA_M_26_ES2, IVA_N_26_ES2, IVA_FSEL_26_ES2, IVA_M2_26_ES2
+/* 3410 */
+.word IVA_M_26, IVA_N_26, IVA_FSEL_26, IVA_M2_26
+
+/* 38.4MHz */
+/* ES1 */
+.word IVA_M_38P4_ES1, IVA_N_38P4_ES1, IVA_FSEL_38P4_ES1, IVA_M2_38P4_ES1
+/* ES2 */
+.word IVA_M_38P4_ES2, IVA_N_38P4_ES2, IVA_FSEL_38P4_ES2, IVA_M2_38P4_ES2
+/* 3410 */
+.word IVA_M_38P4, IVA_N_38P4, IVA_FSEL_38P4, IVA_M2_38P4
+
+
+.globl get_iva_dpll_param
+get_iva_dpll_param:
+	adr	r0, iva_dpll_param
+	mov	pc, lr
+
+/* Core DPLL targets for L3 at 166 & L133 */
+core_dpll_param:
+/* 12MHz */
+/* ES1 */
+.word CORE_M_12_ES1, CORE_N_12_ES1, CORE_FSL_12_ES1, CORE_M2_12_ES1
+/* ES2 */
+.word CORE_M_12, CORE_N_12, CORE_FSEL_12, CORE_M2_12
+/* 3410 */
+.word CORE_M_12, CORE_N_12, CORE_FSEL_12, CORE_M2_12
+
+/* 13MHz */
+/* ES1 */
+.word CORE_M_13_ES1, CORE_N_13_ES1, CORE_FSL_13_ES1, CORE_M2_13_ES1
+/* ES2 */
+.word CORE_M_13, CORE_N_13, CORE_FSEL_13, CORE_M2_13
+/* 3410 */
+.word CORE_M_13, CORE_N_13, CORE_FSEL_13, CORE_M2_13
+
+/* 19.2MHz */
+/* ES1 */
+.word CORE_M_19P2_ES1, CORE_N_19P2_ES1, CORE_FSL_19P2_ES1, CORE_M2_19P2_ES1
+/* ES2 */
+.word CORE_M_19P2, CORE_N_19P2, CORE_FSEL_19P2, CORE_M2_19P2
+/* 3410 */
+.word CORE_M_19P2, CORE_N_19P2, CORE_FSEL_19P2, CORE_M2_19P2
+
+/* 26MHz */
+/* ES1 */
+.word CORE_M_26_ES1, CORE_N_26_ES1, CORE_FSL_26_ES1, CORE_M2_26_ES1
+/* ES2 */
+.word CORE_M_26, CORE_N_26, CORE_FSEL_26, CORE_M2_26
+/* 3410 */
+.word CORE_M_26, CORE_N_26, CORE_FSEL_26, CORE_M2_26
+
+/* 38.4MHz */
+/* ES1 */
+.word CORE_M_38P4_ES1, CORE_N_38P4_ES1, CORE_FSL_38P4_ES1, CORE_M2_38P4_ES1
+/* ES2 */
+.word CORE_M_38P4, CORE_N_38P4, CORE_FSEL_38P4, CORE_M2_38P4
+/* 3410 */
+.word CORE_M_38P4, CORE_N_38P4, CORE_FSEL_38P4, CORE_M2_38P4
+
+.globl get_core_dpll_param
+get_core_dpll_param:
+	adr	r0, core_dpll_param
+	mov	pc, lr
+
+/* PER DPLL values are same for both ES1 and ES2 */
+per_dpll_param:
+/* 12MHz */
+.word PER_M_12, PER_N_12, PER_FSEL_12, PER_M2_12
+
+/* 13MHz */
+.word PER_M_13, PER_N_13, PER_FSEL_13, PER_M2_13
+
+/* 19.2MHz */
+.word PER_M_19P2, PER_N_19P2, PER_FSEL_19P2, PER_M2_19P2
+
+/* 26MHz */
+.word PER_M_26, PER_N_26, PER_FSEL_26, PER_M2_26
+
+/* 38.4MHz */
+.word PER_M_38P4, PER_N_38P4, PER_FSEL_38P4, PER_M2_38P4
+
+.globl get_per_dpll_param
+get_per_dpll_param:
+	adr	r0, per_dpll_param
+	mov	pc, lr
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/omap3/Makefile u-boot/cpu/arm_cortexa8/omap3/Makefile
--- u-boot-2009.01/cpu/arm_cortexa8/omap3/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/omap3/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,46 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	=  $(obj)lib$(SOC).a
+
+SOBJS	:= lowlevel_init.o
+COBJS	:= sys_info.o board.o clock.o interrupts.o mem.o syslib.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+
+all:	 $(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/omap3/mem.c u-boot/cpu/arm_cortexa8/omap3/mem.c
--- u-boot-2009.01/cpu/arm_cortexa8/omap3/mem.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/omap3/mem.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,284 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Author :
+ *     Manikandan Pillai <mani.pillai@ti.com>
+ *
+ * Initial Code from:
+ *     Richard Woodruff <r-woodruff2@ti.com>
+ *     Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/sys_proto.h>
+#include <command.h>
+
+/*
+ * Only One NAND allowed on board at a time.
+ * The GPMC CS Base for the same
+ */
+unsigned int boot_flash_base;
+unsigned int boot_flash_off;
+unsigned int boot_flash_sec;
+unsigned int boot_flash_type;
+volatile unsigned int boot_flash_env_addr;
+
+#if defined(CONFIG_CMD_NAND)
+static u32 gpmc_m_nand[GPMC_MAX_REG] = {
+	M_NAND_GPMC_CONFIG1,
+	M_NAND_GPMC_CONFIG2,
+	M_NAND_GPMC_CONFIG3,
+	M_NAND_GPMC_CONFIG4,
+	M_NAND_GPMC_CONFIG5,
+	M_NAND_GPMC_CONFIG6, 0
+};
+
+gpmc_csx_t *nand_cs_base;
+gpmc_t *gpmc_cfg_base;
+
+#if defined(CONFIG_ENV_IS_IN_NAND)
+#define GPMC_CS 0
+#else
+#define GPMC_CS 1
+#endif
+
+#endif
+
+#if defined(CONFIG_CMD_ONENAND)
+static u32 gpmc_onenand[GPMC_MAX_REG] = {
+	ONENAND_GPMC_CONFIG1,
+	ONENAND_GPMC_CONFIG2,
+	ONENAND_GPMC_CONFIG3,
+	ONENAND_GPMC_CONFIG4,
+	ONENAND_GPMC_CONFIG5,
+	ONENAND_GPMC_CONFIG6, 0
+};
+
+gpmc_csx_t *onenand_cs_base;
+
+#if defined(CONFIG_ENV_IS_IN_ONENAND)
+#define GPMC_CS 0
+#else
+#define GPMC_CS 1
+#endif
+
+#endif
+
+static sdrc_t *sdrc_base = (sdrc_t *)OMAP34XX_SDRC_BASE;
+
+/**************************************************************************
+ * make_cs1_contiguous() - for es2 and above remap cs1 behind cs0 to allow
+ *  command line mem=xyz use all memory with out discontinuous support
+ *  compiled in.  Could do it at the ATAG, but there really is two banks...
+ * Called as part of 2nd phase DDR init.
+ **************************************************************************/
+void make_cs1_contiguous(void)
+{
+	u32 size, a_add_low, a_add_high;
+
+	size = get_sdr_cs_size(CS0);
+	size /= SZ_32M;			/* find size to offset CS1 */
+	a_add_high = (size & 3) << 8;	/* set up low field */
+	a_add_low = (size & 0x3C) >> 2;	/* set up high field */
+	writel((a_add_high | a_add_low), &sdrc_base->cs_cfg);
+
+}
+
+/********************************************************
+ *  mem_ok() - test used to see if timings are correct
+ *             for a part. Helps in guessing which part
+ *             we are currently using.
+ *******************************************************/
+u32 mem_ok(u32 cs)
+{
+	u32 val1, val2, addr;
+	u32 pattern = 0x12345678;
+
+	addr = OMAP34XX_SDRC_CS0 + get_sdr_cs_offset(cs);
+
+	writel(0x0, addr + 0x400);	/* clear pos A */
+	writel(pattern, addr);		/* pattern to pos B */
+	writel(0x0, addr + 4);		/* remove pattern off the bus */
+	val1 = readl(addr + 0x400);	/* get pos A value */
+	val2 = readl(addr);		/* get val2 */
+
+	if ((val1 != 0) || (val2 != pattern))	/* see if pos A val changed */
+		return 0;
+	else
+		return 1;
+}
+
+/********************************************************
+ *  sdrc_init() - init the sdrc chip selects CS0 and CS1
+ *  - early init routines, called from flash or
+ *  SRAM.
+ *******************************************************/
+void sdrc_init(void)
+{
+	/* only init up first bank here */
+	do_sdrc_init(CS0, EARLY_INIT);
+}
+
+/*************************************************************************
+ * do_sdrc_init(): initialize the SDRAM for use.
+ *  -code sets up SDRAM basic SDRC timings for CS0
+ *  -optimal settings can be placed here, or redone after i2c
+ *      inspection of board info
+ *
+ *  - code called once in C-Stack only context for CS0 and a possible 2nd
+ *      time depending on memory configuration from stack+global context
+ **************************************************************************/
+
+void do_sdrc_init(u32 cs, u32 early)
+{
+	sdrc_actim_t *sdrc_actim_base;
+
+	if(cs)
+		sdrc_actim_base = (sdrc_actim_t *)SDRC_ACTIM_CTRL1_BASE;
+	else
+		sdrc_actim_base = (sdrc_actim_t *)SDRC_ACTIM_CTRL0_BASE;
+
+	if (early) {
+		/* reset sdrc controller */
+		writel(SOFTRESET, &sdrc_base->sysconfig);
+		wait_on_value(RESETDONE, RESETDONE, &sdrc_base->status,
+			      12000000);
+		writel(0, &sdrc_base->sysconfig);
+
+		/* setup sdrc to ball mux */
+		writel(SDP_SDRC_SHARING, &sdrc_base->sharing);
+
+		/* Disable Power Down of CKE cuz of 1 CKE on combo part */
+		writel(SRFRONRESET | PAGEPOLICY_HIGH, &sdrc_base->power);
+
+		writel(ENADLL | DLLPHASE_90, &sdrc_base->dlla_ctrl);
+		sdelay(0x20000);
+	}
+
+	writel(RASWIDTH_13BITS | CASWIDTH_10BITS | ADDRMUXLEGACY |
+		RAMSIZE_128 | BANKALLOCATION | B32NOT16 | B32NOT16 |
+		DEEPPD | DDR_SDRAM, &sdrc_base->cs[cs].mcfg);
+	writel(ARCV | ARE_ARCV_1, &sdrc_base->cs[cs].rfr_ctrl);
+	writel(V_ACTIMA_165, &sdrc_actim_base->ctrla);
+	writel(V_ACTIMB_165, &sdrc_actim_base->ctrlb);
+
+	writel(CMD_NOP, &sdrc_base ->cs[cs].manual);
+	writel(CMD_PRECHARGE, &sdrc_base->cs[cs].manual);
+	writel(CMD_AUTOREFRESH, &sdrc_base->cs[cs].manual);
+	writel(CMD_AUTOREFRESH, &sdrc_base->cs[cs].manual);
+
+	/*
+	 * CAS latency 3, Write Burst = Read Burst, Serial Mode,
+	 * Burst length = 4
+	 */
+	writel(CASL3 | BURSTLENGTH4, &sdrc_base->cs[cs].mr);
+
+	if (!mem_ok(cs))
+		writel(0, &sdrc_base->cs[cs].mcfg);
+}
+
+void enable_gpmc_config(u32 *gpmc_config, gpmc_csx_t *gpmc_cs_base, u32 base,
+			u32 size)
+{
+	writel(0, &gpmc_cs_base->config7);
+	sdelay(1000);
+	/* Delay for settling */
+	writel(gpmc_config[0], &gpmc_cs_base->config1);
+	writel(gpmc_config[1], &gpmc_cs_base->config2);
+	writel(gpmc_config[2], &gpmc_cs_base->config3);
+	writel(gpmc_config[3], &gpmc_cs_base->config4);
+	writel(gpmc_config[4], &gpmc_cs_base->config5);
+	writel(gpmc_config[5], &gpmc_cs_base->config6);
+	/* Enable the config */
+	writel((((size & 0xF) << 8) | ((base >> 24) & 0x3F) |
+		(1 << 6)), &gpmc_cs_base->config7);
+	sdelay(2000);
+}
+
+/*****************************************************
+ * gpmc_init(): init gpmc bus
+ * Init GPMC for x16, MuxMode (SDRAM in x32).
+ * This code can only be executed from SRAM or SDRAM.
+ *****************************************************/
+void gpmc_init(void)
+{
+	/* putting a blanket check on GPMC based on ZeBu for now */
+	u32 *gpmc_config = NULL;
+	gpmc_t *gpmc_base = (gpmc_t *)GPMC_BASE;
+	gpmc_csx_t *gpmc_cs_base = (gpmc_csx_t *)GPMC_CONFIG_CS0_BASE;
+	u32 base = 0;
+	u32 size = 0;
+	u32 f_off = CONFIG_SYS_MONITOR_LEN;
+	u32 f_sec = 0;
+	u32 config = 0;
+
+	/* global settings */
+	writel(0, &gpmc_base->irqenable); /* isr's sources masked */
+	writel(0, &gpmc_base->timeout_control);/* timeout disable */
+
+	config = readl(&gpmc_base->config);
+	config &= (~0xf00);
+	writel(config, &gpmc_base->config);
+
+	/*
+	 * Disable the GPMC0 config set by ROM code
+	 * It conflicts with our MPDB (both at 0x08000000)
+	 */
+	writel(0, &gpmc_cs_base->config7);
+	sdelay(1000);
+
+#if defined(CONFIG_CMD_NAND)	/* CS 0 */
+	gpmc_config = gpmc_m_nand;
+	gpmc_cfg_base = gpmc_base;
+	nand_cs_base = (gpmc_csx_t *)(GPMC_CONFIG_CS0_BASE +
+					(GPMC_CS * GPMC_CONFIG_WIDTH));
+	base = PISMO1_NAND_BASE;
+	size = PISMO1_NAND_SIZE;
+	enable_gpmc_config(gpmc_config, nand_cs_base, base, size);
+#if defined(CONFIG_ENV_IS_IN_NAND)
+	f_off = SMNAND_ENV_OFFSET;
+	f_sec = SZ_128K;
+	/* env setup */
+	boot_flash_base = base;
+	boot_flash_off = f_off;
+	boot_flash_sec = f_sec;
+	boot_flash_env_addr = f_off;
+#endif
+#endif
+
+#if defined(CONFIG_CMD_ONENAND)
+	gpmc_config = gpmc_onenand;
+	onenand_cs_base = (gpmc_csx_t *)(GPMC_CONFIG_CS0_BASE +
+					(GPMC_CS * GPMC_CONFIG_WIDTH));
+	base = PISMO1_ONEN_BASE;
+	size = PISMO1_ONEN_SIZE;
+	enable_gpmc_config(gpmc_config, onenand_cs_base, base, size);
+#if defined(CONFIG_ENV_IS_IN_ONENAND)
+	f_off = ONENAND_ENV_OFFSET;
+	f_sec = SZ_128K;
+	/* env setup */
+	boot_flash_base = base;
+	boot_flash_off = f_off;
+	boot_flash_sec = f_sec;
+	boot_flash_env_addr = f_off;
+#endif
+#endif
+}
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/omap3/sys_info.c u-boot/cpu/arm_cortexa8/omap3/sys_info.c
--- u-boot-2009.01/cpu/arm_cortexa8/omap3/sys_info.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/omap3/sys_info.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,281 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Author :
+ *      Manikandan Pillai <mani.pillai@ti.com>
+ *
+ * Derived from Beagle Board and 3430 SDP code by
+ *      Richard Woodruff <r-woodruff2@ti.com>
+ *      Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>	/* get mem tables */
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+
+extern omap3_sysinfo sysinfo;
+static gpmc_csx_t *gpmc_cs_base = (gpmc_csx_t *)GPMC_CONFIG_CS0_BASE;
+static sdrc_t *sdrc_base = (sdrc_t *)OMAP34XX_SDRC_BASE;
+static ctrl_t *ctrl_base = (ctrl_t *)OMAP34XX_CTRL_BASE;
+
+/******************************************
+ * get_cpu_type(void) - extract cpu info
+ ******************************************/
+u32 get_cpu_type(void)
+{
+	return readl(&ctrl_base->ctrl_omap_stat);
+}
+
+/******************************************
+ * get_cpu_rev(void) - extract version info
+ ******************************************/
+u32 get_cpu_rev(void)
+{
+	u32 cpuid = 0;
+
+	/*
+	 * On ES1.0 the IDCODE register is not exposed on L4
+	 * so using CPU ID to differentiate
+	 * between ES2.0 and ES1.0.
+	 */
+	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 0":"=r"(cpuid));
+	if ((cpuid & 0xf) == 0x0)
+		return CPU_3430_ES1;
+	else
+		return CPU_3430_ES2;
+
+}
+
+/****************************************************
+ * is_mem_sdr() - return 1 if mem type in use is SDR
+ ****************************************************/
+u32 is_mem_sdr(void)
+{
+	if (readl(&sdrc_base->cs[CS0].mr) == SDP_SDRC_MR_0_SDR)
+		return 1;
+	return 0;
+}
+
+/***********************************************************************
+ * get_cs0_size() - get size of chip select 0/1
+ ************************************************************************/
+u32 get_sdr_cs_size(u32 cs)
+{
+	u32 size;
+
+	/* get ram size field */
+	size = readl(&sdrc_base->cs[cs].mcfg) >> 8;
+	size &= 0x3FF;		/* remove unwanted bits */
+	size *= SZ_2M;		/* find size in MB */
+	return size;
+}
+
+/***********************************************************************
+ * get_sdr_cs_offset() - get offset of cs from cs0 start
+ ************************************************************************/
+u32 get_sdr_cs_offset(u32 cs)
+{
+	u32 offset;
+
+	if (!cs)
+		return 0;
+
+	offset = readl(&sdrc_base->cs_cfg);
+	offset = (offset & 15) << 27 | (offset & 0x30) >> 17;
+
+	return offset;
+}
+
+/***********************************************************************
+ * get_board_type() - get board type based on current production stats.
+ *  - NOTE-1-: 2 I2C EEPROMs will someday be populated with proper info.
+ *    when they are available we can get info from there.  This should
+ *    be correct of all known boards up until today.
+ *  - NOTE-2- EEPROMs are populated but they are updated very slowly.  To
+ *    avoid waiting on them we will use ES version of the chip to get info.
+ *    A later version of the FPGA migth solve their speed issue.
+ ************************************************************************/
+u32 get_board_type(void)
+{
+	if (get_cpu_rev() == CPU_3430_ES2)
+		return sysinfo.board_type_v2;
+	else
+		return sysinfo.board_type_v1;
+}
+
+/***************************************************************************
+ *  get_gpmc0_base() - Return current address hardware will be
+ *     fetching from. The below effectively gives what is correct, its a bit
+ *   mis-leading compared to the TRM.  For the most general case the mask
+ *   needs to be also taken into account this does work in practice.
+ *   - for u-boot we currently map:
+ *       -- 0 to nothing,
+ *       -- 4 to flash
+ *       -- 8 to enent
+ *       -- c to wifi
+ ****************************************************************************/
+u32 get_gpmc0_base(void)
+{
+	u32 b;
+
+	b = readl(&gpmc_cs_base->config7);
+	b &= 0x1F;		/* keep base [5:0] */
+	b = b << 24;		/* ret 0x0b000000 */
+	return b;
+}
+
+/*******************************************************************
+ * get_gpmc0_width() - See if bus is in x8 or x16 (mainly for nand)
+ *******************************************************************/
+u32 get_gpmc0_width(void)
+{
+	return WIDTH_16BIT;
+}
+
+/*************************************************************************
+ * get_board_rev() - setup to pass kernel board revision information
+ * returns:(bit[0-3] sub version, higher bit[7-4] is higher version)
+ *************************************************************************/
+u32 get_board_rev(void)
+{
+	return 0x20;
+}
+
+/*********************************************************************
+ *  display_board_info() - print banner with board info.
+ *********************************************************************/
+void display_board_info(u32 btype)
+{
+	char *cpu_s, *mem_s, *sec_s;
+
+	switch (get_cpu_type()) {
+	case OMAP3503:
+		cpu_s = "3503";
+		break;
+	case OMAP3515:
+		cpu_s = "3515";
+		break;
+	case OMAP3525:
+		cpu_s = "3525";
+		break;
+	case OMAP3530:
+		cpu_s = "3530";
+		break;
+	default:
+		cpu_s = "35XX";
+		break;
+	}
+
+	if (is_mem_sdr())
+		mem_s = "mSDR";
+	else
+		mem_s = "LPDDR";
+
+	switch (get_device_type()) {
+	case TST_DEVICE:
+		sec_s = "TST";
+		break;
+	case EMU_DEVICE:
+		sec_s = "EMU";
+		break;
+	case HS_DEVICE:
+		sec_s = "HS";
+		break;
+	case GP_DEVICE:
+		sec_s = "GP";
+		break;
+	default:
+		sec_s = "?";
+	}
+
+
+	printf("OMAP%s-%s rev %d, CPU-OPP2 L3-165MHz\n", cpu_s,
+	       sec_s, get_cpu_rev());
+	printf("%s + %s/%s\n", sysinfo.board_string,
+	       mem_s, sysinfo.nand_string);
+
+}
+
+/********************************************************
+ *  get_base(); get upper addr of current execution
+ *******************************************************/
+u32 get_base(void)
+{
+	u32 val;
+
+	__asm__ __volatile__("mov %0, pc \n":"=r"(val)::"memory");
+	val &= 0xF0000000;
+	val >>= 28;
+	return val;
+}
+
+/********************************************************
+ *  is_running_in_flash() - tell if currently running in
+ *  FLASH.
+ *******************************************************/
+u32 is_running_in_flash(void)
+{
+	if (get_base() < 4)
+		return 1;	/* in FLASH */
+
+	return 0;		/* running in SRAM or SDRAM */
+}
+
+/********************************************************
+ *  is_running_in_sram() - tell if currently running in
+ *  SRAM.
+ *******************************************************/
+u32 is_running_in_sram(void)
+{
+	if (get_base() == 4)
+		return 1;	/* in SRAM */
+
+	return 0;		/* running in FLASH or SDRAM */
+}
+
+/********************************************************
+ *  is_running_in_sdram() - tell if currently running in
+ *  SDRAM.
+ *******************************************************/
+u32 is_running_in_sdram(void)
+{
+	if (get_base() > 4)
+		return 1;	/* in SDRAM */
+
+	return 0;		/* running in SRAM or FLASH */
+}
+
+/***************************************************************
+ *  get_boot_type() - Is this an XIP type device or a stream one
+ *  bits 4-0 specify type. Bit 5 says mem/perif
+ ***************************************************************/
+u32 get_boot_type(void)
+{
+	return (readl(&ctrl_base->status) & SYSBOOT_MASK);
+}
+
+/*************************************************************
+ *  get_device_type(): tell if GP/HS/EMU/TST
+ *************************************************************/
+u32 get_device_type(void)
+{
+	return ((readl(&ctrl_base->status) & (DEVICE_MASK)) >> 8);
+}
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/omap3/syslib.c u-boot/cpu/arm_cortexa8/omap3/syslib.c
--- u-boot-2009.01/cpu/arm_cortexa8/omap3/syslib.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/omap3/syslib.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,72 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/clocks.h>
+#include <asm/arch/sys_proto.h>
+
+/************************************************************
+ * sdelay() - simple spin loop.  Will be constant time as
+ *  its generally used in bypass conditions only.  This
+ *  is necessary until timers are accessible.
+ *
+ *  not inline to increase chances its in cache when called
+ *************************************************************/
+void sdelay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
+			  "bne 1b":"=r" (loops):"0"(loops));
+}
+
+/*****************************************************************
+ * sr32 - clear & set a value in a bit range for a 32 bit address
+ *****************************************************************/
+void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
+{
+	u32 tmp, msk = 0;
+	msk = 1 << num_bits;
+	--msk;
+	tmp = readl((u32)addr) & ~(msk << start_bit);
+	tmp |= value << start_bit;
+	writel(tmp, (u32)addr);
+}
+
+/*********************************************************************
+ * wait_on_value() - common routine to allow waiting for changes in
+ *   volatile regs.
+ *********************************************************************/
+u32 wait_on_value(u32 read_bit_mask, u32 match_value, void *read_addr,
+		  u32 bound)
+{
+	u32 i = 0, val;
+	do {
+		++i;
+		val = readl((u32)read_addr) & read_bit_mask;
+		if (val == match_value)
+			return 1;
+		if (i == bound)
+			return 0;
+	} while (1);
+}
diff -Naur u-boot-2009.01/cpu/arm_cortexa8/start.S u-boot/cpu/arm_cortexa8/start.S
--- u-boot-2009.01/cpu/arm_cortexa8/start.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/arm_cortexa8/start.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,516 @@
+/*
+ * armboot - Startup Code for OMAP3530/ARM Cortex CPU-core
+ *
+ * Copyright (c) 2004	Texas Instruments <r-woodruff2@ti.com>
+ *
+ * Copyright (c) 2001	Marius Grger <mag@sysgo.de>
+ * Copyright (c) 2002	Alex Zpke <azu@sysgo.de>
+ * Copyright (c) 2002	Gary Jennejohn <gj@denx.de>
+ * Copyright (c) 2003	Richard Woodruff <r-woodruff2@ti.com>
+ * Copyright (c) 2003	Kshitij <kshitij@ti.com>
+ * Copyright (c) 2006-2008 Syed Mohammed Khasim <x0khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+.globl _start
+_start: b	reset
+	ldr	pc, _undefined_instruction
+	ldr	pc, _software_interrupt
+	ldr	pc, _prefetch_abort
+	ldr	pc, _data_abort
+	ldr	pc, _not_used
+	ldr	pc, _irq
+	ldr	pc, _fiq
+
+_undefined_instruction: .word undefined_instruction
+_software_interrupt:	.word software_interrupt
+_prefetch_abort:	.word prefetch_abort
+_data_abort:		.word data_abort
+_not_used:		.word not_used
+_irq:			.word irq
+_fiq:			.word fiq
+_pad:			.word 0x12345678 /* now 16*4=64 */
+.global _end_vect
+_end_vect:
+
+	.balignl 16,0xdeadbeef
+/*************************************************************************
+ *
+ * Startup Code (reset vector)
+ *
+ * do important init only if we don't start from memory!
+ * setup Memory and board specific bits prior to relocation.
+ * relocate armboot to ram
+ * setup stack
+ *
+ *************************************************************************/
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl _armboot_start
+_armboot_start:
+	.word _start
+
+/*
+ * These are defined in the board-specific linker script.
+ */
+.globl _bss_start
+_bss_start:
+	.word __bss_start
+
+.globl _bss_end
+_bss_end:
+	.word _end
+
+#ifdef CONFIG_USE_IRQ
+/* IRQ stack memory (calculated at run-time) */
+.globl IRQ_STACK_START
+IRQ_STACK_START:
+	.word	0x0badc0de
+
+/* IRQ stack memory (calculated at run-time) */
+.globl FIQ_STACK_START
+FIQ_STACK_START:
+	.word 0x0badc0de
+#endif
+
+/*
+ * the actual reset code
+ */
+
+reset:
+	/*
+	 * set the cpu to SVC32 mode
+	 */
+	mrs	r0, cpsr
+	bic	r0, r0, #0x1f
+	orr	r0, r0, #0xd3
+	msr	cpsr,r0
+
+#if (CONFIG_OMAP34XX)
+	/* Copy vectors to mask ROM indirect addr */
+	adr	r0, _start		@ r0 <- current position of code
+	add	r0, r0, #4		@ skip reset vector
+	mov	r2, #64			@ r2 <- size to copy
+	add	r2, r0, r2		@ r2 <- source end address
+	mov	r1, #SRAM_OFFSET0	@ build vect addr
+	mov	r3, #SRAM_OFFSET1
+	add	r1, r1, r3
+	mov	r3, #SRAM_OFFSET2
+	add	r1, r1, r3
+next:
+	ldmia	r0!, {r3 - r10}		@ copy from source address [r0]
+	stmia	r1!, {r3 - r10}		@ copy to   target address [r1]
+	cmp	r0, r2			@ until source end address [r2]
+	bne	next			@ loop until equal */
+#if !defined(CONFIG_SYS_NAND_BOOT) && !defined(CONFIG_SYS_ONENAND_BOOT)
+	/* No need to copy/exec the clock code - DPLL adjust already done
+	 * in NAND/oneNAND Boot.
+	 */
+	bl	cpy_clk_code		@ put dpll adjust code behind vectors
+#endif /* NAND Boot */
+#endif
+	/* the mask ROM code should have PLL and others stable */
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+	bl	cpu_init_crit
+#endif
+
+#ifndef CONFIG_SKIP_RELOCATE_UBOOT
+relocate:				@ relocate U-Boot to RAM
+	adr	r0, _start		@ r0 <- current position of code
+	ldr	r1, _TEXT_BASE		@ test if we run from flash or RAM
+	cmp	r0, r1			@ don't reloc during debug
+	beq	stack_setup
+
+	ldr	r2, _armboot_start
+	ldr	r3, _bss_start
+	sub	r2, r3, r2		@ r2 <- size of armboot
+	add	r2, r0, r2		@ r2 <- source end address
+
+copy_loop:				@ copy 32 bytes at a time
+	ldmia	r0!, {r3 - r10}		@ copy from source address [r0]
+	stmia	r1!, {r3 - r10}		@ copy to   target address [r1]
+	cmp	r0, r2			@ until source end addreee [r2]
+	ble	copy_loop
+#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
+
+	/* Set up the stack */
+stack_setup:
+	ldr	r0, _TEXT_BASE		@ upper 128 KiB: relocated uboot
+	sub	r0, r0, #CONFIG_SYS_MALLOC_LEN @ malloc area
+	sub	r0, r0, #CONFIG_SYS_GBL_DATA_SIZE @ bdinfo
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ + CONFIG_STACKSIZE_FIQ)
+#endif
+	sub	sp, r0, #12		@ leave 3 words for abort-stack
+	and	sp, sp, #~7		@ 8 byte alinged for (ldr/str)d
+
+	/* Clear BSS (if any). Is below tx (watch load addr - need space) */
+clear_bss:
+	ldr	r0, _bss_start		@ find start of bss segment
+	ldr	r1, _bss_end		@ stop here
+	mov	r2, #0x00000000		@ clear value
+clbss_l:
+	str	r2, [r0]		@ clear BSS location
+	cmp	r0, r1			@ are we at the end yet
+	add	r0, r0, #4		@ increment clear index pointer
+	bne	clbss_l			@ keep clearing till at end
+
+	ldr	pc, _start_armboot	@ jump to C code
+
+_start_armboot: .word start_armboot
+
+
+/*************************************************************************
+ *
+ * CPU_init_critical registers
+ *
+ * setup important registers
+ * setup memory timing
+ *
+ *************************************************************************/
+cpu_init_crit:
+	/*
+	 * Invalidate L1 I/D
+	 */
+	mov	r0, #0			@ set up for MCR
+	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+
+	/*
+	 * disable MMU stuff and caches
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
+	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
+	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
+	orr	r0, r0, #0x00000800	@ set bit 12 (Z---) BTB
+	mcr	p15, 0, r0, c1, c0, 0
+
+	/*
+	 * Jump to board specific initialization...
+	 * The Mask ROM will have already initialized
+	 * basic memory. Go here to bump up clock rate and handle
+	 * wake up conditions.
+	 */
+	mov	ip, lr			@ persevere link reg across call
+	bl	lowlevel_init		@ go setup pll,mux,memory
+	mov	lr, ip			@ restore link
+	mov	pc, lr			@ back to my caller
+/*
+ *************************************************************************
+ *
+ * Interrupt handling
+ *
+ *************************************************************************
+ */
+@
+@ IRQ stack frame.
+@
+#define S_FRAME_SIZE	72
+
+#define S_OLD_R0	68
+#define S_PSR		64
+#define S_PC		60
+#define S_LR		56
+#define S_SP		52
+
+#define S_IP		48
+#define S_FP		44
+#define S_R10		40
+#define S_R9		36
+#define S_R8		32
+#define S_R7		28
+#define S_R6		24
+#define S_R5		20
+#define S_R4		16
+#define S_R3		12
+#define S_R2		8
+#define S_R1		4
+#define S_R0		0
+
+#define MODE_SVC 0x13
+#define I_BIT	 0x80
+
+/*
+ * use bad_save_user_regs for abort/prefetch/undef/swi ...
+ * use irq_save_user_regs / irq_restore_user_regs for IRQ/FIQ handling
+ */
+
+	.macro	bad_save_user_regs
+	sub	sp, sp, #S_FRAME_SIZE		@ carve out a frame on current
+						@ user stack
+	stmia	sp, {r0 - r12}			@ Save user registers (now in
+						@ svc mode) r0-r12
+
+	ldr	r2, _armboot_start
+	sub	r2, r2, #(CONFIG_SYS_MALLOC_LEN)
+	sub	r2, r2, #(CONFIG_SYS_GBL_DATA_SIZE + 8)	@ set base 2 words into abort
+						@ stack
+	ldmia	r2, {r2 - r3}			@ get values for "aborted" pc
+						@ and cpsr (into parm regs)
+	add	r0, sp, #S_FRAME_SIZE		@ grab pointer to old stack
+
+	add	r5, sp, #S_SP
+	mov	r1, lr
+	stmia	r5, {r0 - r3}			@ save sp_SVC, lr_SVC, pc, cpsr
+	mov	r0, sp				@ save current stack into r0
+						@ (param register)
+	.endm
+
+	.macro	irq_save_user_regs
+	sub	sp, sp, #S_FRAME_SIZE
+	stmia	sp, {r0 - r12}			@ Calling r0-r12
+	add	r8, sp, #S_PC			@ !! R8 NEEDS to be saved !!
+						@ a reserved stack spot would
+						@ be good.
+	stmdb	r8, {sp, lr}^			@ Calling SP, LR
+	str	lr, [r8, #0]			@ Save calling PC
+	mrs	r6, spsr
+	str	r6, [r8, #4]			@ Save CPSR
+	str	r0, [r8, #8]			@ Save OLD_R0
+	mov	r0, sp
+	.endm
+
+	.macro	irq_restore_user_regs
+	ldmia	sp, {r0 - lr}^			@ Calling r0 - lr
+	mov	r0, r0
+	ldr	lr, [sp, #S_PC]			@ Get PC
+	add	sp, sp, #S_FRAME_SIZE
+	subs	pc, lr, #4			@ return & move spsr_svc into
+						@ cpsr
+	.endm
+
+	.macro get_bad_stack
+	ldr	r13, _armboot_start		@ setup our mode stack (enter
+						@ in banked mode)
+	sub	r13, r13, #(CONFIG_SYS_MALLOC_LEN)	@ move past malloc pool
+	sub	r13, r13, #(CONFIG_SYS_GBL_DATA_SIZE + 8) @ move to reserved a couple
+						@ spots for abort stack
+
+	str	lr, [r13]			@ save caller lr in position 0
+						@ of saved stack
+	mrs	lr, spsr			@ get the spsr
+	str	lr, [r13, #4]			@ save spsr in position 1 of
+						@ saved stack
+
+	mov	r13, #MODE_SVC			@ prepare SVC-Mode
+	@ msr	spsr_c, r13
+	msr	spsr, r13			@ switch modes, make sure
+						@ moves will execute
+	mov	lr, pc				@ capture return pc
+	movs	pc, lr				@ jump to next instruction &
+						@ switch modes.
+	.endm
+
+	.macro get_bad_stack_swi
+	sub	r13, r13, #4			@ space on current stack for
+						@ scratch reg.
+	str	r0, [r13]			@ save R0's value.
+	ldr	r0, _armboot_start		@ get data regions start
+	sub	r0, r0, #(CONFIG_SYS_MALLOC_LEN)	@ move past malloc pool
+	sub	r0, r0, #(CONFIG_SYS_GBL_DATA_SIZE + 8)	@ move past gbl and a couple
+						@ spots for abort stack
+	str	lr, [r0]			@ save caller lr in position 0
+						@ of saved stack
+	mrs	r0, spsr			@ get the spsr
+	str	lr, [r0, #4]			@ save spsr in position 1 of
+						@ saved stack
+	ldr	r0, [r13]			@ restore r0
+	add	r13, r13, #4			@ pop stack entry
+	.endm
+
+	.macro get_irq_stack			@ setup IRQ stack
+	ldr	sp, IRQ_STACK_START
+	.endm
+
+	.macro get_fiq_stack			@ setup FIQ stack
+	ldr	sp, FIQ_STACK_START
+	.endm
+
+/*
+ * exception handlers
+ */
+	.align	5
+undefined_instruction:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_undefined_instruction
+
+	.align	5
+software_interrupt:
+	get_bad_stack_swi
+	bad_save_user_regs
+	bl	do_software_interrupt
+
+	.align	5
+prefetch_abort:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_prefetch_abort
+
+	.align	5
+data_abort:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_data_abort
+
+	.align	5
+not_used:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_not_used
+
+#ifdef CONFIG_USE_IRQ
+
+	.align	5
+irq:
+	get_irq_stack
+	irq_save_user_regs
+	bl	do_irq
+	irq_restore_user_regs
+
+	.align	5
+fiq:
+	get_fiq_stack
+	/* someone ought to write a more effective fiq_save_user_regs */
+	irq_save_user_regs
+	bl	do_fiq
+	irq_restore_user_regs
+
+#else
+
+	.align	5
+irq:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_irq
+
+	.align	5
+fiq:
+	get_bad_stack
+	bad_save_user_regs
+	bl	do_fiq
+
+#endif
+
+/*
+ *	v7_flush_dcache_all()
+ *
+ *	Flush the whole D-cache.
+ *
+ *	Corrupted registers: r0-r5, r7, r9-r11
+ *
+ *	- mm	- mm_struct describing address space
+ */
+	.align 5
+.global v7_flush_dcache_all
+v7_flush_dcache_all:
+	stmfd	r13!, {r0 - r5, r7, r9 - r12, r14}
+
+	mov	r7, r0				@ take a backup of device type
+	cmp	r0, #0x3			@ check if the device type is
+						@ GP
+	moveq r12, #0x1				@ set up to invalide L2
+smi:	.word 0x01600070			@ Call SMI monitor (smieq)
+	cmp	r7, #0x3			@ compare again in case its
+						@ lost
+	beq	finished_inval			@ if GP device, inval done
+						@ above
+
+	mrc	p15, 1, r0, c0, c0, 1		@ read clidr
+	ands	r3, r0, #0x7000000		@ extract loc from clidr
+	mov	r3, r3, lsr #23			@ left align loc bit field
+	beq	finished_inval			@ if loc is 0, then no need to
+						@ clean
+	mov	r10, #0				@ start clean at cache level 0
+inval_loop1:
+	add	r2, r10, r10, lsr #1		@ work out 3x current cache
+						@ level
+	mov	r1, r0, lsr r2			@ extract cache type bits from
+						@ clidr
+	and	r1, r1, #7			@ mask of the bits for current
+						@ cache only
+	cmp	r1, #2				@ see what cache we have at
+						@ this level
+	blt	skip_inval			@ skip if no cache, or just
+						@ i-cache
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
+						@ in cssr
+	mov	r2, #0				@ operand for mcr SBZ
+	mcr	p15, 0, r2, c7, c5, 4		@ flush prefetch buffer to
+						@ sych the new cssr&csidr,
+						@ with armv7 this is 'isb',
+						@ but we compile with armv5
+	mrc	p15, 1, r1, c0, c0, 0		@ read the new csidr
+	and	r2, r1, #7			@ extract the length of the
+						@ cache lines
+	add	r2, r2, #4			@ add 4 (line length offset)
+	ldr	r4, =0x3ff
+	ands	r4, r4, r1, lsr #3		@ find maximum number on the
+						@ way size
+	clz	r5, r4				@ find bit position of way
+						@ size increment
+	ldr	r7, =0x7fff
+	ands	r7, r7, r1, lsr #13		@ extract max number of the
+						@ index size
+inval_loop2:
+	mov	r9, r4				@ create working copy of max
+						@ way size
+inval_loop3:
+	orr	r11, r10, r9, lsl r5		@ factor way and cache number
+						@ into r11
+	orr	r11, r11, r7, lsl r2		@ factor index number into r11
+	mcr	p15, 0, r11, c7, c6, 2		@ invalidate by set/way
+	subs	r9, r9, #1			@ decrement the way
+	bge	inval_loop3
+	subs	r7, r7, #1			@ decrement the index
+	bge	inval_loop2
+skip_inval:
+	add	r10, r10, #2			@ increment cache number
+	cmp	r3, r10
+	bgt	inval_loop1
+finished_inval:
+	mov	r10, #0				@ swith back to cache level 0
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
+						@ in cssr
+	mcr	p15, 0, r10, c7, c5, 4		@ flush prefetch buffer,
+						@ with armv7 this is 'isb',
+						@ but we compile with armv5
+
+	ldmfd	r13!, {r0 - r5, r7, r9 - r12, pc}
+
+
+	.align	5
+.global reset_cpu
+reset_cpu:
+	ldr	r1, rstctl			@ get addr for global reset
+						@ reg
+	mov	r3, #0x2			@ full reset pll + mpu
+	str	r3, [r1]			@ force reset
+	mov	r0, r0
+_loop_forever:
+	b	_loop_forever
+rstctl:
+	.word	PRM_RSTCTRL
diff -Naur u-boot-2009.01/cpu/at32ap/cpu.c u-boot/cpu/at32ap/cpu.c
--- u-boot-2009.01/cpu/at32ap/cpu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/at32ap/cpu.c	2009-03-07 15:58:35.000000000 +0100
@@ -51,10 +51,10 @@
 
 	/* TODO: Move somewhere else, but needs to be run before we
 	 * increase the clock frequency. */
-	hsmc3_writel(MODE0, 0x00031103);
 	hsmc3_writel(CYCLE0, 0x000c000d);
 	hsmc3_writel(PULSE0, 0x0b0a0906);
 	hsmc3_writel(SETUP0, 0x00010002);
+	hsmc3_writel(MODE0, 0x00031103);
 
 	clk_init();
 
diff -Naur u-boot-2009.01/cpu/blackfin/cache.S u-boot/cpu/blackfin/cache.S
--- u-boot-2009.01/cpu/blackfin/cache.S	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/blackfin/cache.S	2009-02-26 14:03:58.000000000 +0100
@@ -1,5 +1,10 @@
-/* cache.S - low level cache handling routines
- * Copyright (C) 2003-2007 Analog Devices Inc.
+/*
+ * Blackfin cache control code
+ *
+ * Copyright 2003-2008 Analog Devices Inc.
+ *
+ * Enter bugs at http://blackfin.uclinux.org/
+ *
  * Licensed under the GPL-2 or later.
  */
 
@@ -8,54 +13,75 @@
 #include <asm/blackfin.h>
 
 .text
-.align 2
-ENTRY(_blackfin_icache_flush_range)
-	R2 = -32;
-	R2 = R0 & R2;
-	P0 = R2;
-	P1 = R1;
-	CSYNC;
+/* Since all L1 caches work the same way, we use the same method for flushing
+ * them.  Only the actual flush instruction differs.  We write this in asm as
+ * GCC can be hard to coax into writing nice hardware loops.
+ *
+ * Also, we assume the following register setup:
+ * R0 = start address
+ * R1 = end address
+ */
+.macro do_flush flushins:req optflushins optnopins label
+
+	R2 = -L1_CACHE_BYTES;
+
+	/* start = (start & -L1_CACHE_BYTES) */
+	R0 = R0 & R2;
+
+	/* end = ((end - 1) & -L1_CACHE_BYTES) + L1_CACHE_BYTES; */
+	R1 += -1;
+	R1 = R1 & R2;
+	R1 += L1_CACHE_BYTES;
+
+	/* count = (end - start) >> L1_CACHE_SHIFT */
+	R2 = R1 - R0;
+	R2 >>= L1_CACHE_SHIFT;
+	P1 = R2;
+
+.ifnb \label
+\label :
+.endif
+	P0 = R0;
+	LSETUP (1f, 2f) LC1 = P1;
 1:
-	IFLUSH[P0++];
-	CC = P0 < P1(iu);
-	IF CC JUMP 1b(bp);
-	IFLUSH[P0];
-	SSYNC;
+.ifnb \optflushins
+	\optflushins [P0];
+.endif
+#if ANOMALY_05000443
+.ifb \optnopins
+2:
+.endif
+	\flushins [P0++];
+.ifnb \optnopins
+2:	\optnopins;
+.endif
+#else
+2:	\flushins [P0++];
+#endif
+
 	RTS;
+.endm
+
+/* Invalidate all instruction cache lines assocoiated with this memory area */
+ENTRY(_blackfin_icache_flush_range)
+	do_flush IFLUSH, , nop
 ENDPROC(_blackfin_icache_flush_range)
 
+/* Flush all cache lines assocoiated with this area of memory. */
+ENTRY(_blackfin_icache_dcache_flush_range)
+	do_flush FLUSH, IFLUSH
+ENDPROC(_blackfin_icache_dcache_flush_range)
+
+/* Throw away all D-cached data in specified region without any obligation to
+ * write them back.  Since the Blackfin ISA does not have an "invalidate"
+ * instruction, we use flush/invalidate.  Perhaps as a speed optimization we
+ * could bang on the DTEST MMRs ...
+ */
+ENTRY(_blackfin_dcache_flush_invalidate_range)
+	do_flush FLUSHINV
+ENDPROC(_blackfin_dcache_flush_invalidate_range)
+
+/* Flush all data cache lines assocoiated with this memory area */
 ENTRY(_blackfin_dcache_flush_range)
-	R2 = -32;
-	R2 = R0 & R2;
-	P0 = R2;
-	P1 = R1;
-	CSYNC;
-1:
-	FLUSH[P0++];
-	CC = P0 < P1(iu);
-	IF CC JUMP 1b(bp);
-	FLUSH[P0];
-	SSYNC;
-	RTS;
+	do_flush FLUSH, , , .Ldfr
 ENDPROC(_blackfin_dcache_flush_range)
-
-ENTRY(_blackfin_dcache_invalidate_range)
-	R2 = -32;
-	R2 = R0 & R2;
-	P0 = R2;
-	P1 = R1;
-	CSYNC;
-1:
-	FLUSHINV[P0++];
-	CC = P0 < P1(iu);
-	IF CC JUMP 1b(bp);
-
-	/*
-	 * If the data crosses a cache line, then we'll be pointing to
-	 * the last cache line, but won't have flushed/invalidated it yet, so do
-	 * one more.
-	 */
-	FLUSHINV[P0];
-	SSYNC;
-	RTS;
-ENDPROC(_blackfin_dcache_invalidate_range)
diff -Naur u-boot-2009.01/cpu/blackfin/cpu.c u-boot/cpu/blackfin/cpu.c
--- u-boot-2009.01/cpu/blackfin/cpu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/blackfin/cpu.c	2009-02-26 14:03:58.000000000 +0100
@@ -14,11 +14,14 @@
 #include <asm/blackfin.h>
 #include <asm/cplb.h>
 #include <asm/mach-common/bits/core.h>
+#include <asm/mach-common/bits/ebiu.h>
 #include <asm/mach-common/bits/trace.h>
 
 #include "cpu.h"
 #include "serial.h"
 
+ulong bfin_poweron_retx;
+
 __attribute__ ((__noreturn__))
 void cpu_init_f(ulong bootflag, ulong loaded_from_ldr)
 {
@@ -48,6 +51,9 @@
 		bfin_write_EBIU_AMGCTL(CONFIG_EBIU_AMGCTL_VAL);
 #endif
 
+	/* Save RETX so we can pass it while booting Linux */
+	bfin_poweron_retx = bootflag;
+
 #ifdef CONFIG_DEBUG_DUMP
 	/* Turn on hardware trace buffer */
 	bfin_write_TBUFCTL(TBUFPWR | TBUFEN);
diff -Naur u-boot-2009.01/cpu/blackfin/i2c.c u-boot/cpu/blackfin/i2c.c
--- u-boot-2009.01/cpu/blackfin/i2c.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/blackfin/i2c.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,428 +0,0 @@
-/*
- * i2c.c - driver for Blackfin on-chip TWI/I2C
- *
- * Copyright (c) 2006-2008 Analog Devices Inc.
- *
- * Licensed under the GPL-2 or later.
- */
-
-#include <common.h>
-
-#ifdef CONFIG_HARD_I2C
-
-#include <asm/blackfin.h>
-#include <i2c.h>
-#include <asm/io.h>
-#include <asm/mach-common/bits/twi.h>
-
-/* Two-Wire Interface		(0xFFC01400 - 0xFFC014FF) */
-#ifdef TWI0_CLKDIV
-#define bfin_read_TWI_CLKDIV()               bfin_read_TWI0_CLKDIV()
-#define bfin_write_TWI_CLKDIV(val)           bfin_write_TWI0_CLKDIV(val)
-#define bfin_read_TWI_CONTROL()              bfin_read_TWI0_CONTROL()
-#define bfin_write_TWI_CONTROL(val)          bfin_write_TWI0_CONTROL(val)
-#define bfin_read_TWI_SLAVE_CTL()            bfin_read_TWI0_SLAVE_CTL()
-#define bfin_write_TWI_SLAVE_CTL(val)        bfin_write_TWI0_SLAVE_CTL(val)
-#define bfin_read_TWI_SLAVE_STAT()           bfin_read_TWI0_SLAVE_STAT()
-#define bfin_write_TWI_SLAVE_STAT(val)       bfin_write_TWI0_SLAVE_STAT(val)
-#define bfin_read_TWI_SLAVE_ADDR()           bfin_read_TWI0_SLAVE_ADDR()
-#define bfin_write_TWI_SLAVE_ADDR(val)       bfin_write_TWI0_SLAVE_ADDR(val)
-#define bfin_read_TWI_MASTER_CTL()           bfin_read_TWI0_MASTER_CTL()
-#define bfin_write_TWI_MASTER_CTL(val)       bfin_write_TWI0_MASTER_CTL(val)
-#define bfin_read_TWI_MASTER_STAT()          bfin_read_TWI0_MASTER_STAT()
-#define bfin_write_TWI_MASTER_STAT(val)      bfin_write_TWI0_MASTER_STAT(val)
-#define bfin_read_TWI_MASTER_ADDR()          bfin_read_TWI0_MASTER_ADDR()
-#define bfin_write_TWI_MASTER_ADDR(val)      bfin_write_TWI0_MASTER_ADDR(val)
-#define bfin_read_TWI_INT_STAT()             bfin_read_TWI0_INT_STAT()
-#define bfin_write_TWI_INT_STAT(val)         bfin_write_TWI0_INT_STAT(val)
-#define bfin_read_TWI_INT_MASK()             bfin_read_TWI0_INT_MASK()
-#define bfin_write_TWI_INT_MASK(val)         bfin_write_TWI0_INT_MASK(val)
-#define bfin_read_TWI_FIFO_CTL()             bfin_read_TWI0_FIFO_CTL()
-#define bfin_write_TWI_FIFO_CTL(val)         bfin_write_TWI0_FIFO_CTL(val)
-#define bfin_read_TWI_FIFO_STAT()            bfin_read_TWI0_FIFO_STAT()
-#define bfin_write_TWI_FIFO_STAT(val)        bfin_write_TWI0_FIFO_STAT(val)
-#define bfin_read_TWI_XMT_DATA8()            bfin_read_TWI0_XMT_DATA8()
-#define bfin_write_TWI_XMT_DATA8(val)        bfin_write_TWI0_XMT_DATA8(val)
-#define bfin_read_TWI_XMT_DATA_16()          bfin_read_TWI0_XMT_DATA16()
-#define bfin_write_TWI_XMT_DATA16(val)       bfin_write_TWI0_XMT_DATA16(val)
-#define bfin_read_TWI_RCV_DATA8()            bfin_read_TWI0_RCV_DATA8()
-#define bfin_write_TWI_RCV_DATA8(val)        bfin_write_TWI0_RCV_DATA8(val)
-#define bfin_read_TWI_RCV_DATA16()           bfin_read_TWI0_RCV_DATA16()
-#define bfin_write_TWI_RCV_DATA16(val)       bfin_write_TWI0_RCV_DATA16(val)
-#endif
-
-#ifdef DEBUG_I2C
-#define PRINTD(fmt,args...)	do {	\
-	DECLARE_GLOBAL_DATA_PTR;	\
-	if (gd->have_console)		\
-		printf(fmt ,##args);	\
-	} while (0)
-#else
-#define PRINTD(fmt,args...)
-#endif
-
-#ifndef CONFIG_TWICLK_KHZ
-#define CONFIG_TWICLK_KHZ	50
-#endif
-
-/* All transfers are described by this data structure */
-struct i2c_msg {
-	u16 addr;		/* slave address */
-	u16 flags;
-#define I2C_M_STOP		0x2
-#define I2C_M_RD		0x1
-	u16 len;		/* msg length */
-	u8 *buf;		/* pointer to msg data */
-};
-
-/**
- * i2c_reset: - reset the host controller
- */
-static void i2c_reset(void)
-{
-	/* Disable TWI */
-	bfin_write_TWI_CONTROL(0);
-	SSYNC();
-
-	/* Set TWI internal clock as 10MHz */
-	bfin_write_TWI_CONTROL(((get_sclk() / 1024 / 1024 + 5) / 10) & 0x7F);
-
-	/* Set Twi interface clock as specified */
-	if (CONFIG_TWICLK_KHZ > 400)
-		bfin_write_TWI_CLKDIV(((5 * 1024 / 400) << 8) | ((5 * 1024 /
-						400) & 0xFF));
-	else
-		bfin_write_TWI_CLKDIV(((5 * 1024 /
-					CONFIG_TWICLK_KHZ) << 8) | ((5 * 1024 /
-						CONFIG_TWICLK_KHZ)
-						& 0xFF));
-
-	/* Enable TWI */
-	bfin_write_TWI_CONTROL(bfin_read_TWI_CONTROL() | TWI_ENA);
-	SSYNC();
-}
-
-int wait_for_completion(struct i2c_msg *msg, int timeout_count)
-{
-	unsigned short twi_int_stat;
-	unsigned short mast_stat;
-	int i;
-
-	for (i = 0; i < timeout_count; i++) {
-		twi_int_stat = bfin_read_TWI_INT_STAT();
-		mast_stat = bfin_read_TWI_MASTER_STAT();
-
-		if (XMTSERV & twi_int_stat) {
-			/* Transmit next data */
-			if (msg->len > 0) {
-				bfin_write_TWI_XMT_DATA8(*(msg->buf++));
-				msg->len--;
-			} else if (msg->flags & I2C_M_STOP)
-				bfin_write_TWI_MASTER_CTL
-				    (bfin_read_TWI_MASTER_CTL() | STOP);
-			SSYNC();
-			/* Clear status */
-			bfin_write_TWI_INT_STAT(XMTSERV);
-			SSYNC();
-			i = 0;
-		}
-		if (RCVSERV & twi_int_stat) {
-			if (msg->len > 0) {
-				/* Receive next data */
-				*(msg->buf++) = bfin_read_TWI_RCV_DATA8();
-				msg->len--;
-			} else if (msg->flags & I2C_M_STOP) {
-				bfin_write_TWI_MASTER_CTL
-				    (bfin_read_TWI_MASTER_CTL() | STOP);
-				SSYNC();
-			}
-			/* Clear interrupt source */
-			bfin_write_TWI_INT_STAT(RCVSERV);
-			SSYNC();
-			i = 0;
-		}
-		if (MERR & twi_int_stat) {
-			bfin_write_TWI_INT_STAT(MERR);
-			bfin_write_TWI_INT_MASK(0);
-			bfin_write_TWI_MASTER_STAT(0x3e);
-			bfin_write_TWI_MASTER_CTL(0);
-			SSYNC();
-			/*
-			 * if both err and complete int stats are set,
-			 * return proper results.
-			 */
-			if (MCOMP & twi_int_stat) {
-				bfin_write_TWI_INT_STAT(MCOMP);
-				bfin_write_TWI_INT_MASK(0);
-				bfin_write_TWI_MASTER_CTL(0);
-				SSYNC();
-				/*
-				 * If it is a quick transfer,
-				 * only address bug no data, not an err.
-				 */
-				if (msg->len == 0 && mast_stat & BUFRDERR)
-					return 0;
-				/*
-				 * If address not acknowledged return -3,
-				 * else return 0.
-				 */
-				else if (!(mast_stat & ANAK))
-					return 0;
-				else
-					return -3;
-			}
-			return -1;
-		}
-		if (MCOMP & twi_int_stat) {
-			bfin_write_TWI_INT_STAT(MCOMP);
-			SSYNC();
-			bfin_write_TWI_INT_MASK(0);
-			bfin_write_TWI_MASTER_CTL(0);
-			SSYNC();
-			return 0;
-		}
-	}
-	if (msg->flags & I2C_M_RD)
-		return -4;
-	else
-		return -2;
-}
-
-/**
- * i2c_transfer: - Transfer one byte over the i2c bus
- *
- * This function can tranfer a byte over the i2c bus in both directions.
- * It is used by the public API functions.
- *
- * @return:	 0: transfer successful
- *		-1: transfer fail
- *		-2: transmit timeout
- *		-3: ACK missing
- *		-4: receive timeout
- *		-5: controller not ready
- */
-int i2c_transfer(struct i2c_msg *msg)
-{
-	int ret = 0;
-	int timeout_count = 10000;
-	int len = msg->len;
-
-	if (!(bfin_read_TWI_CONTROL() & TWI_ENA)) {
-		ret = -5;
-		goto transfer_error;
-	}
-
-	while (bfin_read_TWI_MASTER_STAT() & BUSBUSY)
-		continue;
-
-	/* Set Transmit device address */
-	bfin_write_TWI_MASTER_ADDR(msg->addr);
-
-	/*
-	 * FIFO Initiation.
-	 * Data in FIFO should be discarded before start a new operation.
-	 */
-	bfin_write_TWI_FIFO_CTL(0x3);
-	SSYNC();
-	bfin_write_TWI_FIFO_CTL(0);
-	SSYNC();
-
-	if (!(msg->flags & I2C_M_RD)) {
-		/* Transmit first data */
-		if (msg->len > 0) {
-			PRINTD("1 in i2c_transfer: buf=%d, len=%d\n", *msg->buf,
-			       len);
-			bfin_write_TWI_XMT_DATA8(*(msg->buf++));
-			msg->len--;
-			SSYNC();
-		}
-	}
-
-	/* clear int stat */
-	bfin_write_TWI_INT_STAT(MERR | MCOMP | XMTSERV | RCVSERV);
-
-	/* Interrupt mask . Enable XMT, RCV interrupt */
-	bfin_write_TWI_INT_MASK(MCOMP | MERR |
-			((msg->flags & I2C_M_RD) ? RCVSERV : XMTSERV));
-	SSYNC();
-
-	if (len > 0 && len <= 255)
-		bfin_write_TWI_MASTER_CTL((len << 6));
-	else if (msg->len > 255) {
-		bfin_write_TWI_MASTER_CTL((0xff << 6));
-		msg->flags &= I2C_M_STOP;
-	} else
-		bfin_write_TWI_MASTER_CTL(0);
-
-	/* Master enable */
-	bfin_write_TWI_MASTER_CTL(bfin_read_TWI_MASTER_CTL() | MEN |
-			((msg->flags & I2C_M_RD)
-			 ? MDIR : 0) | ((CONFIG_TWICLK_KHZ >
-					 100) ? FAST : 0));
-	SSYNC();
-
-	ret = wait_for_completion(msg, timeout_count);
-	PRINTD("3 in i2c_transfer: ret=%d\n", ret);
-
- transfer_error:
-	switch (ret) {
-	case 1:
-		PRINTD(("i2c_transfer: error: transfer fail\n"));
-		break;
-	case 2:
-		PRINTD(("i2c_transfer: error: transmit timeout\n"));
-		break;
-	case 3:
-		PRINTD(("i2c_transfer: error: ACK missing\n"));
-		break;
-	case 4:
-		PRINTD(("i2c_transfer: error: receive timeout\n"));
-		break;
-	case 5:
-		PRINTD(("i2c_transfer: error: controller not ready\n"));
-		i2c_reset();
-		break;
-	default:
-		break;
-	}
-	return ret;
-
-}
-
-/* ---------------------------------------------------------------------*/
-/* API Functions							*/
-/* ---------------------------------------------------------------------*/
-
-void i2c_init(int speed, int slaveaddr)
-{
-	i2c_reset();
-}
-
-/**
- * i2c_probe: - Test if a chip answers for a given i2c address
- *
- * @chip:	address of the chip which is searched for
- * @return:	0 if a chip was found, -1 otherwhise
- */
-
-int i2c_probe(uchar chip)
-{
-	struct i2c_msg msg;
-	u8 probebuf;
-
-	i2c_reset();
-
-	probebuf = 0;
-	msg.addr = chip;
-	msg.flags = 0;
-	msg.len = 1;
-	msg.buf = &probebuf;
-	if (i2c_transfer(&msg))
-		return -1;
-
-	msg.addr = chip;
-	msg.flags = I2C_M_RD;
-	msg.len = 1;
-	msg.buf = &probebuf;
-	if (i2c_transfer(&msg))
-		return -1;
-
-	return 0;
-}
-
-/**
- *   i2c_read: - Read multiple bytes from an i2c device
- *
- *   chip:    I2C chip address, range 0..127
- *   addr:    Memory (register) address within the chip
- *   alen:    Number of bytes to use for addr (typically 1, 2 for larger
- *		memories, 0 for register type devices with only one
- *		register)
- *   buffer:  Where to read/write the data
- *   len:     How many bytes to read/write
- *
- *   Returns: 0 on success, not 0 on failure
- */
-
-int i2c_read(uchar chip, uint addr, int alen, uchar * buffer, int len)
-{
-	struct i2c_msg msg;
-	u8 addr_bytes[3];	/* lowest...highest byte of data address */
-
-	PRINTD("i2c_read: chip=0x%x, addr=0x%x, alen=0x%x, len=0x%x\n", chip,
-			addr, alen, len);
-
-	if (alen > 0) {
-		addr_bytes[0] = (u8) ((addr >> 0) & 0x000000FF);
-		addr_bytes[1] = (u8) ((addr >> 8) & 0x000000FF);
-		addr_bytes[2] = (u8) ((addr >> 16) & 0x000000FF);
-		msg.addr = chip;
-		msg.flags = 0;
-		msg.len = alen;
-		msg.buf = addr_bytes;
-		if (i2c_transfer(&msg))
-			return -1;
-	}
-
-	/* start read sequence */
-	PRINTD(("i2c_read: start read sequence\n"));
-	msg.addr = chip;
-	msg.flags = I2C_M_RD;
-	msg.len = len;
-	msg.buf = buffer;
-	if (i2c_transfer(&msg))
-		return -1;
-
-	return 0;
-}
-
-/**
- *   i2c_write: -  Write multiple bytes to an i2c device
- *
- *   chip:    I2C chip address, range 0..127
- *   addr:    Memory (register) address within the chip
- *   alen:    Number of bytes to use for addr (typically 1, 2 for larger
- *		memories, 0 for register type devices with only one
- *		register)
- *   buffer:  Where to read/write the data
- *   len:     How many bytes to read/write
- *
- *   Returns: 0 on success, not 0 on failure
- */
-
-int i2c_write(uchar chip, uint addr, int alen, uchar * buffer, int len)
-{
-	struct i2c_msg msg;
-	u8 addr_bytes[3];	/* lowest...highest byte of data address */
-
-	PRINTD
-		("i2c_write: chip=0x%x, addr=0x%x, alen=0x%x, len=0x%x, buf0=0x%x\n",
-		 chip, addr, alen, len, buffer[0]);
-
-	/* chip address write */
-	if (alen > 0) {
-		addr_bytes[0] = (u8) ((addr >> 0) & 0x000000FF);
-		addr_bytes[1] = (u8) ((addr >> 8) & 0x000000FF);
-		addr_bytes[2] = (u8) ((addr >> 16) & 0x000000FF);
-		msg.addr = chip;
-		msg.flags = 0;
-		msg.len = alen;
-		msg.buf = addr_bytes;
-		if (i2c_transfer(&msg))
-			return -1;
-	}
-
-	/* start read sequence */
-	PRINTD(("i2c_write: start write sequence\n"));
-	msg.addr = chip;
-	msg.flags = 0;
-	msg.len = len;
-	msg.buf = buffer;
-	if (i2c_transfer(&msg))
-		return -1;
-
-	return 0;
-
-}
-
-#endif /* CONFIG_HARD_I2C */
diff -Naur u-boot-2009.01/cpu/blackfin/initcode.c u-boot/cpu/blackfin/initcode.c
--- u-boot-2009.01/cpu/blackfin/initcode.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/blackfin/initcode.c	2009-02-26 14:03:58.000000000 +0100
@@ -20,7 +20,7 @@
 #include "serial.h"
 
 __attribute__((always_inline))
-static inline uint32_t serial_init(void)
+static inline void serial_init(void)
 {
 #ifdef __ADSPBF54x__
 # ifdef BFIN_BOOT_UART_USE_RTS
@@ -61,21 +61,16 @@
 	}
 #endif
 
-	uint32_t old_baud = serial_early_get_baud();
-
 	if (BFIN_DEBUG_EARLY_SERIAL) {
+		int ucen = *pUART_GCTL & UCEN;
 		serial_early_init();
 
 		/* If the UART is off, that means we need to program
 		 * the baud rate ourselves initially.
 		 */
-		if (!old_baud) {
-			old_baud = CONFIG_BAUDRATE;
+		if (ucen != UCEN)
 			serial_early_set_baud(CONFIG_BAUDRATE);
-		}
 	}
-
-	return old_baud;
 }
 
 __attribute__((always_inline))
@@ -89,30 +84,6 @@
 #endif
 }
 
-/* We need to reset the baud rate when we have early debug turned on
- * or when we are booting over the UART.
- * XXX: we should fix this to calc the old baud and restore it rather
- *      than hardcoding it via CONFIG_LDR_LOAD_BAUD ... but we have
- *      to figure out how to avoid the division in the baud calc ...
- */
-__attribute__((always_inline))
-static inline void serial_reset_baud(uint32_t baud)
-{
-	if (!BFIN_DEBUG_EARLY_SERIAL && CONFIG_BFIN_BOOT_MODE != BFIN_BOOT_UART)
-		return;
-
-#ifndef CONFIG_LDR_LOAD_BAUD
-# define CONFIG_LDR_LOAD_BAUD 115200
-#endif
-
-	if (CONFIG_BFIN_BOOT_MODE == BFIN_BOOT_BYPASS)
-		serial_early_set_baud(baud);
-	else if (CONFIG_BFIN_BOOT_MODE == BFIN_BOOT_UART)
-		serial_early_set_baud(CONFIG_LDR_LOAD_BAUD);
-	else
-		serial_early_set_baud(CONFIG_BAUDRATE);
-}
-
 __attribute__((always_inline))
 static inline void serial_putc(char c)
 {
@@ -129,12 +100,22 @@
 }
 
 
-/* Max SCLK can be 133MHz ... dividing that by 4 gives
- * us a freq of 33MHz for SPI which should generally be
+/* Max SCLK can be 133MHz ... dividing that by (2*4) gives
+ * us a freq of 16MHz for SPI which should generally be
  * slow enough for the slow reads the bootrom uses.
  */
+#if !defined(CONFIG_SPI_FLASH_SLOW_READ) && \
+    ((defined(__ADSPBF52x__) && __SILICON_REVISION__ >= 2) || \
+     (defined(__ADSPBF54x__) && __SILICON_REVISION__ >= 1))
+# define BOOTROM_SUPPORTS_SPI_FAST_READ 1
+#else
+# define BOOTROM_SUPPORTS_SPI_FAST_READ 0
+#endif
 #ifndef CONFIG_SPI_BAUD_INITBLOCK
-# define CONFIG_SPI_BAUD_INITBLOCK 4
+# define CONFIG_SPI_BAUD_INITBLOCK (BOOTROM_SUPPORTS_SPI_FAST_READ ? 2 : 4)
+#endif
+#ifdef SPI0_BAUD
+# define bfin_write_SPI_BAUD bfin_write_SPI0_BAUD
 #endif
 
 /* PLL_DIV defines */
@@ -158,17 +139,24 @@
 #endif
 
 #ifndef CONFIG_PLL_CTL_VAL
-# define CONFIG_PLL_CTL_VAL (SPORT_HYST | (CONFIG_VCO_MULT << 9))
+# define CONFIG_PLL_CTL_VAL (SPORT_HYST | (CONFIG_VCO_MULT << 9) | CONFIG_CLKIN_HALF)
 #endif
 
 #ifndef CONFIG_EBIU_RSTCTL_VAL
 # define CONFIG_EBIU_RSTCTL_VAL 0 /* only MDDRENABLE is useful */
 #endif
+#if ((CONFIG_EBIU_RSTCTL_VAL & 0xFFFFFFC4) != 0)
+# error invalid EBIU_RSTCTL value: must not set reserved bits
+#endif
 
 #ifndef CONFIG_EBIU_MBSCTL_VAL
 # define CONFIG_EBIU_MBSCTL_VAL 0
 #endif
 
+#if defined(CONFIG_EBIU_DDRQUE_VAL) && ((CONFIG_EBIU_DDRQUE_VAL & 0xFFFF8000) != 0)
+# error invalid EBIU_DDRQUE value: must not set reserved bits
+#endif
+
 /* Make sure our voltage value is sane so we don't blow up! */
 #ifndef CONFIG_VR_CTL_VAL
 # define BFIN_CCLK ((CONFIG_CLKIN_HZ * CONFIG_VCO_MULT) / CONFIG_CCLK_DIV)
@@ -195,6 +183,9 @@
 # elif defined(__ADSPBF54x__)	/* TBD; use default */
 #  undef CONFIG_VR_CTL_VLEV
 #  define CONFIG_VR_CTL_VLEV VLEV_120
+# elif defined(__ADSPBF538__) || defined(__ADSPBF539__)	/* TBD; use default */
+#  undef CONFIG_VR_CTL_VLEV
+#  define CONFIG_VR_CTL_VLEV VLEV_125
 # endif
 
 # ifdef CONFIG_BFIN_MAC
@@ -212,10 +203,17 @@
 # define CONFIG_VR_CTL_VAL (CONFIG_VR_CTL_CLKBUF | CONFIG_VR_CTL_VLEV | CONFIG_VR_CTL_FREQ)
 #endif
 
-__attribute__((saveall))
+BOOTROM_CALLED_FUNC_ATTR
 void initcode(ADI_BOOT_DATA *bootstruct)
 {
-	uint32_t old_baud = serial_init();
+	/* Save the clock pieces that are used in baud rate calculation */
+	unsigned int sdivB, divB, vcoB;
+	serial_init();
+	if (BFIN_DEBUG_EARLY_SERIAL || CONFIG_BFIN_BOOT_MODE == BFIN_BOOT_UART) {
+		sdivB = bfin_read_PLL_DIV() & 0xf;
+		vcoB = (bfin_read_PLL_CTL() >> 9) & 0x3f;
+		divB = serial_early_get_div();
+	}
 
 #ifdef CONFIG_HW_WATCHDOG
 # ifndef CONFIG_HW_WATCHDOG_TIMEOUT_INITCODE
@@ -240,12 +238,11 @@
 	 * boot.  Once we switch over to u-boot's SPI flash driver, we'll
 	 * increase the speed appropriately.
 	 */
-	if (CONFIG_BFIN_BOOT_MODE == BFIN_BOOT_SPI_MASTER)
-#ifdef SPI0_BAUD
-		bfin_write_SPI0_BAUD(CONFIG_SPI_BAUD_INITBLOCK);
-#else
+	if (CONFIG_BFIN_BOOT_MODE == BFIN_BOOT_SPI_MASTER) {
+		if (BOOTROM_SUPPORTS_SPI_FAST_READ && CONFIG_SPI_BAUD_INITBLOCK < 4)
+			bootstruct->dFlags |= BFLAG_FASTREAD;
 		bfin_write_SPI_BAUD(CONFIG_SPI_BAUD_INITBLOCK);
-#endif
+	}
 
 	serial_putc('B');
 
@@ -263,40 +260,69 @@
 	bfin_write_SIC_IWR(1);
 #endif
 
-	serial_putc('L');
+	/* With newer bootroms, we use the helper function to set up
+	 * the memory controller.  Older bootroms lacks such helpers
+	 * so we do it ourselves.
+	 */
+#define BOOTROM_CAPS_SYSCONTROL 0
+	if (BOOTROM_CAPS_SYSCONTROL) {
+		serial_putc('S');
+
+		ADI_SYSCTRL_VALUES memory_settings;
+		memory_settings.uwVrCtl = CONFIG_VR_CTL_VAL;
+		memory_settings.uwPllCtl = CONFIG_PLL_CTL_VAL;
+		memory_settings.uwPllDiv = CONFIG_PLL_DIV_VAL;
+		memory_settings.uwPllLockCnt = CONFIG_PLL_LOCKCNT_VAL;
+		syscontrol(SYSCTRL_WRITE | SYSCTRL_VRCTL | SYSCTRL_PLLCTL | SYSCTRL_PLLDIV | SYSCTRL_LOCKCNT |
+			(CONFIG_VR_CTL_VAL & FREQ_MASK ? SYSCTRL_INTVOLTAGE : SYSCTRL_EXTVOLTAGE), &memory_settings, NULL);
+	} else {
+		serial_putc('L');
 
-	bfin_write_PLL_LOCKCNT(CONFIG_PLL_LOCKCNT_VAL);
+		bfin_write_PLL_LOCKCNT(CONFIG_PLL_LOCKCNT_VAL);
 
-	serial_putc('A');
+		serial_putc('A');
 
-	/* Only reprogram when needed to avoid triggering unnecessary
-	 * PLL relock sequences.
-	 */
-	if (bfin_read_VR_CTL() != CONFIG_VR_CTL_VAL) {
-		serial_putc('!');
-		bfin_write_VR_CTL(CONFIG_VR_CTL_VAL);
-		asm("idle;");
-	}
+		/* Only reprogram when needed to avoid triggering unnecessary
+		 * PLL relock sequences.
+		 */
+		if (bfin_read_VR_CTL() != CONFIG_VR_CTL_VAL) {
+			serial_putc('!');
+			bfin_write_VR_CTL(CONFIG_VR_CTL_VAL);
+			asm("idle;");
+		}
 
-	serial_putc('C');
+		serial_putc('C');
 
-	bfin_write_PLL_DIV(CONFIG_PLL_DIV_VAL);
+		bfin_write_PLL_DIV(CONFIG_PLL_DIV_VAL);
 
-	serial_putc('K');
+		serial_putc('K');
 
-	/* Only reprogram when needed to avoid triggering unnecessary
-	 * PLL relock sequences.
-	 */
-	if (bfin_read_PLL_CTL() != CONFIG_PLL_CTL_VAL) {
-		serial_putc('!');
-		bfin_write_PLL_CTL(CONFIG_PLL_CTL_VAL);
-		asm("idle;");
+		/* Only reprogram when needed to avoid triggering unnecessary
+		 * PLL relock sequences.
+		 */
+		if (bfin_read_PLL_CTL() != CONFIG_PLL_CTL_VAL) {
+			serial_putc('!');
+			bfin_write_PLL_CTL(CONFIG_PLL_CTL_VAL);
+			asm("idle;");
+		}
 	}
 
 	/* Since we've changed the SCLK above, we may need to update
 	 * the UART divisors (UART baud rates are based on SCLK).
+	 * Do the division by hand as there are no native instructions
+	 * for dividing which means we'd generate a libgcc reference.
 	 */
-	serial_reset_baud(old_baud);
+	if (CONFIG_BFIN_BOOT_MODE == BFIN_BOOT_UART) {
+		unsigned int sdivR, vcoR;
+		sdivR = bfin_read_PLL_DIV() & 0xf;
+		vcoR = (bfin_read_PLL_CTL() >> 9) & 0x3f;
+		int dividend = sdivB * divB * vcoR;
+		int divisor = vcoB * sdivR;
+		unsigned int quotient;
+		for (quotient = 0; dividend > 0; ++quotient)
+			dividend -= divisor;
+		serial_early_put_div(quotient - ANOMALY_05000230);
+	}
 
 	serial_putc('F');
 
diff -Naur u-boot-2009.01/cpu/blackfin/jtag-console.c u-boot/cpu/blackfin/jtag-console.c
--- u-boot-2009.01/cpu/blackfin/jtag-console.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/blackfin/jtag-console.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,125 @@
+/*
+ * jtag-console.c - console driver over Blackfin JTAG
+ *
+ * Copyright (c) 2008 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <devices.h>
+#include <asm/blackfin.h>
+
+#ifndef CONFIG_JTAG_CONSOLE_TIMEOUT
+# define CONFIG_JTAG_CONSOLE_TIMEOUT 100
+#endif
+
+/* The Blackfin tends to be much much faster than the JTAG hardware. */
+static void jtag_write_emudat(uint32_t emudat)
+{
+	static bool overflowed = false;
+	ulong timeout = get_timer(0) + CONFIG_JTAG_CONSOLE_TIMEOUT;
+	while (bfin_read_DBGSTAT() & 0x1) {
+		if (overflowed)
+			return;
+		if (timeout < get_timer(0))
+			overflowed = true;
+	}
+	overflowed = false;
+	__asm__ __volatile__("emudat = %0;" : : "d"(emudat));
+}
+/* Transmit a buffer.  The format is:
+ * [32bit length][actual data]
+ */
+static void jtag_send(const char *c, uint32_t len)
+{
+	uint32_t i;
+
+	if (len == 0)
+		return;
+
+	/* First send the length */
+	jtag_write_emudat(len);
+
+	/* Then send the data */
+	for (i = 0; i < len; i += 4)
+		jtag_write_emudat((c[i] << 0) | (c[i+1] << 8) | (c[i+2] << 16) | (c[i+3] << 24));
+}
+static void jtag_putc(const char c)
+{
+	jtag_send(&c, 1);
+}
+static void jtag_puts(const char *s)
+{
+	jtag_send(s, strlen(s));
+}
+
+static int jtag_tstc(void)
+{
+	return (bfin_read_DBGSTAT() & 0x2);
+}
+
+/* Receive a buffer.  The format is:
+ * [32bit length][actual data]
+ */
+static size_t inbound_len;
+static int leftovers_len;
+static uint32_t leftovers;
+static int jtag_getc(void)
+{
+	int ret;
+	uint32_t emudat;
+
+	/* see if any data is left over */
+	if (leftovers_len) {
+		--leftovers_len;
+		ret = leftovers & 0xff;
+		leftovers >>= 8;
+		return ret;
+	}
+
+	/* wait for new data ! */
+	while (!jtag_tstc())
+		continue;
+	__asm__("%0 = emudat;" : "=d"(emudat));
+
+	if (inbound_len == 0) {
+		/* grab the length */
+		inbound_len = emudat;
+	} else {
+		/* store the bytes */
+		leftovers_len = min(4, inbound_len);
+		inbound_len -= leftovers_len;
+		leftovers = emudat;
+	}
+
+	return jtag_getc();
+}
+
+int drv_jtag_console_init(void)
+{
+	device_t dev;
+	int ret;
+
+	memset(&dev, 0x00, sizeof(dev));
+	strcpy(dev.name, "jtag");
+	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
+	dev.putc = jtag_putc;
+	dev.puts = jtag_puts;
+	dev.tstc = jtag_tstc;
+	dev.getc = jtag_getc;
+
+	ret = device_register(&dev);
+	return (ret == 0 ? 1 : ret);
+}
+
+#ifdef CONFIG_UART_CONSOLE_IS_JTAG
+/* Since the JTAG is always available (at power on), allow it to fake a UART */
+void serial_set_baud(uint32_t baud) {}
+void serial_setbrg(void)            {}
+int serial_init(void)               { return 0; }
+void serial_putc(const char c)      __attribute__((alias("jtag_putc")));
+void serial_puts(const char *s)     __attribute__((alias("jtag_puts")));
+int serial_tstc(void)               __attribute__((alias("jtag_tstc")));
+int serial_getc(void)               __attribute__((alias("jtag_getc")));
+#endif
diff -Naur u-boot-2009.01/cpu/blackfin/Makefile u-boot/cpu/blackfin/Makefile
--- u-boot-2009.01/cpu/blackfin/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/blackfin/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -17,14 +17,15 @@
 CEXTRA   := initcode.o
 SEXTRA   := start.o
 SOBJS    := interrupt.o cache.o
-COBJS    := cpu.o traps.o interrupts.o reset.o serial.o i2c.o watchdog.o
+COBJS-y  := cpu.o traps.o interrupts.o reset.o serial.o watchdog.o
+COBJS-$(CONFIG_JTAG_CONSOLE) += jtag-console.o
 
 ifeq ($(CONFIG_BFIN_BOOT_MODE),BFIN_BOOT_BYPASS)
-COBJS    += initcode.o
+COBJS-y  += initcode.o
 endif
 
-SRCS     := $(SEXTRA:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS     := $(addprefix $(obj),$(COBJS) $(SOBJS))
+SRCS     := $(SEXTRA:.o=.S) $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS     := $(addprefix $(obj),$(COBJS-y) $(SOBJS))
 EXTRA    := $(addprefix $(obj),$(EXTRA))
 CEXTRA   := $(addprefix $(obj),$(CEXTRA))
 SEXTRA   := $(addprefix $(obj),$(SEXTRA))
@@ -46,6 +47,7 @@
 
 # make sure our initcode (which goes into LDR) does not
 # have relocs or external references
+$(obj)initcode.o: CFLAGS += -fno-function-sections -fno-data-sections
 READINIT = env LC_ALL=C $(CROSS_COMPILE)readelf -s $<
 check_initcode: $(obj)initcode.o
 ifneq ($(CONFIG_BFIN_BOOT_MODE),BFIN_BOOT_BYPASS)
diff -Naur u-boot-2009.01/cpu/blackfin/reset.c u-boot/cpu/blackfin/reset.c
--- u-boot-2009.01/cpu/blackfin/reset.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/blackfin/reset.c	2009-02-26 14:03:58.000000000 +0100
@@ -29,26 +29,35 @@
 	 */
 	__builtin_bfin_ssync();
 
-	while (1) {
+	/* The bootrom checks to see how it was reset and will
+	 * automatically perform a software reset for us when
+	 * it starts executing after the core reset.
+	 */
+	if (ANOMALY_05000353 || ANOMALY_05000386) {
 		/* Initiate System software reset. */
 		bfin_write_SWRST(0x7);
 
 		/* Due to the way reset is handled in the hardware, we need
-		 * to delay for 7 SCLKS.  The only reliable way to do this is
-		 * to calculate the CCLK/SCLK ratio and multiply 7.  For now,
+		 * to delay for 10 SCLKS.  The only reliable way to do this is
+		 * to calculate the CCLK/SCLK ratio and multiply 10.  For now,
 		 * we'll assume worse case which is a 1:15 ratio.
 		 */
 		asm(
 			"LSETUP (1f, 1f) LC0 = %0\n"
 			"1: nop;"
 			:
-			: "a" (15 * 7)
+			: "a" (15 * 10)
 			: "LC0", "LB0", "LT0"
 		);
 
 		/* Clear System software reset */
 		bfin_write_SWRST(0);
 
+		/* The BF526 ROM will crash during reset */
+#if defined(__ADSPBF522__) || defined(__ADSPBF524__) || defined(__ADSPBF526__)
+		bfin_read_SWRST();
+#endif
+
 		/* Wait for the SWRST write to complete.  Cannot rely on SSYNC
 		 * though as the System state is all reset now.
 		 */
@@ -59,10 +68,11 @@
 			: "a" (15 * 1)
 			: "LC1", "LB1", "LT1"
 		);
+	}
 
+	while (1)
 		/* Issue core reset */
 		asm("raise 1");
-	}
 }
 
 /* We need to trampoline ourselves up into L1 since our linker
diff -Naur u-boot-2009.01/cpu/blackfin/serial.c u-boot/cpu/blackfin/serial.c
--- u-boot-2009.01/cpu/blackfin/serial.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/blackfin/serial.c	2009-02-26 14:03:58.000000000 +0100
@@ -29,6 +29,8 @@
 #include <asm/blackfin.h>
 #include <asm/mach-common/bits/uart.h>
 
+#ifdef CONFIG_UART_CONSOLE
+
 #if defined(UART_LSR) && (CONFIG_UART_CONSOLE != 0)
 # error CONFIG_UART_CONSOLE must be 0 on parts with only one UART
 #endif
@@ -170,3 +172,5 @@
 	while (*s)
 		serial_putc(*s++);
 }
+
+#endif
diff -Naur u-boot-2009.01/cpu/blackfin/serial.h u-boot/cpu/blackfin/serial.h
--- u-boot-2009.01/cpu/blackfin/serial.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/blackfin/serial.h	2009-02-26 14:03:58.000000000 +0100
@@ -14,6 +14,10 @@
 #include <asm/blackfin.h>
 #include <asm/mach-common/bits/uart.h>
 
+#ifndef CONFIG_UART_CONSOLE
+# define CONFIG_UART_CONSOLE 0
+#endif
+
 #ifdef CONFIG_DEBUG_EARLY_SERIAL
 # define BFIN_DEBUG_EARLY_SERIAL 1
 #else
@@ -95,7 +99,16 @@
 __attribute__((always_inline))
 static inline void serial_do_portmux(void)
 {
-#ifdef __ADSPBF52x__
+#if defined(__ADSPBF51x__)
+# define DO_MUX(port, mux_tx, mux_rx, tx, rx) \
+	bfin_write_PORT##port##_MUX((bfin_read_PORT##port##_MUX() & ~(PORT_x_MUX_##mux_tx##_MASK | PORT_x_MUX_##mux_rx##_MASK)) | PORT_x_MUX_##mux_tx##_FUNC_2 | PORT_x_MUX_##mux_rx##_FUNC_2); \
+	bfin_write_PORT##port##_FER(bfin_read_PORT##port##_FER() | P##port##tx | P##port##rx);
+	switch (CONFIG_UART_CONSOLE) {
+	case 0: DO_MUX(G, 5, 5, 9, 10);  break;	/* Port G; mux 5; PG9 and PG10 */
+	case 1: DO_MUX(F, 2, 3, 14, 15); break;	/* Port H; mux 2/3; PH14 and PH15 */
+	}
+	SSYNC();
+#elif defined(__ADSPBF52x__)
 # define DO_MUX(port, mux, tx, rx) \
 	bfin_write_PORT##port##_MUX((bfin_read_PORT##port##_MUX() & ~PORT_x_MUX_##mux##_MASK) | PORT_x_MUX_##mux##_FUNC_3); \
 	bfin_write_PORT##port##_FER(bfin_read_PORT##port##_FER() | P##port##tx | P##port##rx);
@@ -143,16 +156,25 @@
 }
 
 __attribute__((always_inline))
-static inline uint32_t serial_early_get_baud(void)
+static inline void serial_early_put_div(uint16_t divisor)
 {
-	/* If the UART isnt enabled, then we are booting an LDR
-	 * from a non-UART source (so like flash) which means
-	 * the baud rate here is meaningless.
-	 */
-	if ((*pUART_GCTL & UCEN) != UCEN)
-		return 0;
+	/* Set DLAB in LCR to Access DLL and DLH */
+	ACCESS_LATCH();
+	SSYNC();
+
+	/* Program the divisor to get the baud rate we want */
+	*pUART_DLL = LOB(divisor);
+	*pUART_DLH = HIB(divisor);
+	SSYNC();
+
+	/* Clear DLAB in LCR to Access THR RBR IER */
+	ACCESS_PORT_IER();
+	SSYNC();
+}
 
-#if (0)	/* See comment for serial_reset_baud() in initcode.c */
+__attribute__((always_inline))
+static inline uint16_t serial_early_get_div(void)
+{
 	/* Set DLAB in LCR to Access DLL and DLH */
 	ACCESS_LATCH();
 	SSYNC();
@@ -160,16 +182,12 @@
 	uint8_t dll = *pUART_DLL;
 	uint8_t dlh = *pUART_DLH;
 	uint16_t divisor = (dlh << 8) | dll;
-	uint32_t baud = get_sclk() / (divisor * 16);
 
 	/* Clear DLAB in LCR to Access THR RBR IER */
 	ACCESS_PORT_IER();
 	SSYNC();
 
-	return baud;
-#else
-	return CONFIG_BAUDRATE;
-#endif
+	return divisor;
 }
 
 __attribute__((always_inline))
@@ -179,20 +197,7 @@
 	 * weird multiplication is to make sure we over sample just
 	 * a little rather than under sample the incoming signals.
 	 */
-	uint16_t divisor = (get_sclk() + (baud * 8)) / (baud * 16) - ANOMALY_05000230;
-
-	/* Set DLAB in LCR to Access DLL and DLH */
-	ACCESS_LATCH();
-	SSYNC();
-
-	/* Program the divisor to get the baud rate we want */
-	*pUART_DLL = LOB(divisor);
-	*pUART_DLH = HIB(divisor);
-	SSYNC();
-
-	/* Clear DLAB in LCR to Access THR RBR IER */
-	ACCESS_PORT_IER();
-	SSYNC();
+	serial_early_put_div((get_sclk() + (baud * 8)) / (baud * 16) - ANOMALY_05000230);
 }
 
 #ifndef BFIN_IN_INITCODE
@@ -222,32 +227,6 @@
 #endif
 .endm
 
-/* Recursively expand calls to _serial_putc for every byte
- * passed to us.  Append a newline when we're all done.
- */
-.macro _serial_early_putc byte:req morebytes:vararg
-#ifdef CONFIG_DEBUG_EARLY_SERIAL
-	R0 = \byte;
-	call _serial_putc;
-.ifnb \morebytes
-	_serial_early_putc \morebytes
-.else
-.if (\byte != '\n')
-	_serial_early_putc '\n'
-.endif
-.endif
-#endif
-.endm
-
-/* Wrapper around recurisve _serial_early_putc macro which
- * simply prepends the string "Early: "
- */
-.macro serial_early_putc byte:req morebytes:vararg
-#ifdef CONFIG_DEBUG_EARLY_SERIAL
-	_serial_early_putc 'E', 'a', 'r', 'l', 'y', ':', ' ', \byte, \morebytes
-#endif
-.endm
-
 /* Since we embed the string right into our .text section, we need
  * to find its address.  We do this by getting our PC and adding 2
  * bytes (which is the length of the jump instruction).  Then we
diff -Naur u-boot-2009.01/cpu/blackfin/start.S u-boot/cpu/blackfin/start.S
--- u-boot-2009.01/cpu/blackfin/start.S	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/blackfin/start.S	2009-02-26 14:03:58.000000000 +0100
@@ -125,8 +125,11 @@
 	 */
 	r6 = 1 (x);
 
-	/* Relocate from wherever are (FLASH/RAM/etc...) to the
-	 * hardcoded monitor location in the end of RAM.
+	/* Relocate from wherever we are (FLASH/RAM/etc...) to the hardcoded
+	 * monitor location in the end of RAM.  We know that memcpy() only
+	 * uses registers, so it is safe to call here.  Note that this only
+	 * copies to external memory ... we do not start executing out of
+	 * it yet (see "lower to 15" below).
 	 */
 	serial_early_puts("Relocate");
 	call _get_pc;
@@ -135,27 +138,16 @@
 	r2.h = .Loffset;
 	r3.l = _start;
 	r3.h = _start;
-	r1 = r2 - r3;
-
-	r0 = r0 - r1;
-
-	cc = r0 == r3;
+	r2 = r2 - r3;
+	r1 = r0 - r2;
+	cc = r1 == r3;
 	if cc jump .Lnorelocate;
-
 	r6 = 0 (x);
-	p1 = r0;
-
-	p2.l = LO(CONFIG_SYS_MONITOR_BASE);
-	p2.h = HI(CONFIG_SYS_MONITOR_BASE);
 
-	p3 = 0x04;
-	p4.l = LO(CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN);
-	p4.h = HI(CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN);
-.Lloop1:
-	r1 = [p1 ++ p3];
-	[p2 ++ p3] = r1;
-	cc=p2==p4;
-	if !cc jump .Lloop1;
+	r0 = r3;
+	r2.l = LO(CONFIG_SYS_MONITOR_LEN);
+	r2.h = HI(CONFIG_SYS_MONITOR_LEN);
+	call _memcpy_ASM;
 
 	/* Initialize BSS section ... we know that memset() does not
 	 * use the BSS, so it is safe to call here.  The bootrom LDR
@@ -173,9 +165,8 @@
 .Lnorelocate:
 
 	/* Setup the actual stack in external memory */
-	r0.h = HI(CONFIG_STACKBASE);
-	r0.l = LO(CONFIG_STACKBASE);
-	sp = r0;
+	sp.h = HI(CONFIG_STACKBASE);
+	sp.l = LO(CONFIG_STACKBASE);
 	fp = sp;
 
 	/* Now lower ourselves from the highest interrupt level to
@@ -183,7 +174,9 @@
 	 * setting the 15 handler to ".Lenable_nested", raising the 15
 	 * interrupt, and then returning from the highest interrupt
 	 * level to the dummy "jump" until the interrupt controller
-	 * services the pending 15 interrupt.
+	 * services the pending 15 interrupt.  If executing out of
+	 * flash, these steps also changes the code flow from flash
+	 * to external memory.
 	 */
 	serial_early_puts("Lower to 15");
 	r0 = r7;
diff -Naur u-boot-2009.01/cpu/blackfin/traps.c u-boot/cpu/blackfin/traps.c
--- u-boot-2009.01/cpu/blackfin/traps.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/blackfin/traps.c	2009-02-26 14:03:58.000000000 +0100
@@ -111,23 +111,12 @@
 		}
 		if (i == ARRAY_SIZE(bfin_memory_map)) {
 			printf("%cCPLB exception outside of memory map at 0x%p\n",
-				(data ? 'D' : 'I'), new_cplb_addr);
+				(data ? 'D' : 'I'), (void *)new_cplb_addr);
 			bfin_panic(regs);
 		} else
 			debug("CPLB addr %p matches map 0x%p - 0x%p\n", new_cplb_addr, bfin_memory_map[i].start, bfin_memory_map[i].end);
 		new_cplb_data = (data ? bfin_memory_map[i].data_flags : bfin_memory_map[i].inst_flags);
 
-		/* Turn the cache off */
-		SSYNC();
-		if (data) {
-			asm(" .align 8; ");
-			*pDMEM_CONTROL &= ~ENDCPLB;
-		} else {
-			asm(" .align 8; ");
-			*pIMEM_CONTROL &= ~ENICPLB;
-		}
-		SSYNC();
-
 		if (data) {
 			CPLB_ADDR_BASE = (uint32_t *)DCPLB_ADDR0;
 			CPLB_DATA_BASE = (uint32_t *)DCPLB_DATA0;
@@ -149,8 +138,17 @@
 
 		debug("evicting entry %i: 0x%p 0x%08X\n", i, *CPLB_ADDR, *CPLB_DATA);
 		last_evicted = i + 1;
+
+		/* need to turn off cplbs whenever we muck with the cplb table */
+#if ENDCPLB != ENICPLB
+# error cplb enable bit violates my sanity
+#endif
+		uint32_t mem_control = (data ? DMEM_CONTROL : IMEM_CONTROL);
+		bfin_write32(mem_control, bfin_read32(mem_control) & ~ENDCPLB);
 		*CPLB_ADDR = new_cplb_addr;
 		*CPLB_DATA = new_cplb_data;
+		bfin_write32(mem_control, bfin_read32(mem_control) | ENDCPLB);
+		SSYNC();
 
 		/* dump current table for debugging purposes */
 		CPLB_ADDR = CPLB_ADDR_BASE;
@@ -158,17 +156,6 @@
 		for (i = 0; i < 16; ++i)
 			debug("%2i 0x%p 0x%08X\n", i, *CPLB_ADDR++, *CPLB_DATA++);
 
-		/* Turn the cache back on */
-		SSYNC();
-		if (data) {
-			asm(" .align 8; ");
-			*pDMEM_CONTROL |= ENDCPLB;
-		} else {
-			asm(" .align 8; ");
-			*pIMEM_CONTROL |= ENICPLB;
-		}
-		SSYNC();
-
 		break;
 	}
 
@@ -220,20 +207,21 @@
 static void decode_address(char *buf, unsigned long address)
 {
 	unsigned long sym_addr;
+	void *paddr = (void *)address;
 	const char *sym = symbol_lookup(address, &sym_addr);
 
 	if (sym) {
-		sprintf(buf, "<0x%p> { %s + 0x%x }", address, sym, address - sym_addr);
+		sprintf(buf, "<0x%p> { %s + 0x%lx }", paddr, sym, address - sym_addr);
 		return;
 	}
 
 	if (!address)
-		sprintf(buf, "<0x%p> /* Maybe null pointer? */", address);
+		sprintf(buf, "<0x%p> /* Maybe null pointer? */", paddr);
 	else if (address >= CONFIG_SYS_MONITOR_BASE &&
 	         address < CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)
-		sprintf(buf, "<0x%p> /* somewhere in u-boot */", address);
+		sprintf(buf, "<0x%p> /* somewhere in u-boot */", paddr);
 	else
-		sprintf(buf, "<0x%p> /* unknown address */", address);
+		sprintf(buf, "<0x%p> /* unknown address */", paddr);
 }
 
 static char *strhwerrcause(uint16_t hwerrcause)
@@ -273,7 +261,7 @@
 void dump(struct pt_regs *fp)
 {
 	char buf[150];
-	size_t i;
+	int i;
 	uint16_t hwerrcause, excause;
 
 	if (!ENABLE_DUMP)
@@ -288,8 +276,8 @@
 	printf("SEQUENCER STATUS:\n");
 	printf(" SEQSTAT: %08lx  IPEND: %04lx  SYSCFG: %04lx\n",
 		fp->seqstat, fp->ipend, fp->syscfg);
-	printf("  HWERRCAUSE: 0x%lx: %s\n", hwerrcause, strhwerrcause(hwerrcause));
-	printf("  EXCAUSE   : 0x%lx: %s\n", excause, strexcause(excause));
+	printf("  HWERRCAUSE: 0x%x: %s\n", hwerrcause, strhwerrcause(hwerrcause));
+	printf("  EXCAUSE   : 0x%x: %s\n", excause, strexcause(excause));
 	for (i = 6; i <= 15; ++i) {
 		if (fp->ipend & (1 << i)) {
 			decode_address(buf, bfin_read32(EVT0 + 4*i));
@@ -323,7 +311,7 @@
 	printf(" P0 : %08lx    P1 : %08lx    P2 : %08lx    P3 : %08lx\n",
 		fp->p0, fp->p1, fp->p2, fp->p3);
 	printf(" P4 : %08lx    P5 : %08lx    FP : %08lx    SP : %08lx\n",
-		fp->p4, fp->p5, fp->fp, fp);
+		fp->p4, fp->p5, fp->fp, (unsigned long)fp);
 	printf(" LB0: %08lx    LT0: %08lx    LC0: %08lx\n",
 		fp->lb0, fp->lt0, fp->lc0);
 	printf(" LB1: %08lx    LT1: %08lx    LC1: %08lx\n",
@@ -349,7 +337,7 @@
 {
 	char buf[150];
 	unsigned long tflags;
-	size_t i = 0;
+	int i = 0;
 
 	if (!ENABLE_DUMP)
 		return;
diff -Naur u-boot-2009.01/cpu/i386/cpu.c u-boot/cpu/i386/cpu.c
--- u-boot-2009.01/cpu/i386/cpu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/i386/cpu.c	2009-02-26 14:03:58.000000000 +0100
@@ -35,6 +35,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/interrupt.h>
 
 int cpu_init(void)
 {
@@ -64,3 +65,19 @@
 	asm("wbinvd\n");
 	return;
 }
+
+void __attribute__ ((regparm(0))) generate_gpf(void);
+
+/* segment 0x70 is an arbitrary segment which does not exist */
+asm(".globl generate_gpf\n"
+    "generate_gpf:\n"
+    "ljmp   $0x70, $0x47114711\n");
+
+void __reset_cpu(ulong addr)
+{
+	printf("Resetting using i386 Triple Fault\n");
+	set_vector(13, generate_gpf);  /* general protection fault handler */
+	set_vector(8, generate_gpf);   /* double fault handler */
+	generate_gpf();                /* start the show */
+}
+void reset_cpu(ulong addr) __attribute__((weak, alias("__reset_cpu")));
diff -Naur u-boot-2009.01/cpu/i386/interrupts.c u-boot/cpu/i386/interrupts.c
--- u-boot-2009.01/cpu/i386/interrupts.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/i386/interrupts.c	2009-02-26 14:03:58.000000000 +0100
@@ -26,6 +26,7 @@
 #include <asm/io.h>
 #include <asm/i8259.h>
 #include <asm/ibmpc.h>
+#include <asm/interrupt.h>
 
 
 struct idt_entry {
@@ -376,7 +377,7 @@
 	".long	idt\n"	 /* offset */
 	".word	0x18\n");/* data segment */
 
-static void set_vector(int intnum, void *routine)
+void set_vector(int intnum, void *routine)
 {
 	idt[intnum].base_high = (u16)((u32)(routine)>>16);
 	idt[intnum].base_low = (u16)((u32)(routine)&0xffff);
@@ -507,19 +508,3 @@
 
 	return (flags&0x200); /* IE flags is bit 9 */
 }
-
-
-#ifdef CONFIG_SYS_RESET_GENERIC
-
-void __attribute__ ((regparm(0))) generate_gpf(void);
-asm(".globl generate_gpf\n"
-    "generate_gpf:\n"
-    "ljmp   $0x70, $0x47114711\n"); /* segment 0x70 is an arbitrary segment which does not
-				    * exist */
-void reset_cpu(ulong addr)
-{
-	set_vector(13, generate_gpf);  /* general protection fault handler */
-	set_vector(8, generate_gpf);   /* double fault handler */
-	generate_gpf();                /* start the show */
-}
-#endif
diff -Naur u-boot-2009.01/cpu/i386/Makefile u-boot/cpu/i386/Makefile
--- u-boot-2009.01/cpu/i386/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/i386/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -28,7 +28,7 @@
 
 LIB	= $(obj)lib$(CPU).a
 
-START	= start.o start16.o reset.o
+START	= start.o start16.o resetvec.o
 COBJS	= serial.o interrupts.o cpu.o timer.o sc520.o
 SOBJS	= sc520_asm.o
 
diff -Naur u-boot-2009.01/cpu/i386/reset.S u-boot/cpu/i386/reset.S
--- u-boot-2009.01/cpu/i386/reset.S	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/i386/reset.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/*
- *  U-boot - i386 Startup Code
- *
- *  Copyright (c) 2002	Omicron Ceti AB, Daniel Engstrm <denaiel@omicron.se>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-/* Reset vector, jumps to start16.S */
-
-.extern start16
-
-.section .reset, "ax"
-.code16
-reset_vector:
-	cli
-	cld
-	jmp start16
-
-	.org 0xf
-	nop
diff -Naur u-boot-2009.01/cpu/i386/resetvec.S u-boot/cpu/i386/resetvec.S
--- u-boot-2009.01/cpu/i386/resetvec.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/i386/resetvec.S	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,37 @@
+/*
+ *  U-boot - i386 Startup Code
+ *
+ *  Copyright (c) 2002	Omicron Ceti AB, Daniel Engstrm <denaiel@omicron.se>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* Reset vector, jumps to start16.S */
+
+.extern start16
+
+.section .resetvec, "ax"
+.code16
+reset_vector:
+	cli
+	cld
+	jmp start16
+
+	.org 0xf
+	nop
diff -Naur u-boot-2009.01/cpu/i386/sc520.c u-boot/cpu/i386/sc520.c
--- u-boot-2009.01/cpu/i386/sc520.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/i386/sc520.c	2009-02-26 14:03:58.000000000 +0100
@@ -25,9 +25,6 @@
  * but idependent of implementation */
 
 #include <config.h>
-
-#ifdef CONFIG_SC520
-
 #include <common.h>
 #include <config.h>
 #include <pci.h>
@@ -344,7 +341,7 @@
 		       SC520_PCI_MEMORY_BUS,
 		       SC520_PCI_MEMORY_PHYS,
 		       SC520_PCI_MEMORY_SIZE,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	/* PCI memory space */
 	pci_set_region(hose->regions + 1,
@@ -507,4 +504,13 @@
 	return read_mmcr_byte(SC520_SSIRCV);
 }
 
-#endif /* CONFIG_SC520 */
+#ifdef CONFIG_SYS_RESET_SC520
+void reset_cpu(ulong addr)
+{
+	printf("Resetting using SC520 MMCR\n");
+	/* Write a '1' to the SYS_RST of the RESCFG MMCR */
+	write_mmcr_word(SC520_RESCFG, 0x0001);
+
+	/* NOTREACHED */
+}
+#endif
diff -Naur u-boot-2009.01/cpu/ixp/cpu.c u-boot/cpu/ixp/cpu.c
--- u-boot-2009.01/cpu/ixp/cpu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ixp/cpu.c	2009-02-26 14:03:58.000000000 +0100
@@ -86,9 +86,6 @@
 	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
 #endif
 
-#if defined(CONFIG_CMD_PCI) || defined (CONFIG_PCI)
-	pci_init();
-#endif
 	return 0;
 }
 
diff -Naur u-boot-2009.01/cpu/ixp/Makefile u-boot/cpu/ixp/Makefile
--- u-boot-2009.01/cpu/ixp/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ixp/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -26,10 +26,14 @@
 LIB	= $(obj)lib$(CPU).a
 
 START	= start.o
-COBJS	= serial.o interrupts.o cpu.o timer.o pci.o
+COBJS-y	+= cpu.o
+COBJS-y	+= interrupts.o
+ifndef CONFIG_USE_IRQ
+COBJS-y	+= timer.o
+endif
 
-SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+SRCS	:= $(START:.o=.S) $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS-y) $(COBJS-y))
 START	:= $(addprefix $(obj),$(START))
 
 all:	$(obj).depend $(START) $(LIB)
diff -Naur u-boot-2009.01/cpu/ixp/npe/IxNpeDlImageMgr.c u-boot/cpu/ixp/npe/IxNpeDlImageMgr.c
--- u-boot-2009.01/cpu/ixp/npe/IxNpeDlImageMgr.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ixp/npe/IxNpeDlImageMgr.c	2009-02-26 14:03:58.000000000 +0100
@@ -133,20 +133,14 @@
  */
 static IxNpeDlImageMgrStats ixNpeDlImageMgrStats;
 
-/* default image */
-#ifdef CONFIG_IXP4XX_NPE_EXT_UCODE_BASE
-static UINT32 *IxNpeMicroCodeImageLibrary = (UINT32 *)CONFIG_IXP4XX_NPE_EXT_UCODE_BASE;
-#else
-static UINT32 *IxNpeMicroCodeImageLibrary = (UINT32 *)IxNpeMicrocode_array;
-#endif
-
 static UINT32* getIxNpeMicroCodeImageLibrary(void)
 {
 	char *s;
+
 	if ((s = getenv("npe_ucode")) != NULL)
 		return (UINT32*) simple_strtoul(s, NULL, 16);
 	else
-		return IxNpeMicroCodeImageLibrary;
+		return NULL;
 }
 
 /*
@@ -422,7 +416,7 @@
 	(IxNpeDlImageMgrImageLibraryHeader *) microCodeImageLibrary;
     BOOL result = TRUE;
 
-    if (header->signature != IX_NPEDL_IMAGEMGR_SIGNATURE)
+    if (!header || header->signature != IX_NPEDL_IMAGEMGR_SIGNATURE)
     {
 	result = FALSE;
 	ixNpeDlImageMgrStats.invalidSignature++;
@@ -643,6 +637,11 @@
 	}
 #else
 	imageLibrary = getIxNpeMicroCodeImageLibrary();
+	if (imageLibrary == NULL)
+        {
+	    printf ("npe:  ERROR, no Microcode found in memory\n");
+	    return IX_FAIL;
+	}
 #endif /* IX_NPEDL_READ_MICROCODE_FROM_FILE */
     }
 
diff -Naur u-boot-2009.01/cpu/ixp/npe/Makefile u-boot/cpu/ixp/npe/Makefile
--- u-boot-2009.01/cpu/ixp/npe/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ixp/npe/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -25,11 +25,11 @@
 
 LIB := $(obj)libnpe.a
 
-LOCAL_CFLAGS  += -I$(TOPDIR)/cpu/ixp/npe/include -DCONFIG_IXP425_COMPONENT_ETHDB
+LOCAL_CFLAGS  += -I$(TOPDIR)/cpu/ixp/npe/include -DCONFIG_IXP425_COMPONENT_ETHDB -D__linux
 CFLAGS  += $(LOCAL_CFLAGS)
 HOST_CFLAGS  += $(LOCAL_CFLAGS)
 
-COBJS := npe.o \
+COBJS-$(CONFIG_IXP4XX_NPE) := npe.o \
 	miiphy.o \
 	IxOsalBufferMgt.o \
 	IxOsalIoMem.o \
@@ -79,17 +79,13 @@
 	IxNpeMhSolicitedCbMgr.o \
 	IxNpeMhUnsolicitedCbMgr.o
 
-ifndef CONFIG_IXP4XX_NPE_EXT_UCODE_BASE
-COBJS += IxNpeMicrocode.o
-endif
-
-SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
-START	:= $(addprefix $(obj),$(START))
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
 
 all:	$(LIB)
 
-$(LIB):	$(OBJS)
+$(LIB):	$(obj).depend $(OBJS)
 	$(AR) $(ARFLAGS) $@ $(OBJS)
 
 #########################################################################
diff -Naur u-boot-2009.01/cpu/ixp/npe/npe.c u-boot/cpu/ixp/npe/npe.c
--- u-boot-2009.01/cpu/ixp/npe/npe.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ixp/npe/npe.c	2009-02-26 14:03:58.000000000 +0100
@@ -44,8 +44,6 @@
 
 #include <npe.h>
 
-#ifdef CONFIG_IXP4XX_NPE
-
 static IxQMgrDispatcherFuncPtr qDispatcherFunc = NULL;
 static int npe_exists[NPE_NUM_PORTS];
 static int npe_used[NPE_NUM_PORTS];
@@ -690,5 +688,3 @@
 
 	return 1;
 }
-
-#endif /* CONFIG_IXP4XX_NPE */
diff -Naur u-boot-2009.01/cpu/ixp/pci.c u-boot/cpu/ixp/pci.c
--- u-boot-2009.01/cpu/ixp/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ixp/pci.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,575 +0,0 @@
-/*
- * IXP PCI Init
- * (C) Copyright 2004 eslab.whut.edu.cn
- * Yue Hu(huyue_whut@yahoo.com.cn), Ligong Xue(lgxue@hotmail.com)
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-
-#include <common.h>
-
-#ifdef CONFIG_PCI
-
-#include <asm/processor.h>
-#include <asm/io.h>
-#include <pci.h>
-#include <asm/arch/ixp425.h>
-#include <asm/arch/ixp425pci.h>
-
-static void non_prefetch_read (unsigned int addr, unsigned int cmd,
-			       unsigned int *data);
-static void non_prefetch_write (unsigned int addr, unsigned int cmd,
-				unsigned int data);
-static void configure_pins (void);
-static void sys_pci_gpio_clock_config (void);
-static void pci_bus_scan (void);
-static int pci_device_exists (unsigned int deviceNo);
-static void sys_pci_bar_info_get (unsigned int devnum, unsigned int bus,
-				  unsigned int dev, unsigned int func);
-static void sys_pci_device_bars_write (void);
-static void calc_bars (PciBar * Bars[], unsigned int nBars,
-		       unsigned int startAddr);
-
-#define PCI_MEMORY_BUS		0x00000000
-#define PCI_MEMORY_PHY		0x48000000
-#define PCI_MEMORY_SIZE		0x04000000
-
-#define PCI_MEM_BUS		0x40000000
-#define PCI_MEM_PHY		0x00000000
-#define PCI_MEM_SIZE		0x04000000
-
-#define	PCI_IO_BUS		0x40000000
-#define PCI_IO_PHY		0x50000000
-#define PCI_IO_SIZE		0x10000000
-
-struct pci_controller hose;
-
-unsigned int nDevices;
-unsigned int nMBars;
-unsigned int nIOBars;
-PciBar *memBars[IXP425_PCI_MAX_BAR];
-PciBar *ioBars[IXP425_PCI_MAX_BAR];
-PciDevice devices[IXP425_PCI_MAX_FUNC_ON_BUS];
-
-int pci_read_config_dword (pci_dev_t dev, int where, unsigned int *val)
-{
-	unsigned int retval;
-	unsigned int addr;
-
-	/*address bits 31:28 specify the device 10:8 specify the function */
-	/*Set the address to be read */
-	addr = BIT ((31 - dev)) | (where & ~3);
-	non_prefetch_read (addr, NP_CMD_CONFIGREAD, &retval);
-
-	*val = retval;
-
-	return (OK);
-}
-
-int pci_read_config_word (pci_dev_t dev, int where, unsigned short *val)
-{
-	unsigned int n;
-	unsigned int retval;
-	unsigned int addr;
-	unsigned int byteEnables;
-
-	n = where % 4;
-	/*byte enables are 4 bits active low, the position of each
-	   bit maps to the byte that it enables */
-	byteEnables =
-		(~(BIT (n) | BIT ((n + 1)))) &
-		IXP425_PCI_BOTTOM_NIBBLE_OF_LONG_MASK;
-	byteEnables = byteEnables << PCI_NP_CBE_BESL;
-	/*address bits 31:28 specify the device 10:8 specify the function */
-	/*Set the address to be read */
-	addr = BIT ((31 - dev)) | (where & ~3);
-	non_prefetch_read (addr, byteEnables | NP_CMD_CONFIGREAD, &retval);
-
-	/*Pick out the word we are interested in */
-	*val = (retval >> (8 * n));
-
-	return (OK);
-}
-
-int pci_read_config_byte (pci_dev_t dev, int where, unsigned char *val)
-{
-	unsigned int retval;
-	unsigned int n;
-	unsigned int byteEnables;
-	unsigned int addr;
-
-	n = where % 4;
-	/*byte enables are 4 bits, active low, the position of each
-	   bit maps to the byte that it enables */
-	byteEnables = (~BIT (n)) & IXP425_PCI_BOTTOM_NIBBLE_OF_LONG_MASK;
-	byteEnables = byteEnables << PCI_NP_CBE_BESL;
-
-	/*address bits 31:28 specify the device, 10:8 specify the function */
-	/*Set the address to be read */
-	addr = BIT ((31 - dev)) | (where & ~3);
-	non_prefetch_read (addr, byteEnables | NP_CMD_CONFIGREAD, &retval);
-	/*Pick out the byte we are interested in */
-	*val = (retval >> (8 * n));
-
-	return (OK);
-}
-
-int pci_write_config_byte (pci_dev_t dev, int where, unsigned char val)
-{
-	unsigned int addr;
-	unsigned int byteEnables;
-	unsigned int n;
-	unsigned int ldata;
-
-	n = where % 4;
-	/*byte enables are 4 bits active low, the position of each
-	   bit maps to the byte that it enables */
-	byteEnables = (~BIT (n)) & IXP425_PCI_BOTTOM_NIBBLE_OF_LONG_MASK;
-	byteEnables = byteEnables << PCI_NP_CBE_BESL;
-	ldata = val << (8 * n);
-	/*address bits 31:28 specify the device 10:8 specify the function */
-	/*Set the address to be written */
-	addr = BIT ((31 - dev)) | (where & ~3);
-	non_prefetch_write (addr, byteEnables | NP_CMD_CONFIGWRITE, ldata);
-
-	return (OK);
-}
-
-int pci_write_config_word (pci_dev_t dev, int where, unsigned short val)
-{
-	unsigned int addr;
-	unsigned int byteEnables;
-	unsigned int n;
-	unsigned int ldata;
-
-	n = where % 4;
-	/*byte enables are 4 bits active low, the position of each
-	   bit maps to the byte that it enables */
-	byteEnables =
-		(~(BIT (n) | BIT ((n + 1)))) &
-		IXP425_PCI_BOTTOM_NIBBLE_OF_LONG_MASK;
-	byteEnables = byteEnables << PCI_NP_CBE_BESL;
-	ldata = val << (8 * n);
-	/*address bits 31:28 specify the device 10:8 specify the function */
-	/*Set the address to be written */
-	addr = BIT (31 - dev) | (where & ~3);
-	non_prefetch_write (addr, byteEnables | NP_CMD_CONFIGWRITE, ldata);
-
-	return (OK);
-}
-
-int pci_write_config_dword (pci_dev_t dev, int where, unsigned int val)
-{
-	unsigned int addr;
-
-	/*address bits 31:28 specify the device 10:8 specify the function */
-	/*Set the address to be written */
-	addr = BIT (31 - dev) | (where & ~3);
-	non_prefetch_write (addr, NP_CMD_CONFIGWRITE, val);
-
-	return (OK);
-}
-
-void non_prefetch_read (unsigned int addr,
-			unsigned int cmd, unsigned int *data)
-{
-	REG_WRITE (PCI_CSR_BASE, PCI_NP_AD_OFFSET, addr);
-
-	/*set up and execute the read */
-	REG_WRITE (PCI_CSR_BASE, PCI_NP_CBE_OFFSET, cmd);
-
-	/*The result of the read is now in np_rdata */
-	REG_READ (PCI_CSR_BASE, PCI_NP_RDATA_OFFSET, *data);
-
-	return;
-}
-
-void non_prefetch_write (unsigned int addr,
-			 unsigned int cmd, unsigned int data)
-{
-
-	REG_WRITE (PCI_CSR_BASE, PCI_NP_AD_OFFSET, addr);
-	/*set up the write */
-	REG_WRITE (PCI_CSR_BASE, PCI_NP_CBE_OFFSET, cmd);
-	/*Execute the write by writing to NP_WDATA */
-	REG_WRITE (PCI_CSR_BASE, PCI_NP_WDATA_OFFSET, data);
-
-	return;
-}
-
-/*
- * PCI controller config registers are accessed through these functions
- * i.e. these allow us to set up our own BARs etc.
- */
-void crp_read (unsigned int offset, unsigned int *data)
-{
-	REG_WRITE (PCI_CSR_BASE, PCI_CRP_AD_CBE_OFFSET, offset);
-	REG_READ (PCI_CSR_BASE, PCI_CRP_RDATA_OFFSET, *data);
-}
-
-void crp_write (unsigned int offset, unsigned int data)
-{
-	/*The CRP address register bit 16 indicates that we want to do a write */
-	REG_WRITE (PCI_CSR_BASE, PCI_CRP_AD_CBE_OFFSET,
-		   PCI_CRP_WRITE | offset);
-	REG_WRITE (PCI_CSR_BASE, PCI_CRP_WDATA_OFFSET, data);
-}
-
-/*struct pci_controller *hose*/
-void pci_ixp_init (struct pci_controller *hose)
-{
-	unsigned int regval;
-
-	hose->first_busno = 0;
-	hose->last_busno = 0x00;
-
-	/* System memory space */
-	pci_set_region (hose->regions + 0,
-			PCI_MEMORY_BUS,
-			PCI_MEMORY_PHY, PCI_MEMORY_SIZE, PCI_REGION_MEMORY);
-
-	/* PCI memory space */
-	pci_set_region (hose->regions + 1,
-			PCI_MEM_BUS,
-			PCI_MEM_PHY, PCI_MEM_SIZE, PCI_REGION_MEM);
-	/* PCI I/O space */
-	pci_set_region (hose->regions + 2,
-			PCI_IO_BUS, PCI_IO_PHY, PCI_IO_SIZE, PCI_REGION_IO);
-
-	hose->region_count = 3;
-
-	pci_register_hose (hose);
-
-/*
- ==========================================================
-		Init IXP PCI
- ==========================================================
-*/
-	REG_READ (PCI_CSR_BASE, PCI_CSR_OFFSET, regval);
-	regval |= 1 << 2;
-	REG_WRITE (PCI_CSR_BASE, PCI_CSR_OFFSET, regval);
-
-	configure_pins ();
-
-	READ_GPIO_REG (IXP425_GPIO_GPOUTR, regval);
-	WRITE_GPIO_REG (IXP425_GPIO_GPOUTR, regval & (~(1 << 13)));
-	udelay (533);
-	sys_pci_gpio_clock_config ();
-	REG_WRITE (PCI_CSR_BASE, PCI_INTEN_OFFSET, 0);
-	udelay (100);
-	READ_GPIO_REG (IXP425_GPIO_GPOUTR, regval);
-	WRITE_GPIO_REG (IXP425_GPIO_GPOUTR, regval | (1 << 13));
-	udelay (533);
-	crp_write (PCI_CFG_BASE_ADDRESS_0, IXP425_PCI_BAR_0_DEFAULT);
-	crp_write (PCI_CFG_BASE_ADDRESS_1, IXP425_PCI_BAR_1_DEFAULT);
-	crp_write (PCI_CFG_BASE_ADDRESS_2, IXP425_PCI_BAR_2_DEFAULT);
-	crp_write (PCI_CFG_BASE_ADDRESS_3, IXP425_PCI_BAR_3_DEFAULT);
-	crp_write (PCI_CFG_BASE_ADDRESS_4, IXP425_PCI_BAR_4_DEFAULT);
-	crp_write (PCI_CFG_BASE_ADDRESS_5, IXP425_PCI_BAR_5_DEFAULT);
-	/*Setup PCI-AHB and AHB-PCI address mappings */
-	REG_WRITE (PCI_CSR_BASE, PCI_AHBMEMBASE_OFFSET,
-		   IXP425_PCI_AHBMEMBASE_DEFAULT);
-
-	REG_WRITE (PCI_CSR_BASE, PCI_AHBIOBASE_OFFSET,
-		   IXP425_PCI_AHBIOBASE_DEFAULT);
-
-	REG_WRITE (PCI_CSR_BASE, PCI_PCIMEMBASE_OFFSET,
-		   IXP425_PCI_PCIMEMBASE_DEFAULT);
-
-	crp_write (PCI_CFG_SUB_VENDOR_ID, IXP425_PCI_SUB_VENDOR_SYSTEM);
-
-	REG_READ (PCI_CSR_BASE, PCI_CSR_OFFSET, regval);
-	regval |= PCI_CSR_IC | PCI_CSR_ABE | PCI_CSR_PDS;
-	REG_WRITE (PCI_CSR_BASE, PCI_CSR_OFFSET, regval);
-	crp_write (PCI_CFG_COMMAND, PCI_CFG_CMD_MAE | PCI_CFG_CMD_BME);
-	udelay (1000);
-
-	pci_write_config_word (0, PCI_CFG_COMMAND, INITIAL_PCI_CMD);
-	REG_WRITE (PCI_CSR_BASE, PCI_ISR_OFFSET, PCI_ISR_PSE
-		   | PCI_ISR_PFE | PCI_ISR_PPE | PCI_ISR_AHBE);
-#ifdef CONFIG_PCI_SCAN_SHOW
-	printf ("Device  bus  dev  func  deviceID  vendorID \n");
-#endif
-	pci_bus_scan ();
-}
-
-void configure_pins (void)
-{
-	unsigned int regval;
-
-	/* Disable clock on GPIO PIN 14 */
-	READ_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
-	WRITE_GPIO_REG (IXP425_GPIO_GPCLKR, regval & (~(1 << 8)));
-	READ_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
-
-	READ_GPIO_REG (IXP425_GPIO_GPOER, regval);
-	WRITE_GPIO_REG (IXP425_GPIO_GPOER,
-			(((~(3 << 13)) & regval) | (0xf << 8)));
-	READ_GPIO_REG (IXP425_GPIO_GPOER, regval);
-
-	READ_GPIO_REG (IXP425_GPIO_GPIT2R, regval);
-	WRITE_GPIO_REG (IXP425_GPIO_GPIT2R,
-			(regval &
-			 ((0x1 << 9) | (0x1 << 6) | (0x1 << 3) | 0x1)));
-	READ_GPIO_REG (IXP425_GPIO_GPIT2R, regval);
-
-	READ_GPIO_REG (IXP425_GPIO_GPISR, regval);
-	WRITE_GPIO_REG (IXP425_GPIO_GPISR, (regval | (0xf << 8)));
-	READ_GPIO_REG (IXP425_GPIO_GPISR, regval);
-}
-
-void sys_pci_gpio_clock_config (void)
-{
-	unsigned int regval;
-
-	READ_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
-	regval |= 0x1 << 4;
-	WRITE_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
-	READ_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
-	regval |= 0x1 << 8;
-	WRITE_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
-}
-
-void pci_bus_scan (void)
-{
-	unsigned int bus = 0, dev, func = 0;
-	unsigned short data16;
-	unsigned int data32;
-	unsigned char intPin;
-
-	/* Assign first device to ourselves */
-	devices[0].bus = 0;
-	devices[0].device = 0;
-	devices[0].func = 0;
-
-	crp_read (PCI_CFG_VENDOR_ID, &data32);
-
-	devices[0].vendor_id = data32 & IXP425_PCI_BOTTOM_WORD_OF_LONG_MASK;
-	devices[0].device_id = data32 >> 16;
-	devices[0].error = FALSE;
-	devices[0].bar[NO_BAR].size = 0;	/*dummy - required */
-
-	nDevices = 1;
-
-	nMBars = 0;
-	nIOBars = 0;
-
-	for (dev = 0; dev < IXP425_PCI_MAX_DEV; dev++) {
-
-		/*Check whether a device is present */
-		if (pci_device_exists (dev) != TRUE) {
-
-			/*Clear error bits in ISR, write 1 to clear */
-			REG_WRITE (PCI_CSR_BASE, PCI_ISR_OFFSET, PCI_ISR_PSE
-				   | PCI_ISR_PFE | PCI_ISR_PPE |
-				   PCI_ISR_AHBE);
-			continue;
-		}
-
-		/*A device is present, add an entry to the array */
-		devices[nDevices].bus = bus;
-		devices[nDevices].device = dev;
-		devices[nDevices].func = func;
-
-		pci_read_config_word (dev, PCI_CFG_VENDOR_ID, &data16);
-
-		devices[nDevices].vendor_id = data16;
-
-		pci_read_config_word (dev, PCI_CFG_DEVICE_ID, &data16);
-		devices[nDevices].device_id = data16;
-
-		/*The device is functioning correctly, set error to FALSE */
-		devices[nDevices].error = FALSE;
-
-		/*Figure out what BARs are on this device */
-		sys_pci_bar_info_get (nDevices, bus, dev, func);
-		/*Figure out what INTX# line the card uses */
-		pci_read_config_byte (dev, PCI_CFG_DEV_INT_PIN, &intPin);
-
-		/*assign the appropriate irq line */
-		if (intPin > PCI_IRQ_LINES) {
-			devices[nDevices].error = TRUE;
-		} else if (intPin != 0) {
-			/*This device uses an interrupt line */
-			/*devices[nDevices].irq = ixp425PciIntTranslate[dev][intPin-1]; */
-			devices[nDevices].irq = intPin;
-		}
-#ifdef CONFIG_PCI_SCAN_SHOW
-		printf ("%06d    %03d %03d %04d  %08d      %08x\n", nDevices,
-			devices[nDevices].vendor_id);
-#endif
-		nDevices++;
-
-	}
-
-	calc_bars (memBars, nMBars, IXP425_PCI_BAR_MEM_BASE);
-	sys_pci_device_bars_write ();
-
-	REG_WRITE (PCI_CSR_BASE, PCI_ISR_OFFSET, PCI_ISR_PSE
-		   | PCI_ISR_PFE | PCI_ISR_PPE | PCI_ISR_AHBE);
-}
-
-void sys_pci_bar_info_get (unsigned int devnum,
-			   unsigned int bus,
-			   unsigned int dev, unsigned int func)
-{
-	unsigned int data32;
-	unsigned int tmp;
-	unsigned int size;
-
-	pci_write_config_dword (devnum,
-				PCI_CFG_BASE_ADDRESS_0, IXP425_PCI_BAR_QUERY);
-	pci_read_config_dword (devnum, PCI_CFG_BASE_ADDRESS_0, &data32);
-
-	devices[devnum].bar[0].address = (data32 & 1);
-
-	if (data32 & 1) {
-		/* IO space */
-		tmp = data32 & ~0x3;
-		size = ~(tmp - 1);
-		devices[devnum].bar[0].size = size;
-
-		if (nIOBars < IXP425_PCI_MAX_BAR) {
-			ioBars[nIOBars++] = &devices[devnum].bar[0];
-		}
-	} else {
-		/* Mem space */
-		tmp = data32 & ~IXP425_PCI_BOTTOM_NIBBLE_OF_LONG_MASK;
-		size = ~(tmp - 1);
-		devices[devnum].bar[0].size = size;
-
-		if (nMBars < IXP425_PCI_MAX_BAR) {
-			memBars[nMBars++] = &devices[devnum].bar[0];
-		} else {
-			devices[devnum].error = TRUE;
-		}
-
-	}
-
-	devices[devnum].bar[1].size = 0;
-}
-
-void sortBars (PciBar * Bars[], unsigned int nBars)
-{
-	unsigned int i, j;
-	PciBar *tmp;
-
-	if (nBars == 0) {
-		return;
-	}
-
-	/* Sort biggest to smallest */
-	for (i = 0; i < nBars - 1; i++) {
-		for (j = i + 1; j < nBars; j++) {
-			if (Bars[j]->size > Bars[i]->size) {
-				/* swap them */
-				tmp = Bars[i];
-				Bars[i] = Bars[j];
-				Bars[j] = tmp;
-			}
-		}
-	}
-}
-
-void calc_bars (PciBar * Bars[], unsigned int nBars, unsigned int startAddr)
-{
-	unsigned int i;
-
-	if (nBars == 0) {
-		return;
-	}
-
-	for (i = 0; i < nBars; i++) {
-		Bars[i]->address |= startAddr;
-		startAddr += Bars[i]->size;
-	}
-}
-
-void sys_pci_device_bars_write (void)
-{
-	unsigned int i;
-	int addr;
-
-	for (i = 1; i < nDevices; i++) {
-		if (devices[i].error) {
-			continue;
-		}
-
-		pci_write_config_dword (devices[i].device,
-					PCI_CFG_BASE_ADDRESS_0,
-					devices[i].bar[0].address);
-		addr = BIT (31 - devices[i].device) |
-			(0 << PCI_NP_AD_FUNCSL) |
-			(PCI_CFG_BASE_ADDRESS_0 & ~3);
-		pci_write_config_dword (devices[i].device,
-					PCI_CFG_DEV_INT_LINE, devices[i].irq);
-
-		pci_write_config_word (devices[i].device,
-				       PCI_CFG_COMMAND, INITIAL_PCI_CMD);
-
-	}
-}
-
-
-int pci_device_exists (unsigned int deviceNo)
-{
-	unsigned int vendorId;
-	unsigned int regval;
-
-	pci_read_config_dword (deviceNo, PCI_CFG_VENDOR_ID, &vendorId);
-
-	/* There are two ways to find out an empty device.
-	 *   1. check Master Abort bit after the access.
-	 *   2. check whether the vendor id read back is 0x0.
-	 */
-	REG_READ (PCI_CSR_BASE, PCI_ISR_OFFSET, regval);
-	if ((vendorId != 0x0) && ((regval & PCI_ISR_PFE) == 0)) {
-		return TRUE;
-	}
-	/*no device present, make sure that the master abort bit is reset */
-
-	REG_WRITE (PCI_CSR_BASE, PCI_ISR_OFFSET, PCI_ISR_PFE);
-	return FALSE;
-}
-
-pci_dev_t pci_find_devices (struct pci_device_id * ids, int devNo)
-{
-	unsigned int i;
-	unsigned int devdidvid;
-	unsigned int didvid;
-	unsigned int vendorId, deviceId;
-
-	vendorId = ids->vendor;
-	deviceId = ids->device;
-	didvid = ((deviceId << 16) & IXP425_PCI_TOP_WORD_OF_LONG_MASK) |
-		(vendorId & IXP425_PCI_BOTTOM_WORD_OF_LONG_MASK);
-
-	for (i = devNo + 1; i < nDevices; i++) {
-
-		pci_read_config_dword (devices[i].device, PCI_CFG_VENDOR_ID,
-				       &devdidvid);
-
-		if (devdidvid == didvid) {
-			return devices[i].device;
-		}
-	}
-	return -1;
-}
-#endif	/* CONFIG_PCI */
diff -Naur u-boot-2009.01/cpu/ixp/serial.c u-boot/cpu/ixp/serial.c
--- u-boot-2009.01/cpu/ixp/serial.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ixp/serial.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,125 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
- *
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Marius Groeger <mgroeger@sysgo.de>
- *
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Alex Zuepke <azu@sysgo.de>
- *
- * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include <common.h>
-#include <asm/arch/ixp425.h>
-
-/*
- *               14.7456 MHz
- * Baud Rate = --------------
- *              16 x Divisor
- */
-#define SERIAL_CLOCK 921600
-
-DECLARE_GLOBAL_DATA_PTR;
-
-void serial_setbrg (void)
-{
-	unsigned int quot = 0;
-	int uart = CONFIG_SYS_IXP425_CONSOLE;
-
-	if ((gd->baudrate <= SERIAL_CLOCK) && (SERIAL_CLOCK % gd->baudrate == 0))
-		quot = SERIAL_CLOCK / gd->baudrate;
-	else
-		hang ();
-
-	IER(uart) = 0;					/* Disable for now */
-	FCR(uart) = 0;					/* No fifos enabled */
-
-	/* set baud rate */
-	LCR(uart) = LCR_WLS0 | LCR_WLS1 | LCR_DLAB;
-	DLL(uart) = quot & 0xff;
-	DLH(uart) = quot >> 8;
-	LCR(uart) = LCR_WLS0 | LCR_WLS1;
-#ifdef CONFIG_SERIAL_RTS_ACTIVE
-	MCR(uart) = MCR_RTS;				/* set RTS active */
-#else
-	MCR(uart) = 0;					/* set RTS inactive */
-#endif
-	IER(uart) = IER_UUE;
-}
-
-/*
- * Initialise the serial port with the given baudrate. The settings
- * are always 8 data bits, no parity, 1 stop bit, no start bits.
- *
- */
-int serial_init (void)
-{
-	serial_setbrg ();
-
-	return (0);
-}
-
-
-/*
- * Output a single byte to the serial port.
- */
-void serial_putc (const char c)
-{
-	/* wait for room in the tx FIFO on UART */
-	while ((LSR(CONFIG_SYS_IXP425_CONSOLE) & LSR_TEMT) == 0);
-
-	THR(CONFIG_SYS_IXP425_CONSOLE) = c;
-
-	/* If \n, also do \r */
-	if (c == '\n')
-		serial_putc ('\r');
-}
-
-/*
- * Read a single byte from the serial port. Returns 1 on success, 0
- * otherwise. When the function is succesfull, the character read is
- * written into its argument c.
- */
-int serial_tstc (void)
-{
-	return LSR(CONFIG_SYS_IXP425_CONSOLE) & LSR_DR;
-}
-
-/*
- * Read a single byte from the serial port. Returns 1 on success, 0
- * otherwise. When the function is succesfull, the character read is
- * written into its argument c.
- */
-int serial_getc (void)
-{
-	while (!(LSR(CONFIG_SYS_IXP425_CONSOLE) & LSR_DR));
-
-	return (char) RBR(CONFIG_SYS_IXP425_CONSOLE) & 0xff;
-}
-
-void
-serial_puts (const char *s)
-{
-	while (*s) {
-		serial_putc (*s++);
-	}
-}
diff -Naur u-boot-2009.01/cpu/ixp/timer.c u-boot/cpu/ixp/timer.c
--- u-boot-2009.01/cpu/ixp/timer.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ixp/timer.c	2009-02-26 14:03:58.000000000 +0100
@@ -32,7 +32,6 @@
 #include <common.h>
 #include <asm/arch/ixp425.h>
 
-#ifndef CONFIG_USE_IRQ
 ulong get_timer (ulong base)
 {
        return get_timer_masked () - base;
@@ -80,4 +79,3 @@
 	}
 	return (reload_constant - current);
 }
-#endif /* #ifndef CONFIG_USE_IRQ */
diff -Naur u-boot-2009.01/cpu/mcf52x2/cpu_init.c u-boot/cpu/mcf52x2/cpu_init.c
--- u-boot-2009.01/cpu/mcf52x2/cpu_init.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mcf52x2/cpu_init.c	2009-02-26 14:03:58.000000000 +0100
@@ -181,9 +181,14 @@
 	/* FlexBus Chipselect */
 	init_fbcs();
 
+#ifdef CONFIG_SYS_MCF_SYNCR
+	/* Set clockspeed according to board header file */
+	mbar_writeLong(MCF_FMPLL_SYNCR, CONFIG_SYS_MCF_SYNCR);
+#else
 	/* Set clockspeed to 100MHz */
-	mbar_writeShort(MCF_FMPLL_SYNCR,
+	mbar_writeLong(MCF_FMPLL_SYNCR,
 			MCF_FMPLL_SYNCR_MFD(0) | MCF_FMPLL_SYNCR_RFD(0));
+#endif
 	while (!mbar_readByte(MCF_FMPLL_SYNSR) & MCF_FMPLL_SYNSR_LOCK) ;
 }
 
@@ -219,7 +224,8 @@
 {
 	if (setclear) {
 		/* Enable Ethernet pins */
-		mbar_writeByte(MCF_GPIO_PAR_FECI2C, CONFIG_SYS_FECI2C);
+		mbar_writeByte(MCF_GPIO_PAR_FECI2C,
+			       (mbar_readByte(MCF_GPIO_PAR_FECI2C) | 0xF0));
 	} else {
 	}
 
diff -Naur u-boot-2009.01/cpu/mcf52x2/speed.c u-boot/cpu/mcf52x2/speed.c
--- u-boot-2009.01/cpu/mcf52x2/speed.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mcf52x2/speed.c	2009-02-26 14:03:58.000000000 +0100
@@ -77,7 +77,8 @@
 #endif
 
 	gd->cpu_clk = CONFIG_SYS_CLK;
-#if defined(CONFIG_M5249) || defined(CONFIG_M5253) || defined(CONFIG_M5275)
+#if defined(CONFIG_M5249) || defined(CONFIG_M5253) || \
+    defined(CONFIG_M5271) || defined(CONFIG_M5275)
 	gd->bus_clk = gd->cpu_clk / 2;
 #else
 	gd->bus_clk = gd->cpu_clk;
diff -Naur u-boot-2009.01/cpu/mcf5445x/pci.c u-boot/cpu/mcf5445x/pci.c
--- u-boot-2009.01/cpu/mcf5445x/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mcf5445x/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -146,7 +146,7 @@
 
 	pci_set_region(hose->regions + 2, CONFIG_SYS_PCI_SYS_MEM_BUS,
 		       CONFIG_SYS_PCI_SYS_MEM_PHYS, CONFIG_SYS_PCI_SYS_MEM_SIZE,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose->region_count = 3;
 
diff -Naur u-boot-2009.01/cpu/mcf547x_8x/pci.c u-boot/cpu/mcf547x_8x/pci.c
--- u-boot-2009.01/cpu/mcf547x_8x/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mcf547x_8x/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -149,7 +149,7 @@
 
 	pci_set_region(hose->regions + 2, CONFIG_SYS_PCI_SYS_MEM_BUS,
 		       CONFIG_SYS_PCI_SYS_MEM_PHYS, CONFIG_SYS_PCI_SYS_MEM_SIZE,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose->region_count = 3;
 
diff -Naur u-boot-2009.01/cpu/microblaze/cache.c u-boot/cpu/microblaze/cache.c
--- u-boot-2009.01/cpu/microblaze/cache.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/microblaze/cache.c	2009-02-26 14:03:58.000000000 +0100
@@ -25,8 +25,6 @@
 #include <common.h>
 #include <asm/asm.h>
 
-#if defined(CONFIG_CMD_CACHE)
-
 int dcache_status (void)
 {
 	int i = 0;
@@ -62,4 +60,3 @@
 void	dcache_disable(void) {
 	MSRCLR(0x80);
 }
-#endif
diff -Naur u-boot-2009.01/cpu/mips/au1x00_usb_ohci.c u-boot/cpu/mips/au1x00_usb_ohci.c
--- u-boot-2009.01/cpu/mips/au1x00_usb_ohci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mips/au1x00_usb_ohci.c	2009-02-26 14:03:58.000000000 +0100
@@ -27,9 +27,7 @@
  */
 /*
  * IMPORTANT NOTES
- * 1 - you MUST define LITTLEENDIAN in the configuration file for the
- *     board or this driver will NOT work!
- * 2 - this driver is intended for use with USB Mass Storage Devices
+ * 1 - this driver is intended for use with USB Mass Storage Devices
  *     (BBB) ONLY. There is NO support for Interrupt or Isochronous pipes!
  */
 
@@ -56,7 +54,7 @@
 #define USBH_ENABLE_CE (1<<3)
 #define USBH_ENABLE_RD (1<<4)
 
-#ifdef LITTLEENDIAN
+#ifdef __LITTLE_ENDIAN
 #define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C)
 #else
 #define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C | USBH_ENABLE_BE)
diff -Naur u-boot-2009.01/cpu/mips/cpu.c u-boot/cpu/mips/cpu.c
--- u-boot-2009.01/cpu/mips/cpu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mips/cpu.c	2009-02-26 14:03:58.000000000 +0100
@@ -65,6 +65,34 @@
 	}
 }
 
+void flush_dcache_range(ulong start_addr, ulong stop)
+{
+	unsigned long lsize = CONFIG_SYS_CACHELINE_SIZE;
+	unsigned long addr = start_addr & ~(lsize - 1);
+	unsigned long aend = (stop - 1) & ~(lsize - 1);
+
+	while (1) {
+		cache_op(Hit_Writeback_Inv_D, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+}
+
+void invalidate_dcache_range(ulong start_addr, ulong stop)
+{
+	unsigned long lsize = CONFIG_SYS_CACHELINE_SIZE;
+	unsigned long addr = start_addr & ~(lsize - 1);
+	unsigned long aend = (stop - 1) & ~(lsize - 1);
+
+	while (1) {
+		cache_op(Hit_Invalidate_D, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+}
+
 void write_one_tlb(int index, u32 pagemask, u32 hi, u32 low0, u32 low1)
 {
 	write_c0_entrylo0(low0);
diff -Naur u-boot-2009.01/cpu/mips/Makefile u-boot/cpu/mips/Makefile
--- u-boot-2009.01/cpu/mips/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mips/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -25,6 +25,7 @@
 
 LIB	= $(obj)lib$(CPU).a
 
+START	= start.o
 SOBJS-y	= cache.o
 COBJS-y	= cpu.o interrupts.o
 
diff -Naur u-boot-2009.01/cpu/mpc512x/iim.c u-boot/cpu/mpc512x/iim.c
--- u-boot-2009.01/cpu/mpc512x/iim.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/mpc512x/iim.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,394 @@
+/*
+ * Copyright 2008 Silicon Turnkey Express, Inc.
+ * Martha Marx <mmarx@silicontkx.com>
+ *
+ * ADS5121 IIM (Fusebox) Interface
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_CMD_FUSE
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static char cur_bank = '1';
+
+char *iim_err_msg(u32 err)
+{
+	static char *IIM_errs[] = {
+		"Parity Error in cache",
+		"Explicit Sense Cycle Error",
+		"Write to Locked Register Error",
+		"Read Protect Error",
+		"Override Protect Error",
+		"Write Protect Error"};
+
+	int i;
+
+	if (!err)
+		return "";
+	for (i = 1; i < 8; i++)
+		if (err & (1 << i))
+			printf("IIM - %s\n", IIM_errs[i-1]);
+	return "";
+}
+
+int in_range(int n, int min, int max, char *err, char *usg)
+{
+	if (n > max || n < min) {
+		printf(err);
+		printf("Usage:\n%s\n", usg);
+		return 0;
+	}
+	return 1;
+}
+
+int ads5121_fuse_read(int bank, int fstart, int num)
+{
+	iim512x_t *iim = &((immap_t *) CONFIG_SYS_IMMR)->iim;
+	u32 *iim_fb, dummy;
+	int f, ctr;
+
+	out_be32(&iim->err, in_be32(&iim->err));
+	if (bank == 0)
+		iim_fb = (u32 *)&(iim->fbac0);
+	else
+		iim_fb = (u32 *)&(iim->fbac1);
+/* try a read to see if Read Protect is set */
+	dummy = in_be32(&iim_fb[0]);
+	if (in_be32(&iim->err) & IIM_ERR_RPE) {
+		printf("\tRead protect fuse is set\n");
+		out_be32(&iim->err, IIM_ERR_RPE);
+		return 0;
+	}
+	printf("Reading Bank %d cache\n", bank);
+	for (f = fstart, ctr = 0; num > 0; ctr++, num--, f++) {
+		if (ctr % 4 == 0)
+			printf("F%2d:", f);
+		printf("\t%#04x", (u8)(iim_fb[f]));
+		if (ctr % 4 == 3)
+			printf("\n");
+	}
+	if (ctr % 4 != 0)
+		printf("\n");
+}
+
+int ads5121_fuse_override(int bank, int f, u8 val)
+{
+	iim512x_t *iim = &((immap_t *) CONFIG_SYS_IMMR)->iim;
+	u32 *iim_fb;
+	u32 iim_stat;
+	int i;
+
+	out_be32(&iim->err, in_be32(&iim->err));
+	if (bank == 0)
+		iim_fb = (u32 *)&(iim->fbac0);
+	else
+		iim_fb = (u32 *)&(iim->fbac1);
+/* try a read to see if Read Protect is set */
+	iim_stat = in_be32(&iim_fb[0]);
+	if (in_be32(&iim->err) & IIM_ERR_RPE) {
+		printf("Read protect fuse is set on bank %d;"
+			"Override protect may also be set\n", bank);
+		printf("An attempt will be made to override\n");
+		out_be32(&iim->err, IIM_ERR_RPE);
+	}
+	if (iim_stat & IIM_FBAC_FBOP) {
+		printf("Override protect fuse is set on bank %d\n", bank);
+		return 1;
+	}
+	if (f > IIM_FMAX) /* reset the entire bank */
+		for (i = 0; i < IIM_FMAX + 1; i++)
+			out_be32(&iim_fb[i],  0);
+	else
+		out_be32(&iim_fb[f], val);
+	return 0;
+}
+
+int ads5121_fuse_prog(cmd_tbl_t *cmdtp, int bank, char *fuseno_bitno)
+{
+	iim512x_t *iim = &((immap_t *) CONFIG_SYS_IMMR)->iim;
+	int f, i, bitno;
+	u32 stat, err;
+
+	f = simple_strtol(fuseno_bitno, NULL, 10);
+	if (f == 0 && fuseno_bitno[0] != '0')
+		f = -1;
+	if (!in_range(f, 0, IIM_FMAX,
+		"<frow> must be between 0-31\n\n", cmdtp->usage))
+		return 1;
+	bitno = -1;
+	for (i = 0; i < 6; i++) {
+		if (fuseno_bitno[i] == '_') {
+			bitno = simple_strtol(&(fuseno_bitno[i+1]), NULL, 10);
+			if (bitno == 0 && fuseno_bitno[i+1] != '0')
+				bitno = -1;
+			break;
+		}
+	}
+	if (!in_range(bitno, 0, 7, "Bit number ranges from 0-7\n"
+		"Example of <frow_bitno>: \"18_4\" sets bit 4 of row 18\n",
+		cmdtp->usage))
+		return 1;
+	out_be32(&iim->err, in_be32(&iim->err));
+	out_be32(&iim->prg_p, IIM_PRG_P_SET);
+	out_be32(&iim->ua, IIM_SET_UA(bank, f));
+	out_be32(&iim->la, IIM_SET_LA(f, bitno));
+#ifdef DEBUG
+	printf("Programming disabled with DEBUG defined \n");
+	printf(""Set up to pro
+	printf("iim.ua = %x; iim.la = %x\n", iim->ua, iim->la);
+#else
+	out_be32(&iim->fctl, IIM_FCTL_PROG_PULSE | IIM_FCTL_PROG);
+	do
+		udelay(20);
+	while ((stat = in_be32(&iim->stat)) & IIM_STAT_BUSY);
+	out_be32(&iim->prg_p, 0);
+	err = in_be32(&iim->err);
+	if (stat & IIM_STAT_PRGD) {
+		if (!(err & (IIM_ERR_WPE | IIM_ERR_WPE))) {
+			printf("Fuse is successfully set");
+			if (err)
+				printf(" - however there are other errors");
+			printf("\n");
+		}
+		iim->stat = 0;
+	}
+	if (err) {
+		iim_err_msg(err);
+		out_be32(&iim->err, in_be32(&iim->err));
+	}
+#endif
+}
+
+int ads5121_fuse_sense(int bank, int fstart, int num)
+{
+	iim512x_t *iim = &((immap_t *) CONFIG_SYS_IMMR)->iim;
+	u32 iim_fbac;
+	u32 stat, err, err_hold = 0;
+	int f, ctr;
+
+	out_be32(&iim->err, in_be32(&iim->err));
+	if (bank == 0)
+		iim_fbac = in_be32(&iim->fbac0);
+	else
+		iim_fbac = in_be32(&iim->fbac1);
+	if (iim_fbac & IIM_FBAC_FBESP) {
+		printf("\tSense Protect disallows this operation\n");
+		out_be32(&iim->err, IIM_FBAC_FBESP);
+		return 1;
+	}
+	err = in_be32(&iim->err);
+	if (err) {
+		iim_err_msg(err);
+		err_hold |= err;
+	}
+	if (err & IIM_ERR_RPE)
+		printf("\tRead protect fuse is set; "
+			"Sense Protect may be set but will be attempted\n");
+	if (err)
+		out_be32(&iim->err, err);
+	printf("Sensing fuse(s) on Bank %d\n", bank);
+	for (f = fstart, ctr = 0; num > 0; ctr++, f++, num--) {
+		out_be32(&iim->ua, IIM_SET_UA(bank, f));
+		out_be32(&iim->la, IIM_SET_LA(f, 0));
+		out_be32(&iim->fctl,  IIM_FCTL_ESNS_N);
+		do
+			udelay(20);
+		while ((stat = in_be32(&iim->stat)) & IIM_STAT_BUSY);
+		err = in_be32(&iim->err);
+		if (err & IIM_ERR_SNSE) {
+			iim_err_msg(err);
+			out_be32(&iim->err, IIM_ERR_SNSE);
+			return 1;
+		}
+		if (stat & IIM_STAT_SNSD) {
+			out_be32(&iim->stat, 0);
+			if (ctr % 4 == 0)
+				printf("F%2d:", f);
+			printf("\t%#04x", (u8)iim->sdat);
+			if (ctr % 4 == 3)
+				printf("\n");
+		}
+		if (err) {
+			err_hold |= err;
+			out_be32(&iim->err, err);
+		}
+	}
+	if (ctr % 4 != 0)
+		printf("\n");
+	if (err_hold)
+		iim_err_msg(err_hold);
+
+	return 0;
+}
+
+int ads5121_fuse_stat(int bank)
+{
+	iim512x_t *iim = &((immap_t *) CONFIG_SYS_IMMR)->iim;
+	u32 iim_fbac;
+	u32 err;
+
+	out_be32(&iim->err, in_be32(&iim->err));
+	if (bank == 0)
+		iim_fbac = in_be32(&iim->fbac0);
+	else
+		iim_fbac = in_be32(&iim->fbac1);
+	err = in_be32(&iim->err);
+	if (err)
+		iim_err_msg(err);
+	if (err & IIM_ERR_RPE  || iim_fbac & IIM_FBAC_FBRP) {
+		if (iim_fbac == 0)
+			printf("Since protection settings can't be read - "
+				"try sensing fuse row 0;\n");
+		return 0;
+	}
+	if (iim_fbac & IIM_PROTECTION)
+		printf("Protection Fuses Bank %d = %#04x:\n", bank, iim_fbac);
+	else if (!(err & IIM_ERR_RPE))
+		printf("No Protection fuses are set\n");
+	if (iim_fbac & IIM_FBAC_FBWP)
+		printf("\tWrite Protect fuse is set\n");
+	if (iim_fbac & IIM_FBAC_FBOP)
+		printf("\tOverride Protect fuse is set\n");
+	if (iim_fbac & IIM_FBAC_FBESP)
+		printf("\tSense Protect Fuse is set\n");
+	out_be32(&iim->err, in_be32(&iim->err));
+
+	return 0;
+}
+
+int do_ads5121_fuse(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int frow, n, v, bank;
+
+	if (cur_bank == '0')
+		bank = 0;
+	else
+		bank = 1;
+
+	switch (argc) {
+	case 0:
+	case 1:
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	case 2:
+		if (strncmp(argv[1], "stat", 4) == 0)
+			return ads5121_fuse_stat(bank);
+		if (strncmp(argv[1], "read", 4) == 0)
+			return ads5121_fuse_read(bank, 0, IIM_FMAX + 1);
+		if (strncmp(argv[1], "sense", 5) == 0)
+			return ads5121_fuse_sense(bank, 0, IIM_FMAX + 1);
+		if (strncmp(argv[1], "ovride", 6) == 0)
+			return ads5121_fuse_override(bank, IIM_FMAX + 1, 0);
+		if (strncmp(argv[1], "bank", 4) == 0) {
+			printf("Active Fuse Bank is %c\n", cur_bank);
+			return 0;
+		}
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	case 3:
+		if (strncmp(argv[1], "bank", 4) == 0) {
+			if (argv[2][0] == '0')
+				cur_bank = '0';
+			else if (argv[2][0] == '1')
+				cur_bank = '1';
+			else {
+				printf("Usage:\n%s\n", cmdtp->usage);
+				return 1;
+			}
+
+			printf("Setting Active Fuse Bank to %c\n", cur_bank);
+			return 0;
+		}
+		if (strncmp(argv[1], "prog", 4) == 0)
+			return ads5121_fuse_prog(cmdtp, bank, argv[2]);
+
+		frow = (int)simple_strtol(argv[2], NULL, 10);
+		if (frow == 0 && argv[2][0] != '0')
+			frow = -1;
+		if (!in_range(frow, 0, IIM_FMAX,
+			"<frow> must be between 0-31\n\n", cmdtp->usage))
+			return 1;
+		if (strncmp(argv[1], "read", 4) == 0)
+			return ads5121_fuse_read(bank, frow, 1);
+		if (strncmp(argv[1], "ovride", 6) == 0)
+			return ads5121_fuse_override(bank, frow, 0);
+		if (strncmp(argv[1], "sense", 5) == 0)
+			return ads5121_fuse_sense(bank, frow, 1);
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	case 4:
+		frow = (int)simple_strtol(argv[2], NULL, 10);
+		if (frow == 0 && argv[2][0] != '0')
+			frow = -1;
+		if (!in_range(frow, 0, IIM_FMAX,
+			"<frow> must be between 0-31\n\n", cmdtp->usage))
+			return 1;
+		if (strncmp(argv[1], "read", 4) == 0) {
+			n = (int)simple_strtol(argv[3], NULL, 10);
+			if (!in_range(frow + n, frow + 1, IIM_FMAX + 1,
+				"<frow>+<n> must be between 1-32\n\n",
+				cmdtp->usage))
+				return 1;
+			return ads5121_fuse_read(bank, frow, n);
+		}
+		if (strncmp(argv[1], "ovride", 6) == 0) {
+			v = (int)simple_strtol(argv[3], NULL, 10);
+			return ads5121_fuse_override(bank, frow, v);
+		}
+		if (strncmp(argv[1], "sense", 5) == 0) {
+			n = (int)simple_strtol(argv[3], NULL, 10);
+			if (!in_range(frow + n, frow + 1, IIM_FMAX + 1,
+				"<frow>+<n> must be between 1-32\n\n",
+				cmdtp->usage))
+				return 1;
+			return ads5121_fuse_sense(bank, frow, n);
+		}
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	default: /* at least 5 args */
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+}
+
+U_BOOT_CMD(
+	fuse, CONFIG_SYS_MAXARGS, 0, do_ads5121_fuse,
+	"   - Read, Sense, Override or Program Fuses\n",
+	"bank <n>		- sets active Fuse Bank to 0 or 1\n"
+	"			    no args shows current active bank\n"
+	"fuse stat		- print active fuse bank's protection status\n"
+	"fuse read [<frow> [<n>]] - print <n> fuse rows starting at <frow>\n"
+	"			    no args to print entire bank's fuses\n"
+	"fuse ovride [<frow> [<v>]]- override fuses at <frow> with <v>\n"
+	"			    no <v> defaults to 0 for the row\n"
+	"			    no args resets entire bank to 0\n"
+	"			  NOTE - settings persist until hard reset\n"
+	"fuse sense [<frow>]	- senses current fuse at <frow>\n"
+	"			    no args for entire bank\n"
+	"fuse prog <frow_bit> 	- program fuse at row <frow>, bit <_bit>\n"
+	"			    <frow> is 0-31, <bit> is 0-7; eg. 13_2 \n"
+	"			  WARNING - this is permanent\n"
+	);
+#endif /* CONFIG_CMD_FUSE */
diff -Naur u-boot-2009.01/cpu/mpc512x/Makefile u-boot/cpu/mpc512x/Makefile
--- u-boot-2009.01/cpu/mpc512x/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc512x/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -26,6 +26,9 @@
 
 START	= start.o
 COBJS	= traps.o cpu.o cpu_init.o speed.o interrupts.o serial.o i2c.o iopin.o
+ifdef CONFIG_IIM
+COBJS	+= iim.o
+endif
 
 SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
diff -Naur u-boot-2009.01/cpu/mpc512x/speed.c u-boot/cpu/mpc512x/speed.c
--- u-boot-2009.01/cpu/mpc512x/speed.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc512x/speed.c	2009-02-26 14:03:58.000000000 +0100
@@ -137,7 +137,7 @@
 }
 
 U_BOOT_CMD(clocks, 1, 0, do_clocks,
-	"clocks  - print clock configuration\n",
+	"print clock configuration",
 	"    clocks\n"
 );
 
diff -Naur u-boot-2009.01/cpu/mpc5xxx/pci_mpc5200.c u-boot/cpu/mpc5xxx/pci_mpc5200.c
--- u-boot-2009.01/cpu/mpc5xxx/pci_mpc5200.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc5xxx/pci_mpc5200.c	2009-02-26 14:03:58.000000000 +0100
@@ -93,7 +93,7 @@
 		       CONFIG_PCI_MEMORY_BUS,
 		       CONFIG_PCI_MEMORY_PHYS,
 		       CONFIG_PCI_MEMORY_SIZE,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	/* PCI memory space */
 	pci_set_region(hose->regions + 1,
diff -Naur u-boot-2009.01/cpu/mpc8220/pci.c u-boot/cpu/mpc8220/pci.c
--- u-boot-2009.01/cpu/mpc8220/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8220/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -165,7 +165,7 @@
 		CONFIG_PCI_SYS_MEM_BUS,
 		CONFIG_PCI_SYS_MEM_PHYS,
 		CONFIG_PCI_SYS_MEM_SIZE,
-		PCI_REGION_MEM | PCI_REGION_MEMORY);
+		PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	hose->region_count = 3;
 
diff -Naur u-boot-2009.01/cpu/mpc824x/pci.c u-boot/cpu/mpc824x/pci.c
--- u-boot-2009.01/cpu/mpc824x/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc824x/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -34,7 +34,7 @@
 		       CHRP_PCI_MEMORY_BUS,
 		       CHRP_PCI_MEMORY_PHYS,
 		       CHRP_PCI_MEMORY_SIZE,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	/* PCI memory space */
 	pci_set_region(hose->regions + 1,
diff -Naur u-boot-2009.01/cpu/mpc8260/bedbug_603e.c u-boot/cpu/mpc8260/bedbug_603e.c
--- u-boot-2009.01/cpu/mpc8260/bedbug_603e.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8260/bedbug_603e.c	2009-02-26 14:03:58.000000000 +0100
@@ -72,7 +72,7 @@
 
   if (argc < 2)
   {
-    printf ("Usage:\n%s\n", cmdtp->usage);
+    cmd_usage(cmdtp);
     return;
   }
 
@@ -119,7 +119,7 @@
 	(( argv[ 1 ][ 0 ] >= 'a' ) && ( argv[ 1 ][ 0 ] <= 'f' )) ||
 	(( argv[ 1 ][ 0 ] >= 'A' ) && ( argv[ 1 ][ 0 ] <= 'F' ))))
   {
-    printf ("Usage:\n%s\n", cmdtp->usage);
+    cmd_usage(cmdtp);
     return;
   }
 
diff -Naur u-boot-2009.01/cpu/mpc8260/cpu.c u-boot/cpu/mpc8260/cpu.c
--- u-boot-2009.01/cpu/mpc8260/cpu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8260/cpu.c	2009-02-26 14:03:58.000000000 +0100
@@ -326,5 +326,8 @@
 #if defined(CONFIG_ETHER_ON_FCC)
 	fec_initialize(bis);
 #endif
+#if defined(CONFIG_ETHER_ON_SCC)
+	mpc82xx_scc_enet_initialize(bis);
+#endif
 	return 0;
 }
diff -Naur u-boot-2009.01/cpu/mpc8260/ether_scc.c u-boot/cpu/mpc8260/ether_scc.c
--- u-boot-2009.01/cpu/mpc8260/ether_scc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8260/ether_scc.c	2009-02-26 14:03:58.000000000 +0100
@@ -10,6 +10,12 @@
  * Advent Networks, Inc. <http://www.adventnetworks.com>
  * Jay Monkman <jtm@smoothsmoothie.com>
  *
+ * Modified so that it plays nicely when more than one ETHERNET interface
+ * is in use a la ether_fcc.c.
+ * (C) Copyright 2008
+ * DENX Software Engineerin GmbH
+ * Gary Jennejohn <garyj@denx.de>
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -32,11 +38,14 @@
 #include <common.h>
 #include <asm/cpm_8260.h>
 #include <mpc8260.h>
+#include <malloc.h>
 #include <net.h>
 #include <command.h>
 #include <config.h>
 
-#if defined(CONFIG_ETHER_ON_SCC) && defined(CONFIG_CMD_NET)
+#ifndef CONFIG_NET_MULTI
+#error "CONFIG_NET_MULTI must be defined."
+#endif
 
 #if (CONFIG_ETHER_INDEX == 1)
 #  define PROFF_ENET            PROFF_SCC1
@@ -100,7 +109,7 @@
 static RTXBD *rtx;
 
 
-int eth_send(volatile void *packet, int length)
+static int sec_send(struct eth_device *dev, volatile void *packet, int length)
 {
     int i;
     int result = 0;
@@ -137,7 +146,7 @@
 }
 
 
-int eth_rx(void)
+static int sec_rx(struct eth_device *dev)
 {
     int length;
 
@@ -184,7 +193,7 @@
  *
  *************************************************************/
 
-int eth_init(bd_t *bis)
+static int sec_init(struct eth_device *dev, bd_t *bis)
 {
     int i;
     volatile immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
@@ -194,9 +203,14 @@
     rxIdx = 0;
     txIdx = 0;
 
-    /* assign static pointer to BD area */
-    dpaddr = m8260_cpm_dpalloc(sizeof(RTXBD) + 2, 16);
-    rtx = (RTXBD *)&immr->im_dprambase[dpaddr];
+    /*
+     * Assign static pointer to BD area.
+     * Avoid exhausting DPRAM, which would cause a panic.
+     */
+    if (rtx == NULL) {
+	    dpaddr = m8260_cpm_dpalloc(sizeof(RTXBD) + 2, 16);
+	    rtx = (RTXBD *)&immr->im_dprambase[dpaddr];
+    }
 
     /* 24.21 - (1-3): ioports have been set up already */
 
@@ -338,7 +352,7 @@
 }
 
 
-void eth_halt(void)
+static void sec_halt(struct eth_device *dev)
 {
     volatile immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
     immr->im_scc[CONFIG_ETHER_INDEX-1].scc_gsmrl &= ~(SCC_GSMRL_ENR |
@@ -346,7 +360,7 @@
 }
 
 #if 0
-void restart(void)
+static void sec_restart(void)
 {
     volatile immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
     immr->im_cpm.cp_scc[CONFIG_ETHER_INDEX-1].scc_gsmrl |= (SCC_GSMRL_ENR |
@@ -354,4 +368,20 @@
 }
 #endif
 
-#endif
+int mpc82xx_scc_enet_initialize(bd_t *bis)
+{
+	struct eth_device *dev;
+
+	dev = (struct eth_device *) malloc(sizeof *dev);
+	memset(dev, 0, sizeof *dev);
+
+	sprintf(dev->name, "SCC ETHERNET");
+	dev->init   = sec_init;
+	dev->halt   = sec_halt;
+	dev->send   = sec_send;
+	dev->recv   = sec_rx;
+
+	eth_register(dev);
+
+	return 1;
+}
diff -Naur u-boot-2009.01/cpu/mpc8260/Makefile u-boot/cpu/mpc8260/Makefile
--- u-boot-2009.01/cpu/mpc8260/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8260/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -1,5 +1,5 @@
 #
-# (C) Copyright 2000-2006
+# (C) Copyright 2000-2008
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
 # See file CREDITS for list of people who contributed to this
@@ -27,9 +27,13 @@
 
 START	= start.o kgdb.o
 COBJS	= traps.o serial_smc.o serial_scc.o cpu.o cpu_init.o speed.o \
-	  interrupts.o ether_scc.o ether_fcc.o i2c.o commproc.o \
+	  interrupts.o ether_fcc.o i2c.o commproc.o \
 	  bedbug_603e.o pci.o spi.o
 
+COBJS-$(CONFIG_ETHER_ON_SCC) = ether_scc.o
+
+COBJS	+= $(COBJS-y)
+
 SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
 START	:= $(addprefix $(obj),$(START))
diff -Naur u-boot-2009.01/cpu/mpc8260/pci.c u-boot/cpu/mpc8260/pci.c
--- u-boot-2009.01/cpu/mpc8260/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8260/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -410,12 +410,12 @@
 	pci_set_region (hose->regions + 0,
 			PCI_SLV_MEM_BUS,
 			PCI_SLV_MEM_LOCAL,
-			gd->ram_size, PCI_REGION_MEM | PCI_REGION_MEMORY);
+			gd->ram_size, PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 #else
 	pci_set_region (hose->regions + 0,
 			CONFIG_SYS_SDRAM_BASE,
 			CONFIG_SYS_SDRAM_BASE,
-			0x4000000, PCI_REGION_MEM | PCI_REGION_MEMORY);
+			0x4000000, PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 #endif
 
 	/* PCI memory space */
diff -Naur u-boot-2009.01/cpu/mpc8260/serial_smc.c u-boot/cpu/mpc8260/serial_smc.c
--- u-boot-2009.01/cpu/mpc8260/serial_smc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8260/serial_smc.c	2009-02-26 14:03:58.000000000 +0100
@@ -64,6 +64,23 @@
 
 #endif
 
+#if !defined(CONFIG_SYS_SMC_RXBUFLEN)
+#define CONFIG_SYS_SMC_RXBUFLEN	1
+#define CONFIG_SYS_MAXIDLE	0
+#else
+#if !defined(CONFIG_SYS_MAXIDLE)
+#error "you must define CONFIG_SYS_MAXIDLE"
+#endif
+#endif
+
+typedef volatile struct serialbuffer {
+	cbd_t	rxbd;		/* Rx BD */
+	cbd_t	txbd;		/* Tx BD */
+	uint	rxindex;	/* index for next character to read */
+	volatile uchar	rxbuf[CONFIG_SYS_SMC_RXBUFLEN];/* rx buffers */
+	volatile uchar	txbuf;	/* tx buffers */
+} serialbuffer_t;
+
 /* map rs_table index to baud rate generator index */
 static unsigned char brg_map[] = {
 	6,	/* BRG7 for SMC1 */
@@ -79,9 +96,9 @@
 	volatile immap_t *im = (immap_t *)CONFIG_SYS_IMMR;
 	volatile smc_t *sp;
 	volatile smc_uart_t *up;
-	volatile cbd_t *tbdf, *rbdf;
 	volatile cpm8260_t *cp = &(im->im_cpm);
 	uint	dpaddr;
+	volatile serialbuffer_t *rtx;
 
 	/* initialize pointers to SMC */
 
@@ -89,8 +106,7 @@
 	*(ushort *)(&im->im_dprambase[PROFF_SMC_BASE]) = PROFF_SMC;
 	up = (smc_uart_t *)&im->im_dprambase[PROFF_SMC];
 
-	/* Disable transmitter/receiver.
-	*/
+	/* Disable transmitter/receiver. */
 	sp->smc_smcmr &= ~(SMCMR_REN | SMCMR_TEN);
 
 	/* NOTE: I/O port pins are set up via the iop_conf_tab[] table */
@@ -99,20 +115,23 @@
 	 * damm: allocating space after the two buffers for rx/tx data
 	 */
 
-	dpaddr = m8260_cpm_dpalloc((2 * sizeof (cbd_t)) + 2, 16);
+	/* allocate size of struct serialbuffer with bd rx/tx,
+	 * buffer rx/tx and rx index
+	 */
+	dpaddr = m8260_cpm_dpalloc((sizeof(serialbuffer_t)), 16);
+
+	rtx = (serialbuffer_t *)&im->im_dprambase[dpaddr];
 
 	/* Set the physical address of the host memory buffers in
 	 * the buffer descriptors.
 	 */
-	rbdf = (cbd_t *)&im->im_dprambase[dpaddr];
-	rbdf->cbd_bufaddr = (uint) (rbdf+2);
-	rbdf->cbd_sc = 0;
-	tbdf = rbdf + 1;
-	tbdf->cbd_bufaddr = ((uint) (rbdf+2)) + 1;
-	tbdf->cbd_sc = 0;
+	rtx->rxbd.cbd_bufaddr = (uint) &rtx->rxbuf;
+	rtx->rxbd.cbd_sc      = 0;
+
+	rtx->txbd.cbd_bufaddr = (uint) &rtx->txbuf;
+	rtx->txbd.cbd_sc      = 0;
 
-	/* Set up the uart parameters in the parameter ram.
-	*/
+	/* Set up the uart parameters in the parameter ram. */
 	up->smc_rbase = dpaddr;
 	up->smc_tbase = dpaddr+sizeof(cbd_t);
 	up->smc_rfcr = CPMFCR_EB;
@@ -126,8 +145,7 @@
 	 */
 	sp->smc_smcmr = smcr_mk_clen(9) |  SMCMR_SM_UART;
 
-	/* Mask all interrupts and remove anything pending.
-	*/
+	/* Mask all interrupts and remove anything pending. */
 	sp->smc_smcm = 0;
 	sp->smc_smce = 0xff;
 
@@ -136,22 +154,19 @@
 	 */
 	im->im_cpmux.cmx_smr = (im->im_cpmux.cmx_smr&~CMXSMR_MASK)|CMXSMR_VALUE;
 
-	/* Set up the baud rate generator.
-	*/
+	/* Set up the baud rate generator. */
 	serial_setbrg ();
 
-	/* Make the first buffer the only buffer.
-	*/
-	tbdf->cbd_sc |= BD_SC_WRAP;
-	rbdf->cbd_sc |= BD_SC_EMPTY | BD_SC_WRAP;
+	/* Make the first buffer the only buffer. */
+	rtx->txbd.cbd_sc |= BD_SC_WRAP;
+	rtx->rxbd.cbd_sc |= BD_SC_EMPTY | BD_SC_WRAP;
+
+	/* single/multi character receive. */
+	up->smc_mrblr = CONFIG_SYS_SMC_RXBUFLEN;
+	up->smc_maxidl = CONFIG_SYS_MAXIDLE;
+	rtx->rxindex = 0;
 
-	/* Single character receive.
-	*/
-	up->smc_mrblr = 1;
-	up->smc_maxidl = 0;
-
-	/* Initialize Tx/Rx parameters.
-	*/
+	/* Initialize Tx/Rx parameters. */
 
 	while (cp->cp_cpcr & CPM_CR_FLG)  /* wait if cp is busy */
 	  ;
@@ -162,8 +177,7 @@
 	while (cp->cp_cpcr & CPM_CR_FLG)  /* wait if cp is busy */
 	  ;
 
-	/* Enable transmitter/receiver.
-	*/
+	/* Enable transmitter/receiver. */
 	sp->smc_smcmr |= SMCMR_REN | SMCMR_TEN;
 
 	return (0);
@@ -183,27 +197,23 @@
 void
 serial_putc(const char c)
 {
-	volatile cbd_t		*tbdf;
-	volatile char		*buf;
 	volatile smc_uart_t	*up;
 	volatile immap_t	*im = (immap_t *)CONFIG_SYS_IMMR;
+	volatile serialbuffer_t	*rtx;
 
 	if (c == '\n')
 		serial_putc ('\r');
 
 	up = (smc_uart_t *)&(im->im_dprambase[PROFF_SMC]);
 
-	tbdf = (cbd_t *)&im->im_dprambase[up->smc_tbase];
+	rtx = (serialbuffer_t *)&im->im_dprambase[up->smc_rbase];
 
-	/* Wait for last character to go.
-	*/
-	buf = (char *)tbdf->cbd_bufaddr;
-	while (tbdf->cbd_sc & BD_SC_READY)
+	/* Wait for last character to go. */
+	while (rtx->txbd.cbd_sc & BD_SC_READY & BD_SC_READY)
 		;
-
-	*buf = c;
-	tbdf->cbd_datlen = 1;
-	tbdf->cbd_sc |= BD_SC_READY;
+	rtx->txbuf = c;
+	rtx->txbd.cbd_datlen = 1;
+	rtx->txbd.cbd_sc |= BD_SC_READY;
 }
 
 void
@@ -217,39 +227,44 @@
 int
 serial_getc(void)
 {
-	volatile cbd_t		*rbdf;
-	volatile unsigned char	*buf;
 	volatile smc_uart_t	*up;
 	volatile immap_t	*im = (immap_t *)CONFIG_SYS_IMMR;
-	unsigned char		c;
+	volatile serialbuffer_t	*rtx;
+	unsigned char  c;
 
 	up = (smc_uart_t *)&(im->im_dprambase[PROFF_SMC]);
 
-	rbdf = (cbd_t *)&im->im_dprambase[up->smc_rbase];
+	rtx = (serialbuffer_t *)&im->im_dprambase[up->smc_rbase];
 
-	/* Wait for character to show up.
-	*/
-	buf = (unsigned char *)rbdf->cbd_bufaddr;
-	while (rbdf->cbd_sc & BD_SC_EMPTY)
+	/* Wait for character to show up. */
+	while (rtx->rxbd.cbd_sc & BD_SC_EMPTY)
 		;
-	c = *buf;
-	rbdf->cbd_sc |= BD_SC_EMPTY;
 
+	/* the characters are read one by one,
+	 * use the rxindex to know the next char to deliver
+	 */
+	c = *(unsigned char *) (rtx->rxbd.cbd_bufaddr + rtx->rxindex);
+	rtx->rxindex++;
+
+	/* check if all char are readout, then make prepare for next receive */
+	if (rtx->rxindex >= rtx->rxbd.cbd_datlen) {
+		rtx->rxindex = 0;
+		rtx->rxbd.cbd_sc |= BD_SC_EMPTY;
+	}
 	return(c);
 }
 
 int
 serial_tstc()
 {
-	volatile cbd_t		*rbdf;
 	volatile smc_uart_t	*up;
 	volatile immap_t	*im = (immap_t *)CONFIG_SYS_IMMR;
+	volatile serialbuffer_t	*rtx;
 
 	up = (smc_uart_t *)&(im->im_dprambase[PROFF_SMC]);
+	rtx = (serialbuffer_t *)&im->im_dprambase[up->smc_rbase];
 
-	rbdf = (cbd_t *)&im->im_dprambase[up->smc_rbase];
-
-	return(!(rbdf->cbd_sc & BD_SC_EMPTY));
+	return !(rtx->rxbd.cbd_sc & BD_SC_EMPTY);
 }
 
 #endif	/* CONFIG_CONS_ON_SMC */
@@ -309,8 +324,7 @@
 	*(ushort *)(&im->im_dprambase[KGDB_PROFF_SMC_BASE]) = KGDB_PROFF_SMC;
 	up = (smc_uart_t *)&im->im_dprambase[KGDB_PROFF_SMC];
 
-	/* Disable transmitter/receiver.
-	*/
+	/* Disable transmitter/receiver. */
 	sp->smc_smcmr &= ~(SMCMR_REN | SMCMR_TEN);
 
 	/* NOTE: I/O port pins are set up via the iop_conf_tab[] table */
@@ -331,8 +345,7 @@
 	tbdf->cbd_bufaddr = ((uint) (rbdf+2)) + 1;
 	tbdf->cbd_sc = 0;
 
-	/* Set up the uart parameters in the parameter ram.
-	*/
+	/* Set up the uart parameters in the parameter ram. */
 	up->smc_rbase = dpaddr;
 	up->smc_tbase = dpaddr+sizeof(cbd_t);
 	up->smc_rfcr = CPMFCR_EB;
@@ -346,8 +359,7 @@
 	 */
 	sp->smc_smcmr = smcr_mk_clen(9) |  SMCMR_SM_UART;
 
-	/* Mask all interrupts and remove anything pending.
-	*/
+	/* Mask all interrupts and remove anything pending. */
 	sp->smc_smcm = 0;
 	sp->smc_smce = 0xff;
 
@@ -357,8 +369,7 @@
 	im->im_cpmux.cmx_smr =
 		(im->im_cpmux.cmx_smr & ~KGDB_CMXSMR_MASK) | KGDB_CMXSMR_VALUE;
 
-	/* Set up the baud rate generator.
-	*/
+	/* Set up the baud rate generator. */
 #if defined(CONFIG_KGDB_USE_EXTC)
 	m8260_cpm_extcbrg(brg_map[KGDB_SMC_INDEX], speed,
 		CONFIG_KGDB_EXTC_RATE, CONFIG_KGDB_EXTC_PINSEL);
@@ -366,18 +377,15 @@
 	m8260_cpm_setbrg(brg_map[KGDB_SMC_INDEX], speed);
 #endif
 
-	/* Make the first buffer the only buffer.
-	*/
+	/* Make the first buffer the only buffer. */
 	tbdf->cbd_sc |= BD_SC_WRAP;
 	rbdf->cbd_sc |= BD_SC_EMPTY | BD_SC_WRAP;
 
-	/* Single character receive.
-	*/
+	/* Single character receive. */
 	up->smc_mrblr = 1;
 	up->smc_maxidl = 0;
 
-	/* Initialize Tx/Rx parameters.
-	*/
+	/* Initialize Tx/Rx parameters. */
 
 	while (cp->cp_cpcr & CPM_CR_FLG)  /* wait if cp is busy */
 	  ;
@@ -388,8 +396,7 @@
 	while (cp->cp_cpcr & CPM_CR_FLG)  /* wait if cp is busy */
 	  ;
 
-	/* Enable transmitter/receiver.
-	*/
+	/* Enable transmitter/receiver.	*/
 	sp->smc_smcmr |= SMCMR_REN | SMCMR_TEN;
 
 	printf("SMC%d at %dbps ", CONFIG_KGDB_INDEX, speed);
@@ -410,8 +417,7 @@
 
 	tbdf = (cbd_t *)&im->im_dprambase[up->smc_tbase];
 
-	/* Wait for last character to go.
-	*/
+	/* Wait for last character to go. */
 	buf = (char *)tbdf->cbd_bufaddr;
 	while (tbdf->cbd_sc & BD_SC_READY)
 		;
@@ -442,8 +448,7 @@
 
 	rbdf = (cbd_t *)&im->im_dprambase[up->smc_rbase];
 
-	/* Wait for character to show up.
-	*/
+	/* Wait for character to show up. */
 	buf = (unsigned char *)rbdf->cbd_bufaddr;
 	while (rbdf->cbd_sc & BD_SC_EMPTY)
 		;
diff -Naur u-boot-2009.01/cpu/mpc83xx/cpu.c u-boot/cpu/mpc83xx/cpu.c
--- u-boot-2009.01/cpu/mpc83xx/cpu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc83xx/cpu.c	2009-02-26 14:03:58.000000000 +0100
@@ -34,6 +34,7 @@
 #include <libfdt.h>
 #include <tsec.h>
 #include <netdev.h>
+#include <fsl_esdhc.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -385,3 +386,16 @@
 #endif
 	return 0;
 }
+
+/*
+ * Initializes on-chip MMC controllers.
+ * to override, implement board_mmc_init()
+ */
+int cpu_mmc_init(bd_t *bis)
+{
+#ifdef CONFIG_FSL_ESDHC
+	return fsl_esdhc_mmc_init(bis);
+#else
+	return 0;
+#endif
+}
diff -Naur u-boot-2009.01/cpu/mpc83xx/ecc.c u-boot/cpu/mpc83xx/ecc.c
--- u-boot-2009.01/cpu/mpc83xx/ecc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc83xx/ecc.c	2009-02-26 14:03:58.000000000 +0100
@@ -119,7 +119,7 @@
 	writeback[1] = 0x89abcdefUL;
 
 	if (argc > 4) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -350,12 +350,12 @@
 			return 0;
 		}
 	}
-	printf("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
 U_BOOT_CMD(ecc, 4, 0, do_ecc,
-	   "ecc     - support for DDR ECC features\n",
+	   "support for DDR ECC features",
 	   "status              - print out status info\n"
 	   "ecc captureclear        - clear capture regs data\n"
 	   "ecc sbecnt <val>        - set Single-Bit Error counter\n"
diff -Naur u-boot-2009.01/cpu/mpc83xx/Makefile u-boot/cpu/mpc83xx/Makefile
--- u-boot-2009.01/cpu/mpc83xx/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc83xx/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -39,6 +39,7 @@
 COBJS-$(CONFIG_QE) += qe_io.o
 COBJS-$(CONFIG_FSL_SERDES) += serdes.o
 COBJS-$(CONFIG_83XX_GENERIC_PCI) += pci.o
+COBJS-$(CONFIG_83XX_GENERIC_PCIE) += pcie.o
 COBJS-$(CONFIG_OF_LIBFDT) += fdt.o
 
 COBJS	:= $(COBJS-y)
diff -Naur u-boot-2009.01/cpu/mpc83xx/pci.c u-boot/cpu/mpc83xx/pci.c
--- u-boot-2009.01/cpu/mpc83xx/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc83xx/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -89,7 +89,7 @@
 	hose->regions[i].bus_start = 0;
 	hose->regions[i].phys_start = 0;
 	hose->regions[i].size = gd->ram_size;
-	hose->regions[i].flags = PCI_REGION_MEM | PCI_REGION_MEMORY;
+	hose->regions[i].flags = PCI_REGION_MEM | PCI_REGION_SYS_MEMORY;
 
 	hose->first_busno = 0;
 	hose->last_busno = 0xff;
@@ -118,10 +118,12 @@
 #ifdef CONFIG_PCI_SCAN_SHOW
 	printf("PCI:   Bus Dev VenId DevId Class Int\n");
 #endif
+#ifndef CONFIG_PCISLAVE
 	/*
 	 * Hose scan.
 	 */
 	hose->last_busno = pci_hose_scan(hose);
+#endif
 }
 
 /*
@@ -190,6 +192,9 @@
 	pci_hose_read_config_word (hose, dev, PCI_FUNCTION_CONFIG, &reg16);
 	reg16 &= ~(PCI_FUNCTION_CFG_LOCK);
 	pci_hose_write_config_word (hose, dev, PCI_FUNCTION_CONFIG, reg16);
+
+	/* The configuration bit is now unlocked, so we can scan the bus */
+	hose->last_busno = pci_hose_scan(hose);
 }
 #endif
 
diff -Naur u-boot-2009.01/cpu/mpc83xx/pcie.c u-boot/cpu/mpc83xx/pcie.c
--- u-boot-2009.01/cpu/mpc83xx/pcie.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/cpu/mpc83xx/pcie.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,314 @@
+/*
+ * Copyright (C) 2007-2009  Freescale Semiconductor, Inc.
+ * Copyright (C) 2008-2009  MontaVista Software, Inc.
+ *
+ * Authors: Tony Li <tony.li@freescale.com>
+ *          Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <mpc83xx.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define PCIE_MAX_BUSES 2
+
+#ifdef CONFIG_83XX_GENERIC_PCIE_REGISTER_HOSES
+
+static int mpc83xx_pcie_remap_cfg(struct pci_controller *hose, pci_dev_t dev)
+{
+	int bus = PCI_BUS(dev) - hose->first_busno;
+	immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
+	pex83xx_t *pex = &immr->pciexp[bus];
+	struct pex_outbound_window *out_win = &pex->bridge.pex_outbound_win[0];
+	u8 devfn = PCI_DEV(dev) << 3 | PCI_FUNC(dev);
+	u32 dev_base = bus << 24 | devfn << 16;
+
+	if (hose->indirect_type == INDIRECT_TYPE_NO_PCIE_LINK)
+		return -1;
+	/*
+	 * Workaround for the HW bug: for Type 0 configure transactions the
+	 * PCI-E controller does not check the device number bits and just
+	 * assumes that the device number bits are 0.
+	 */
+	if (devfn & 0xf8)
+		return -1;
+
+	out_le32(&out_win->tarl, dev_base);
+	return 0;
+}
+
+#define cfg_read(val, addr, type, op) \
+	do { *val = op((type)(addr)); } while (0)
+#define cfg_write(val, addr, type, op) \
+	do { op((type *)(addr), (val)); } while (0)
+
+#define PCIE_OP(rw, size, type, op)					\
+static int pcie_##rw##_config_##size(struct pci_controller *hose,	\
+				     pci_dev_t dev, int offset,		\
+				     type val)				\
+{									\
+	int ret;							\
+									\
+	ret = mpc83xx_pcie_remap_cfg(hose, dev);			\
+	if (ret)							\
+		return ret;						\
+	cfg_##rw(val, (void *)hose->cfg_addr + offset, type, op);	\
+	return 0;							\
+}
+
+PCIE_OP(read, byte, u8 *, in_8)
+PCIE_OP(read, word, u16 *, in_le16)
+PCIE_OP(read, dword, u32 *, in_le32)
+PCIE_OP(write, byte, u8, out_8)
+PCIE_OP(write, word, u16, out_le16)
+PCIE_OP(write, dword, u32, out_le32)
+
+static void mpc83xx_pcie_register_hose(int bus, struct pci_region *reg,
+				       u8 link)
+{
+	extern void disable_addr_trans(void); /* start.S */
+	static struct pci_controller pcie_hose[PCIE_MAX_BUSES];
+	static int max_bus;
+	struct pci_controller *hose = &pcie_hose[bus];
+	int i;
+
+	/*
+	 * There are no spare BATs to remap all PCI-E windows for U-Boot, so
+	 * disable translations. In general, this is not great solution, and
+	 * that's why we don't register PCI-E hoses by default.
+	 */
+	disable_addr_trans();
+
+	for (i = 0; i < 2; i++, reg++) {
+		if (reg->size == 0)
+			break;
+
+		hose->regions[i] = *reg;
+		hose->region_count++;
+	}
+
+	i = hose->region_count++;
+	hose->regions[i].bus_start = 0;
+	hose->regions[i].phys_start = 0;
+	hose->regions[i].size = gd->ram_size;
+	hose->regions[i].flags = PCI_REGION_MEM | PCI_REGION_SYS_MEMORY;
+
+	i = hose->region_count++;
+	hose->regions[i].bus_start = CONFIG_SYS_IMMR;
+	hose->regions[i].phys_start = CONFIG_SYS_IMMR;
+	hose->regions[i].size = 0x100000;
+	hose->regions[i].flags = PCI_REGION_MEM | PCI_REGION_SYS_MEMORY;
+
+	hose->first_busno = max_bus;
+	hose->last_busno = 0xff;
+
+	if (bus == 0)
+		hose->cfg_addr = (unsigned int *)CONFIG_SYS_PCIE1_CFG_BASE;
+	else
+		hose->cfg_addr = (unsigned int *)CONFIG_SYS_PCIE2_CFG_BASE;
+
+	pci_set_ops(hose,
+			pcie_read_config_byte,
+			pcie_read_config_word,
+			pcie_read_config_dword,
+			pcie_write_config_byte,
+			pcie_write_config_word,
+			pcie_write_config_dword);
+
+	if (!link)
+		hose->indirect_type = INDIRECT_TYPE_NO_PCIE_LINK;
+
+	pci_register_hose(hose);
+
+#ifdef CONFIG_PCI_SCAN_SHOW
+	printf("PCI:   Bus Dev VenId DevId Class Int\n");
+#endif
+	/*
+	 * Hose scan.
+	 */
+	hose->last_busno = pci_hose_scan(hose);
+	max_bus = hose->last_busno + 1;
+}
+
+#else
+
+static void mpc83xx_pcie_register_hose(int bus, struct pci_region *reg,
+				       u8 link) {}
+
+#endif /* CONFIG_83XX_GENERIC_PCIE_REGISTER_HOSES */
+
+static void mpc83xx_pcie_init_bus(int bus, struct pci_region *reg)
+{
+	immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
+	pex83xx_t *pex = &immr->pciexp[bus];
+	struct pex_outbound_window *out_win;
+	struct pex_inbound_window *in_win;
+	void *hose_cfg_base;
+	unsigned int ram_sz;
+	unsigned int barl;
+	unsigned int tar;
+	u16 reg16;
+	int i;
+
+	/* Enable pex csb bridge inbound & outbound transactions */
+	out_le32(&pex->bridge.pex_csb_ctrl,
+		in_le32(&pex->bridge.pex_csb_ctrl) | PEX_CSB_CTRL_OBPIOE |
+		PEX_CSB_CTRL_IBPIOE);
+
+	/* Enable bridge outbound */
+	out_le32(&pex->bridge.pex_csb_obctrl, PEX_CSB_OBCTRL_PIOE |
+		PEX_CSB_OBCTRL_MEMWE | PEX_CSB_OBCTRL_IOWE |
+		PEX_CSB_OBCTRL_CFGWE);
+
+	out_win = &pex->bridge.pex_outbound_win[0];
+	if (bus) {
+		out_le32(&out_win->ar, PEX_OWAR_EN | PEX_OWAR_TYPE_CFG |
+			CONFIG_SYS_PCIE2_CFG_SIZE);
+		out_le32(&out_win->bar, CONFIG_SYS_PCIE2_CFG_BASE);
+	} else {
+		out_le32(&out_win->ar, PEX_OWAR_EN | PEX_OWAR_TYPE_CFG |
+			CONFIG_SYS_PCIE1_CFG_SIZE);
+		out_le32(&out_win->bar, CONFIG_SYS_PCIE1_CFG_BASE);
+	}
+	out_le32(&out_win->tarl, 0);
+	out_le32(&out_win->tarh, 0);
+
+	for (i = 0; i < 2; i++, reg++) {
+		u32 ar;
+
+		if (reg->size == 0)
+			break;
+
+		out_win = &pex->bridge.pex_outbound_win[i + 1];
+		out_le32(&out_win->bar, reg->phys_start);
+		out_le32(&out_win->tarl, reg->bus_start);
+		out_le32(&out_win->tarh, 0);
+		ar = PEX_OWAR_EN | (reg->size & PEX_OWAR_SIZE);
+		if (reg->flags & PCI_REGION_IO)
+			ar |= PEX_OWAR_TYPE_IO;
+		else
+			ar |= PEX_OWAR_TYPE_MEM;
+		out_le32(&out_win->ar, ar);
+	}
+
+	out_le32(&pex->bridge.pex_csb_ibctrl, PEX_CSB_IBCTRL_PIOE);
+
+	ram_sz = gd->ram_size;
+	barl = 0;
+	tar = 0;
+	i = 0;
+	while (ram_sz > 0) {
+		in_win = &pex->bridge.pex_inbound_win[i];
+		out_le32(&in_win->barl, barl);
+		out_le32(&in_win->barh, 0x0);
+		out_le32(&in_win->tar, tar);
+		if (ram_sz >= 0x10000000) {
+			/* The maxium windows size is 256M */
+			out_le32(&in_win->ar, PEX_IWAR_EN | PEX_IWAR_NSOV |
+				PEX_IWAR_TYPE_PF | 0x0FFFF000);
+			barl += 0x10000000;
+			tar += 0x10000000;
+			ram_sz -= 0x10000000;
+		} else {
+			/* The UM  is not clear here.
+			 * So, round up to even Mb boundary */
+
+			ram_sz = ram_sz >> (20 +
+					((ram_sz & 0xFFFFF) ? 1 : 0));
+			if (!(ram_sz % 2))
+				ram_sz -= 1;
+			out_le32(&in_win->ar, PEX_IWAR_EN | PEX_IWAR_NSOV |
+				PEX_IWAR_TYPE_PF | (ram_sz << 20) | 0xFF000);
+			ram_sz = 0;
+		}
+		i++;
+	}
+
+	in_win = &pex->bridge.pex_inbound_win[i];
+	out_le32(&in_win->barl, CONFIG_SYS_IMMR);
+	out_le32(&in_win->barh, 0);
+	out_le32(&in_win->tar, CONFIG_SYS_IMMR);
+	out_le32(&in_win->ar, PEX_IWAR_EN |
+		PEX_IWAR_TYPE_NO_PF | PEX_IWAR_SIZE_1M);
+
+	/* Enable the host virtual INTX interrupts */
+	out_le32(&pex->bridge.pex_int_axi_misc_enb,
+		in_le32(&pex->bridge.pex_int_axi_misc_enb) | 0x1E0);
+
+	/* Hose configure header is memory-mapped */
+	hose_cfg_base = (void *)pex;
+
+	get_clocks();
+	/* Configure the PCIE controller core clock ratio */
+	out_le32(hose_cfg_base + PEX_GCLK_RATIO,
+		(((bus ? gd->pciexp2_clk : gd->pciexp1_clk) / 1000000) * 16)
+		/ 333);
+	udelay(1000000);
+
+	/* Do Type 1 bridge configuration */
+	out_8(hose_cfg_base + PCI_PRIMARY_BUS, 0);
+	out_8(hose_cfg_base + PCI_SECONDARY_BUS, 1);
+	out_8(hose_cfg_base + PCI_SUBORDINATE_BUS, 255);
+
+	/*
+	 * Write to Command register
+	 */
+	reg16 = in_le16(hose_cfg_base + PCI_COMMAND);
+	reg16 |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY | PCI_COMMAND_IO |
+			PCI_COMMAND_SERR | PCI_COMMAND_PARITY;
+	out_le16(hose_cfg_base + PCI_COMMAND, reg16);
+
+	/*
+	 * Clear non-reserved bits in status register.
+	 */
+	out_le16(hose_cfg_base + PCI_STATUS, 0xffff);
+	out_8(hose_cfg_base + PCI_LATENCY_TIMER, 0x80);
+	out_8(hose_cfg_base + PCI_CACHE_LINE_SIZE, 0x08);
+
+	printf("PCIE%d: ", bus);
+
+	reg16 = in_le16(hose_cfg_base + PCI_LTSSM);
+	if (reg16 >= PCI_LTSSM_L0)
+		printf("link\n");
+	else
+		printf("No link\n");
+
+	mpc83xx_pcie_register_hose(bus, reg, reg16 >= PCI_LTSSM_L0);
+}
+
+/*
+ * The caller must have already set SCCR, SERDES and the PCIE_LAW BARs
+ * must have been set to cover all of the requested regions.
+ */
+void mpc83xx_pcie_init(int num_buses, struct pci_region **reg, int warmboot)
+{
+	int i;
+
+	/*
+	 * Release PCI RST Output signal.
+	 * Power on to RST high must be at least 100 ms as per PCI spec.
+	 * On warm boots only 1 ms is required.
+	 */
+	udelay(warmboot ? 1000 : 100000);
+
+	for (i = 0; i < num_buses; i++)
+		mpc83xx_pcie_init_bus(i, reg[i]);
+}
diff -Naur u-boot-2009.01/cpu/mpc83xx/speed.c u-boot/cpu/mpc83xx/speed.c
--- u-boot-2009.01/cpu/mpc83xx/speed.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc83xx/speed.c	2009-02-26 14:03:58.000000000 +0100
@@ -132,7 +132,7 @@
 	u32 qe_clk;
 	u32 brg_clk;
 #endif
-#if defined(CONFIG_MPC837X)
+#if defined(CONFIG_MPC837X) || defined(CONFIG_MPC831X)
 	u32 pciexp1_clk;
 	u32 pciexp2_clk;
 #endif
@@ -328,7 +328,7 @@
 	i2c2_clk = csb_clk; /* i2c-2 clk is equal to csb clk */
 #endif
 
-#if defined(CONFIG_MPC837X)
+#if defined(CONFIG_MPC837X) || defined(CONFIG_MPC831X)
 	switch ((sccr & SCCR_PCIEXP1CM) >> SCCR_PCIEXP1CM_SHIFT) {
 	case 0:
 		pciexp1_clk = 0;
@@ -544,6 +544,6 @@
 }
 
 U_BOOT_CMD(clocks, 1, 0, do_clocks,
-	"clocks  - print clock configuration\n",
+	"print clock configuration",
 	"    clocks\n"
 );
diff -Naur u-boot-2009.01/cpu/mpc83xx/start.S u-boot/cpu/mpc83xx/start.S
--- u-boot-2009.01/cpu/mpc83xx/start.S	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc83xx/start.S	2009-02-26 14:03:58.000000000 +0100
@@ -109,6 +109,45 @@
 	.ascii " (", U_BOOT_DATE, " - ", U_BOOT_TIME, ")"
 	.ascii " ", CONFIG_IDENT_STRING, "\0"
 
+	.align 2
+
+	.globl enable_addr_trans
+enable_addr_trans:
+	/* enable address translation */
+	mfmsr	r5
+	ori	r5, r5, (MSR_IR | MSR_DR)
+	mtmsr	r5
+	isync
+	blr
+
+	.globl disable_addr_trans
+disable_addr_trans:
+	/* disable address translation */
+	mflr	r4
+	mfmsr	r3
+	andi.	r0, r3, (MSR_IR | MSR_DR)
+	beqlr
+	andc	r3, r3, r0
+	mtspr	SRR0, r4
+	mtspr	SRR1, r3
+	rfi
+
+	.globl get_pvr
+get_pvr:
+	mfspr	r3, PVR
+	blr
+
+	.globl	ppcDWstore
+ppcDWstore:
+	lfd	1, 0(r4)
+	stfd	1, 0(r3)
+	blr
+
+	.globl	ppcDWload
+ppcDWload:
+	lfd	1, 0(r3)
+	stfd	1, 0(r4)
+	blr
 
 #ifndef CONFIG_DEFAULT_IMMR
 #error CONFIG_DEFAULT_IMMR must be defined
@@ -161,9 +200,23 @@
 	nop
 boot_warm: /* time t 5 */
 	mfmsr	r5			/* save msr contents	*/
+
+	/* 83xx manuals prescribe a specific sequence for updating IMMRBAR. */
+	bl	1f
+1:	mflr	r7
+
 	lis	r3, CONFIG_SYS_IMMR@h
 	ori	r3, r3, CONFIG_SYS_IMMR@l
+
+	lwz	r6, IMMRBAR(r4)
+	isync
+
 	stw	r3, IMMRBAR(r4)
+	lwz	r6, 0(r7)		/* Arbitrary external load */
+	isync
+
+	lwz	r6, IMMRBAR(r3)
+	isync
 
 	/* Initialise the E300 processor core		*/
 	/*------------------------------------------*/
@@ -173,9 +226,7 @@
 	 * is loaded.  Wait for the rest before branching
 	 * to another flash page.
 	 */
-	addi	r7, r3, 0x50b0
-1:	dcbi	0, r7
-	lwz	r6, 0(r7)
+1:	lwz	r6, 0x50b0(r3)
 	andi.	r6, r6, 1
 	beq	1b
 #endif
@@ -698,27 +749,6 @@
 
 	blr
 
-	.globl enable_addr_trans
-enable_addr_trans:
-	/* enable address translation */
-	mfmsr	r5
-	ori	r5, r5, (MSR_IR | MSR_DR)
-	mtmsr	r5
-	isync
-	blr
-
-	.globl disable_addr_trans
-disable_addr_trans:
-	/* disable address translation */
-	mflr	r4
-	mfmsr	r3
-	andi.	r0, r3, (MSR_IR | MSR_DR)
-	beqlr
-	andc	r3, r3, r0
-	mtspr	SRR0, r4
-	mtspr	SRR1, r3
-	rfi
-
 /* Cache functions.
  *
  * Note: requires that all cache bits in
@@ -796,23 +826,6 @@
 	b	1b
 2:	blr
 
-	.globl get_pvr
-get_pvr:
-	mfspr	r3, PVR
-	blr
-
-	.globl	ppcDWstore
-ppcDWstore:
-	lfd	1, 0(r4)
-	stfd	1, 0(r3)
-	blr
-
-	.globl	ppcDWload
-ppcDWload:
-	lfd	1, 0(r3)
-	stfd	1, 0(r4)
-	blr
-
 /*-------------------------------------------------------------------*/
 
 /*
diff -Naur u-boot-2009.01/cpu/mpc85xx/cpu.c u-boot/cpu/mpc85xx/cpu.c
--- u-boot-2009.01/cpu/mpc85xx/cpu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc85xx/cpu.c	2009-02-26 14:03:58.000000000 +0100
@@ -31,6 +31,7 @@
 #include <command.h>
 #include <tsec.h>
 #include <netdev.h>
+#include <fsl_esdhc.h>
 #include <asm/cache.h>
 #include <asm/io.h>
 
@@ -62,6 +63,8 @@
 	CPU_TYPE_ENTRY(8568, 8568_E),
 	CPU_TYPE_ENTRY(8572, 8572),
 	CPU_TYPE_ENTRY(8572, 8572_E),
+	CPU_TYPE_ENTRY(P2020, P2020),
+	CPU_TYPE_ENTRY(P2020, P2020_E),
 };
 
 struct cpu_type *identify_cpu(u32 ver)
@@ -90,6 +93,7 @@
 #else
 	u32 ddr_ratio = 0;
 #endif
+	int i;
 
 	svr = get_svr();
 	ver = SVR_SOC_VER(svr);
@@ -141,9 +145,14 @@
 
 	get_sys_info(&sysinfo);
 
-	puts("Clock Configuration:\n");
-	printf("       CPU:%-4s MHz, ", strmhz(buf1, sysinfo.freqProcessor));
-	printf("CCB:%-4s MHz,\n", strmhz(buf1, sysinfo.freqSystemBus));
+	puts("Clock Configuration:");
+	for (i = 0; i < CONFIG_NUM_CPUS; i++) {
+		if (!(i & 3))
+			printf ("\n       ");
+		printf("CPU%d:%-4s MHz, ",
+				i,strmhz(buf1, sysinfo.freqProcessor[i]));
+	}
+	printf("\n       CCB:%-4s MHz,\n", strmhz(buf1, sysinfo.freqSystemBus));
 
 	switch (ddr_ratio) {
 	case 0x0:
@@ -387,5 +396,19 @@
 #if defined(CONFIG_TSEC_ENET) || defined(CONFIG_MPC85XX_FEC)
 	tsec_standard_init(bis);
 #endif
+
 	return 0;
 }
+
+/*
+ * Initializes on-chip MMC controllers.
+ * to override, implement board_mmc_init()
+ */
+int cpu_mmc_init(bd_t *bis)
+{
+#ifdef CONFIG_FSL_ESDHC
+	return fsl_esdhc_mmc_init(bis);
+#else
+	return 0;
+#endif
+}
diff -Naur u-boot-2009.01/cpu/mpc85xx/ddr-gen3.c u-boot/cpu/mpc85xx/ddr-gen3.c
--- u-boot-2009.01/cpu/mpc85xx/ddr-gen3.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc85xx/ddr-gen3.c	2009-02-26 14:03:58.000000000 +0100
@@ -19,6 +19,7 @@
 {
 	unsigned int i;
 	volatile ccsr_ddr_t *ddr;
+	u32 temp_sdram_cfg;
 
 	switch (ctrl_num) {
 	case 0:
@@ -78,6 +79,10 @@
 	out_be32(&ddr->ddr_sdram_rcw_1, regs->ddr_sdram_rcw_1);
 	out_be32(&ddr->ddr_sdram_rcw_2, regs->ddr_sdram_rcw_2);
 
+	/* Do not enable the memory */
+	temp_sdram_cfg = in_be32(&ddr->sdram_cfg);
+	temp_sdram_cfg &= ~(SDRAM_CFG_MEM_EN);
+	out_be32(&ddr->sdram_cfg, temp_sdram_cfg);
 	/*
 	 * For 8572 DDR1 erratum - DDR controller may enter illegal state
 	 * when operatiing in 32-bit bus mode with 4-beat bursts,
@@ -99,7 +104,9 @@
 	udelay(200);
 	asm volatile("sync;isync");
 
-	out_be32(&ddr->sdram_cfg, regs->ddr_sdram_cfg);
+	/* Let the controller go */
+	temp_sdram_cfg = in_be32(&ddr->sdram_cfg);
+	out_be32(&ddr->sdram_cfg, temp_sdram_cfg | SDRAM_CFG_MEM_EN);
 
 	/* Poll DDR_SDRAM_CFG_2[D_INIT] bit until auto-data init is done.  */
 	while (in_be32(&ddr->sdram_cfg_2) & 0x10) {
diff -Naur u-boot-2009.01/cpu/mpc85xx/fdt.c u-boot/cpu/mpc85xx/fdt.c
--- u-boot-2009.01/cpu/mpc85xx/fdt.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc85xx/fdt.c	2009-02-26 14:03:58.000000000 +0100
@@ -213,6 +213,10 @@
 
 void ft_cpu_setup(void *blob, bd_t *bd)
 {
+	int off;
+	int val;
+	sys_info_t sysinfo;
+
 	/* delete crypto node if not on an E-processor */
 	if (!IS_E_PROCESSOR(get_svr()))
 		fdt_fixup_crypto_node(blob, 0);
@@ -228,8 +232,15 @@
 		"timebase-frequency", bd->bi_busfreq / 8, 1);
 	do_fixup_by_prop_u32(blob, "device_type", "cpu", 4,
 		"bus-frequency", bd->bi_busfreq, 1);
-	do_fixup_by_prop_u32(blob, "device_type", "cpu", 4,
-		"clock-frequency", bd->bi_intfreq, 1);
+	get_sys_info(&sysinfo);
+	off = fdt_node_offset_by_prop_value(blob, -1, "device_type", "cpu", 4);
+	while (off != -FDT_ERR_NOTFOUND) {
+		u32 *reg = (u32 *)fdt_getprop(blob, off, "reg", 0);
+		val = cpu_to_fdt32(sysinfo.freqProcessor[*reg]);
+		fdt_setprop(blob, off, "clock-frequency", &val, 4);
+		off = fdt_node_offset_by_prop_value(blob, off, "device_type",
+							"cpu", 4);
+	}
 	do_fixup_by_prop_u32(blob, "device_type", "soc", 4,
 		"bus-frequency", bd->bi_busfreq, 1);
 
diff -Naur u-boot-2009.01/cpu/mpc85xx/Makefile u-boot/cpu/mpc85xx/Makefile
--- u-boot-2009.01/cpu/mpc85xx/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc85xx/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -48,6 +48,7 @@
 # supports ddr1/2/3
 COBJS-$(CONFIG_MPC8572) += ddr-gen3.o
 COBJS-$(CONFIG_MPC8536) += ddr-gen3.o
+COBJS-$(CONFIG_P2020)	+= ddr-gen3.o
 
 COBJS-$(CONFIG_MPC8536) += mpc8536_serdes.o
 COBJS	= traps.o cpu.o cpu_init.o speed.o interrupts.o tlb.o \
diff -Naur u-boot-2009.01/cpu/mpc85xx/pci.c u-boot/cpu/mpc85xx/pci.c
--- u-boot-2009.01/cpu/mpc85xx/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc85xx/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -31,6 +31,22 @@
 
 #if defined(CONFIG_PCI) && !defined(CONFIG_FSL_PCI_INIT)
 
+#ifndef CONFIG_SYS_PCI1_MEM_BUS
+#define CONFIG_SYS_PCI1_MEM_BUS CONFIG_SYS_PCI1_MEM_BASE
+#endif
+
+#ifndef CONFIG_SYS_PCI1_IO_BUS
+#define CONFIG_SYS_PCI1_IO_BUS CONFIG_SYS_PCI1_IO_BASE
+#endif
+
+#ifndef CONFIG_SYS_PCI2_MEM_BUS
+#define CONFIG_SYS_PCI2_MEM_BUS CONFIG_SYS_PCI2_MEM_BASE
+#endif
+
+#ifndef CONFIG_SYS_PCI2_IO_BUS
+#define CONFIG_SYS_PCI2_IO_BUS CONFIG_SYS_PCI2_IO_BASE
+#endif
+
 static struct pci_controller *pci_hose;
 
 void
@@ -80,14 +96,14 @@
 		pci_hose_write_config_word(hose, dev, PCIX_COMMAND, reg16);
 	}
 
-	pcix->potar1   = (CONFIG_SYS_PCI1_MEM_BASE >> 12) & 0x000fffff;
+	pcix->potar1   = (CONFIG_SYS_PCI1_MEM_BUS >> 12) & 0x000fffff;
 	pcix->potear1  = 0x00000000;
 	pcix->powbar1  = (CONFIG_SYS_PCI1_MEM_PHYS >> 12) & 0x000fffff;
 	pcix->powbear1 = 0x00000000;
 	pcix->powar1 = (POWAR_EN | POWAR_MEM_READ |
 			POWAR_MEM_WRITE | (__ilog2(CONFIG_SYS_PCI1_MEM_SIZE) - 1));
 
-	pcix->potar2  = (CONFIG_SYS_PCI1_IO_BASE >> 12) & 0x000fffff;
+	pcix->potar2  = (CONFIG_SYS_PCI1_IO_BUS >> 12) & 0x000fffff;
 	pcix->potear2  = 0x00000000;
 	pcix->powbar2  = (CONFIG_SYS_PCI1_IO_PHYS >> 12) & 0x000fffff;
 	pcix->powbear2 = 0x00000000;
@@ -105,13 +121,13 @@
 	pcix->piwar3 = 0;
 
 	pci_set_region(hose->regions + 0,
-		       CONFIG_SYS_PCI1_MEM_BASE,
+		       CONFIG_SYS_PCI1_MEM_BUS,
 		       CONFIG_SYS_PCI1_MEM_PHYS,
 		       CONFIG_SYS_PCI1_MEM_SIZE,
 		       PCI_REGION_MEM);
 
 	pci_set_region(hose->regions + 1,
-		       CONFIG_SYS_PCI1_IO_BASE,
+		       CONFIG_SYS_PCI1_IO_BUS,
 		       CONFIG_SYS_PCI1_IO_PHYS,
 		       CONFIG_SYS_PCI1_IO_SIZE,
 		       PCI_REGION_IO);
@@ -165,14 +181,14 @@
 	 */
 	pci_hose_write_config_word(hose, dev, PCI_STATUS, 0xffff);
 
-	pcix2->potar1   = (CONFIG_SYS_PCI2_MEM_BASE >> 12) & 0x000fffff;
+	pcix2->potar1   = (CONFIG_SYS_PCI2_MEM_BUS >> 12) & 0x000fffff;
 	pcix2->potear1  = 0x00000000;
 	pcix2->powbar1  = (CONFIG_SYS_PCI2_MEM_PHYS >> 12) & 0x000fffff;
 	pcix2->powbear1 = 0x00000000;
 	pcix2->powar1 = (POWAR_EN | POWAR_MEM_READ |
 			POWAR_MEM_WRITE | (__ilog2(CONFIG_SYS_PCI2_MEM_SIZE) - 1));
 
-	pcix2->potar2  = (CONFIG_SYS_PCI2_IO_BASE >> 12) & 0x000fffff;
+	pcix2->potar2  = (CONFIG_SYS_PCI2_IO_BUS >> 12) & 0x000fffff;
 	pcix2->potear2  = 0x00000000;
 	pcix2->powbar2  = (CONFIG_SYS_PCI2_IO_PHYS >> 12) & 0x000fffff;
 	pcix2->powbear2 = 0x00000000;
@@ -190,13 +206,13 @@
 	pcix2->piwar3 = 0;
 
 	pci_set_region(hose->regions + 0,
-		       CONFIG_SYS_PCI2_MEM_BASE,
+		       CONFIG_SYS_PCI2_MEM_BUS,
 		       CONFIG_SYS_PCI2_MEM_PHYS,
 		       CONFIG_SYS_PCI2_MEM_SIZE,
 		       PCI_REGION_MEM);
 
 	pci_set_region(hose->regions + 1,
-		       CONFIG_SYS_PCI2_IO_BASE,
+		       CONFIG_SYS_PCI2_IO_BUS,
 		       CONFIG_SYS_PCI2_IO_PHYS,
 		       CONFIG_SYS_PCI2_IO_SIZE,
 		       PCI_REGION_IO);
diff -Naur u-boot-2009.01/cpu/mpc85xx/speed.c u-boot/cpu/mpc85xx/speed.c
--- u-boot-2009.01/cpu/mpc85xx/speed.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc85xx/speed.c	2009-02-26 14:03:58.000000000 +0100
@@ -39,17 +39,19 @@
 	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
 	uint plat_ratio,e500_ratio,half_freqSystemBus;
 	uint lcrr_div;
+	int i;
 
 	plat_ratio = (gur->porpllsr) & 0x0000003e;
 	plat_ratio >>= 1;
 	sysInfo->freqSystemBus = plat_ratio * CONFIG_SYS_CLK_FREQ;
-	e500_ratio = (gur->porpllsr) & 0x003f0000;
-	e500_ratio >>= 16;
 
 	/* Divide before multiply to avoid integer
 	 * overflow for processor speeds above 2GHz */
 	half_freqSystemBus = sysInfo->freqSystemBus/2;
-	sysInfo->freqProcessor = e500_ratio*half_freqSystemBus;
+	for (i = 0; i < CONFIG_NUM_CPUS; i++) {
+		e500_ratio = ((gur->porpllsr) >> (i * 8 + 16)) & 0x3f;
+		sysInfo->freqProcessor[i] = e500_ratio * half_freqSystemBus;
+	}
 
 	/* Note: freqDDRBus is the MCLK frequency, not the data rate. */
 	sysInfo->freqDDRBus = sysInfo->freqSystemBus;
@@ -105,7 +107,7 @@
 	dfbrg = (sccr & SCCR_DFBRG_MSK) >> SCCR_DFBRG_SHIFT;
 #endif
 	get_sys_info (&sys_info);
-	gd->cpu_clk = sys_info.freqProcessor;
+	gd->cpu_clk = sys_info.freqProcessor[0];
 	gd->bus_clk = sys_info.freqSystemBus;
 	gd->mem_clk = sys_info.freqDDRBus;
 	gd->lbc_clk = sys_info.freqLocalBus;
diff -Naur u-boot-2009.01/cpu/mpc85xx/tlb.c u-boot/cpu/mpc85xx/tlb.c
--- u-boot-2009.01/cpu/mpc85xx/tlb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc85xx/tlb.c	2009-02-26 14:03:58.000000000 +0100
@@ -132,61 +132,41 @@
 unsigned int setup_ddr_tlbs(unsigned int memsize_in_meg)
 {
 	unsigned int tlb_size;
-	unsigned int ram_tlb_index;
-	unsigned int ram_tlb_address;
+	unsigned int ram_tlb_index = CONFIG_SYS_DDR_TLB_START;
+	unsigned int ram_tlb_address = (unsigned int)CONFIG_SYS_DDR_SDRAM_BASE;
+	unsigned int max_cam = (mfspr(SPRN_TLB1CFG) >> 16) & 0xff;
+	u64 size, memsize = (u64)memsize_in_meg << 20;
 
-	/*
-	 * Determine size of each TLB1 entry.
-	 */
-	switch (memsize_in_meg) {
-	case 16:
-	case 32:
-		tlb_size = BOOKE_PAGESZ_16M;
-		break;
-	case 64:
-	case 128:
-		tlb_size = BOOKE_PAGESZ_64M;
-		break;
-	case 256:
-	case 512:
-		tlb_size = BOOKE_PAGESZ_256M;
-		break;
-	case 1024:
-	case 2048:
-		if (PVR_VER(get_pvr()) > PVR_VER(PVR_85xx))
-			tlb_size = BOOKE_PAGESZ_1G;
-		else
-			tlb_size = BOOKE_PAGESZ_256M;
-		break;
-	default:
-		puts("DDR: only 16M, 32M, 64M, 128M, 256M, 512M, 1G"
-			" and 2G are supported.\n");
-
-		/*
-		 * The memory was not able to be mapped.
-		 * Default to a small size.
-		 */
-		tlb_size = BOOKE_PAGESZ_64M;
-		memsize_in_meg = 64;
-		break;
-	}
+	size = min(memsize, CONFIG_MAX_MEM_MAPPED);
+
+	/* Convert (4^max) kB to (2^max) bytes */
+	max_cam = max_cam * 2 + 10;
+
+	for (; size && ram_tlb_index < 16; ram_tlb_index++) {
+		u32 camsize = __ilog2_u64(size) & ~1U;
+		u32 align = __ilog2(ram_tlb_address) & ~1U;
+
+		if (align == -2) align = max_cam;
+		if (camsize > align)
+			camsize = align;
+
+		if (camsize > max_cam)
+			camsize = max_cam;
+
+		tlb_size = (camsize - 10) / 2;
 
-	/*
-	 * Configure DDR TLB1 entries.
-	 * Starting at TLB1 8, use no more than 8 TLB1 entries.
-	 */
-	ram_tlb_index = CONFIG_SYS_DDR_TLB_START;
-	ram_tlb_address = (unsigned int)CONFIG_SYS_DDR_SDRAM_BASE;
-	while (ram_tlb_address < (memsize_in_meg * 1024 * 1024)
-	      && ram_tlb_index < 16) {
 		set_tlb(1, ram_tlb_address, ram_tlb_address,
 			MAS3_SX|MAS3_SW|MAS3_SR, 0,
 			0, ram_tlb_index, tlb_size, 1);
 
-		ram_tlb_address += (0x1000 << ((tlb_size - 1) * 2));
-		ram_tlb_index++;
+		size -= 1ULL << camsize;
+		memsize -= 1ULL << camsize;
+		ram_tlb_address += 1UL << camsize;
 	}
 
+	if (memsize)
+		printf("%lldM left unmapped\n", memsize >> 20);
+
 	/*
 	 * Confirm that the requested amount of memory was mapped.
 	 */
diff -Naur u-boot-2009.01/cpu/mpc86xx/cpu.c u-boot/cpu/mpc86xx/cpu.c
--- u-boot-2009.01/cpu/mpc86xx/cpu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc86xx/cpu.c	2009-02-26 14:03:58.000000000 +0100
@@ -32,6 +32,17 @@
 #include <asm/fsl_law.h>
 
 
+/*
+ * Default board reset function
+ */
+static void
+__board_reset(void)
+{
+	/* Do nothing */
+}
+void board_reset(void) __attribute((weak, alias("__board_reset")));
+
+
 int
 checkcpu(void)
 {
@@ -39,49 +50,25 @@
 	uint pvr, svr;
 	uint ver;
 	uint major, minor;
+	char buf1[32], buf2[32];
 	volatile immap_t *immap = (immap_t *) CONFIG_SYS_IMMR;
 	volatile ccsr_gur_t *gur = &immap->im_gur;
-
-	puts("Freescale PowerPC\n");
-
-	pvr = get_pvr();
-	ver = PVR_VER(pvr);
-	major = PVR_MAJ(pvr);
-	minor = PVR_MIN(pvr);
-
-	puts("CPU:\n");
-	puts("    Core: ");
-
-	switch (ver) {
-	case PVR_VER(PVR_86xx):
-	{
-		uint msscr0 = mfspr(MSSCR0);
-		printf("E600 Core %d", (msscr0 & 0x20) ? 1 : 0 );
-		if (gur->pordevsr & MPC86xx_PORDEVSR_CORE1TE)
-			puts("\n    Core1Translation Enabled");
-		debug(" (MSSCR0=%x, PORDEVSR=%x)", msscr0, gur->pordevsr);
-	}
-	break;
-	default:
-		puts("Unknown");
-		break;
-	}
-	printf(", Version: %d.%d, (0x%08x)\n", major, minor, pvr);
+	uint msscr0 = mfspr(MSSCR0);
 
 	svr = get_svr();
 	ver = SVR_SOC_VER(svr);
 	major = SVR_MAJ(svr);
 	minor = SVR_MIN(svr);
 
-	puts("    System: ");
+	puts("CPU:   ");
+
 	switch (ver) {
 	case SVR_8641:
-	    if (SVR_SUBVER(svr) == 1) {
-		puts("8641D");
-	    } else {
 		puts("8641");
-	    }
-	    break;
+		break;
+	case SVR_8641D:
+		puts("8641D");
+		break;
 	case SVR_8610:
 		puts("8610");
 		break;
@@ -90,98 +77,69 @@
 		break;
 	}
 	printf(", Version: %d.%d, (0x%08x)\n", major, minor, svr);
+	puts("Core:  ");
+
+	pvr = get_pvr();
+	ver = PVR_E600_VER(pvr);
+	major = PVR_E600_MAJ(pvr);
+	minor = PVR_E600_MIN(pvr);
+
+	printf("E600 Core %d", (msscr0 & 0x20) ? 1 : 0 );
+	if (gur->pordevsr & MPC86xx_PORDEVSR_CORE1TE)
+		puts("\n    Core1Translation Enabled");
+	debug(" (MSSCR0=%x, PORDEVSR=%x)", msscr0, gur->pordevsr);
+
+	printf(", Version: %d.%d, (0x%08x)\n", major, minor, pvr);
 
 	get_sys_info(&sysinfo);
 
-	puts("    Clocks: ");
-	printf("CPU:%4lu MHz, ", sysinfo.freqProcessor / 1000000);
-	printf("MPX:%4lu MHz, ", sysinfo.freqSystemBus / 1000000);
-	printf("DDR:%4lu MHz, ", sysinfo.freqSystemBus / 2000000);
+	puts("Clock Configuration:\n");
+	printf("       CPU:%-4s MHz, ", strmhz(buf1, sysinfo.freqProcessor));
+	printf("MPX:%-4s MHz\n", strmhz(buf1, sysinfo.freqSystemBus));
+	printf("       DDR:%-4s MHz (%s MT/s data rate), ",
+		strmhz(buf1, sysinfo.freqSystemBus / 2),
+		strmhz(buf2, sysinfo.freqSystemBus));
 
 	if (sysinfo.freqLocalBus > LCRR_CLKDIV) {
-		printf("LBC:%4lu MHz\n", sysinfo.freqLocalBus / 1000000);
+		printf("LBC:%-4s MHz\n", strmhz(buf1, sysinfo.freqLocalBus));
 	} else {
 		printf("LBC: unknown (LCRR[CLKDIV] = 0x%02lx)\n",
 		       sysinfo.freqLocalBus);
 	}
 
-	puts("    L2: ");
-	if (get_l2cr() & 0x80000000)
-		puts("Enabled\n");
-	else
+	puts("L1:    D-cache 32 KB enabled\n");
+	puts("       I-cache 32 KB enabled\n");
+
+	puts("L2:    ");
+	if (get_l2cr() & 0x80000000) {
+#if defined(CONFIG_MPC8610)
+		puts("256");
+#elif defined(CONFIG_MPC8641)
+		puts("512");
+#endif
+		puts(" KB enabled\n");
+	} else {
 		puts("Disabled\n");
+	}
 
 	return 0;
 }
 
 
-static inline void
-soft_restart(unsigned long addr)
-{
-#if !defined(CONFIG_MPC8641HPCN) && !defined(CONFIG_MPC8610HPCD)
-
-	/*
-	 * SRR0 has system reset vector, SRR1 has default MSR value
-	 * rfi restores MSR from SRR1 and sets the PC to the SRR0 value
-	 */
-
-	__asm__ __volatile__ ("mtspr	26, %0"		:: "r" (addr));
-	__asm__ __volatile__ ("li	4, (1 << 6)"	::: "r4");
-	__asm__ __volatile__ ("mtspr	27, 4");
-	__asm__ __volatile__ ("rfi");
-
-#else /* CONFIG_MPC8641HPCN */
-
-	out8(PIXIS_BASE + PIXIS_RST, 0);
-
-#endif /* !CONFIG_MPC8641HPCN */
-
-	while (1) ;		/* not reached */
-}
-
-
-/*
- * No generic way to do board reset. Simply call soft_reset.
- */
 void
 do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-#if !defined(CONFIG_MPC8641HPCN) && !defined(CONFIG_MPC8610HPCD)
-
-#ifdef CONFIG_SYS_RESET_ADDRESS
-	ulong addr = CONFIG_SYS_RESET_ADDRESS;
-#else
-	/*
-	 * note: when CONFIG_SYS_MONITOR_BASE points to a RAM address,
-	 * CONFIG_SYS_MONITOR_BASE - sizeof (ulong) is usually a valid
-	 * address. Better pick an address known to be invalid on your
-	 * system and assign it to CONFIG_SYS_RESET_ADDRESS.
-	 */
-	ulong addr = CONFIG_SYS_MONITOR_BASE - sizeof(ulong);
-#endif
-
-	/* flush and disable I/D cache */
-	__asm__ __volatile__ ("mfspr	3, 1008"	::: "r3");
-	__asm__ __volatile__ ("ori	5, 5, 0xcc00"	::: "r5");
-	__asm__ __volatile__ ("ori	4, 3, 0xc00"	::: "r4");
-	__asm__ __volatile__ ("andc	5, 3, 5"	::: "r5");
-	__asm__ __volatile__ ("sync");
-	__asm__ __volatile__ ("mtspr	1008, 4");
-	__asm__ __volatile__ ("isync");
-	__asm__ __volatile__ ("sync");
-	__asm__ __volatile__ ("mtspr	1008, 5");
-	__asm__ __volatile__ ("isync");
-	__asm__ __volatile__ ("sync");
-
-	soft_restart(addr);
-
-#else /* CONFIG_MPC8641HPCN */
+	volatile immap_t *immap = (immap_t *)CONFIG_SYS_IMMR;
+	volatile ccsr_gur_t *gur = &immap->im_gur;
 
-	out8(PIXIS_BASE + PIXIS_RST, 0);
+	/* Attempt board-specific reset */
+	board_reset();
 
-#endif /* !CONFIG_MPC8641HPCN */
+	/* Next try asserting HRESET_REQ */
+	out_be32(&gur->rstcr, MPC86xx_RSTCR_HRST_REQ);
 
-	while (1) ;		/* not reached */
+	while (1)
+		;
 }
 
 
diff -Naur u-boot-2009.01/cpu/mpc86xx/cpu_init.c u-boot/cpu/mpc86xx/cpu_init.c
--- u-boot-2009.01/cpu/mpc86xx/cpu_init.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc86xx/cpu_init.c	2009-02-26 14:03:58.000000000 +0100
@@ -154,3 +154,30 @@
 
 	return;
 }
+
+#ifdef CONFIG_ADDR_MAP
+/* Initialize address mapping array */
+void init_addr_map(void)
+{
+	int i;
+	ppc_bat_t bat = DBAT0;
+	phys_size_t size;
+	unsigned long upper, lower;
+
+	for (i = 0; i < CONFIG_SYS_NUM_ADDR_MAP; i++, bat++) {
+		if (read_bat(bat, &upper, &lower) != -1) {
+			if (!BATU_VALID(upper))
+				size = 0;
+			else
+				size = BATU_SIZE(upper);
+			addrmap_set_entry(BATU_VADDR(upper), BATL_PADDR(lower),
+					  size, i);
+		}
+#ifdef CONFIG_HIGH_BATS
+		/* High bats are not contiguous with low BAT numbers */
+		if (bat == DBAT3)
+			bat = DBAT4 - 1;
+#endif
+	}
+}
+#endif
diff -Naur u-boot-2009.01/cpu/mpc8xx/bedbug_860.c u-boot/cpu/mpc8xx/bedbug_860.c
--- u-boot-2009.01/cpu/mpc8xx/bedbug_860.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8xx/bedbug_860.c	2009-02-26 14:03:58.000000000 +0100
@@ -71,7 +71,7 @@
 
   if (argc < 2)
   {
-    printf ("Usage:\n%s\n", cmdtp->usage);
+    cmd_usage(cmdtp);
     return;
   }
 
@@ -122,7 +122,7 @@
 
   if( !isdigit( argv[ 1 ][ 0 ]))
   {
-    printf ("Usage:\n%s\n", cmdtp->usage);
+    cmd_usage(cmdtp);
     return;
   }
 
diff -Naur u-boot-2009.01/cpu/mpc8xx/serial.c u-boot/cpu/mpc8xx/serial.c
--- u-boot-2009.01/cpu/mpc8xx/serial.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8xx/serial.c	2009-02-26 14:03:58.000000000 +0100
@@ -65,6 +65,23 @@
 
 #endif /* CONFIG_8xx_CONS_SCCx */
 
+#if !defined(CONFIG_SYS_SMC_RXBUFLEN)
+#define CONFIG_SYS_SMC_RXBUFLEN	1
+#define CONFIG_SYS_MAXIDLE	0
+#else
+#if !defined(CONFIG_SYS_MAXIDLE)
+#error "you must define CONFIG_SYS_MAXIDLE"
+#endif
+#endif
+
+typedef volatile struct serialbuffer {
+	cbd_t	rxbd;		/* Rx BD */
+	cbd_t	txbd;		/* Tx BD */
+	uint	rxindex;	/* index for next character to read */
+	volatile uchar	rxbuf[CONFIG_SYS_SMC_RXBUFLEN];/* rx buffers */
+	volatile uchar	txbuf;	/* tx buffers */
+} serialbuffer_t;
+
 static void serial_setdivisor(volatile cpm8xx_t *cp)
 {
 	int divisor=(gd->cpu_clk + 8*gd->baudrate)/16/gd->baudrate;
@@ -113,12 +130,12 @@
 	volatile immap_t *im = (immap_t *)CONFIG_SYS_IMMR;
 	volatile smc_t *sp;
 	volatile smc_uart_t *up;
-	volatile cbd_t *tbdf, *rbdf;
 	volatile cpm8xx_t *cp = &(im->im_cpm);
 #if (!defined(CONFIG_8xx_CONS_SMC1)) && (defined(CONFIG_MPC823) || defined(CONFIG_MPC850))
 	volatile iop8xx_t *ip = (iop8xx_t *)&(im->im_ioport);
 #endif
 	uint	dpaddr;
+	volatile serialbuffer_t *rtx;
 
 	/* initialize pointers to SMC */
 
@@ -131,12 +148,10 @@
 	up->smc_rpbase = 0;
 #endif
 
-	/* Disable transmitter/receiver.
-	*/
+	/* Disable transmitter/receiver. */
 	sp->smc_smcmr &= ~(SMCMR_REN | SMCMR_TEN);
 
-	/* Enable SDMA.
-	*/
+	/* Enable SDMA. */
 	im->im_siu_conf.sc_sdcr = 1;
 
 	/* clear error conditions */
@@ -154,21 +169,19 @@
 #endif
 
 #if defined(CONFIG_8xx_CONS_SMC1)
-	/* Use Port B for SMC1 instead of other functions.
-	*/
+	/* Use Port B for SMC1 instead of other functions. */
 	cp->cp_pbpar |=  0x000000c0;
 	cp->cp_pbdir &= ~0x000000c0;
 	cp->cp_pbodr &= ~0x000000c0;
 #else	/* CONFIG_8xx_CONS_SMC2 */
 # if defined(CONFIG_MPC823) || defined(CONFIG_MPC850)
-	/* Use Port A for SMC2 instead of other functions.
-	*/
+	/* Use Port A for SMC2 instead of other functions. */
 	ip->iop_papar |=  0x00c0;
 	ip->iop_padir &= ~0x00c0;
 	ip->iop_paodr &= ~0x00c0;
 # else	/* must be a 860 then */
 	/* Use Port B for SMC2 instead of other functions.
-	*/
+	 */
 	cp->cp_pbpar |=  0x00000c00;
 	cp->cp_pbdir &= ~0x00000c00;
 	cp->cp_pbodr &= ~0x00000c00;
@@ -194,26 +207,28 @@
 	 */
 
 #ifdef CONFIG_SYS_ALLOC_DPRAM
-	dpaddr = dpram_alloc_align (sizeof(cbd_t)*2 + 2, 8) ;
+	/* allocate
+	 * size of struct serialbuffer with bd rx/tx, buffer rx/tx and rx index
+	 */
+	dpaddr = dpram_alloc_align((sizeof(serialbuffer_t)), 8);
 #else
 	dpaddr = CPM_SERIAL_BASE ;
 #endif
 
+	rtx = (serialbuffer_t *)&cp->cp_dpmem[dpaddr];
 	/* Allocate space for two buffer descriptors in the DP ram.
 	 * For now, this address seems OK, but it may have to
 	 * change with newer versions of the firmware.
 	 * damm: allocating space after the two buffers for rx/tx data
 	 */
 
-	rbdf = (cbd_t *)&cp->cp_dpmem[dpaddr];
-	rbdf->cbd_bufaddr = (uint) (rbdf+2);
-	rbdf->cbd_sc = 0;
-	tbdf = rbdf + 1;
-	tbdf->cbd_bufaddr = ((uint) (rbdf+2)) + 1;
-	tbdf->cbd_sc = 0;
+	rtx->rxbd.cbd_bufaddr = (uint) &rtx->rxbuf;
+	rtx->rxbd.cbd_sc      = 0;
 
-	/* Set up the uart parameters in the parameter ram.
-	*/
+	rtx->txbd.cbd_bufaddr = (uint) &rtx->txbuf;
+	rtx->txbd.cbd_sc      = 0;
+
+	/* Set up the uart parameters in the parameter ram. */
 	up->smc_rbase = dpaddr;
 	up->smc_tbase = dpaddr+sizeof(cbd_t);
 	up->smc_rfcr = SMC_EB;
@@ -254,19 +269,16 @@
 	smc_setbrg ();
 #endif
 
-	/* Make the first buffer the only buffer.
-	*/
-	tbdf->cbd_sc |= BD_SC_WRAP;
-	rbdf->cbd_sc |= BD_SC_EMPTY | BD_SC_WRAP;
-
-	/* Single character receive.
-	*/
-	up->smc_mrblr = 1;
-	up->smc_maxidl = 0;
-
-	/* Initialize Tx/Rx parameters.
-	*/
+	/* Make the first buffer the only buffer. */
+	rtx->txbd.cbd_sc |= BD_SC_WRAP;
+	rtx->rxbd.cbd_sc |= BD_SC_EMPTY | BD_SC_WRAP;
+
+	/* single/multi character receive. */
+	up->smc_mrblr = CONFIG_SYS_SMC_RXBUFLEN;
+	up->smc_maxidl = CONFIG_SYS_MAXIDLE;
+	rtx->rxindex = 0;
 
+	/* Initialize Tx/Rx parameters.	*/
 	while (cp->cp_cpcr & CPM_CR_FLG)  /* wait if cp is busy */
 	  ;
 
@@ -275,8 +287,7 @@
 	while (cp->cp_cpcr & CPM_CR_FLG)  /* wait if cp is busy */
 	  ;
 
-	/* Enable transmitter/receiver.
-	*/
+	/* Enable transmitter/receiver.	*/
 	sp->smc_smcmr |= SMCMR_REN | SMCMR_TEN;
 
 	return (0);
@@ -285,11 +296,10 @@
 static void
 smc_putc(const char c)
 {
-	volatile cbd_t		*tbdf;
-	volatile char		*buf;
 	volatile smc_uart_t	*up;
 	volatile immap_t	*im = (immap_t *)CONFIG_SYS_IMMR;
 	volatile cpm8xx_t	*cpmp = &(im->im_cpm);
+	volatile serialbuffer_t	*rtx;
 
 #ifdef CONFIG_MODEM_SUPPORT
 	if (gd->be_quiet)
@@ -304,19 +314,15 @@
 	up = (smc_uart_t *) &cpmp->cp_dpmem[up->smc_rpbase];
 #endif
 
-	tbdf = (cbd_t *)&cpmp->cp_dpmem[up->smc_tbase];
-
-	/* Wait for last character to go.
-	*/
-
-	buf = (char *)tbdf->cbd_bufaddr;
+	rtx = (serialbuffer_t *)&cpmp->cp_dpmem[up->smc_rbase];
 
-	*buf = c;
-	tbdf->cbd_datlen = 1;
-	tbdf->cbd_sc |= BD_SC_READY;
+	/* Wait for last character to go. */
+	rtx->txbuf = c;
+	rtx->txbd.cbd_datlen = 1;
+	rtx->txbd.cbd_sc |= BD_SC_READY;
 	__asm__("eieio");
 
-	while (tbdf->cbd_sc & BD_SC_READY) {
+	while (rtx->txbd.cbd_sc & BD_SC_READY) {
 		WATCHDOG_RESET ();
 		__asm__("eieio");
 	}
@@ -333,49 +339,52 @@
 static int
 smc_getc(void)
 {
-	volatile cbd_t		*rbdf;
-	volatile unsigned char	*buf;
 	volatile smc_uart_t	*up;
 	volatile immap_t	*im = (immap_t *)CONFIG_SYS_IMMR;
 	volatile cpm8xx_t	*cpmp = &(im->im_cpm);
-	unsigned char		c;
+	volatile serialbuffer_t	*rtx;
+	unsigned char  c;
 
 	up = (smc_uart_t *)&cpmp->cp_dparam[PROFF_SMC];
 #ifdef CONFIG_SYS_SMC_UCODE_PATCH
 	up = (smc_uart_t *) &cpmp->cp_dpmem[up->smc_rpbase];
 #endif
+	rtx = (serialbuffer_t *)&cpmp->cp_dpmem[up->smc_rbase];
 
-	rbdf = (cbd_t *)&cpmp->cp_dpmem[up->smc_rbase];
-
-	/* Wait for character to show up.
-	*/
-	buf = (unsigned char *)rbdf->cbd_bufaddr;
-
-	while (rbdf->cbd_sc & BD_SC_EMPTY)
+	/* Wait for character to show up. */
+	while (rtx->rxbd.cbd_sc & BD_SC_EMPTY)
 		WATCHDOG_RESET ();
 
-	c = *buf;
-	rbdf->cbd_sc |= BD_SC_EMPTY;
+	/* the characters are read one by one,
+	 * use the rxindex to know the next char to deliver
+	 */
+	c = *(unsigned char *) (rtx->rxbd.cbd_bufaddr+rtx->rxindex);
+	rtx->rxindex++;
 
+	/* check if all char are readout, then make prepare for next receive */
+	if (rtx->rxindex >= rtx->rxbd.cbd_datlen) {
+		rtx->rxindex = 0;
+		rtx->rxbd.cbd_sc |= BD_SC_EMPTY;
+	}
 	return(c);
 }
 
 static int
 smc_tstc(void)
 {
-	volatile cbd_t		*rbdf;
 	volatile smc_uart_t	*up;
 	volatile immap_t	*im = (immap_t *)CONFIG_SYS_IMMR;
 	volatile cpm8xx_t	*cpmp = &(im->im_cpm);
+	volatile serialbuffer_t	*rtx;
 
 	up = (smc_uart_t *)&cpmp->cp_dparam[PROFF_SMC];
 #ifdef CONFIG_SYS_SMC_UCODE_PATCH
 	up = (smc_uart_t *) &cpmp->cp_dpmem[up->smc_rpbase];
 #endif
 
-	rbdf = (cbd_t *)&cpmp->cp_dpmem[up->smc_rbase];
+	rtx = (serialbuffer_t *)&cpmp->cp_dpmem[up->smc_rbase];
 
-	return(!(rbdf->cbd_sc & BD_SC_EMPTY));
+	return !(rtx->rxbd.cbd_sc & BD_SC_EMPTY);
 }
 
 struct serial_device serial_smc_device =
@@ -445,8 +454,7 @@
     }
 #endif	/* CONFIG_LWMON */
 
-	/* Disable transmitter/receiver.
-	*/
+	/* Disable transmitter/receiver. */
 	sp->scc_gsmrl &= ~(SCC_GSMRL_ENR | SCC_GSMRL_ENT);
 
 #if (SCC_INDEX == 2) && defined(CONFIG_MPC850)
@@ -471,8 +479,7 @@
 	ip->iop_pdpar |=  ((3 << (2 * SCC_INDEX)));
 #endif
 
-	/* Allocate space for two buffer descriptors in the DP ram.
-	 */
+	/* Allocate space for two buffer descriptors in the DP ram. */
 
 #ifdef CONFIG_SYS_ALLOC_DPRAM
 	dpaddr = dpram_alloc_align (sizeof(cbd_t)*2 + 2, 8) ;
@@ -480,8 +487,7 @@
 	dpaddr = CPM_SERIAL2_BASE ;
 #endif
 
-	/* Enable SDMA.
-	*/
+	/* Enable SDMA.	*/
 	im->im_siu_conf.sc_sdcr = 0x0001;
 
 	/* Set the physical address of the host memory buffers in
@@ -495,17 +501,14 @@
 	tbdf->cbd_bufaddr = ((uint) (rbdf+2)) + 1;
 	tbdf->cbd_sc = 0;
 
-	/* Set up the baud rate generator.
-	*/
+	/* Set up the baud rate generator. */
 	scc_setbrg ();
 
-	/* Set up the uart parameters in the parameter ram.
-	*/
+	/* Set up the uart parameters in the parameter ram. */
 	up->scc_genscc.scc_rbase = dpaddr;
 	up->scc_genscc.scc_tbase = dpaddr+sizeof(cbd_t);
 
-	/* Initialize Tx/Rx parameters.
-	*/
+	/* Initialize Tx/Rx parameters. */
 	while (cp->cp_cpcr & CPM_CR_FLG)  /* wait if cp is busy */
 		;
 	cp->cp_cpcr = mk_cr_cmd(CPM_CR_CH_SCC, CPM_CR_INIT_TRX) | CPM_CR_FLG;
@@ -536,8 +539,7 @@
 	up->scc_char8  = 0x8000;
 	up->scc_rccm   = 0xc0ff;
 
-	/* Set low latency / small fifo.
-	 */
+	/* Set low latency / small fifo. */
 	sp->scc_gsmrh = SCC_GSMRH_RFW;
 
 	/* Set SCC(x) clock mode to 16x
@@ -546,8 +548,7 @@
 	 * Wire BRG1 to SCCn
 	 */
 
-	/* Set UART mode, clock divider 16 on Tx and Rx
-	 */
+	/* Set UART mode, clock divider 16 on Tx and Rx */
 	sp->scc_gsmrl &= ~0xF;
 	sp->scc_gsmrl |=
 		(SCC_GSMRL_MODE_UART | SCC_GSMRL_TDCR_16 | SCC_GSMRL_RDCR_16);
@@ -555,20 +556,17 @@
 	sp->scc_psmr  = 0;
 	sp->scc_psmr  |= SCU_PSMR_CL;
 
-	/* Mask all interrupts and remove anything pending.
-	*/
+	/* Mask all interrupts and remove anything pending. */
 	sp->scc_sccm = 0;
 	sp->scc_scce = 0xffff;
 	sp->scc_dsr  = 0x7e7e;
 	sp->scc_psmr = 0x3000;
 
-	/* Make the first buffer the only buffer.
-	*/
+	/* Make the first buffer the only buffer. */
 	tbdf->cbd_sc |= BD_SC_WRAP;
 	rbdf->cbd_sc |= BD_SC_EMPTY | BD_SC_WRAP;
 
-	/* Enable transmitter/receiver.
-	*/
+	/* Enable transmitter/receiver.	*/
 	sp->scc_gsmrl |= (SCC_GSMRL_ENR | SCC_GSMRL_ENT);
 
 	return (0);
@@ -595,8 +593,7 @@
 
 	tbdf = (cbd_t *)&cpmp->cp_dpmem[up->scc_genscc.scc_tbase];
 
-	/* Wait for last character to go.
-	*/
+	/* Wait for last character to go. */
 
 	buf = (char *)tbdf->cbd_bufaddr;
 
@@ -633,8 +630,7 @@
 
 	rbdf = (cbd_t *)&cpmp->cp_dpmem[up->scc_genscc.scc_rbase];
 
-	/* Wait for character to show up.
-	*/
+	/* Wait for character to show up. */
 	buf = (unsigned char *)rbdf->cbd_bufaddr;
 
 	while (rbdf->cbd_sc & BD_SC_EMPTY)
diff -Naur u-boot-2009.01/cpu/mpc8xxx/ddr/ctrl_regs.c u-boot/cpu/mpc8xxx/ddr/ctrl_regs.c
--- u-boot-2009.01/cpu/mpc8xxx/ddr/ctrl_regs.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8xxx/ddr/ctrl_regs.c	2009-02-26 14:03:58.000000000 +0100
@@ -167,7 +167,7 @@
 		| ((trrt_mclk & 0x3) << 26)	/* RRT */
 		| ((twwt_mclk & 0x3) << 24)	/* WWT */
 		| ((act_pd_exit_mclk & 0x7) << 20)  /* ACT_PD_EXIT */
-		| ((pre_pd_exit_mclk & 0x7) << 16)  /* PRE_PD_EXIT */
+		| ((pre_pd_exit_mclk & 0xF) << 16)  /* PRE_PD_EXIT */
 		| ((taxpd_mclk & 0xf) << 8)	/* ODT_PD_EXIT */
 		| ((tmrd_mclk & 0xf) << 0)	/* MRS_CYC */
 		);
@@ -185,10 +185,14 @@
 	unsigned int ext_caslat = 0; /* Extended MCAS latency from READ cmd */
 	unsigned int cntl_adj = 0; /* Control Adjust */
 
+	/* If the tRAS > 19 MCLK, we use the ext mode */
+	if (picos_to_mclk(common_dimm->tRAS_ps) > 0x13)
+		ext_acttopre = 1;
+
 	ext_refrec = (picos_to_mclk(common_dimm->tRFC_ps) - 8) >> 4;
 	ddr->timing_cfg_3 = (0
 		| ((ext_acttopre & 0x1) << 24)
-		| ((ext_refrec & 0x7) << 16)
+		| ((ext_refrec & 0xF) << 16)
 		| ((ext_caslat & 0x1) << 12)
 		| ((cntl_adj & 0x7) << 0)
 		);
@@ -251,12 +255,12 @@
 	wrtord_mclk = picos_to_mclk(common_dimm->tWTR_ps);
 
 	ddr->timing_cfg_1 = (0
-		| ((pretoact_mclk & 0x07) << 28)
+		| ((pretoact_mclk & 0x0F) << 28)
 		| ((acttopre_mclk & 0x0F) << 24)
-		| ((acttorw_mclk & 0x7) << 20)
+		| ((acttorw_mclk & 0xF) << 20)
 		| ((caslat_ctrl & 0xF) << 16)
 		| ((refrec_ctrl & 0xF) << 12)
-		| ((wrrec_mclk & 0x07) << 8)
+		| ((wrrec_mclk & 0x0F) << 8)
 		| ((acttoact_mclk & 0x07) << 4)
 		| ((wrtord_mclk & 0x07) << 0)
 		);
@@ -309,13 +313,13 @@
 	four_act = picos_to_mclk(popts->tFAW_window_four_activates_ps);
 
 	ddr->timing_cfg_2 = (0
-		| ((add_lat_mclk & 0x7) << 28)
+		| ((add_lat_mclk & 0xf) << 28)
 		| ((cpo & 0x1f) << 23)
-		| ((wr_lat & 0x7) << 19)
+		| ((wr_lat & 0xf) << 19)
 		| ((rd_to_pre & 0x7) << 13)
 		| ((wr_data_delay & 0x7) << 10)
 		| ((cke_pls & 0x7) << 6)
-		| ((four_act & 0x1f) << 0)
+		| ((four_act & 0x3f) << 0)
 		);
 	debug("FSLDDR: timing_cfg_2 = 0x%08x\n", ddr->timing_cfg_2);
 }
@@ -332,7 +336,7 @@
 	unsigned int sdram_type;	/* Type of SDRAM */
 	unsigned int dyn_pwr;		/* Dynamic power management mode */
 	unsigned int dbw;		/* DRAM dta bus width */
-	unsigned int eight_be;		/* 8-beat burst enable */
+	unsigned int eight_be = 0;	/* 8-beat burst enable, DDR2 is zero */
 	unsigned int ncap = 0;		/* Non-concurrent auto-precharge */
 	unsigned int threeT_en;		/* Enable 3T timing */
 	unsigned int twoT_en;		/* Enable 2T timing */
@@ -359,7 +363,9 @@
 
 	dyn_pwr = popts->dynamic_power;
 	dbw = popts->data_bus_width;
-	eight_be = 0;		/* always 0 for DDR2 */
+	/* DDR3 must use 8-beat bursts when using 32-bit bus mode */
+	if ((sdram_type == SDRAM_TYPE_DDR3) && (dbw == 0x1))
+		eight_be = 1;
 	threeT_en = popts->threeT_en;
 	twoT_en = popts->twoT_en;
 	ba_intlv_ctl = popts->ba_intlv_ctl;
@@ -691,10 +697,10 @@
 	unsigned int wodt_off = 0;	/* Write to ODT off */
 
 	ddr->timing_cfg_5 = (0
-			     | ((rodt_on & 0xf) << 24)
-			     | ((rodt_off & 0xf) << 20)
-			     | ((wodt_on & 0xf) << 12)
-			     | ((wodt_off & 0xf) << 8)
+			     | ((rodt_on & 0x1f) << 24)
+			     | ((rodt_off & 0x7) << 20)
+			     | ((wodt_on & 0x1f) << 12)
+			     | ((wodt_off & 0x7) << 8)
 			     );
 	debug("FSLDDR: timing_cfg_5 = 0x%08x\n", ddr->timing_cfg_5);
 }
@@ -744,15 +750,14 @@
 			       | ((wrlvl_dqsen & 0x7) << 16)
 			       | ((wrlvl_smpl & 0xf) << 12)
 			       | ((wrlvl_wlr & 0x7) << 8)
-			       | ((wrlvl_start & 0xF) << 0)
+			       | ((wrlvl_start & 0x1F) << 0)
 			       );
 }
 
 /* DDR Self Refresh Counter (DDR_SR_CNTR) */
-static void set_ddr_sr_cntr(fsl_ddr_cfg_regs_t *ddr)
+static void set_ddr_sr_cntr(fsl_ddr_cfg_regs_t *ddr, unsigned int sr_it)
 {
-	unsigned int sr_it = 0;	/* Self Refresh Idle Threshold */
-
+	/* Self Refresh Idle Threshold */
 	ddr->ddr_sr_cntr = (sr_it & 0xF) << 16;
 }
 
@@ -855,6 +860,7 @@
 	unsigned int i;
 	unsigned int cas_latency;
 	unsigned int additive_latency;
+	unsigned int sr_it;
 
 	memset(ddr, 0, sizeof(fsl_ddr_cfg_regs_t));
 
@@ -876,6 +882,10 @@
 		? popts->additive_latency_override_value
 		: common_dimm->additive_latency;
 
+	sr_it = (popts->auto_self_refresh_en)
+		? popts->sr_it
+		: 0;
+
 	/* Chip Select Memory Bounds (CSn_BNDS) */
 	for (i = 0; i < CONFIG_CHIP_SELECTS_PER_CTRL; i++) {
 		phys_size_t sa = 0;
@@ -1036,7 +1046,7 @@
 	set_ddr_wrlvl_cntl(ddr);
 
 	set_ddr_pd_cntl(ddr);
-	set_ddr_sr_cntr(ddr);
+	set_ddr_sr_cntr(ddr, sr_it);
 
 	set_ddr_sdram_rcw_1(ddr);
 	set_ddr_sdram_rcw_2(ddr);
diff -Naur u-boot-2009.01/cpu/mpc8xxx/ddr/main.c u-boot/cpu/mpc8xxx/ddr/main.c
--- u-boot-2009.01/cpu/mpc8xxx/ddr/main.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8xxx/ddr/main.c	2009-02-26 14:03:58.000000000 +0100
@@ -429,7 +429,7 @@
 		if (max_end >= 0xff) {
 			printf("This U-Boot only supports < 4G of DDR\n");
 			printf("You could rebuild it with CONFIG_PHYS_64BIT\n");
-			return 0;	/* Ensure DDR setup failure. */
+			return CONFIG_MAX_MEM_MAPPED;
 		}
 #endif
 
diff -Naur u-boot-2009.01/cpu/mpc8xxx/ddr/options.c u-boot/cpu/mpc8xxx/ddr/options.c
--- u-boot-2009.01/cpu/mpc8xxx/ddr/options.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/mpc8xxx/ddr/options.c	2009-02-26 14:03:58.000000000 +0100
@@ -22,7 +22,9 @@
 			unsigned int ctrl_num)
 {
 	unsigned int i;
+#if (CONFIG_NUM_DDR_CONTROLLERS > 1)
 	const char *p;
+#endif
 
 	/* Chip select options. */
 
@@ -142,7 +144,7 @@
 	 *	- number of components, number of active ranks
 	 *	- how much time you want to spend playing around
 	 */
-	popts->twoT_en = 1;
+	popts->twoT_en = 0;
 	popts->threeT_en = 0;
 
 	/*
@@ -195,6 +197,7 @@
 	 * requested ranks interleaved together such that the result
 	 * should be a subset of the requested configuration.
 	 */
+#if (CONFIG_NUM_DDR_CONTROLLERS > 1)
 	if ((p = getenv("memctl_intlv_ctl")) != NULL) {
 		if (pdimm[0].n_ranks == 0) {
 			printf("There is no rank on CS0. Because only rank on "
@@ -262,6 +265,7 @@
 			break;
 		}
 	}
+#endif
 
 	fsl_ddr_board_options(popts, pdimm, ctrl_num);
 
diff -Naur u-boot-2009.01/cpu/nios2/sysid.c u-boot/cpu/nios2/sysid.c
--- u-boot-2009.01/cpu/nios2/sysid.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/nios2/sysid.c	2009-02-26 14:03:58.000000000 +0100
@@ -52,7 +52,7 @@
 
 U_BOOT_CMD(
 	sysid,	1,	1,	do_sysid,
-	"sysid   - display Nios-II system id\n\n",
+	"display Nios-II system id",
 	"\n    - display Nios-II system id\n"
 );
 #endif /* CONFIG_SYS_NIOS_SYSID_BASE */
diff -Naur u-boot-2009.01/cpu/ppc4xx/44x_spd_ddr2.c u-boot/cpu/ppc4xx/44x_spd_ddr2.c
--- u-boot-2009.01/cpu/ppc4xx/44x_spd_ddr2.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ppc4xx/44x_spd_ddr2.c	2009-02-26 14:03:58.000000000 +0100
@@ -160,9 +160,6 @@
  * SDRAM. This is because we only map the first 2GB on such systems, and therefore
  * the ECC parity byte of the remaining area can't be written.
  */
-#ifndef CONFIG_MAX_MEM_MAPPED
-#define CONFIG_MAX_MEM_MAPPED	((phys_size_t)2 << 30)
-#endif
 
 /*
  * Board-specific Platform code can reimplement spd_ddr_init_hang () if needed
@@ -1104,11 +1101,8 @@
 	 * Set the SDRAM Controller On Die Termination Register
 	 *-----------------------------------------------------------------*/
 	mfsdram(SDRAM_CODT, codt);
-	codt |= (SDRAM_CODT_IO_NMODE
-		 & (~SDRAM_CODT_DQS_SINGLE_END
-		    & ~SDRAM_CODT_CKSE_SINGLE_END
-		    & ~SDRAM_CODT_FEEBBACK_RCV_SINGLE_END
-		    & ~SDRAM_CODT_FEEBBACK_DRV_SINGLE_END));
+	codt &= ~(SDRAM_CODT_DQS_SINGLE_END | SDRAM_CODT_CKSE_SINGLE_END);
+	codt |= SDRAM_CODT_IO_NMODE;
 
 	for (dimm_num = 0; dimm_num < num_dimm_banks; dimm_num++) {
 		if (dimm_populated[dimm_num] != SDRAM_NONE) {
diff -Naur u-boot-2009.01/cpu/ppc4xx/4xx_ibm_ddr2_autocalib.c u-boot/cpu/ppc4xx/4xx_ibm_ddr2_autocalib.c
--- u-boot-2009.01/cpu/ppc4xx/4xx_ibm_ddr2_autocalib.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ppc4xx/4xx_ibm_ddr2_autocalib.c	2009-02-26 14:03:58.000000000 +0100
@@ -61,6 +61,8 @@
 #define NUMLOOPS		1	/* configure as you deem approporiate */
 #define NUMMEMWORDS		16
 
+#define SDRAM_RDCC_RDSS_VAL(n)	SDRAM_RDCC_RDSS_DECODE(ddr_rdss_opt(n))
+
 /* Private Structure Definitions */
 
 struct autocal_regs {
@@ -147,6 +149,13 @@
 }
 ulong ddr_scan_option(ulong) __attribute__((weak, alias("__ddr_scan_option")));
 
+u32 __ddr_rdss_opt(u32 default_val)
+{
+	return default_val;
+}
+u32 ddr_rdss_opt(ulong) __attribute__((weak, alias("__ddr_rdss_opt")));
+
+
 static u32 *get_membase(int bxcr_num)
 {
 	ulong bxcf;
@@ -341,6 +350,7 @@
 			ppcDcbf((ulong)&(base_address[j]));
 		}
 		sync();
+		iobarrier_rw();
 		for (l = 0; l < NUMLOOPS; l++) {
 			for (j = 0; j < NUMMEMWORDS; j++) {
 				if (base_address[j] != test[i][j]) {
@@ -355,6 +365,7 @@
 				ppcDcbf((u32)&(base_address[j]));
 			} /* for (j = 0; j < NUMMEMWORDS; j++) */
 			sync();
+			iobarrier_rw();
 		} /* for (l=0; l<NUMLOOPS; l++) */
 	}
 
@@ -447,7 +458,8 @@
 	 * Program RDCC register
 	 * Read sample cycle auto-update enable
 	 */
-	mtsdram(SDRAM_RDCC, SDRAM_RDCC_RDSS_T1 | SDRAM_RDCC_RSAE_ENABLE);
+	mtsdram(SDRAM_RDCC,
+		ddr_rdss_opt(SDRAM_RDCC_RDSS_T2) | SDRAM_RDCC_RSAE_ENABLE);
 
 #ifdef DEBUG
 	mfsdram(SDRAM_RDCC, temp);
@@ -633,7 +645,8 @@
 	 * Program RDCC register
 	 * Read sample cycle auto-update enable
 	 */
-	mtsdram(SDRAM_RDCC, SDRAM_RDCC_RDSS_T2 | SDRAM_RDCC_RSAE_ENABLE);
+	mtsdram(SDRAM_RDCC,
+		ddr_rdss_opt(SDRAM_RDCC_RDSS_T2) | SDRAM_RDCC_RSAE_ENABLE);
 
 #ifdef DEBUG
 	mfsdram(SDRAM_RDCC, temp);
@@ -1091,32 +1104,36 @@
 		 * if no passing window was found, or is the
 		 * size of the RFFD passing window.
 		 */
-		if (result != 0) {
-			tcal.autocal.flags = 1;
-			debug("*** (%d)(%d) result passed window size: 0x%08x, "
-			      "rqfd = 0x%08x, rffd = 0x%08x, rdcc = 0x%08x\n",
-				wdtr, clkp, result, ddrcal.rqfd,
-				ddrcal.rffd, ddrcal.rdcc);
-			/*
-			 * Save the SDRAM_WRDTR and SDRAM_CLKTR
-			 * settings for the largest returned
-			 * RFFD passing window size.
-			 */
-			if (result > best_result) {
+		/*
+		 * want the lowest Read Sample Cycle Select
+		 */
+		val = SDRAM_RDCC_RDSS_DECODE(val);
+		debug("*** (%d) (%d) current_rdcc, best_rdcc\n",
+			val, best_rdcc);
+
+		if ((result != 0) &&
+		    (val >= SDRAM_RDCC_RDSS_VAL(SDRAM_RDCC_RDSS_T2))) {
+			if (((result == best_result) && (val < best_rdcc)) ||
+			    ((result > best_result) && (val <= best_rdcc))) {
+				tcal.autocal.flags = 1;
+				debug("*** (%d)(%d) result passed window "
+					"size: 0x%08x, rqfd = 0x%08x, "
+					"rffd = 0x%08x, rdcc = 0x%08x\n",
+					wdtr, clkp, result, ddrcal.rqfd,
+					ddrcal.rffd, ddrcal.rdcc);
+
 				/*
-				 * want the lowest Read Sample Cycle Select
+				 * Save the SDRAM_WRDTR and SDRAM_CLKTR
+				 * settings for the largest returned
+				 * RFFD passing window size.
 				 */
-				val = (val & SDRAM_RDCC_RDSS_MASK) >> 30;
-				debug("*** (%d) (%d) current_rdcc, best_rdcc\n",
-							val, best_rdcc);
-				if (val <= best_rdcc) {
-					best_rdcc = val;
-					tcal.clocks.wrdtr = wdtr;
-					tcal.clocks.clktr = clkp;
-					tcal.clocks.rdcc = (val << 30);
-					tcal.autocal.rqfd = ddrcal.rqfd;
-					tcal.autocal.rffd = ddrcal.rffd;
-					best_result = result;
+				best_rdcc = val;
+				tcal.clocks.wrdtr = wdtr;
+				tcal.clocks.clktr = clkp;
+				tcal.clocks.rdcc = SDRAM_RDCC_RDSS_ENCODE(val);
+				tcal.autocal.rqfd = ddrcal.rqfd;
+				tcal.autocal.rffd = ddrcal.rffd;
+				best_result = result;
 
 					if (verbose_lvl > 2) {
 						printf("** (%d)(%d)  "
@@ -1152,9 +1169,8 @@
 						       "loop FCSR: 0x%08x\n",
 							wdtr, clkp, val);
 					}
-				} /* if (val <= best_rdcc) */
-			} /* if (result >= best_result) */
-		} /* if (result != 0) */
+			}
+		} /* if ((result != 0) && (val >= (ddr_rdss_opt()))) */
 		scan_list++;
 	} /* while ((scan_list->wrdtr != -1) && (scan_list->clktr != -1)) */
 
diff -Naur u-boot-2009.01/cpu/ppc4xx/4xx_pci.c u-boot/cpu/ppc4xx/4xx_pci.c
--- u-boot-2009.01/cpu/ppc4xx/4xx_pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ppc4xx/4xx_pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -179,7 +179,7 @@
 				       ptmpcila[i], ptmla[i],
 				       ~(ptmms[i] & 0xfffff000) + 1,
 				       PCI_REGION_MEM |
-				       PCI_REGION_MEMORY);
+				       PCI_REGION_SYS_MEMORY);
 		}
 
 	/* PCI memory spaces */
@@ -504,7 +504,7 @@
 		       CONFIG_PCI_SYS_MEM_BUS,
 		       CONFIG_PCI_SYS_MEM_PHYS,
 		       CONFIG_PCI_SYS_MEM_SIZE,
-		       PCI_REGION_MEM | PCI_REGION_MEMORY );
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY );
 #endif
 
 	hose->region_count = reg_num;
@@ -588,8 +588,9 @@
 	int busno;
 
 	busno = pci_440_init (&ppc440_hose);
-#if defined(CONFIG_440SPE) || \
-    defined(CONFIG_460EX) || defined(CONFIG_460GT)
+#if (defined(CONFIG_440SPE) || \
+    defined(CONFIG_460EX) || defined(CONFIG_460GT)) && \
+    !defined(CONFIG_PCI_DISABLE_PCIE)
 	pcie_setup_hoses(busno + 1);
 #endif
 }
diff -Naur u-boot-2009.01/cpu/ppc4xx/4xx_pcie.c u-boot/cpu/ppc4xx/4xx_pcie.c
--- u-boot-2009.01/cpu/ppc4xx/4xx_pcie.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ppc4xx/4xx_pcie.c	2009-02-26 14:03:58.000000000 +0100
@@ -33,7 +33,7 @@
 
 #if (defined(CONFIG_440SPE) || defined(CONFIG_405EX) ||	\
     defined(CONFIG_460EX) || defined(CONFIG_460GT)) && \
-    defined(CONFIG_PCI)
+    defined(CONFIG_PCI) && !defined(CONFIG_PCI_DISABLE_PCIE)
 
 #include <asm/4xx_pcie.h>
 
@@ -1028,10 +1028,10 @@
 #endif
 	}
 
-	/* Set up 16GB inbound memory window at 0 */
+	/* Set up 4GB inbound memory window at 0 */
 	out_le32(mbase + PCI_BASE_ADDRESS_0, 0);
 	out_le32(mbase + PCI_BASE_ADDRESS_1, 0);
-	out_le32(mbase + PECFG_BAR0HMPA, 0x7fffffc);
+	out_le32(mbase + PECFG_BAR0HMPA, 0x7ffffff);
 	out_le32(mbase + PECFG_BAR0LMPA, 0);
 
 	out_le32(mbase + PECFG_PIM01SAH, 0xffff0000);
diff -Naur u-boot-2009.01/cpu/ppc4xx/bedbug_405.c u-boot/cpu/ppc4xx/bedbug_405.c
--- u-boot-2009.01/cpu/ppc4xx/bedbug_405.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ppc4xx/bedbug_405.c	2009-02-26 14:03:58.000000000 +0100
@@ -71,7 +71,7 @@
 	/* -------------------------------------------------- */
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return;
 	}
 
@@ -125,7 +125,7 @@
 	/* Set a breakpoint at the address */
 
 	if (!isdigit (argv[1][0])) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return;
 	}
 
diff -Naur u-boot-2009.01/cpu/ppc4xx/fdt.c u-boot/cpu/ppc4xx/fdt.c
--- u-boot-2009.01/cpu/ppc4xx/fdt.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ppc4xx/fdt.c	2009-02-26 14:03:58.000000000 +0100
@@ -113,6 +113,7 @@
 void ft_cpu_setup(void *blob, bd_t *bd)
 {
 	sys_info_t sys_info;
+	int off, ndepth = 0;
 
 	get_sys_info(&sys_info);
 
@@ -133,9 +134,28 @@
 	fdt_fixup_memory(blob, (u64)bd->bi_memstart, (u64)bd->bi_memsize);
 
 	/*
-	 * Setup all baudrates for the UARTs
+	 * Fixup all UART clocks for CPU internal UARTs
+	 * (only these UARTs are definitely clocked by gd->uart_clk)
+	 *
+	 * These UARTs are direct childs of /plb/opb. This code
+	 * does not touch any UARTs that are connected to the ebc.
 	 */
-	do_fixup_by_compat_u32(blob, "ns16550", "clock-frequency", gd->uart_clk, 1);
+	off = fdt_path_offset(blob, "/plb/opb");
+	while ((off = fdt_next_node(blob, off, &ndepth)) >= 0) {
+		/*
+		 * process all sub nodes and stop when we are back
+		 * at the starting depth
+		 */
+		if (ndepth <= 0)
+			break;
+
+		/* only update direct childs */
+		if ((ndepth == 1) &&
+		    (fdt_node_check_compatible(blob, off, "ns16550") == 0))
+			fdt_setprop(blob, off,
+				    "clock-frequency",
+				    (void*)&(gd->uart_clk), 4);
+	}
 
 	/*
 	 * Fixup all ethernet nodes
diff -Naur u-boot-2009.01/cpu/ppc4xx/sdram.c u-boot/cpu/ppc4xx/sdram.c
--- u-boot-2009.01/cpu/ppc4xx/sdram.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/ppc4xx/sdram.c	2009-02-26 14:03:58.000000000 +0100
@@ -259,6 +259,7 @@
 #ifndef CONFIG_SYS_SDRAM_TABLE
 sdram_conf_t mb0cf[] = {
 	{(256 << 20), 13, 0x000C4001},	/* 256MB mode 3, 13x10(4)	*/
+	{(128 << 20), 13, 0x000A4001},	/* 128MB mode 3, 13x10(4)	*/
 	{(64 << 20),  12, 0x00082001}	/* 64MB mode 2, 12x9(4)		*/
 };
 #else
@@ -269,6 +270,18 @@
 #define	CONFIG_SYS_SDRAM0_TR0		0x41094012
 #endif
 
+#ifndef CONFIG_SYS_SDRAM0_WDDCTR
+#define CONFIG_SYS_SDRAM0_WDDCTR	0x00000000  /* wrcp=0 dcd=0	*/
+#endif
+
+#ifndef CONFIG_SYS_SDRAM0_RTR
+#define CONFIG_SYS_SDRAM0_RTR 		0x04100000 /* 7.8us @ 133MHz PLB */
+#endif
+
+#ifndef CONFIG_SYS_SDRAM0_CFG0
+#define CONFIG_SYS_SDRAM0_CFG0		0x82000000 /* DCEN=1, PMUD=0, 64-bit */
+#endif
+
 #define N_MB0CF (sizeof(mb0cf) / sizeof(mb0cf[0]))
 
 #define NUM_TRIES 64
@@ -378,7 +391,7 @@
 		mtsdram(mem_uabba, 0x00000000); /* ubba=0 (default)		*/
 		mtsdram(mem_slio, 0x00000000);	/* rdre=0 wrre=0 rarw=0		*/
 		mtsdram(mem_devopt, 0x00000000); /* dll=0 ds=0 (normal)		*/
-		mtsdram(mem_wddctr, 0x00000000); /* wrcp=0 dcd=0		*/
+		mtsdram(mem_wddctr, CONFIG_SYS_SDRAM0_WDDCTR);
 		mtsdram(mem_clktr, 0x40000000); /* clkp=1 (90 deg wr) dcdt=0	*/
 
 		/*
@@ -387,31 +400,63 @@
 		mtsdram(mem_b0cr, mb0cf[i].reg);
 		mtsdram(mem_tr0, CONFIG_SYS_SDRAM0_TR0);
 		mtsdram(mem_tr1, 0x80800800);	/* SS=T2 SL=STAGE 3 CD=1 CT=0x00*/
-		mtsdram(mem_rtr, 0x04100000);	/* Interval 7.8s @ 133MHz PLB	*/
+		mtsdram(mem_rtr, CONFIG_SYS_SDRAM0_RTR);
 		mtsdram(mem_cfg1, 0x00000000);	/* Self-refresh exit, disable PM*/
 		udelay(400);			/* Delay 200 usecs (min)	*/
 
 		/*
 		 * Enable the controller, then wait for DCEN to complete
 		 */
-		mtsdram(mem_cfg0, 0x82000000);	/* DCEN=1, PMUD=0, 64-bit	*/
+		mtsdram(mem_cfg0, CONFIG_SYS_SDRAM0_CFG0);
 		udelay(10000);
 
 		if (get_ram_size(0, mb0cf[i].size) == mb0cf[i].size) {
+			phys_size_t size = mb0cf[i].size;
 			/*
 			 * Optimize TR1 to current hardware environment
 			 */
 			sdram_tr1_set(0x00000000, &tr1_bank1);
 			mtsdram(mem_tr1, (tr1_bank1 | 0x80800800));
 
+
+			/*
+			 * OK, size detected.  Enable second bank if
+			 * defined (assumes same type as bank 0)
+			 */
+#ifdef CONFIG_SDRAM_BANK1
+			mtsdram(mem_cfg0, 0);
+			mtsdram(mem_b1cr, mb0cf[i].size | mb0cf[i].reg);
+			mtsdram(mem_cfg0, CONFIG_SYS_SDRAM0_CFG0);
+			udelay(10000);
+
+			/*
+			 * Check if 2nd bank is really available.
+			 * If the size not equal to the size of the first
+			 * bank, then disable the 2nd bank completely.
+			 */
+			if (get_ram_size((long *)mb0cf[i].size, mb0cf[i].size)
+			    != mb0cf[i].size) {
+				mtsdram(mem_cfg0, 0);
+				mtsdram(mem_b1cr, 0);
+				mtsdram(mem_cfg0, CONFIG_SYS_SDRAM0_CFG0);
+				udelay(10000);
+			} else {
+				/*
+				 * We have two identical banks, so the size
+				 * is twice the bank size
+				 */
+				size = 2 * size;
+			}
+#endif
+
 #ifdef CONFIG_SDRAM_ECC
-			ecc_init(0, mb0cf[i].size);
+			ecc_init(0, size);
 #endif
 
 			/*
 			 * OK, size detected -> all done
 			 */
-			return mb0cf[i].size;
+			return size;
 		}
 	}
 
diff -Naur u-boot-2009.01/cpu/pxa/interrupts.c u-boot/cpu/pxa/interrupts.c
--- u-boot-2009.01/cpu/pxa/interrupts.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/pxa/interrupts.c	2009-02-26 14:03:58.000000000 +0100
@@ -33,6 +33,14 @@
 #error: interrupts not implemented yet
 #endif
 
+#if defined(CONFIG_PXA27X) || defined(CONFIG_CPU_MONAHANS)
+#define TIMER_FREQ_HZ 3250000
+#elif defined(CONFIG_PXA250)
+#define TIMER_FREQ_HZ 3686400
+#else
+#error "Timer frequency unknown - please config PXA CPU type"
+#endif
+
 int interrupt_init (void)
 {
 	/* nothing happens here - we don't setup any IRQs */
@@ -67,7 +75,10 @@
 
 ulong get_timer_masked (void)
 {
-	return OSCR;
+	unsigned long long ticks = get_ticks();
+
+	return (((ticks / TIMER_FREQ_HZ) * 1000) +
+	        ((ticks % TIMER_FREQ_HZ) * 1000) / TIMER_FREQ_HZ);
 }
 
 void udelay_masked (unsigned long usec)
@@ -78,17 +89,17 @@
 
 	if (usec >= 1000) {
 		tmo = usec / 1000;
-		tmo *= CONFIG_SYS_HZ;
+		tmo *= TIMER_FREQ_HZ;
 		tmo /= 1000;
 	} else {
-		tmo = usec * CONFIG_SYS_HZ;
+		tmo = usec * TIMER_FREQ_HZ;
 		tmo /= (1000*1000);
 	}
 
-	endtime = get_timer_masked () + tmo;
+	endtime = get_ticks() + tmo;
 
 	do {
-		ulong now = get_timer_masked ();
+		ulong now = get_ticks();
 		diff = endtime - now;
 	} while (diff >= 0);
 }
@@ -99,7 +110,7 @@
  */
 unsigned long long get_ticks(void)
 {
-	return get_timer(0);
+	return OSCR;
 }
 
 /*
@@ -109,6 +120,6 @@
 ulong get_tbclk (void)
 {
 	ulong tbclk;
-	tbclk = CONFIG_SYS_HZ;
+	tbclk = TIMER_FREQ_HZ;
 	return tbclk;
 }
diff -Naur u-boot-2009.01/cpu/pxa/Makefile u-boot/cpu/pxa/Makefile
--- u-boot-2009.01/cpu/pxa/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/pxa/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -26,7 +26,7 @@
 LIB	= $(obj)lib$(CPU).a
 
 START	= start.o
-COBJS	= serial.o interrupts.o cpu.o i2c.o pxafb.o mmc.o usb.o
+COBJS	= serial.o interrupts.o cpu.o i2c.o pxafb.o usb.o
 
 SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
diff -Naur u-boot-2009.01/cpu/pxa/mmc.c u-boot/cpu/pxa/mmc.c
--- u-boot-2009.01/cpu/pxa/mmc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/pxa/mmc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,662 +0,0 @@
-/*
- * (C) Copyright 2003
- * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-#include <mmc.h>
-#include <asm/errno.h>
-#include <asm/arch/hardware.h>
-#include <part.h>
-
-#ifdef CONFIG_MMC
-
-extern int fat_register_device(block_dev_desc_t * dev_desc, int part_no);
-
-static block_dev_desc_t mmc_dev;
-
-block_dev_desc_t *mmc_get_dev(int dev)
-{
-	return ((block_dev_desc_t *) & mmc_dev);
-}
-
-/*
- * FIXME needs to read cid and csd info to determine block size
- * and other parameters
- */
-static uchar mmc_buf[MMC_BLOCK_SIZE];
-static uchar spec_ver;
-static int mmc_ready = 0;
-static int wide = 0;
-
-static uint32_t *
-/****************************************************/
-mmc_cmd(ushort cmd, ushort argh, ushort argl, ushort cmdat)
-/****************************************************/
-{
-	static uint32_t resp[4], a, b, c;
-	ulong status;
-	int i;
-
-	debug("mmc_cmd %u 0x%04x 0x%04x 0x%04x\n", cmd, argh, argl,
-	      cmdat | wide);
-	MMC_STRPCL = MMC_STRPCL_STOP_CLK;
-	MMC_I_MASK = ~MMC_I_MASK_CLK_IS_OFF;
-	while (!(MMC_I_REG & MMC_I_REG_CLK_IS_OFF)) ;
-	MMC_CMD = cmd;
-	MMC_ARGH = argh;
-	MMC_ARGL = argl;
-	MMC_CMDAT = cmdat | wide;
-	MMC_I_MASK = ~MMC_I_MASK_END_CMD_RES;
-	MMC_STRPCL = MMC_STRPCL_START_CLK;
-	while (!(MMC_I_REG & MMC_I_REG_END_CMD_RES)) ;
-
-	status = MMC_STAT;
-	debug("MMC status 0x%08x\n", status);
-	if (status & MMC_STAT_TIME_OUT_RESPONSE) {
-		return 0;
-	}
-
-	/* Linux says:
-	 * Did I mention this is Sick.  We always need to
-	 * discard the upper 8 bits of the first 16-bit word.
-	 */
-	a = (MMC_RES & 0xffff);
-	for (i = 0; i < 4; i++) {
-		b = (MMC_RES & 0xffff);
-		c = (MMC_RES & 0xffff);
-		resp[i] = (a << 24) | (b << 8) | (c >> 8);
-		a = c;
-		debug("MMC resp[%d] = %#08x\n", i, resp[i]);
-	}
-
-	return resp;
-}
-
-int
-/****************************************************/
-mmc_block_read(uchar * dst, ulong src, ulong len)
-/****************************************************/
-{
-	ushort argh, argl;
-	ulong status;
-
-	if (len == 0) {
-		return 0;
-	}
-
-	debug("mmc_block_rd dst %lx src %lx len %d\n", (ulong) dst, src, len);
-
-	argh = len >> 16;
-	argl = len & 0xffff;
-
-	/* set block len */
-	mmc_cmd(MMC_CMD_SET_BLOCKLEN, argh, argl, MMC_CMDAT_R1);
-
-	/* send read command */
-	argh = src >> 16;
-	argl = src & 0xffff;
-	MMC_STRPCL = MMC_STRPCL_STOP_CLK;
-	MMC_RDTO = 0xffff;
-	MMC_NOB = 1;
-	MMC_BLKLEN = len;
-	mmc_cmd(MMC_CMD_READ_SINGLE_BLOCK, argh, argl,
-		MMC_CMDAT_R1 | MMC_CMDAT_READ | MMC_CMDAT_BLOCK |
-		MMC_CMDAT_DATA_EN);
-
-	MMC_I_MASK = ~MMC_I_MASK_RXFIFO_RD_REQ;
-	while (len) {
-		if (MMC_I_REG & MMC_I_REG_RXFIFO_RD_REQ) {
-#ifdef CONFIG_PXA27X
-			int i;
-			for (i = min(len, 32); i; i--) {
-				*dst++ = *((volatile uchar *)&MMC_RXFIFO);
-				len--;
-			}
-#else
-			*dst++ = MMC_RXFIFO;
-			len--;
-#endif
-		}
-		status = MMC_STAT;
-		if (status & MMC_STAT_ERRORS) {
-			printf("MMC_STAT error %lx\n", status);
-			return -1;
-		}
-	}
-	MMC_I_MASK = ~MMC_I_MASK_DATA_TRAN_DONE;
-	while (!(MMC_I_REG & MMC_I_REG_DATA_TRAN_DONE)) ;
-	status = MMC_STAT;
-	if (status & MMC_STAT_ERRORS) {
-		printf("MMC_STAT error %lx\n", status);
-		return -1;
-	}
-	return 0;
-}
-
-int
-/****************************************************/
-mmc_block_write(ulong dst, uchar * src, int len)
-/****************************************************/
-{
-	ushort argh, argl;
-	ulong status;
-
-	if (len == 0) {
-		return 0;
-	}
-
-	debug("mmc_block_wr dst %lx src %lx len %d\n", dst, (ulong) src, len);
-
-	argh = len >> 16;
-	argl = len & 0xffff;
-
-	/* set block len */
-	mmc_cmd(MMC_CMD_SET_BLOCKLEN, argh, argl, MMC_CMDAT_R1);
-
-	/* send write command */
-	argh = dst >> 16;
-	argl = dst & 0xffff;
-	MMC_STRPCL = MMC_STRPCL_STOP_CLK;
-	MMC_NOB = 1;
-	MMC_BLKLEN = len;
-	mmc_cmd(MMC_CMD_WRITE_BLOCK, argh, argl,
-		MMC_CMDAT_R1 | MMC_CMDAT_WRITE | MMC_CMDAT_BLOCK |
-		MMC_CMDAT_DATA_EN);
-
-	MMC_I_MASK = ~MMC_I_MASK_TXFIFO_WR_REQ;
-	while (len) {
-		if (MMC_I_REG & MMC_I_REG_TXFIFO_WR_REQ) {
-			int i, bytes = min(32, len);
-
-			for (i = 0; i < bytes; i++) {
-				MMC_TXFIFO = *src++;
-			}
-			if (bytes < 32) {
-				MMC_PRTBUF = MMC_PRTBUF_BUF_PART_FULL;
-			}
-			len -= bytes;
-		}
-		status = MMC_STAT;
-		if (status & MMC_STAT_ERRORS) {
-			printf("MMC_STAT error %lx\n", status);
-			return -1;
-		}
-	}
-	MMC_I_MASK = ~MMC_I_MASK_DATA_TRAN_DONE;
-	while (!(MMC_I_REG & MMC_I_REG_DATA_TRAN_DONE)) ;
-	MMC_I_MASK = ~MMC_I_MASK_PRG_DONE;
-	while (!(MMC_I_REG & MMC_I_REG_PRG_DONE)) ;
-	status = MMC_STAT;
-	if (status & MMC_STAT_ERRORS) {
-		printf("MMC_STAT error %lx\n", status);
-		return -1;
-	}
-	return 0;
-}
-
-int
-/****************************************************/
-mmc_read(ulong src, uchar * dst, int size)
-/****************************************************/
-{
-	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
-	ulong mmc_block_size, mmc_block_address;
-
-	if (size == 0) {
-		return 0;
-	}
-
-	if (!mmc_ready) {
-		printf("Please initial the MMC first\n");
-		return -1;
-	}
-
-	mmc_block_size = MMC_BLOCK_SIZE;
-	mmc_block_address = ~(mmc_block_size - 1);
-
-	src -= CONFIG_SYS_MMC_BASE;
-	end = src + size;
-	part_start = ~mmc_block_address & src;
-	part_end = ~mmc_block_address & end;
-	aligned_start = mmc_block_address & src;
-	aligned_end = mmc_block_address & end;
-
-	/* all block aligned accesses */
-	debug
-	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-	     src, (ulong) dst, end, part_start, part_end, aligned_start,
-	     aligned_end);
-	if (part_start) {
-		part_len = mmc_block_size - part_start;
-		debug
-		    ("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-		     src, (ulong) dst, end, part_start, part_end, aligned_start,
-		     aligned_end);
-		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) <
-		    0) {
-			return -1;
-		}
-		memcpy(dst, mmc_buf + part_start, part_len);
-		dst += part_len;
-		src += part_len;
-	}
-	debug
-	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-	     src, (ulong) dst, end, part_start, part_end, aligned_start,
-	     aligned_end);
-	for (; src < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
-		debug
-		    ("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-		     src, (ulong) dst, end, part_start, part_end, aligned_start,
-		     aligned_end);
-		if ((mmc_block_read((uchar *) (dst), src, mmc_block_size)) < 0) {
-			return -1;
-		}
-	}
-	debug
-	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-	     src, (ulong) dst, end, part_start, part_end, aligned_start,
-	     aligned_end);
-	if (part_end && src < end) {
-		debug
-		    ("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-		     src, (ulong) dst, end, part_start, part_end, aligned_start,
-		     aligned_end);
-		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
-			return -1;
-		}
-		memcpy(dst, mmc_buf, part_end);
-	}
-	return 0;
-}
-
-int
-/****************************************************/
-mmc_write(uchar * src, ulong dst, int size)
-/****************************************************/
-{
-	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
-	ulong mmc_block_size, mmc_block_address;
-
-	if (size == 0) {
-		return 0;
-	}
-
-	if (!mmc_ready) {
-		printf("Please initial the MMC first\n");
-		return -1;
-	}
-
-	mmc_block_size = MMC_BLOCK_SIZE;
-	mmc_block_address = ~(mmc_block_size - 1);
-
-	dst -= CONFIG_SYS_MMC_BASE;
-	end = dst + size;
-	part_start = ~mmc_block_address & dst;
-	part_end = ~mmc_block_address & end;
-	aligned_start = mmc_block_address & dst;
-	aligned_end = mmc_block_address & end;
-
-	/* all block aligned accesses */
-	debug
-	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-	     src, (ulong) dst, end, part_start, part_end, aligned_start,
-	     aligned_end);
-	if (part_start) {
-		part_len = mmc_block_size - part_start;
-		debug
-		    ("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-		     (ulong) src, dst, end, part_start, part_end, aligned_start,
-		     aligned_end);
-		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) <
-		    0) {
-			return -1;
-		}
-		memcpy(mmc_buf + part_start, src, part_len);
-		if ((mmc_block_write(aligned_start, mmc_buf, mmc_block_size)) <
-		    0) {
-			return -1;
-		}
-		dst += part_len;
-		src += part_len;
-	}
-	debug
-	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-	     src, (ulong) dst, end, part_start, part_end, aligned_start,
-	     aligned_end);
-	for (; dst < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
-		debug
-		    ("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-		     src, (ulong) dst, end, part_start, part_end, aligned_start,
-		     aligned_end);
-		if ((mmc_block_write(dst, (uchar *) src, mmc_block_size)) < 0) {
-			return -1;
-		}
-	}
-	debug
-	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-	     src, (ulong) dst, end, part_start, part_end, aligned_start,
-	     aligned_end);
-	if (part_end && dst < end) {
-		debug
-		    ("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
-		     src, (ulong) dst, end, part_start, part_end, aligned_start,
-		     aligned_end);
-		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
-			return -1;
-		}
-		memcpy(mmc_buf, src, part_end);
-		if ((mmc_block_write(aligned_end, mmc_buf, mmc_block_size)) < 0) {
-			return -1;
-		}
-	}
-	return 0;
-}
-
-ulong
-/****************************************************/
-mmc_bread(int dev_num, ulong blknr, lbaint_t blkcnt, void *dst)
-/****************************************************/
-{
-	int mmc_block_size = MMC_BLOCK_SIZE;
-	ulong src = blknr * mmc_block_size + CONFIG_SYS_MMC_BASE;
-
-	mmc_read(src, (uchar *) dst, blkcnt * mmc_block_size);
-	return blkcnt;
-}
-
-#ifdef __GNUC__
-#define likely(x)       __builtin_expect(!!(x), 1)
-#define unlikely(x)     __builtin_expect(!!(x), 0)
-#else
-#define likely(x)	(x)
-#define unlikely(x)	(x)
-#endif
-
-#define UNSTUFF_BITS(resp,start,size)					\
-	({								\
-		const int __size = size;				\
-		const uint32_t __mask = (__size < 32 ? 1 << __size : 0) - 1;	\
-		const int32_t __off = 3 - ((start) / 32);			\
-		const int32_t __shft = (start) & 31;			\
-		uint32_t __res;						\
-									\
-		__res = resp[__off] >> __shft;				\
-		if (__size + __shft > 32)				\
-			__res |= resp[__off-1] << ((32 - __shft) % 32);	\
-		__res & __mask;						\
-	})
-
-/*
- * Given the decoded CSD structure, decode the raw CID to our CID structure.
- */
-static void mmc_decode_cid(uint32_t * resp)
-{
-	if (IF_TYPE_SD == mmc_dev.if_type) {
-		/*
-		 * SD doesn't currently have a version field so we will
-		 * have to assume we can parse this.
-		 */
-		sprintf((char *)mmc_dev.vendor,
-			"Man %02x OEM %c%c \"%c%c%c%c%c\" Date %02u/%04u",
-			UNSTUFF_BITS(resp, 120, 8), UNSTUFF_BITS(resp, 112, 8),
-			UNSTUFF_BITS(resp, 104, 8), UNSTUFF_BITS(resp, 96, 8),
-			UNSTUFF_BITS(resp, 88, 8), UNSTUFF_BITS(resp, 80, 8),
-			UNSTUFF_BITS(resp, 72, 8), UNSTUFF_BITS(resp, 64, 8),
-			UNSTUFF_BITS(resp, 8, 4), UNSTUFF_BITS(resp, 12,
-							       8) + 2000);
-		sprintf((char *)mmc_dev.revision, "%d.%d",
-			UNSTUFF_BITS(resp, 60, 4), UNSTUFF_BITS(resp, 56, 4));
-		sprintf((char *)mmc_dev.product, "%u",
-			UNSTUFF_BITS(resp, 24, 32));
-	} else {
-		/*
-		 * The selection of the format here is based upon published
-		 * specs from sandisk and from what people have reported.
-		 */
-		switch (spec_ver) {
-		case 0:	/* MMC v1.0 - v1.2 */
-		case 1:	/* MMC v1.4 */
-			sprintf((char *)mmc_dev.vendor,
-				"Man %02x%02x%02x \"%c%c%c%c%c%c%c\" Date %02u/%04u",
-				UNSTUFF_BITS(resp, 120, 8), UNSTUFF_BITS(resp,
-									 112,
-									 8),
-				UNSTUFF_BITS(resp, 104, 8), UNSTUFF_BITS(resp,
-									 96, 8),
-				UNSTUFF_BITS(resp, 88, 8), UNSTUFF_BITS(resp,
-									80, 8),
-				UNSTUFF_BITS(resp, 72, 8), UNSTUFF_BITS(resp,
-									64, 8),
-				UNSTUFF_BITS(resp, 56, 8), UNSTUFF_BITS(resp,
-									48, 8),
-				UNSTUFF_BITS(resp, 12, 4), UNSTUFF_BITS(resp, 8,
-									4) +
-				1997);
-			sprintf((char *)mmc_dev.revision, "%d.%d",
-				UNSTUFF_BITS(resp, 44, 4), UNSTUFF_BITS(resp,
-									40, 4));
-			sprintf((char *)mmc_dev.product, "%u",
-				UNSTUFF_BITS(resp, 16, 24));
-			break;
-
-		case 2:	/* MMC v2.0 - v2.2 */
-		case 3:	/* MMC v3.1 - v3.3 */
-		case 4:	/* MMC v4 */
-			sprintf((char *)mmc_dev.vendor,
-				"Man %02x OEM %04x \"%c%c%c%c%c%c\" Date %02u/%04u",
-				UNSTUFF_BITS(resp, 120, 8), UNSTUFF_BITS(resp,
-									 104,
-									 16),
-				UNSTUFF_BITS(resp, 96, 8), UNSTUFF_BITS(resp,
-									88, 8),
-				UNSTUFF_BITS(resp, 80, 8), UNSTUFF_BITS(resp,
-									72, 8),
-				UNSTUFF_BITS(resp, 64, 8), UNSTUFF_BITS(resp,
-									56, 8),
-				UNSTUFF_BITS(resp, 12, 4), UNSTUFF_BITS(resp, 8,
-									4) +
-				1997);
-			sprintf((char *)mmc_dev.product, "%u",
-				UNSTUFF_BITS(resp, 16, 32));
-			sprintf((char *)mmc_dev.revision, "N/A");
-			break;
-
-		default:
-			printf("MMC card has unknown MMCA version %d\n",
-			       spec_ver);
-			break;
-		}
-	}
-	printf("%s card.\nVendor: %s\nProduct: %s\nRevision: %s\n",
-	       (IF_TYPE_SD == mmc_dev.if_type) ? "SD" : "MMC", mmc_dev.vendor,
-	       mmc_dev.product, mmc_dev.revision);
-}
-
-/*
- * Given a 128-bit response, decode to our card CSD structure.
- */
-static void mmc_decode_csd(uint32_t * resp)
-{
-	unsigned int mult, csd_struct;
-
-	if (IF_TYPE_SD == mmc_dev.if_type) {
-		csd_struct = UNSTUFF_BITS(resp, 126, 2);
-		if (csd_struct != 0) {
-			printf("SD: unrecognised CSD structure version %d\n",
-			       csd_struct);
-			return;
-		}
-	} else {
-		/*
-		 * We only understand CSD structure v1.1 and v1.2.
-		 * v1.2 has extra information in bits 15, 11 and 10.
-		 */
-		csd_struct = UNSTUFF_BITS(resp, 126, 2);
-		if (csd_struct != 1 && csd_struct != 2) {
-			printf("MMC: unrecognised CSD structure version %d\n",
-			       csd_struct);
-			return;
-		}
-
-		spec_ver = UNSTUFF_BITS(resp, 122, 4);
-		mmc_dev.if_type = IF_TYPE_MMC;
-	}
-
-	mult = 1 << (UNSTUFF_BITS(resp, 47, 3) + 2);
-	mmc_dev.lba = (1 + UNSTUFF_BITS(resp, 62, 12)) * mult;
-	mmc_dev.blksz = 1 << UNSTUFF_BITS(resp, 80, 4);
-
-	/* FIXME: The following just makes assumes that's the partition type -- should really read it */
-	mmc_dev.part_type = PART_TYPE_DOS;
-	mmc_dev.dev = 0;
-	mmc_dev.lun = 0;
-	mmc_dev.type = DEV_TYPE_HARDDISK;
-	mmc_dev.removable = 0;
-	mmc_dev.block_read = mmc_bread;
-
-	printf("Detected: %lu blocks of %lu bytes (%luMB) ",
-		mmc_dev.lba,
-		mmc_dev.blksz,
-		mmc_dev.lba * mmc_dev.blksz / (1024 * 1024));
-}
-
-int
-/****************************************************/
-mmc_init(int verbose)
-/****************************************************/
-{
-	int retries, rc = -ENODEV;
-	uint32_t cid_resp[4];
-	uint32_t *resp;
-	uint16_t rca = 0;
-
-	/* Reset device interface type */
-	mmc_dev.if_type = IF_TYPE_UNKNOWN;
-
-#if defined (CONFIG_LUBBOCK) || (defined (CONFIG_GUMSTIX) && !defined(CONFIG_PXA27X))
-	set_GPIO_mode(GPIO6_MMCCLK_MD);
-	set_GPIO_mode(GPIO8_MMCCS0_MD);
-#endif
-	CKEN |= CKEN12_MMC;	/* enable MMC unit clock */
-
-	MMC_CLKRT = MMC_CLKRT_0_3125MHZ;
-	MMC_RESTO = MMC_RES_TO_MAX;
-	MMC_SPI = MMC_SPI_DISABLE;
-
-	/* reset */
-	mmc_cmd(MMC_CMD_GO_IDLE_STATE, 0, 0, MMC_CMDAT_INIT | MMC_CMDAT_R0);
-	udelay(200000);
-	retries = 3;
-	while (retries--) {
-		resp = mmc_cmd(MMC_CMD_APP_CMD, 0, 0, MMC_CMDAT_R1);
-		if (!(resp[0] & 0x00000020)) {	/* Card does not support APP_CMD */
-			debug("Card does not support APP_CMD\n");
-			break;
-		}
-
-		/* Select 3.2-3.3V and 3.3-3.4V */
-		resp = mmc_cmd(SD_CMD_APP_SEND_OP_COND, 0x0030, 0x0000,
-				MMC_CMDAT_R3 | (retries < 2 ? 0
-					: MMC_CMDAT_INIT));
-		if (resp[0] & 0x80000000) {
-			mmc_dev.if_type = IF_TYPE_SD;
-			debug("Detected SD card\n");
-			break;
-		}
-#ifdef CONFIG_PXA27X
-		udelay(10000);
-#else
-		udelay(200000);
-#endif
-	}
-
-	if (retries <= 0 || !(IF_TYPE_SD == mmc_dev.if_type)) {
-		debug("Failed to detect SD Card, trying MMC\n");
-		resp =
-		    mmc_cmd(MMC_CMD_SEND_OP_COND, 0x00ff, 0x8000, MMC_CMDAT_R3);
-
-		retries = 10;
-		while (retries-- && resp && !(resp[0] & 0x80000000)) {
-#ifdef CONFIG_PXA27X
-			udelay(10000);
-#else
-			udelay(200000);
-#endif
-			resp =
-			    mmc_cmd(MMC_CMD_SEND_OP_COND, 0x00ff, 0x8000,
-				    MMC_CMDAT_R3);
-		}
-	}
-
-	/* try to get card id */
-	resp =
-	    mmc_cmd(MMC_CMD_ALL_SEND_CID, 0, 0, MMC_CMDAT_R2 | MMC_CMDAT_BUSY);
-	if (resp) {
-		memcpy(cid_resp, resp, sizeof(cid_resp));
-
-		/* MMC exists, get CSD too */
-		resp = mmc_cmd(MMC_CMD_SET_RELATIVE_ADDR, 0, 0, MMC_CMDAT_R1);
-		if (IF_TYPE_SD == mmc_dev.if_type)
-			rca = ((resp[0] & 0xffff0000) >> 16);
-		resp = mmc_cmd(MMC_CMD_SEND_CSD, rca, 0, MMC_CMDAT_R2);
-		if (resp) {
-			mmc_decode_csd(resp);
-			rc = 0;
-			mmc_ready = 1;
-		}
-
-		mmc_decode_cid(cid_resp);
-	}
-
-	MMC_CLKRT = 0;		/* 20 MHz */
-	resp = mmc_cmd(MMC_CMD_SELECT_CARD, rca, 0, MMC_CMDAT_R1);
-
-#ifdef CONFIG_PXA27X
-	if (IF_TYPE_SD == mmc_dev.if_type) {
-		resp = mmc_cmd(MMC_CMD_APP_CMD, rca, 0, MMC_CMDAT_R1);
-		resp = mmc_cmd(SD_CMD_APP_SET_BUS_WIDTH, 0, 2, MMC_CMDAT_R1);
-		wide = MMC_CMDAT_SD_4DAT;
-	}
-#endif
-
-	fat_register_device(&mmc_dev, 1);	/* partitions start counting with 1 */
-
-	return rc;
-}
-
-int mmc_ident(block_dev_desc_t * dev)
-{
-	return 0;
-}
-
-int mmc2info(ulong addr)
-{
-	if (addr >= CONFIG_SYS_MMC_BASE
-	    && addr < CONFIG_SYS_MMC_BASE + (mmc_dev.lba * mmc_dev.blksz)) {
-		return 1;
-	}
-	return 0;
-}
-
-#endif /* CONFIG_MMC */
diff -Naur u-boot-2009.01/cpu/sh4/cpu.c u-boot/cpu/sh4/cpu.c
--- u-boot-2009.01/cpu/sh4/cpu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/cpu/sh4/cpu.c	2009-02-26 14:03:58.000000000 +0100
@@ -82,3 +82,11 @@
 {
 	return 0;
 }
+
+int cpu_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_SH_ETHER
+	sh_eth_initialize(bis);
+#endif
+	return 0;
+}
diff -Naur u-boot-2009.01/disk/Makefile u-boot/disk/Makefile
--- u-boot-2009.01/disk/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/disk/Makefile	2009-02-27 11:21:05.000000000 +0100
@@ -28,11 +28,11 @@
 LIB	= $(obj)libdisk.a
 
 COBJS-y += part.o
-COBJS-y += part_mac.o
-COBJS-y += part_dos.o
-COBJS-y += part_iso.o
-COBJS-y += part_amiga.o
-COBJS-y += part_efi.o
+COBJS-$(CONFIG_MAC_PARTITION)   += part_mac.o
+COBJS-$(CONFIG_DOS_PARTITION)   += part_dos.o
+COBJS-$(CONFIG_ISO_PARTITION)   += part_iso.o
+COBJS-$(CONFIG_AMIGA_PARTITION) += part_amiga.o
+COBJS-$(CONFIG_EFI_PARTITION)   += part_efi.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff -Naur u-boot-2009.01/disk/part_amiga.c u-boot/disk/part_amiga.c
--- u-boot-2009.01/disk/part_amiga.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/disk/part_amiga.c	2009-02-26 14:03:58.000000000 +0100
@@ -26,11 +26,11 @@
 #include <ide.h>
 #include "part_amiga.h"
 
-#if (defined(CONFIG_CMD_IDE) || \
-     defined(CONFIG_CMD_SCSI) || \
-     defined(CONFIG_CMD_USB) || \
-     defined(CONFIG_MMC) || \
-     defined(CONFIG_SYSTEMACE) ) && defined(CONFIG_AMIGA_PARTITION)
+#if defined(CONFIG_CMD_IDE) || \
+    defined(CONFIG_CMD_SCSI) || \
+    defined(CONFIG_CMD_USB) || \
+    defined(CONFIG_MMC) || \
+    defined(CONFIG_SYSTEMACE)
 
 #undef AMIGA_DEBUG
 
diff -Naur u-boot-2009.01/disk/part_dos.c u-boot/disk/part_dos.c
--- u-boot-2009.01/disk/part_dos.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/disk/part_dos.c	2009-02-26 14:03:58.000000000 +0100
@@ -35,12 +35,12 @@
 #include <ide.h>
 #include "part_dos.h"
 
-#if (defined(CONFIG_CMD_IDE) || \
-     defined(CONFIG_CMD_SATA) || \
-     defined(CONFIG_CMD_SCSI) || \
-     defined(CONFIG_CMD_USB) || \
-     defined(CONFIG_MMC) || \
-     defined(CONFIG_SYSTEMACE) ) && defined(CONFIG_DOS_PARTITION)
+#if defined(CONFIG_CMD_IDE) || \
+    defined(CONFIG_CMD_SATA) || \
+    defined(CONFIG_CMD_SCSI) || \
+    defined(CONFIG_CMD_USB) || \
+    defined(CONFIG_MMC) || \
+    defined(CONFIG_SYSTEMACE)
 
 /* Convert char[4] in little endian format to the host format integer
  */
diff -Naur u-boot-2009.01/disk/part_efi.c u-boot/disk/part_efi.c
--- u-boot-2009.01/disk/part_efi.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/disk/part_efi.c	2009-02-26 14:03:58.000000000 +0100
@@ -36,12 +36,12 @@
 #include <malloc.h>
 #include "part_efi.h"
 
-#if (defined(CONFIG_CMD_IDE) || \
-     defined(CONFIG_CMD_SATA) || \
-     defined(CONFIG_CMD_SCSI) || \
-     defined(CONFIG_CMD_USB) || \
-     defined(CONFIG_MMC) || \
-     defined(CONFIG_SYSTEMACE) ) && defined(CONFIG_EFI_PARTITION)
+#if defined(CONFIG_CMD_IDE) || \
+    defined(CONFIG_CMD_SATA) || \
+    defined(CONFIG_CMD_SCSI) || \
+    defined(CONFIG_CMD_USB) || \
+    defined(CONFIG_MMC) || \
+    defined(CONFIG_SYSTEMACE)
 
 /* Convert char[2] in little endian format to the host format integer
  */
@@ -163,7 +163,9 @@
 
 	/* The ulong casting limits the maximum disk size to 2 TB */
 	info->start = (ulong) le64_to_int((*pgpt_pte)[part - 1].starting_lba);
-	info->size = (ulong) le64_to_int((*pgpt_pte)[part - 1].ending_lba) - info->start;
+	/* The ending LBA is inclusive, to calculate size, add 1 to it */
+	info->size = ((ulong)le64_to_int((*pgpt_pte)[part - 1].ending_lba) + 1)
+		     - info->start;
 	info->blksz = GPT_BLOCK_SIZE;
 
 	sprintf((char *)info->name, "%s%d\n", GPT_ENTRY_NAME, part);
diff -Naur u-boot-2009.01/disk/part_iso.c u-boot/disk/part_iso.c
--- u-boot-2009.01/disk/part_iso.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/disk/part_iso.c	2009-02-26 14:03:58.000000000 +0100
@@ -25,12 +25,12 @@
 #include <command.h>
 #include "part_iso.h"
 
-#if (defined(CONFIG_CMD_IDE) || \
-     defined(CONFIG_CMD_SCSI) || \
-     defined(CONFIG_CMD_SATA) || \
-     defined(CONFIG_CMD_USB) || \
-     defined(CONFIG_MMC) || \
-     defined(CONFIG_SYSTEMACE) ) && defined(CONFIG_ISO_PARTITION)
+#if defined(CONFIG_CMD_IDE) || \
+    defined(CONFIG_CMD_SCSI) || \
+    defined(CONFIG_CMD_SATA) || \
+    defined(CONFIG_CMD_USB) || \
+    defined(CONFIG_MMC) || \
+    defined(CONFIG_SYSTEMACE)
 
 /* #define	ISO_PART_DEBUG */
 
diff -Naur u-boot-2009.01/disk/part_mac.c u-boot/disk/part_mac.c
--- u-boot-2009.01/disk/part_mac.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/disk/part_mac.c	2009-02-26 14:03:58.000000000 +0100
@@ -34,12 +34,12 @@
 #include <ide.h>
 #include "part_mac.h"
 
-#if (defined(CONFIG_CMD_IDE) || \
-     defined(CONFIG_CMD_SCSI) || \
-     defined(CONFIG_CMD_SATA) || \
-     defined(CONFIG_CMD_USB) || \
-     defined(CONFIG_MMC) || \
-     defined(CONFIG_SYSTEMACE) ) && defined(CONFIG_MAC_PARTITION)
+#if defined(CONFIG_CMD_IDE) || \
+    defined(CONFIG_CMD_SCSI) || \
+    defined(CONFIG_CMD_SATA) || \
+    defined(CONFIG_CMD_USB) || \
+    defined(CONFIG_MMC) || \
+    defined(CONFIG_SYSTEMACE)
 
 /* stdlib.h causes some compatibility problems; should fixe these! -- wd */
 #ifndef __ldiv_t_defined
diff -Naur u-boot-2009.01/doc/feature-removal-schedule.txt u-boot/doc/feature-removal-schedule.txt
--- u-boot-2009.01/doc/feature-removal-schedule.txt	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/doc/feature-removal-schedule.txt	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,37 @@
+The following is a list of files and features that are going to be
+removed from the U-Boot source tree.  Every entry should contain what
+exactly is going away, when it will be gone, why it is being removed,
+and who is going to be doing the work.  When the feature is removed
+from U-Boot, its corresponding entry should also be removed from this
+file.
+
+---------------------------
+
+What:	"autoscr" command
+When:	August 2009
+Why:	"autosrc" is an ugly and completely non-standard name.  The "autoscr"
+	command is deprecated and will be replaced the "source" command as
+	used by other shells such as bash.  Both commands will be supported
+	for a transition period of 6 months after which "autoscr" will be
+	removed.
+Who:	Peter Tyser <ptyser@xes-inc.com>
+
+---------------------------
+
+What:	Individual I2C commands
+When:	April 2009
+Why:	Per the U-Boot README, individual I2C commands such as "imd", "imm",
+	"imw", etc are deprecated.  The single "i2c" command which is
+	currently enabled via CONFIG_I2C_CMD_TREE contains the same
+	functionality as the individual I2C commands.  The individual
+	I2C commands should be removed as well as any references to
+	CONFIG_I2C_CMD_TREE.
+Who:	Peter Tyser <ptyser@xes-inc.com>
+
+---------------------------
+
+What:	Legacy NAND code
+When:	April 2009
+Why:	Legacy NAND code is deprecated.  Similar functionality exists in
+	more recent NAND code ported from the Linux kernel.
+Who:	Scott Wood <scottwood@freescale.com>
diff -Naur u-boot-2009.01/doc/README.kmeter1 u-boot/doc/README.kmeter1
--- u-boot-2009.01/doc/README.kmeter1	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/doc/README.kmeter1	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,91 @@
+Keymile kmeter1 Board
+-----------------------------------------
+1.	Alternative Boot EEPROM
+
+    Upon the kmeter1 startup the I2C_1 controller is used to fetch the boot
+    configuration from a serial EEPROM. During the development and debugging
+    phase it might be helpful to apply an alternative boot configuration in
+    a simple way. Therefore it is an alternative boot eeprom on the PIGGY,
+    which can be activated by setting the "ST" jumper on the PIGGY board.
+
+2.	Memory Map
+
+    BaseAddr    PortSz  Size  Device
+    ----------- ------  -----  ------
+    0x0000_0000 64 bit  256MB  DDR
+    0x8000_0000  8 bit  256KB  GPIO/PIGGY on CS1
+    0xa000_0000  8 bit  256MB  PAXE on CS3
+    0xe000_0000           2MB  Int Mem Reg Space
+    0xf000_0000 16 bit  256MB  FLASH on CS0
+
+
+    DDR-SDRAM:
+    The current realization is made with four 16-bits memory devices.
+    Mounting options have been foreseen for device architectures from
+    4Mx16 to 512Mx16. The kmeter1 is equipped with four 32Mx16 devices
+    thus resulting in a total capacity of 256MBytes.
+
+3. Compilation
+
+	Assuming you're using BASH shell:
+
+		export CROSS_COMPILE=your-cross-compile-prefix
+		cd u-boot
+		make distclean
+		make kmeter1_config
+		make
+
+4. Downloading and Flashing Images
+
+4.0 Download over serial line using Kermit:
+
+	loadb
+	[Drop to kermit:
+	    ^\c
+	    send <u-boot-bin-image>
+	    c
+	]
+
+
+    Or via tftp:
+
+	tftp 10000 u-boot.bin
+    => run load
+    Using FSL UEC0 device
+    TFTP from server 192.168.1.1; our IP address is 192.168.205.4
+    Filename '/tftpboot/kmeter1/u-boot.bin'.
+    Load address: 0x200000
+    Loading: ##############
+    done
+    Bytes transferred = 204204 (31dac hex)
+    =>
+
+4.1 Reflash U-boot Image using U-boot
+
+    => run update
+    ..... done
+    Un-Protected 5 sectors
+
+    ..... done
+    Erased 5 sectors
+    Copy to Flash... done
+    ..... done
+    Protected 5 sectors
+    Total of 204204 bytes were the same
+    Saving Environment to Flash...
+    . done
+    Un-Protected 1 sectors
+    . done
+    Un-Protected 1 sectors
+    Erasing Flash...
+    . done
+    Erased 1 sectors
+    Writing to Flash... done
+    . done
+    Protected 1 sectors
+    . done
+    Protected 1 sectors
+    =>
+
+5. Notes
+	1) The console baudrate for kmeter1 is 115200bps.
diff -Naur u-boot-2009.01/doc/README.korat u-boot/doc/README.korat
--- u-boot-2009.01/doc/README.korat	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/doc/README.korat	2009-02-26 14:03:58.000000000 +0100
@@ -49,3 +49,16 @@
 leaving preprocessor symbol "CONFIG_KORAT_PERMANENT" undefined.
 
 2008-02-22, Larry Johnson <lrj@acm.org>
+
+
+The CompactFlash(R) controller on the Korat board provides a hi-speed USB
+interface.  This may be connected to either a dedicated port on the on-board
+USB controller, or to a USB port on the PowerPC 440EPx processor.  The U-Boot
+environment variable "korat_usbcf" can be used to specify which of these two
+USB host ports is used for CompactFlash.  The valid setting for the variable are
+the strings "pci" and "ppc".  If the variable defined and set to "ppc", then the
+PowerPC USB port is used.  In all other cases the on-board USB controller is
+used, but if "korat_usbcf" is defined but is set to a string other than the two
+valid options, a warning is also issued.
+
+2009-01-28, Larry Johnson <lrj@acm.org>
diff -Naur u-boot-2009.01/doc/README.mpc8572ds u-boot/doc/README.mpc8572ds
--- u-boot-2009.01/doc/README.mpc8572ds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/doc/README.mpc8572ds	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,166 @@
+Overview
+--------
+MPC8572DS is a high-performance computing, evaluation and development platform
+supporting the mpc8572 PowerTM processor.
+
+Building U-boot
+-----------
+	make MPC8572DS_config
+	make
+
+Flash Banks
+-----------
+MPC8572DS board has two flash banks. They are both present on boot, but their
+locations can be swapped using the dip-switch SW9[1:2].
+
+Booting is always from the boot bank at 0xec00_0000.
+
+
+Memory Map
+----------
+
+0xe800_0000 - 0xebff_ffff	Alernate bank		64MB
+0xec00_0000 - 0xefff_ffff	Boot bank		64MB
+
+0xebf8_0000 - 0xebff_ffff	Alternate u-boot address	512KB
+0xeff8_0000 - 0xefff_ffff	Boot u-boot address		512KB
+
+
+Flashing Images
+---------------
+
+To place a new u-boot image in the alternate flash bank and then reset with that
+ new image temporarily, use this:
+
+	tftp 1000000 u-boot.bin
+	erase ebf80000 ebffffff
+	cp.b 1000000 ebf80000 80000
+	pixis_reset altbank
+
+
+To program the image in the boot flash bank:
+
+	tftp 1000000 u-boot.bin
+	protect off all
+	erase eff80000 ffffffff
+	cp.b 1000000 eff80000 80000
+
+
+The pixis_reset command
+-----------------------
+The command - "pixis_reset", is introduced to reset mpc8572ds board
+using the FPGA sequencer.  When the board restarts, it has the option
+of using either the current or alternate flash bank as the boot
+image, with or without the watchdog timer enabled, and finally with
+or without frequency changes.
+
+Usage is;
+
+	pixis_reset
+	pixis_reset altbank
+	pixis_reset altbank wd
+	pixis_reset altbank cf <SYSCLK freq> <COREPLL ratio> <MPXPLL ratio>
+	pixis_reset cf <SYSCLK freq> <COREPLL ratio> <MPXPLL ratio>
+
+Examples:
+
+	/* reset to current bank, like "reset" command */
+	pixis_reset
+
+	/* reset board but use the to alternate flash bank */
+	pixis_reset altbank
+
+
+Using the Device Tree Source File
+---------------------------------
+To create the DTB (Device Tree Binary) image file,
+use a command similar to this:
+
+	dtc -b 0 -f -I dts -O dtb mpc8572ds.dts > mpc8572ds.dtb
+
+Likely, that .dts file will come from here;
+
+	linux-2.6/arch/powerpc/boot/dts/mpc8572ds.dts
+
+
+Booting Linux
+-------------
+
+Place a linux uImage in the TFTP disk area.
+
+	tftp 1000000 uImage.8572
+	tftp c00000 mpc8572ds.dtb
+	bootm 1000000 - c00000
+
+
+Implementing AMP(Asymmetric MultiProcessing)
+-------------
+1. Build kernel image for core0:
+
+	a. $ make 85xx/mpc8572_ds_defconfig
+
+	b. $ make menuconfig
+	   - un-select "Processor support"->"Symetric multi-processing support"
+
+	c. $ make uImage
+
+	d. $ cp arch/powerpc/boot/uImage /tftpboot/uImage.core0
+
+2. Build kernel image for core1:
+
+	a. $ make 85xx/mpc8572_ds_defconfig
+
+	b. $ make menuconfig
+	   - Un-select "Processor support"->"Symetric multi-processing support"
+	   - Select "Advanced setup" -> " Prompt for advanced kernel
+	     configuration options"
+		- Select "Set physical address where the kernel is loaded" and
+		  set it to 0x20000000, asssuming core1 will start from 512MB.
+		- Select "Set custom page offset address"
+		- Select "Set custom kernel base address"
+		- Select "Set maximum low memory"
+	   - "Exit" and save the selection.
+
+	c. $ make uImage
+
+	d. $ cp arch/powerpc/boot/uImage /tftpboot/uImage.core1
+
+3. Create dtb for core0:
+
+	$ dtc -I dts -O dtb -f -b 0 arch/powerpc/boot/dts/mpc8572ds_core0.dts > /tftpboot/mpc8572ds_core0.dtb
+
+4. Create dtb for core1:
+
+	$ dtc -I dts -O dtb -f -b 1 arch/powerpc/boot/dts/mpc8572ds_core1.dts > /tftpboot/mpc8572ds_core1.dtb
+
+5. Bring up two cores separately:
+
+	a. Power on the board, under u-boot prompt:
+		=> setenv <serverip>
+		=> setenv <ipaddr>
+		=> setenv bootargs root=/dev/ram rw console=ttyS0,115200
+	b. Bring up core1's kernel first:
+		=> setenv bootm_low 0x20000000
+		=> setenv bootm_size 0x10000000
+		=> tftp 21000000 8572/uImage.core1
+		=> tftp 22000000 8572/ramdiskfile
+		=> tftp 20c00000 8572/mpc8572ds_core1.dtb
+		=> interrupts off
+		=> bootm start 21000000 22000000 20c00000
+		=> bootm loados
+		=> bootm ramdisk
+		=> bootm fdt
+		=> fdt boardsetup
+		=> fdt chosen $initrd_start $initrd_end
+		=> bootm prep
+		=> cpu 1 release $bootm_low - $fdtaddr -
+	c. Bring up core0's kernel(on the same u-boot console):
+		=> setenv bootm_low 0
+		=> setenv bootm_size 0x20000000
+		=> tftp 1000000 8572/uImage.core0
+		=> tftp 2000000 8572/ramdiskfile
+		=> tftp c00000 8572/mpc8572ds_core0.dtb
+		=> bootm 1000000 2000000 c00000
+
+Please note only core0 will run u-boot, core1 starts kernel directly after
+"cpu release" command is issued.
diff -Naur u-boot-2009.01/doc/README.nand u-boot/doc/README.nand
--- u-boot-2009.01/doc/README.nand	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/doc/README.nand	2009-02-26 14:03:58.000000000 +0100
@@ -172,7 +172,7 @@
    #define ADDR_COLUMN_PAGE 3
    #define NAND_ChipID_UNKNOWN 0x00
    #define NAND_MAX_FLOORS 1
-   #define NAND_MAX_CHIPS 1
+   #define CONFIG_SYS_NAND_MAX_CHIPS 1
 
    #define CONFIG_SYS_DAVINCI_BROKEN_ECC
       Versions of U-Boot <= 1.3.3 and Montavista Linux kernels
diff -Naur u-boot-2009.01/doc/README.nios_CONFIG_SYS_NIOS_CPU u-boot/doc/README.nios_CONFIG_SYS_NIOS_CPU
--- u-boot-2009.01/doc/README.nios_CONFIG_SYS_NIOS_CPU	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/doc/README.nios_CONFIG_SYS_NIOS_CPU	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,140 @@
+
+===============================================================================
+	C F G _ N I O S _ C P U _ *   v s .   N I O S	S D K
+===============================================================================
+
+When ever you have to make a new NIOS CPU configuration you can use this table
+as a reference list to the original NIOS SDK symbols made by Alteras SOPC
+Builder. Look into excalibur.h and excalibur.s in your SDK path cpu_sdk/inc.
+Symbols beginning with a '[ptf]:' are coming from your SOPC sytem description
+(PTF file) in sections WIZARD_SCRIPT_ARGUMENTS or SYSTEM_BUILDER_INFO.
+
+C O R E					N I O S	  S D K			[1],[7]
+-------------------------------------------------------------------------------
+CONFIG_SYS_NIOS_CPU_CLK					nasys_clock_freq
+CONFIG_SYS_NIOS_CPU_ICACHE					nasys_icache_size
+CONFIG_SYS_NIOS_CPU_DCACHE					nasys_dcache_size
+CONFIG_SYS_NIOS_CPU_REG_NUMS					nasys_nios_num_regs
+CONFIG_SYS_NIOS_CPU_MUL					__nios_use_multiply__
+CONFIG_SYS_NIOS_CPU_MSTEP					__nios_use_mstep__
+CONFIG_SYS_NIOS_CPU_STACK					nasys_stack_top
+CONFIG_SYS_NIOS_CPU_VEC_BASE					nasys_vector_table
+CONFIG_SYS_NIOS_CPU_VEC_SIZE					nasys_vector_table_size
+CONFIG_SYS_NIOS_CPU_VEC_NUMS
+CONFIG_SYS_NIOS_CPU_RST_VECT					nasys_reset_address
+CONFIG_SYS_NIOS_CPU_DBG_CORE					nasys_debug_core
+CONFIG_SYS_NIOS_CPU_RAM_BASE		na_onchip_ram_64_kbytes
+CONFIG_SYS_NIOS_CPU_RAM_SIZE		na_onchip_ram_64_kbytes_size
+CONFIG_SYS_NIOS_CPU_ROM_BASE		na_boot_monitor_rom
+CONFIG_SYS_NIOS_CPU_ROM_SIZE		na_boot_monitor_rom_size
+CONFIG_SYS_NIOS_CPU_OCI_BASE					nasys_oci_core
+CONFIG_SYS_NIOS_CPU_OCI_SIZE
+CONFIG_SYS_NIOS_CPU_SRAM_BASE		na_ext_ram		nasys_program_mem
+							nasys_data_mem
+CONFIG_SYS_NIOS_CPU_SRAM_SIZE		na_ext_ram_size		nasys_program_mem_size
+							nasys_data_mem_size
+CONFIG_SYS_NIOS_CPU_SDRAM_BASE		 na_sdram
+CONFIG_SYS_NIOS_CPU_SDRAM_SIZE		 na_sdram_size
+CONFIG_SYS_NIOS_CPU_FLASH_BASE		 na_ext_flash		nasys_main_flash
+							nasys_am29lv065d_flash_0
+							nasys_flash_0
+CONFIG_SYS_NIOS_CPU_FLASH_SIZE	    na_ext_flash_size		nasys_main_flash_size
+
+T I M E R				N I O S	  S D K			    [3]
+-------------------------------------------------------------------------------
+CONFIG_SYS_NIOS_CPU_TIMER_NUMS					nasys_timer_count
+CONFIG_SYS_NIOS_CPU_TIMER[0-9]					nasys_timer_[0-9]
+CONFIG_SYS_NIOS_CPU_TIMER[0-9]_IRQ				nasys_timer_[0-9]_irq
+CONFIG_SYS_NIOS_CPU_TIMER[0-9]_PER				[ptf]:period
+							[ptf]:period_units
+							[ptf]:mult
+CONFIG_SYS_NIOS_CPU_TIMER[0-9]_AR				[ptf]:always_run
+CONFIG_SYS_NIOS_CPU_TIMER[0-9]_FP				[ptf]:fixed_period
+CONFIG_SYS_NIOS_CPU_TIMER[0-9]_SS				[ptf]:snapshot
+
+U A R T					N I O S	  S D K			    [2]
+-------------------------------------------------------------------------------
+CONFIG_SYS_NIOS_CPU_UART_NUMS					nasys_uart_count
+CONFIG_SYS_NIOS_CPU_UART[0-9]					nasys_uart_[0-9]
+CONFIG_SYS_NIOS_CPU_UART[0-9]_IRQ				nasys_uart_[0-9]_irq
+CONFIG_SYS_NIOS_CPU_UART[0-9]_BR				[ptf]:baud
+CONFIG_SYS_NIOS_CPU_UART[0-9]_DB				[ptf]:data_bits
+CONFIG_SYS_NIOS_CPU_UART[0-9]_SB				[ptf]:stop_bits
+CONFIG_SYS_NIOS_CPU_UART[0-9]_PA				[ptf]:parity
+CONFIG_SYS_NIOS_CPU_UART[0-9]_HS				[ptf]:use_cts_rts
+CONFIG_SYS_NIOS_CPU_UART[0-9]_EOP				[ptf]:use_eop_register
+
+P I O					N I O S	  S D K			    [4]
+-------------------------------------------------------------------------------
+CONFIG_SYS_NIOS_CPU_PIO_NUMS					nasys_pio_count
+CONFIG_SYS_NIOS_CPU_PIO[0-9]					nasys_pio_[0-9]
+CONFIG_SYS_NIOS_CPU_PIO[0-9]_IRQ				nasys_pio_[0-9]_irq
+CONFIG_SYS_NIOS_CPU_PIO[0-9]_BITS				[ptf]:Data_Width
+CONFIG_SYS_NIOS_CPU_PIO[0-9]_TYPE				[ptf]:has_tri
+							[ptf]:has_out
+							[ptf]:has_in
+CONFIG_SYS_NIOS_CPU_PIO[0-9]_CAP				[ptf]:capture
+CONFIG_SYS_NIOS_CPU_PIO[0-9]_EDGE				[ptf]:edge_type
+CONFIG_SYS_NIOS_CPU_PIO[0-9]_ITYPE				[ptf]:irq_type
+
+S P I					N I O S	  S D K			    [6]
+-------------------------------------------------------------------------------
+CONFIG_SYS_NIOS_CPU_SPI_NUMS					nasys_spi_count
+CONFIG_SYS_NIOS_CPU_SPI[0-9]					nasys_spi_[0-9]
+CONFIG_SYS_NIOS_CPU_SPI[0-9]_IRQ				nasys_spi_[0-9]_irq
+CONFIG_SYS_NIOS_CPU_SPI[0-9]_BITS				[ptf]:databits
+CONFIG_SYS_NIOS_CPU_SPI[0-9]_MA				[ptf]:ismaster
+CONFIG_SYS_NIOS_CPU_SPI[0-9]_SLN				[ptf]:numslaves
+CONFIG_SYS_NIOS_CPU_SPI[0-9]_TCLK				[ptf]:targetclock
+CONFIG_SYS_NIOS_CPU_SPI[0-9]_TDELAY				[ptf]:targetdelay
+CONFIG_SYS_NIOS_CPU_SPI[0-9]_*					[ptf]:*
+
+I D E					N I O S	  S D K
+-------------------------------------------------------------------------------
+CONFIG_SYS_NIOS_CPU_IDE_NUMS					nasys_usersocket_count
+CONFIG_SYS_NIOS_CPU_IDE[0-9]					nasys_usersocket_[0-9]
+
+A S M I					N I O S	  S D K			    [5]
+-------------------------------------------------------------------------------
+CONFIG_SYS_NIOS_CPU_ASMI_NUMS					nasys_asmi_count
+CONFIG_SYS_NIOS_CPU_ASMI[0-9]					nasys_asmi_[0-9]
+CONFIG_SYS_NIOS_CPU_ASMI[0-9]_IRQ				nasys_asmi_[0-9]_irq
+
+E t h e r n e t	  ( L A N )		N I O S	  S D K
+-------------------------------------------------------------------------------
+CONFIG_SYS_NIOS_CPU_LAN_NUMS
+CONFIG_SYS_NIOS_CPU_LAN[0-9]_BASE	na_lan91c111
+CONFIG_SYS_NIOS_CPU_LAN[0-9]_OFFS				LAN91C111_REGISTERS_OFFSET
+CONFIG_SYS_NIOS_CPU_LAN[0-9]_IRQ	na_lan91c111_irq
+CONFIG_SYS_NIOS_CPU_LAN[0-9]_BUSW				LAN91C111_DATA_BUS_WIDTH
+CONFIG_SYS_NIOS_CPU_LAN[0-9]_TYPE
+
+s y s t e m   c o m p o s i n g		N I O S	  S D K
+-------------------------------------------------------------------------------
+CONFIG_SYS_NIOS_CPU_TICK_TIMER		(na_low_priority_timer2)
+CONFIG_SYS_NIOS_CPU_USER_TIMER		(na_timer1)
+CONFIG_SYS_NIOS_CPU_BUTTON_PIO		(na_button_pio)
+CONFIG_SYS_NIOS_CPU_LCD_PIO		(na_lcd_pio)
+CONFIG_SYS_NIOS_CPU_LED_PIO		(na_led_pio)
+CONFIG_SYS_NIOS_CPU_SEVENSEG_PIO	(na_seven_seg_pio)
+CONFIG_SYS_NIOS_CPU_RECONF_PIO		(na_reconfig_request_pio)
+CONFIG_SYS_NIOS_CPU_CFPRESENT_PIO	(na_cf_present_pio)
+CONFIG_SYS_NIOS_CPU_CFPOWER_PIO	(na_cf_power_pio)
+CONFIG_SYS_NIOS_CPU_CFATASEL_PIO	(na_cf_ata_select_pio)
+CONFIG_SYS_NIOS_CPU_USER_SPI		(na_spi)
+
+
+===============================================================================
+	R E F E R E N C E S
+===============================================================================
+[1]	http://www.altera.com/literature/ds/ds_nioscpu.pdf
+[2]	http://www.altera.com/literature/ds/ds_nios_uart.pdf
+[3]	http://www.altera.com/literature/ds/ds_nios_timer.pdf
+[4]	http://www.altera.com/literature/ds/ds_nios_pio.pdf
+[5]	http://www.altera.com/literature/ds/ds_nios_asmi.pdf
+[6]	http://www.altera.com/literature/ds/ds_nios_spi.pdf
+[7]	http://www.altera.com/literature/ds/ds_legacy_sdram_ctrl.pdf
+
+
+===============================================================================
+Stephan Linz <linz@li-pro.net>
diff -Naur u-boot-2009.01/doc/README.nmdk8815 u-boot/doc/README.nmdk8815
--- u-boot-2009.01/doc/README.nmdk8815	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/doc/README.nmdk8815	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,22 @@
+
+The Nomadik 8815 CPU has a "secure" boot mode where no external access
+(not even JTAG) is allowed.  The "remap" bits in the evaluation board
+are configured in order to boot from the internal ROM memory (in
+secure mode).
+
+The boot process as defined by the manufacturer executes external code
+(loaded from NAND or OneNAND) that that disables such "security" in
+order to run u-boot and later the kernel without constraints. Such
+code is a proprietary initial boot loader, called "X-Loader" (in case
+anyone wonders, it has no relations with other loaders with the same
+name and there is no GPL code inside the ST X-Loader).
+
+SDRAM configuration, PLL setup and initial loading from NAND is
+implemented in the X-Loader, so U-Boot is already running in SDRAM
+when control is handed over to it.
+
+
+On www.st.com/nomadik and on www.stnwireless.com there are documents,
+summary data and white papers on Nomadik. The full datasheet for
+STn8815 is not currently available on line but under specific request
+to the local ST sales offices.
diff -Naur u-boot-2009.01/doc/README.omap3 u-boot/doc/README.omap3
--- u-boot-2009.01/doc/README.omap3	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/doc/README.omap3	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,116 @@
+
+Summary
+=======
+
+This README is about U-Boot support for TI's ARM Cortex-A8 based OMAP3 [1]
+family of SoCs. TI's OMAP3 SoC family contains an ARM Cortex-A8. Additionally,
+some family members contain a TMS320C64x+ DSP and/or an Imagination SGX 2D/3D
+graphics processor and various other standard peripherals.
+
+Currently the following boards are supported:
+
+* OMAP3530 BeagleBoard [2]
+
+* Gumstix Overo [3]
+
+* TI EVM [4]
+
+* OpenPandora Ltd. Pandora [5]
+
+* TI/Logic PD Zoom MDK [6]
+
+Toolchain
+=========
+
+While ARM Cortex-A8 support ARM v7 instruction set (-march=armv7a) we compile
+with -march=armv5 to allow more compilers to work. For U-Boot code this has
+no performance impact.
+
+Build
+=====
+
+* BeagleBoard:
+
+make omap3_beagle_config
+make
+
+* Gumstix Overo:
+
+make omap3_overo_config
+make
+
+* TI EVM:
+
+make omap3_evm_config
+make
+
+* Pandora:
+
+make omap3_pandora_config
+make
+
+* Zoom MDK:
+
+make omap3_zoom1_config
+make
+
+Custom commands
+===============
+
+To make U-Boot for OMAP3 support NAND device SW or HW ECC calculation, U-Boot
+for OMAP3 supports custom user command
+
+nandecc hw/sw
+
+To be compatible with NAND drivers using SW ECC (e.g. kernel code)
+
+nandecc sw
+
+enables SW ECC calculation. HW ECC enabled with
+
+nandecc hw
+
+is typically used to write 2nd stage bootloader (known as 'x-loader') which is
+executed by OMAP3's boot rom and therefore has to be written with HW ECC.
+
+For all other commands see
+
+help
+
+Acknowledgements
+================
+
+OMAP3 U-Boot is based on U-Boot tar ball [7] for BeagleBoard and EVM done by
+several TI employees.
+
+Links
+=====
+
+[1] OMAP3:
+
+http://www.ti.com/omap3 (high volume) and
+http://www.ti.com/omap35x (broad market)
+
+[2] OMAP3530 BeagleBoard:
+
+http://beagleboard.org/
+
+[3] Gumstix Overo:
+
+http://www.gumstix.net/Overo/
+
+[4] TI EVM:
+
+http://focus.ti.com/docs/toolsw/folders/print/tmdxevm3503.html
+
+[5] OpenPandora Ltd. Pandora:
+
+http://openpandora.org/
+
+[6] TI/Logic PD Zoom MDK:
+
+http://www.logicpd.com/products/devkit/ti/zoom_mobile_development_kit
+
+[7] TI OMAP3 U-Boot:
+
+http://beagleboard.googlecode.com/files/u-boot_beagle_revb.tar.gz
diff -Naur u-boot-2009.01/doc/README.simpc8313 u-boot/doc/README.simpc8313
--- u-boot-2009.01/doc/README.simpc8313	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/doc/README.simpc8313	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,80 @@
+Sheldon Instruments SIMPC8313 Board
+-----------------------------------------
+
+1.	Board Switches and Jumpers
+
+	S2 is used to set CFG_RESET_SOURCE.
+
+	To boot the image in Large page NAND flash, use these DIP
+	switch settings for S2:
+
+	+----------+ ON
+	| * * **** |
+	|  * *     |
+	+----------+
+	  12345678
+
+	To boot the image in Small page NAND flash, use these DIP
+	switch settings for S2:
+
+	+----------+ ON
+	| *** **** |
+	|    *     |
+	+----------+
+	  12345678
+	(where the '*' indicates the position of the tab of the switch.)
+
+2.	Memory Map
+	The memory map looks like this:
+
+	0x0000_0000	0x1fff_ffff	DDR			512M
+	0x8000_0000	0x8fff_ffff	PCI MEM			256M
+	0x9000_0000	0x9fff_ffff	PCI_MMIO		256M
+	0xe000_0000	0xe00f_ffff	IMMR			1M
+	0xe200_0000	0xe20f_ffff	PCI IO			16M
+	0xe280_0000	0xe280_7fff	NAND FLASH (CS0)	32K
+	or
+	0xe280_0000	0xe281_ffff	NAND FLASH (CS0)	128K
+	0xff00_0000	0xff00_7fff	FPGA (CS1)		1M
+
+3.	Compilation
+
+	Assuming you're using BASH (or similar) as your shell:
+
+	export CROSS_COMPILE=your-cross-compiler-prefix-
+	make distclean
+	make SIMPC8313_LP_config
+	(or make SIMPC8313_SP_config, depending on the page size
+	of your NAND flash)
+	make
+
+4.	Downloading and Flashing Images
+
+4.1	Reflash U-boot Image using U-boot
+
+	=>run update_uboot
+
+	You may want to try
+	=>tftp $loadaddr $uboot
+	first, to make sure that the TFTP load will succeed before it
+	goes ahead and wipes out your current firmware.  And of course,
+	if the new u-boot doesn't boot, you can plug the board into
+	your PCI slot and with the supplied driver and sample app
+	you can reburn a working u-boot.
+
+4.2	Downloading and Booting Linux Kernel
+
+	Ensure that all networking-related environment variables are set
+	properly (including ipaddr, serverip, gatewayip (if needed),
+	netmask, ethaddr, eth1addr, fdtfile, and bootfile).
+
+	=>tftp $loadaddr uImage
+	=>nand write $loadaddr kernel $filesize
+	=>tftp $loadaddr $fdtfile
+	=>nand write $loadaddr 7e0000 1800
+
+	=>boot
+
+5	Notes
+
+	The console baudrate for SIMPC8313 is 115200bps.
diff -Naur u-boot-2009.01/drivers/block/ahci.c u-boot/drivers/block/ahci.c
--- u-boot-2009.01/drivers/block/ahci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/block/ahci.c	2009-02-26 14:03:58.000000000 +0100
@@ -251,7 +251,6 @@
 
 static int ahci_init_one(pci_dev_t pdev)
 {
-	u32 iobase;
 	u16 vendor;
 	int rc;
 
@@ -261,9 +260,6 @@
 	memset(probe_ent, 0, sizeof(struct ahci_probe_ent));
 	probe_ent->dev = pdev;
 
-	pci_read_config_dword(pdev, AHCI_PCI_BAR, &iobase);
-	iobase &= ~0xf;
-
 	probe_ent->host_flags = ATA_FLAG_SATA
 				| ATA_FLAG_NO_LEGACY
 				| ATA_FLAG_MMIO
@@ -272,7 +268,8 @@
 	probe_ent->pio_mask = 0x1f;
 	probe_ent->udma_mask = 0x7f;	/*Fixme,assume to support UDMA6 */
 
-	probe_ent->mmio_base = iobase;
+	probe_ent->mmio_base = (u32)pci_map_bar(pdev, AHCI_PCI_BAR,
+						PCI_REGION_MEM);
 
 	/* Take from kernel:
 	 * JMicron-specific fixup:
diff -Naur u-boot-2009.01/drivers/block/Makefile u-boot/drivers/block/Makefile
--- u-boot-2009.01/drivers/block/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/block/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -29,6 +29,7 @@
 COBJS-$(CONFIG_ATA_PIIX) += ata_piix.o
 COBJS-$(CONFIG_FSL_SATA) += fsl_sata.o
 COBJS-$(CONFIG_LIBATA) += libata.o
+COBJS-$(CONFIG_PATA_BFIN) += pata_bfin.o
 COBJS-$(CONFIG_SATA_SIL3114) += sata_sil3114.o
 COBJS-$(CONFIG_IDE_SIL680) += sil680.o
 COBJS-$(CONFIG_SCSI_SYM53C8XX) += sym53c8xx.o
diff -Naur u-boot-2009.01/drivers/block/pata_bfin.c u-boot/drivers/block/pata_bfin.c
--- u-boot-2009.01/drivers/block/pata_bfin.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/block/pata_bfin.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,1201 @@
+/*
+ * Driver for Blackfin on-chip ATAPI controller.
+ *
+ * Enter bugs at http://blackfin.uclinux.org/
+ *
+ * Copyright (c) 2008 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <config.h>
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <asm/mach-common/bits/pata.h>
+#include <ata.h>
+#include <libata.h>
+#include "pata_bfin.h"
+
+static struct ata_port port[CONFIG_SYS_SATA_MAX_DEVICE];
+
+/**
+ * PIO Mode - Frequency compatibility
+ */
+/* mode: 0         1         2         3         4 */
+static const u32 pio_fsclk[] =
+{ 33333333, 33333333, 33333333, 33333333, 33333333 };
+
+/**
+ * MDMA Mode - Frequency compatibility
+ */
+/*               mode:      0         1         2        */
+static const u32 mdma_fsclk[] = { 33333333, 33333333, 33333333 };
+
+/**
+ * UDMA Mode - Frequency compatibility
+ *
+ * UDMA5 - 100 MB/s   - SCLK  = 133 MHz
+ * UDMA4 - 66 MB/s    - SCLK >=  80 MHz
+ * UDMA3 - 44.4 MB/s  - SCLK >=  50 MHz
+ * UDMA2 - 33 MB/s    - SCLK >=  40 MHz
+ */
+/* mode: 0         1         2         3         4          5 */
+static const u32 udma_fsclk[] =
+{ 33333333, 33333333, 40000000, 50000000, 80000000, 133333333 };
+
+/**
+ * Register transfer timing table
+ */
+/*               mode:       0    1    2    3    4    */
+/* Cycle Time                     */
+static const u32 reg_t0min[]   = { 600, 383, 330, 180, 120 };
+/* DIOR/DIOW to end cycle         */
+static const u32 reg_t2min[]   = { 290, 290, 290, 70,  25  };
+/* DIOR/DIOW asserted pulse width */
+static const u32 reg_teocmin[] = { 290, 290, 290, 80,  70  };
+
+/**
+ * PIO timing table
+ */
+/*               mode:       0    1    2    3    4    */
+/* Cycle Time                     */
+static const u32 pio_t0min[]   = { 600, 383, 240, 180, 120 };
+/* Address valid to DIOR/DIORW    */
+static const u32 pio_t1min[]   = { 70,  50,  30,  30,  25  };
+/* DIOR/DIOW to end cycle         */
+static const u32 pio_t2min[]   = { 165, 125, 100, 80,  70  };
+/* DIOR/DIOW asserted pulse width */
+static const u32 pio_teocmin[] = { 165, 125, 100, 70,  25  };
+/* DIOW data hold                 */
+static const u32 pio_t4min[]   = { 30,  20,  15,  10,  10  };
+
+/* ******************************************************************
+ * Multiword DMA timing table
+ * ******************************************************************
+ */
+/*               mode:       0   1    2        */
+/* Cycle Time                     */
+static const u32 mdma_t0min[]  = { 480, 150, 120 };
+/* DIOR/DIOW asserted pulse width */
+static const u32 mdma_tdmin[]  = { 215, 80,  70  };
+/* DMACK to read data released    */
+static const u32 mdma_thmin[]  = { 20,  15,  10  };
+/* DIOR/DIOW to DMACK hold        */
+static const u32 mdma_tjmin[]  = { 20,  5,   5   };
+/* DIOR negated pulse width       */
+static const u32 mdma_tkrmin[] = { 50,  50,  25  };
+/* DIOR negated pulse width       */
+static const u32 mdma_tkwmin[] = { 215, 50,  25  };
+/* CS[1:0] valid to DIOR/DIOW     */
+static const u32 mdma_tmmin[]  = { 50,  30,  25  };
+/* DMACK to read data released    */
+static const u32 mdma_tzmax[]  = { 20,  25,  25  };
+
+/**
+ * Ultra DMA timing table
+ */
+/*               mode:         0    1    2    3    4    5       */
+static const u32 udma_tcycmin[]  = { 112, 73,  54,  39,  25,  17 };
+static const u32 udma_tdvsmin[]  = { 70,  48,  31,  20,  7,   5  };
+static const u32 udma_tenvmax[]  = { 70,  70,  70,  55,  55,  50 };
+static const u32 udma_trpmin[]   = { 160, 125, 100, 100, 100, 85 };
+static const u32 udma_tmin[]     = { 5,   5,   5,   5,   3,   3  };
+
+
+static const u32 udma_tmlimin = 20;
+static const u32 udma_tzahmin = 20;
+static const u32 udma_tenvmin = 20;
+static const u32 udma_tackmin = 20;
+static const u32 udma_tssmin = 50;
+
+static void msleep(int count)
+{
+	int i;
+
+	for (i = 0; i < count; i++)
+		udelay(1000);
+}
+
+/**
+ *
+ *	Function:       num_clocks_min
+ *
+ *	Description:
+ *	calculate number of SCLK cycles to meet minimum timing
+ */
+static unsigned short num_clocks_min(unsigned long tmin,
+				unsigned long fsclk)
+{
+	unsigned long tmp ;
+	unsigned short result;
+
+	tmp = tmin * (fsclk/1000/1000) / 1000;
+	result = (unsigned short)tmp;
+	if ((tmp*1000*1000) < (tmin*(fsclk/1000)))
+		result++;
+
+	return result;
+}
+
+/**
+ *	bfin_set_piomode - Initialize host controller PATA PIO timings
+ *	@ap: Port whose timings we are configuring
+ *	@pio_mode: mode
+ *
+ *	Set PIO mode for device.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+
+static void bfin_set_piomode(struct ata_port *ap, int pio_mode)
+{
+	int mode = pio_mode - XFER_PIO_0;
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+	unsigned int fsclk = get_sclk();
+	unsigned short teoc_reg, t2_reg, teoc_pio;
+	unsigned short t4_reg, t2_pio, t1_reg;
+	unsigned short n0, n6, t6min = 5;
+
+	/* the most restrictive timing value is t6 and tc, the DIOW - data hold
+	* If one SCLK pulse is longer than this minimum value then register
+	* transfers cannot be supported at this frequency.
+	*/
+	n6 = num_clocks_min(t6min, fsclk);
+	if (mode >= 0 && mode <= 4 && n6 >= 1) {
+		debug("set piomode: mode=%d, fsclk=%ud\n", mode, fsclk);
+		/* calculate the timing values for register transfers. */
+		while (mode > 0 && pio_fsclk[mode] > fsclk)
+			mode--;
+
+		/* DIOR/DIOW to end cycle time */
+		t2_reg = num_clocks_min(reg_t2min[mode], fsclk);
+		/* DIOR/DIOW asserted pulse width */
+		teoc_reg = num_clocks_min(reg_teocmin[mode], fsclk);
+		/* Cycle Time */
+		n0  = num_clocks_min(reg_t0min[mode], fsclk);
+
+		/* increase t2 until we meed the minimum cycle length */
+		if (t2_reg + teoc_reg < n0)
+			t2_reg = n0 - teoc_reg;
+
+		/* calculate the timing values for pio transfers. */
+
+		/* DIOR/DIOW to end cycle time */
+		t2_pio = num_clocks_min(pio_t2min[mode], fsclk);
+		/* DIOR/DIOW asserted pulse width */
+		teoc_pio = num_clocks_min(pio_teocmin[mode], fsclk);
+		/* Cycle Time */
+		n0  = num_clocks_min(pio_t0min[mode], fsclk);
+
+		/* increase t2 until we meed the minimum cycle length */
+		if (t2_pio + teoc_pio < n0)
+			t2_pio = n0 - teoc_pio;
+
+		/* Address valid to DIOR/DIORW */
+		t1_reg = num_clocks_min(pio_t1min[mode], fsclk);
+
+		/* DIOW data hold */
+		t4_reg = num_clocks_min(pio_t4min[mode], fsclk);
+
+		ATAPI_SET_REG_TIM_0(base, (teoc_reg<<8 | t2_reg));
+		ATAPI_SET_PIO_TIM_0(base, (t4_reg<<12 | t2_pio<<4 | t1_reg));
+		ATAPI_SET_PIO_TIM_1(base, teoc_pio);
+		if (mode > 2) {
+			ATAPI_SET_CONTROL(base,
+				ATAPI_GET_CONTROL(base) | IORDY_EN);
+		} else {
+			ATAPI_SET_CONTROL(base,
+				ATAPI_GET_CONTROL(base) & ~IORDY_EN);
+		}
+
+		/* Disable host ATAPI PIO interrupts */
+		ATAPI_SET_INT_MASK(base, ATAPI_GET_INT_MASK(base)
+			& ~(PIO_DONE_MASK | HOST_TERM_XFER_MASK));
+		SSYNC();
+	}
+}
+
+/**
+ *
+ *    Function:       wait_complete
+ *
+ *    Description:    Waits the interrupt from device
+ *
+ */
+static inline void wait_complete(void __iomem *base, unsigned short mask)
+{
+	unsigned short status;
+	unsigned int i = 0;
+
+	for (i = 0; i < PATA_BFIN_WAIT_TIMEOUT; i++) {
+		status = ATAPI_GET_INT_STATUS(base) & mask;
+		if (status)
+			break;
+	}
+
+	ATAPI_SET_INT_STATUS(base, mask);
+}
+
+/**
+ *
+ *    Function:       write_atapi_register
+ *
+ *    Description:    Writes to ATA Device Resgister
+ *
+ */
+
+static void write_atapi_register(void __iomem *base,
+		unsigned long ata_reg, unsigned short value)
+{
+	/* Program the ATA_DEV_TXBUF register with write data (to be
+	 * written into the device).
+	 */
+	ATAPI_SET_DEV_TXBUF(base, value);
+
+	/* Program the ATA_DEV_ADDR register with address of the
+	 * device register (0x01 to 0x0F).
+	 */
+	ATAPI_SET_DEV_ADDR(base, ata_reg);
+
+	/* Program the ATA_CTRL register with dir set to write (1)
+	 */
+	ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) | XFER_DIR));
+
+	/* ensure PIO DMA is not set */
+	ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) & ~PIO_USE_DMA));
+
+	/* and start the transfer */
+	ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) | PIO_START));
+
+	/* Wait for the interrupt to indicate the end of the transfer.
+	 * (We need to wait on and clear rhe ATA_DEV_INT interrupt status)
+	 */
+	wait_complete(base, PIO_DONE_INT);
+}
+
+/**
+ *
+ *	Function:       read_atapi_register
+ *
+ *Description:    Reads from ATA Device Resgister
+ *
+ */
+
+static unsigned short read_atapi_register(void __iomem *base,
+		unsigned long ata_reg)
+{
+	/* Program the ATA_DEV_ADDR register with address of the
+	 * device register (0x01 to 0x0F).
+	 */
+	ATAPI_SET_DEV_ADDR(base, ata_reg);
+
+	/* Program the ATA_CTRL register with dir set to read (0) and
+	 */
+	ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) & ~XFER_DIR));
+
+	/* ensure PIO DMA is not set */
+	ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) & ~PIO_USE_DMA));
+
+	/* and start the transfer */
+	ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) | PIO_START));
+
+	/* Wait for the interrupt to indicate the end of the transfer.
+	 * (PIO_DONE interrupt is set and it doesn't seem to matter
+	 * that we don't clear it)
+	 */
+	wait_complete(base, PIO_DONE_INT);
+
+	/* Read the ATA_DEV_RXBUF register with write data (to be
+	 * written into the device).
+	 */
+	return ATAPI_GET_DEV_RXBUF(base);
+}
+
+/**
+ *
+ *    Function:       write_atapi_register_data
+ *
+ *    Description:    Writes to ATA Device Resgister
+ *
+ */
+
+static void write_atapi_data(void __iomem *base,
+		int len, unsigned short *buf)
+{
+	int i;
+
+	/* Set transfer length to 1 */
+	ATAPI_SET_XFER_LEN(base, 1);
+
+	/* Program the ATA_DEV_ADDR register with address of the
+	 * ATA_REG_DATA
+	 */
+	ATAPI_SET_DEV_ADDR(base, ATA_REG_DATA);
+
+	/* Program the ATA_CTRL register with dir set to write (1)
+	 */
+	ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) | XFER_DIR));
+
+	/* ensure PIO DMA is not set */
+	ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) & ~PIO_USE_DMA));
+
+	for (i = 0; i < len; i++) {
+		/* Program the ATA_DEV_TXBUF register with write data (to be
+		 * written into the device).
+		 */
+		ATAPI_SET_DEV_TXBUF(base, buf[i]);
+
+		/* and start the transfer */
+		ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) | PIO_START));
+
+		/* Wait for the interrupt to indicate the end of the transfer.
+		 * (We need to wait on and clear rhe ATA_DEV_INT
+		 * interrupt status)
+		 */
+		wait_complete(base, PIO_DONE_INT);
+	}
+}
+
+/**
+ *
+ *	Function:       read_atapi_register_data
+ *
+ *	Description:    Reads from ATA Device Resgister
+ *
+ */
+
+static void read_atapi_data(void __iomem *base,
+		int len, unsigned short *buf)
+{
+	int i;
+
+	/* Set transfer length to 1 */
+	ATAPI_SET_XFER_LEN(base, 1);
+
+	/* Program the ATA_DEV_ADDR register with address of the
+	 * ATA_REG_DATA
+	 */
+	ATAPI_SET_DEV_ADDR(base, ATA_REG_DATA);
+
+	/* Program the ATA_CTRL register with dir set to read (0) and
+	 */
+	ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) & ~XFER_DIR));
+
+	/* ensure PIO DMA is not set */
+	ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) & ~PIO_USE_DMA));
+
+	for (i = 0; i < len; i++) {
+		/* and start the transfer */
+		ATAPI_SET_CONTROL(base, (ATAPI_GET_CONTROL(base) | PIO_START));
+
+		/* Wait for the interrupt to indicate the end of the transfer.
+		 * (PIO_DONE interrupt is set and it doesn't seem to matter
+		 * that we don't clear it)
+		 */
+		wait_complete(base, PIO_DONE_INT);
+
+		/* Read the ATA_DEV_RXBUF register with write data (to be
+		 * written into the device).
+		 */
+		buf[i] = ATAPI_GET_DEV_RXBUF(base);
+	}
+}
+
+/**
+ *	bfin_check_status - Read device status reg & clear interrupt
+ *	@ap: port where the device is
+ *
+ *	Note: Original code is ata_check_status().
+ */
+
+static u8 bfin_check_status(struct ata_port *ap)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+	return read_atapi_register(base, ATA_REG_STATUS);
+}
+
+/**
+ *	bfin_check_altstatus - Read device alternate status reg
+ *	@ap: port where the device is
+ */
+
+static u8 bfin_check_altstatus(struct ata_port *ap)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+	return read_atapi_register(base, ATA_REG_ALTSTATUS);
+}
+
+/**
+ *      bfin_ata_busy_wait - Wait for a port status register
+ *      @ap: Port to wait for.
+ *      @bits: bits that must be clear
+ *      @max: number of 10uS waits to perform
+ *
+ *      Waits up to max*10 microseconds for the selected bits in the port's
+ *      status register to be cleared.
+ *      Returns final value of status register.
+ *
+ *      LOCKING:
+ *      Inherited from caller.
+ */
+static inline u8 bfin_ata_busy_wait(struct ata_port *ap, unsigned int bits,
+				unsigned int max, u8 usealtstatus)
+{
+	u8 status;
+
+	do {
+		udelay(10);
+		if (usealtstatus)
+			status = bfin_check_altstatus(ap);
+		else
+			status = bfin_check_status(ap);
+		max--;
+	} while (status != 0xff && (status & bits) && (max > 0));
+
+	return status;
+}
+
+/**
+ *	bfin_ata_busy_sleep - sleep until BSY clears, or timeout
+ *	@ap: port containing status register to be polled
+ *	@tmout_pat: impatience timeout in msecs
+ *	@tmout: overall timeout in msecs
+ *
+ *	Sleep until ATA Status register bit BSY clears,
+ *	or a timeout occurs.
+ *
+ *	RETURNS:
+ *	0 on success, -errno otherwise.
+ */
+static int bfin_ata_busy_sleep(struct ata_port *ap,
+		       long tmout_pat, unsigned long tmout)
+{
+	u8 status;
+
+	status = bfin_ata_busy_wait(ap, ATA_BUSY, 300, 0);
+	while (status != 0xff && (status & ATA_BUSY) && tmout_pat > 0) {
+		msleep(50);
+		tmout_pat -= 50;
+		status = bfin_ata_busy_wait(ap, ATA_BUSY, 3, 0);
+	}
+
+	if (status != 0xff && (status & ATA_BUSY))
+		printf("port is slow to respond, please be patient "
+				"(Status 0x%x)\n", status);
+
+	while (status != 0xff && (status & ATA_BUSY) && tmout_pat > 0) {
+		msleep(50);
+		tmout_pat -= 50;
+		status = bfin_check_status(ap);
+	}
+
+	if (status == 0xff)
+		return -ENODEV;
+
+	if (status & ATA_BUSY) {
+		printf("port failed to respond "
+				"(%lu secs, Status 0x%x)\n",
+				DIV_ROUND_UP(tmout, 1000), status);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/**
+ *	bfin_dev_select - Select device 0/1 on ATA bus
+ *	@ap: ATA channel to manipulate
+ *	@device: ATA device (numbered from zero) to select
+ *
+ *	Note: Original code is ata_sff_dev_select().
+ */
+
+static void bfin_dev_select(struct ata_port *ap, unsigned int device)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+	u8 tmp;
+
+
+	if (device == 0)
+		tmp = ATA_DEVICE_OBS;
+	else
+		tmp = ATA_DEVICE_OBS | ATA_DEV1;
+
+	write_atapi_register(base, ATA_REG_DEVICE, tmp);
+	udelay(1);
+}
+
+/**
+ *	bfin_devchk - PATA device presence detection
+ *	@ap: ATA channel to examine
+ *	@device: Device to examine (starting at zero)
+ *
+ *	Note: Original code is ata_devchk().
+ */
+
+static unsigned int bfin_devchk(struct ata_port *ap,
+				unsigned int device)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+	u8 nsect, lbal;
+
+	bfin_dev_select(ap, device);
+
+	write_atapi_register(base, ATA_REG_NSECT, 0x55);
+	write_atapi_register(base, ATA_REG_LBAL, 0xaa);
+
+	write_atapi_register(base, ATA_REG_NSECT, 0xaa);
+	write_atapi_register(base, ATA_REG_LBAL, 0x55);
+
+	write_atapi_register(base, ATA_REG_NSECT, 0x55);
+	write_atapi_register(base, ATA_REG_LBAL, 0xaa);
+
+	nsect = read_atapi_register(base, ATA_REG_NSECT);
+	lbal = read_atapi_register(base, ATA_REG_LBAL);
+
+	if ((nsect == 0x55) && (lbal == 0xaa))
+		return 1;	/* we found a device */
+
+	return 0;		/* nothing found */
+}
+
+/**
+ *	bfin_bus_post_reset - PATA device post reset
+ *
+ *	Note: Original code is ata_bus_post_reset().
+ */
+
+static void bfin_bus_post_reset(struct ata_port *ap, unsigned int devmask)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+	unsigned int dev0 = devmask & (1 << 0);
+	unsigned int dev1 = devmask & (1 << 1);
+	long deadline;
+
+	/* if device 0 was found in ata_devchk, wait for its
+	 * BSY bit to clear
+	 */
+	if (dev0)
+		bfin_ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT);
+
+	/* if device 1 was found in ata_devchk, wait for
+	 * register access, then wait for BSY to clear
+	 */
+	deadline = ATA_TMOUT_BOOT;
+	while (dev1) {
+		u8 nsect, lbal;
+
+		bfin_dev_select(ap, 1);
+		nsect = read_atapi_register(base, ATA_REG_NSECT);
+		lbal = read_atapi_register(base, ATA_REG_LBAL);
+		if ((nsect == 1) && (lbal == 1))
+			break;
+		if (deadline <= 0) {
+			dev1 = 0;
+			break;
+		}
+		msleep(50);	/* give drive a breather */
+		deadline -= 50;
+	}
+	if (dev1)
+		bfin_ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT);
+
+	/* is all this really necessary? */
+	bfin_dev_select(ap, 0);
+	if (dev1)
+		bfin_dev_select(ap, 1);
+	if (dev0)
+		bfin_dev_select(ap, 0);
+}
+
+/**
+ *	bfin_bus_softreset - PATA device software reset
+ *
+ *	Note: Original code is ata_bus_softreset().
+ */
+
+static unsigned int bfin_bus_softreset(struct ata_port *ap,
+				       unsigned int devmask)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+
+	/* software reset.  causes dev0 to be selected */
+	write_atapi_register(base, ATA_REG_CTRL, ap->ctl_reg);
+	udelay(20);
+	write_atapi_register(base, ATA_REG_CTRL, ap->ctl_reg | ATA_SRST);
+	udelay(20);
+	write_atapi_register(base, ATA_REG_CTRL, ap->ctl_reg);
+
+	/* spec mandates ">= 2ms" before checking status.
+	 * We wait 150ms, because that was the magic delay used for
+	 * ATAPI devices in Hale Landis's ATADRVR, for the period of time
+	 * between when the ATA command register is written, and then
+	 * status is checked.  Because waiting for "a while" before
+	 * checking status is fine, post SRST, we perform this magic
+	 * delay here as well.
+	 *
+	 * Old drivers/ide uses the 2mS rule and then waits for ready
+	 */
+	msleep(150);
+
+	/* Before we perform post reset processing we want to see if
+	 * the bus shows 0xFF because the odd clown forgets the D7
+	 * pulldown resistor.
+	 */
+	if (bfin_check_status(ap) == 0xFF)
+		return 0;
+
+	bfin_bus_post_reset(ap, devmask);
+
+	return 0;
+}
+
+/**
+ *	bfin_softreset - reset host port via ATA SRST
+ *	@ap: port to reset
+ *
+ *	Note: Original code is ata_sff_softreset().
+ */
+
+static int bfin_softreset(struct ata_port *ap)
+{
+	unsigned int err_mask;
+
+	ap->dev_mask = 0;
+
+	/* determine if device 0/1 are present.
+	 * only one device is supported on one port by now.
+	*/
+	if (bfin_devchk(ap, 0))
+		ap->dev_mask |= (1 << 0);
+	else if (bfin_devchk(ap, 1))
+		ap->dev_mask |= (1 << 1);
+	else
+		return -ENODEV;
+
+	/* select device 0 again */
+	bfin_dev_select(ap, 0);
+
+	/* issue bus reset */
+	err_mask = bfin_bus_softreset(ap, ap->dev_mask);
+	if (err_mask) {
+		printf("SRST failed (err_mask=0x%x)\n",
+				err_mask);
+		ap->dev_mask = 0;
+		return -EIO;
+	}
+
+	return 0;
+}
+
+/**
+ *	bfin_irq_clear - Clear ATAPI interrupt.
+ *	@ap: Port associated with this ATA transaction.
+ *
+ *	Note: Original code is ata_sff_irq_clear().
+ */
+
+static void bfin_irq_clear(struct ata_port *ap)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+
+	ATAPI_SET_INT_STATUS(base, ATAPI_GET_INT_STATUS(base)|ATAPI_DEV_INT
+		| MULTI_DONE_INT | UDMAIN_DONE_INT | UDMAOUT_DONE_INT
+		| MULTI_TERM_INT | UDMAIN_TERM_INT | UDMAOUT_TERM_INT);
+}
+
+static u8 bfin_wait_for_irq(struct ata_port *ap, unsigned int max)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+
+	do {
+		if (ATAPI_GET_INT_STATUS(base) & (ATAPI_DEV_INT
+		| MULTI_DONE_INT | UDMAIN_DONE_INT | UDMAOUT_DONE_INT
+		| MULTI_TERM_INT | UDMAIN_TERM_INT | UDMAOUT_TERM_INT)) {
+			break;
+		}
+		udelay(1000);
+		max--;
+	} while ((max > 0));
+
+	return max == 0;
+}
+
+/**
+ *	bfin_ata_reset_port - initialize BFIN ATAPI port.
+ */
+
+static int bfin_ata_reset_port(struct ata_port *ap)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+	int count;
+	unsigned short status;
+
+	/* Disable all ATAPI interrupts */
+	ATAPI_SET_INT_MASK(base, 0);
+	SSYNC();
+
+	/* Assert the RESET signal 25us*/
+	ATAPI_SET_CONTROL(base, ATAPI_GET_CONTROL(base) | DEV_RST);
+	udelay(30);
+
+	/* Negate the RESET signal for 2ms*/
+	ATAPI_SET_CONTROL(base, ATAPI_GET_CONTROL(base) & ~DEV_RST);
+	msleep(2);
+
+	/* Wait on Busy flag to clear */
+	count = 10000000;
+	do {
+		status = read_atapi_register(base, ATA_REG_STATUS);
+	} while (--count && (status & ATA_BUSY));
+
+	/* Enable only ATAPI Device interrupt */
+	ATAPI_SET_INT_MASK(base, 1);
+	SSYNC();
+
+	return !count;
+}
+
+/**
+ *
+ *	Function:       bfin_config_atapi_gpio
+ *
+ *	Description:    Configures the ATAPI pins for use
+ *
+ */
+static int bfin_config_atapi_gpio(struct ata_port *ap)
+{
+	bfin_write_PORTH_FER(bfin_read_PORTH_FER() | 0x4);
+	bfin_write_PORTH_MUX(bfin_read_PORTH_MUX() & ~0x30);
+	bfin_write_PORTH_DIR_SET(0x4);
+
+	bfin_write_PORTJ_FER(0x7f8);
+	bfin_write_PORTJ_MUX(bfin_read_PORTI_MUX() & ~0x3fffc0);
+	bfin_write_PORTJ_DIR_SET(0x5f8);
+	bfin_write_PORTJ_DIR_CLEAR(0x200);
+	bfin_write_PORTJ_INEN(0x200);
+
+	bfin_write_PINT2_ASSIGN(0x0707);
+	bfin_write_PINT2_MASK_SET(0x200);
+	SSYNC();
+
+	return 0;
+}
+
+/**
+ *	bfin_atapi_probe	-	attach a bfin atapi interface
+ *	@pdev: platform device
+ *
+ *	Register a bfin atapi interface.
+ *
+ *
+ *	Platform devices are expected to contain 2 resources per port:
+ *
+ *		- I/O Base (IORESOURCE_IO)
+ *		- IRQ	   (IORESOURCE_IRQ)
+ *
+ */
+static int bfin_ata_probe_port(struct ata_port *ap)
+{
+	if (bfin_config_atapi_gpio(ap)) {
+		printf("Requesting Peripherals faild\n");
+		return -EFAULT;
+	}
+
+	if (bfin_ata_reset_port(ap)) {
+		printf("Fail to reset ATAPI device\n");
+		return -EFAULT;
+	}
+
+	if (ap->ata_mode >= XFER_PIO_0 && ap->ata_mode <= XFER_PIO_4)
+		bfin_set_piomode(ap, ap->ata_mode);
+	else {
+		printf("Given ATA data transfer mode is not supported.\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+#define ATA_SECTOR_WORDS (ATA_SECT_SIZE/2)
+
+static void bfin_ata_identify(struct ata_port *ap, int dev)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+	u8 status = 0;
+	static u16 iobuf[ATA_SECTOR_WORDS];
+	u64 n_sectors = 0;
+	hd_driveid_t *iop = (hd_driveid_t *)iobuf;
+
+	memset(iobuf, 0, sizeof(iobuf));
+
+	if (!(ap->dev_mask & (1 << dev)))
+		return;
+
+	debug("port=%d dev=%d\n", ap->port_no, dev);
+
+	bfin_dev_select(ap, dev);
+
+	status = 0;
+	/* Device Identify Command */
+	write_atapi_register(base, ATA_REG_CMD, ATA_CMD_ID_ATA);
+	bfin_check_altstatus(ap);
+	udelay(10);
+
+	status = bfin_ata_busy_wait(ap, ATA_BUSY, 1000, 0);
+	if (status & ATA_ERR) {
+		printf("\ndevice not responding\n");
+		ap->dev_mask &= ~(1 << dev);
+		return;
+	}
+
+	read_atapi_data(base, ATA_SECTOR_WORDS, iobuf);
+
+	ata_swap_buf_le16(iobuf, ATA_SECTOR_WORDS);
+
+	/* we require LBA and DMA support (bits 8 & 9 of word 49) */
+	if (!ata_id_has_dma(iobuf) || !ata_id_has_lba(iobuf))
+		printf("ata%u: no dma/lba\n", ap->port_no);
+
+#ifdef DEBUG
+	ata_dump_id(iobuf);
+#endif
+
+	n_sectors = ata_id_n_sectors(iobuf);
+
+	if (n_sectors == 0) {
+		ap->dev_mask &= ~(1 << dev);
+		return;
+	}
+
+	ata_id_c_string(iobuf, (unsigned char *)sata_dev_desc[ap->port_no].revision,
+			 ATA_ID_FW_REV, sizeof(sata_dev_desc[ap->port_no].revision));
+	ata_id_c_string(iobuf, (unsigned char *)sata_dev_desc[ap->port_no].vendor,
+			 ATA_ID_PROD, sizeof(sata_dev_desc[ap->port_no].vendor));
+	ata_id_c_string(iobuf, (unsigned char *)sata_dev_desc[ap->port_no].product,
+			 ATA_ID_SERNO, sizeof(sata_dev_desc[ap->port_no].product));
+
+	if ((iop->config & 0x0080) == 0x0080)
+		sata_dev_desc[ap->port_no].removable = 1;
+	else
+		sata_dev_desc[ap->port_no].removable = 0;
+
+	sata_dev_desc[ap->port_no].lba = (u32) n_sectors;
+	debug("lba=0x%x\n", sata_dev_desc[ap->port_no].lba);
+
+#ifdef CONFIG_LBA48
+	if (iop->command_set_2 & 0x0400)
+		sata_dev_desc[ap->port_no].lba48 = 1;
+	else
+		sata_dev_desc[ap->port_no].lba48 = 0;
+#endif
+
+	/* assuming HD */
+	sata_dev_desc[ap->port_no].type = DEV_TYPE_HARDDISK;
+	sata_dev_desc[ap->port_no].blksz = ATA_SECT_SIZE;
+	sata_dev_desc[ap->port_no].lun = 0;	/* just to fill something in... */
+
+	printf("PATA device#%d %s is found on ata port#%d.\n",
+		ap->port_no%PATA_DEV_NUM_PER_PORT,
+		sata_dev_desc[ap->port_no].vendor,
+		ap->port_no/PATA_DEV_NUM_PER_PORT);
+}
+
+static void bfin_ata_set_Feature_cmd(struct ata_port *ap, int dev)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+	u8 status = 0;
+
+	if (!(ap->dev_mask & (1 << dev)))
+		return;
+
+	bfin_dev_select(ap, dev);
+
+	write_atapi_register(base, ATA_REG_FEATURE, SETFEATURES_XFER);
+	write_atapi_register(base, ATA_REG_NSECT, ap->ata_mode);
+	write_atapi_register(base, ATA_REG_LBAL, 0);
+	write_atapi_register(base, ATA_REG_LBAM, 0);
+	write_atapi_register(base, ATA_REG_LBAH, 0);
+
+	write_atapi_register(base, ATA_REG_DEVICE, ATA_DEVICE_OBS);
+	write_atapi_register(base, ATA_REG_CMD, ATA_CMD_SET_FEATURES);
+
+	udelay(50);
+	msleep(150);
+
+	status = bfin_ata_busy_wait(ap, ATA_BUSY, 5000, 0);
+	if ((status & (ATA_BUSY | ATA_ERR))) {
+		printf("Error  : status 0x%02x\n", status);
+		ap->dev_mask &= ~(1 << dev);
+	}
+}
+
+int scan_sata(int dev)
+{
+	/* dev is the index of each ata device in the system. one PATA port
+	 * contains 2 devices. one element in scan_done array indicates one
+	 * PATA port. device connected to one PATA port is selected by
+	 * bfin_dev_select() before access.
+	 */
+	struct ata_port *ap = &port[dev];
+	static int scan_done[(CONFIG_SYS_SATA_MAX_DEVICE+1)/PATA_DEV_NUM_PER_PORT];
+
+	if (scan_done[dev/PATA_DEV_NUM_PER_PORT])
+		return 0;
+
+	/* Check for attached device */
+	if (!bfin_ata_probe_port(ap)) {
+		if (bfin_softreset(ap)) {
+			/* soft reset failed, try a hard one */
+			bfin_ata_reset_port(ap);
+			if (bfin_softreset(ap))
+				scan_done[dev/PATA_DEV_NUM_PER_PORT] = 1;
+		} else {
+			scan_done[dev/PATA_DEV_NUM_PER_PORT] = 1;
+		}
+	}
+	if (scan_done[dev/PATA_DEV_NUM_PER_PORT]) {
+		/* Probe device and set xfer mode */
+		bfin_ata_identify(ap, dev%PATA_DEV_NUM_PER_PORT);
+		bfin_ata_set_Feature_cmd(ap, dev%PATA_DEV_NUM_PER_PORT);
+		init_part(&sata_dev_desc[dev]);
+		return 0;
+	}
+
+	printf("PATA device#%d is not present on ATA port#%d.\n",
+		ap->port_no%PATA_DEV_NUM_PER_PORT,
+		ap->port_no/PATA_DEV_NUM_PER_PORT);
+
+	return -1;
+}
+
+int init_sata(int dev)
+{
+	struct ata_port *ap = &port[dev];
+	static u8 init_done;
+	int res = 1;
+
+	if (init_done)
+		return res;
+
+	init_done = 1;
+
+	switch (dev/PATA_DEV_NUM_PER_PORT) {
+	case 0:
+		ap->ioaddr.ctl_addr = ATAPI_CONTROL;
+		ap->ata_mode = CONFIG_BFIN_ATA_MODE;
+		break;
+	default:
+		printf("Tried to scan unknown port %d.\n", dev);
+		return res;
+	}
+
+	if (ap->ata_mode < XFER_PIO_0 || ap->ata_mode > XFER_PIO_4) {
+		ap->ata_mode = XFER_PIO_4;
+		printf("DMA mode is not supported. Set to PIO mode 4.\n");
+	}
+
+	ap->port_no = dev;
+	ap->ctl_reg = 0x8;	/*Default value of control reg */
+
+	res = 0;
+	return res;
+}
+
+/* Read up to 255 sectors
+ *
+ * Returns sectors read
+*/
+static u8 do_one_read(struct ata_port *ap, u64 blknr, u8 blkcnt, u16 *buffer,
+			uchar lba48)
+{
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+	u8 sr = 0;
+	u8 status;
+	u16 err = 0;
+
+	if (!(bfin_check_status(ap) & ATA_DRDY)) {
+		printf("Device ata%d not ready\n", ap->port_no);
+		return 0;
+	}
+
+	/* Set up transfer */
+#ifdef CONFIG_LBA48
+	if (lba48) {
+		/* write high bits */
+		write_atapi_register(base, ATA_REG_NSECT, 0);
+		write_atapi_register(base, ATA_REG_LBAL, (blknr >> 24) & 0xFF);
+		write_atapi_register(base, ATA_REG_LBAM, (blknr >> 32) & 0xFF);
+		write_atapi_register(base, ATA_REG_LBAH, (blknr >> 40) & 0xFF);
+	}
+#endif
+	write_atapi_register(base, ATA_REG_NSECT, blkcnt);
+	write_atapi_register(base, ATA_REG_LBAL, (blknr >> 0) & 0xFF);
+	write_atapi_register(base, ATA_REG_LBAM, (blknr >> 8) & 0xFF);
+	write_atapi_register(base, ATA_REG_LBAH, (blknr >> 16) & 0xFF);
+
+#ifdef CONFIG_LBA48
+	if (lba48) {
+		write_atapi_register(base, ATA_REG_DEVICE, ATA_LBA);
+		write_atapi_register(base, ATA_REG_CMD, ATA_CMD_PIO_READ_EXT);
+	} else
+#endif
+	{
+		write_atapi_register(base, ATA_REG_DEVICE, ATA_LBA | ((blknr >> 24) & 0xF));
+		write_atapi_register(base, ATA_REG_CMD, ATA_CMD_PIO_READ);
+	}
+	status = bfin_ata_busy_wait(ap, ATA_BUSY, 500000, 1);
+
+	if (status & (ATA_BUSY | ATA_ERR)) {
+		printf("Device %d not responding status 0x%x.\n", ap->port_no, status);
+		err = read_atapi_register(base, ATA_REG_ERR);
+		printf("Error reg = 0x%x\n", err);
+		return sr;
+	}
+
+	while (blkcnt--) {
+		if (bfin_wait_for_irq(ap, 500)) {
+			printf("ata%u irq failed\n", ap->port_no);
+			return sr;
+		}
+
+		status = bfin_check_status(ap);
+		if (status & ATA_ERR) {
+			err = read_atapi_register(base, ATA_REG_ERR);
+			printf("ata%u error %d\n", ap->port_no, err);
+			return sr;
+		}
+		bfin_irq_clear(ap);
+
+		/* Read one sector */
+		read_atapi_data(base, ATA_SECTOR_WORDS, buffer);
+		buffer += ATA_SECTOR_WORDS;
+		sr++;
+	}
+
+	return sr;
+}
+
+ulong sata_read(int dev, ulong block, ulong blkcnt, void *buff)
+{
+	struct ata_port *ap = &port[dev];
+	ulong n = 0, sread;
+	u16 *buffer = (u16 *) buff;
+	u8 status = 0;
+	u64 blknr = (u64) block;
+	unsigned char lba48 = 0;
+
+#ifdef CONFIG_LBA48
+	if (blknr > 0xfffffff) {
+		if (!sata_dev_desc[dev].lba48) {
+			printf("Drive doesn't support 48-bit addressing\n");
+			return 0;
+		}
+		/* more than 28 bits used, use 48bit mode */
+		lba48 = 1;
+	}
+#endif
+	bfin_dev_select(ap, dev%PATA_DEV_NUM_PER_PORT);
+
+	while (blkcnt > 0) {
+
+		if (blkcnt > 255)
+			sread = 255;
+		else
+			sread = blkcnt;
+
+		status = do_one_read(ap, blknr, sread, buffer, lba48);
+		if (status != sread) {
+			printf("Read failed\n");
+			return n;
+		}
+
+		blkcnt -= sread;
+		blknr += sread;
+		n += sread;
+		buffer += sread * ATA_SECTOR_WORDS;
+	}
+	return n;
+}
+
+ulong sata_write(int dev, ulong block, ulong blkcnt, const void *buff)
+{
+	struct ata_port *ap = &port[dev];
+	void __iomem *base = (void __iomem *)ap->ioaddr.ctl_addr;
+	ulong n = 0;
+	u16 *buffer = (u16 *) buff;
+	unsigned char status = 0;
+	u64 blknr = (u64) block;
+#ifdef CONFIG_LBA48
+	unsigned char lba48 = 0;
+
+	if (blknr > 0xfffffff) {
+		if (!sata_dev_desc[dev].lba48) {
+			printf("Drive doesn't support 48-bit addressing\n");
+			return 0;
+		}
+		/* more than 28 bits used, use 48bit mode */
+		lba48 = 1;
+	}
+#endif
+
+	bfin_dev_select(ap, dev%PATA_DEV_NUM_PER_PORT);
+
+	while (blkcnt-- > 0) {
+		status = bfin_ata_busy_wait(ap, ATA_BUSY, 50000, 0);
+		if (status & ATA_BUSY) {
+			printf("ata%u failed to respond\n", ap->port_no);
+			return n;
+		}
+#ifdef CONFIG_LBA48
+		if (lba48) {
+			/* write high bits */
+			write_atapi_register(base, ATA_REG_NSECT, 0);
+			write_atapi_register(base, ATA_REG_LBAL,
+				(blknr >> 24) & 0xFF);
+			write_atapi_register(base, ATA_REG_LBAM,
+				(blknr >> 32) & 0xFF);
+			write_atapi_register(base, ATA_REG_LBAH,
+				(blknr >> 40) & 0xFF);
+		}
+#endif
+		write_atapi_register(base, ATA_REG_NSECT, 1);
+		write_atapi_register(base, ATA_REG_LBAL, (blknr >> 0) & 0xFF);
+		write_atapi_register(base, ATA_REG_LBAM, (blknr >> 8) & 0xFF);
+		write_atapi_register(base, ATA_REG_LBAH, (blknr >> 16) & 0xFF);
+#ifdef CONFIG_LBA48
+		if (lba48) {
+			write_atapi_register(base, ATA_REG_DEVICE, ATA_LBA);
+			write_atapi_register(base, ATA_REG_CMD,
+				ATA_CMD_PIO_WRITE_EXT);
+		} else
+#endif
+		{
+			write_atapi_register(base, ATA_REG_DEVICE,
+				ATA_LBA | ((blknr >> 24) & 0xF));
+			write_atapi_register(base, ATA_REG_CMD,
+				ATA_CMD_PIO_WRITE);
+		}
+
+		/*may take up to 5 sec */
+		status = bfin_ata_busy_wait(ap, ATA_BUSY, 50000, 0);
+		if ((status & (ATA_DRQ | ATA_BUSY | ATA_ERR)) != ATA_DRQ) {
+			printf("Error no DRQ dev %d blk %ld: sts 0x%02x\n",
+				ap->port_no, (ulong) blknr, status);
+			return n;
+		}
+
+		write_atapi_data(base, ATA_SECTOR_WORDS, buffer);
+		bfin_check_altstatus(ap);
+		udelay(1);
+
+		++n;
+		++blknr;
+		buffer += ATA_SECTOR_WORDS;
+	}
+	return n;
+}
diff -Naur u-boot-2009.01/drivers/block/pata_bfin.h u-boot/drivers/block/pata_bfin.h
--- u-boot-2009.01/drivers/block/pata_bfin.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/block/pata_bfin.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,173 @@
+/*
+ * Driver for Blackfin on-chip ATAPI controller.
+ *
+ * Enter bugs at http://blackfin.uclinux.org/
+ *
+ * Copyright (c) 2008 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#ifndef PATA_BFIN_H
+#define PATA_BFIN_H
+
+#include <asm/blackfin_local.h>
+
+struct ata_ioports {
+	unsigned long cmd_addr;
+	unsigned long data_addr;
+	unsigned long error_addr;
+	unsigned long feature_addr;
+	unsigned long nsect_addr;
+	unsigned long lbal_addr;
+	unsigned long lbam_addr;
+	unsigned long lbah_addr;
+	unsigned long device_addr;
+	unsigned long status_addr;
+	unsigned long command_addr;
+	unsigned long altstatus_addr;
+	unsigned long ctl_addr;
+	unsigned long bmdma_addr;
+	unsigned long scr_addr;
+};
+
+struct ata_port {
+	unsigned int port_no;		/* primary=0, secondary=1       */
+	struct ata_ioports ioaddr;	/* ATA cmd/ctl/dma reg blks     */
+	unsigned long flag;
+	unsigned int ata_mode;
+	unsigned char ctl_reg;
+	unsigned char last_ctl;
+	unsigned char dev_mask;
+};
+
+extern block_dev_desc_t sata_dev_desc[CONFIG_SYS_SATA_MAX_DEVICE];
+
+#define DRV_NAME		"pata-bfin"
+#define DRV_VERSION		"0.9"
+#define __iomem
+
+#define ATA_REG_CTRL		0x0E
+#define ATA_REG_ALTSTATUS	ATA_REG_CTRL
+#define ATA_TMOUT_BOOT		30000
+#define ATA_TMOUT_BOOT_QUICK	7000
+
+#define PATA_BFIN_WAIT_TIMEOUT		10000
+#define PATA_DEV_NUM_PER_PORT	2
+
+/* These are the offset of the controller's registers */
+#define ATAPI_OFFSET_CONTROL		0x00
+#define ATAPI_OFFSET_STATUS		0x04
+#define ATAPI_OFFSET_DEV_ADDR		0x08
+#define ATAPI_OFFSET_DEV_TXBUF		0x0c
+#define ATAPI_OFFSET_DEV_RXBUF		0x10
+#define ATAPI_OFFSET_INT_MASK		0x14
+#define ATAPI_OFFSET_INT_STATUS		0x18
+#define ATAPI_OFFSET_XFER_LEN		0x1c
+#define ATAPI_OFFSET_LINE_STATUS	0x20
+#define ATAPI_OFFSET_SM_STATE		0x24
+#define ATAPI_OFFSET_TERMINATE		0x28
+#define ATAPI_OFFSET_PIO_TFRCNT		0x2c
+#define ATAPI_OFFSET_DMA_TFRCNT		0x30
+#define ATAPI_OFFSET_UMAIN_TFRCNT	0x34
+#define ATAPI_OFFSET_UDMAOUT_TFRCNT	0x38
+#define ATAPI_OFFSET_REG_TIM_0		0x40
+#define ATAPI_OFFSET_PIO_TIM_0		0x44
+#define ATAPI_OFFSET_PIO_TIM_1		0x48
+#define ATAPI_OFFSET_MULTI_TIM_0	0x50
+#define ATAPI_OFFSET_MULTI_TIM_1	0x54
+#define ATAPI_OFFSET_MULTI_TIM_2	0x58
+#define ATAPI_OFFSET_ULTRA_TIM_0	0x60
+#define ATAPI_OFFSET_ULTRA_TIM_1	0x64
+#define ATAPI_OFFSET_ULTRA_TIM_2	0x68
+#define ATAPI_OFFSET_ULTRA_TIM_3	0x6c
+
+
+#define ATAPI_GET_CONTROL(base)\
+	bfin_read16(base + ATAPI_OFFSET_CONTROL)
+#define ATAPI_SET_CONTROL(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_CONTROL, val)
+#define ATAPI_GET_STATUS(base)\
+	bfin_read16(base + ATAPI_OFFSET_STATUS)
+#define ATAPI_GET_DEV_ADDR(base)\
+	bfin_read16(base + ATAPI_OFFSET_DEV_ADDR)
+#define ATAPI_SET_DEV_ADDR(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_DEV_ADDR, val)
+#define ATAPI_GET_DEV_TXBUF(base)\
+	bfin_read16(base + ATAPI_OFFSET_DEV_TXBUF)
+#define ATAPI_SET_DEV_TXBUF(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_DEV_TXBUF, val)
+#define ATAPI_GET_DEV_RXBUF(base)\
+	bfin_read16(base + ATAPI_OFFSET_DEV_RXBUF)
+#define ATAPI_SET_DEV_RXBUF(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_DEV_RXBUF, val)
+#define ATAPI_GET_INT_MASK(base)\
+	bfin_read16(base + ATAPI_OFFSET_INT_MASK)
+#define ATAPI_SET_INT_MASK(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_INT_MASK, val)
+#define ATAPI_GET_INT_STATUS(base)\
+	bfin_read16(base + ATAPI_OFFSET_INT_STATUS)
+#define ATAPI_SET_INT_STATUS(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_INT_STATUS, val)
+#define ATAPI_GET_XFER_LEN(base)\
+	bfin_read16(base + ATAPI_OFFSET_XFER_LEN)
+#define ATAPI_SET_XFER_LEN(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_XFER_LEN, val)
+#define ATAPI_GET_LINE_STATUS(base)\
+	bfin_read16(base + ATAPI_OFFSET_LINE_STATUS)
+#define ATAPI_GET_SM_STATE(base)\
+	bfin_read16(base + ATAPI_OFFSET_SM_STATE)
+#define ATAPI_GET_TERMINATE(base)\
+	bfin_read16(base + ATAPI_OFFSET_TERMINATE)
+#define ATAPI_SET_TERMINATE(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_TERMINATE, val)
+#define ATAPI_GET_PIO_TFRCNT(base)\
+	bfin_read16(base + ATAPI_OFFSET_PIO_TFRCNT)
+#define ATAPI_GET_DMA_TFRCNT(base)\
+	bfin_read16(base + ATAPI_OFFSET_DMA_TFRCNT)
+#define ATAPI_GET_UMAIN_TFRCNT(base)\
+	bfin_read16(base + ATAPI_OFFSET_UMAIN_TFRCNT)
+#define ATAPI_GET_UDMAOUT_TFRCNT(base)\
+	bfin_read16(base + ATAPI_OFFSET_UDMAOUT_TFRCNT)
+#define ATAPI_GET_REG_TIM_0(base)\
+	bfin_read16(base + ATAPI_OFFSET_REG_TIM_0)
+#define ATAPI_SET_REG_TIM_0(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_REG_TIM_0, val)
+#define ATAPI_GET_PIO_TIM_0(base)\
+	bfin_read16(base + ATAPI_OFFSET_PIO_TIM_0)
+#define ATAPI_SET_PIO_TIM_0(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_PIO_TIM_0, val)
+#define ATAPI_GET_PIO_TIM_1(base)\
+	bfin_read16(base + ATAPI_OFFSET_PIO_TIM_1)
+#define ATAPI_SET_PIO_TIM_1(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_PIO_TIM_1, val)
+#define ATAPI_GET_MULTI_TIM_0(base)\
+	bfin_read16(base + ATAPI_OFFSET_MULTI_TIM_0)
+#define ATAPI_SET_MULTI_TIM_0(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_MULTI_TIM_0, val)
+#define ATAPI_GET_MULTI_TIM_1(base)\
+	bfin_read16(base + ATAPI_OFFSET_MULTI_TIM_1)
+#define ATAPI_SET_MULTI_TIM_1(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_MULTI_TIM_1, val)
+#define ATAPI_GET_MULTI_TIM_2(base)\
+	bfin_read16(base + ATAPI_OFFSET_MULTI_TIM_2)
+#define ATAPI_SET_MULTI_TIM_2(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_MULTI_TIM_2, val)
+#define ATAPI_GET_ULTRA_TIM_0(base)\
+	bfin_read16(base + ATAPI_OFFSET_ULTRA_TIM_0)
+#define ATAPI_SET_ULTRA_TIM_0(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_ULTRA_TIM_0, val)
+#define ATAPI_GET_ULTRA_TIM_1(base)\
+	bfin_read16(base + ATAPI_OFFSET_ULTRA_TIM_1)
+#define ATAPI_SET_ULTRA_TIM_1(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_ULTRA_TIM_1, val)
+#define ATAPI_GET_ULTRA_TIM_2(base)\
+	bfin_read16(base + ATAPI_OFFSET_ULTRA_TIM_2)
+#define ATAPI_SET_ULTRA_TIM_2(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_ULTRA_TIM_2, val)
+#define ATAPI_GET_ULTRA_TIM_3(base)\
+	bfin_read16(base + ATAPI_OFFSET_ULTRA_TIM_3)
+#define ATAPI_SET_ULTRA_TIM_3(base, val)\
+	bfin_write16(base + ATAPI_OFFSET_ULTRA_TIM_3, val)
+
+#endif
diff -Naur u-boot-2009.01/drivers/block/sata_sil3114.c u-boot/drivers/block/sata_sil3114.c
--- u-boot-2009.01/drivers/block/sata_sil3114.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/block/sata_sil3114.c	2009-02-26 14:03:58.000000000 +0100
@@ -96,7 +96,7 @@
 	}
 
 	if (status & ATA_BUSY) {
-		printf ("ata%u is slow to respond,plz be patient\n", port);
+		printf ("ata%u is slow to respond,plz be patient\n", num);
 	}
 
 	while ((status & ATA_BUSY)) {
@@ -105,7 +105,7 @@
 	}
 
 	if (status & ATA_BUSY) {
-		printf ("ata%u failed to respond : ", port);
+		printf ("ata%u failed to respond : ", num);
 		printf ("bus reset failed\n");
 		port[num].dev_mask = 0;
 		return 1;
diff -Naur u-boot-2009.01/drivers/fpga/spartan2.c u-boot/drivers/fpga/spartan2.c
--- u-boot-2009.01/drivers/fpga/spartan2.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/fpga/spartan2.c	2009-02-26 14:03:58.000000000 +0100
@@ -260,8 +260,6 @@
 		ts = get_timer (0);		/* get current time */
 		ret_val = FPGA_SUCCESS;
 		while ((*fn->done) (cookie) == FPGA_FAIL) {
-			/* XXX - we should have a check in here somewhere to
-			 * make sure we aren't busy forever... */
 
 			CONFIG_FPGA_DELAY ();
 			(*fn->clk) (FALSE, TRUE, cookie);	/* Deassert the clock pin */
@@ -276,23 +274,18 @@
 			}
 		}
 
-		if (ret_val == FPGA_SUCCESS) {
-#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
-			puts ("Done.\n");
-#endif
-		}
 		/*
 		 * Run the post configuration function if there is one.
 		 */
-		if (*fn->post) {
+		if (*fn->post)
 			(*fn->post) (cookie);
-		}
 
-		else {
 #ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+		if (ret_val == FPGA_SUCCESS)
+			puts ("Done.\n");
+		else
 			puts ("Fail.\n");
 #endif
-		}
 
 	} else {
 		printf ("%s: NULL Interface function table!\n", __FUNCTION__);
@@ -412,8 +405,10 @@
 			addr = (ulong) (fn->abort) + reloc_offset;
 			fn_r->abort = (Xilinx_abort_fn) addr;
 
-			addr = (ulong) (fn->post) + reloc_offset;
-			fn_r->post = (Xilinx_post_fn) addr;
+			if (fn->post) {
+				addr = (ulong) (fn->post) + reloc_offset;
+				fn_r->post = (Xilinx_post_fn) addr;
+			}
 
 			fn_r->relocated = TRUE;
 
@@ -541,8 +536,6 @@
 		(*fn->wr) (TRUE, TRUE, cookie);
 
 		while (! (*fn->done) (cookie)) {
-			/* XXX - we should have a check in here somewhere to
-			 * make sure we aren't busy forever... */
 
 			CONFIG_FPGA_DELAY ();
 			(*fn->clk) (FALSE, TRUE, cookie);	/* Deassert the clock pin */
@@ -562,17 +555,14 @@
 		/*
 		 * Run the post configuration function if there is one.
 		 */
-		if (*fn->post) {
+		if (*fn->post)
 			(*fn->post) (cookie);
-		}
 
 #ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
-		if (ret_val == FPGA_SUCCESS) {
+		if (ret_val == FPGA_SUCCESS)
 			puts ("Done.\n");
-		}
-		else {
+		else
 			puts ("Fail.\n");
-		}
 #endif
 
 	} else {
diff -Naur u-boot-2009.01/drivers/fpga/spartan3.c u-boot/drivers/fpga/spartan3.c
--- u-boot-2009.01/drivers/fpga/spartan3.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/fpga/spartan3.c	2009-02-26 14:03:58.000000000 +0100
@@ -281,23 +281,18 @@
 			}
 		}
 
-		if (ret_val == FPGA_SUCCESS) {
-#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
-			puts ("Done.\n");
-#endif
-		}
 		/*
 		 * Run the post configuration function if there is one.
 		 */
-		if (*fn->post) {
+		if (*fn->post)
 			(*fn->post) (cookie);
-		}
 
-		else {
 #ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+		if (ret_val == FPGA_SUCCESS)
+			puts ("Done.\n");
+		else
 			puts ("Fail.\n");
 #endif
-		}
 
 	} else {
 		printf ("%s: NULL Interface function table!\n", __FUNCTION__);
@@ -567,17 +562,14 @@
 		/*
 		 * Run the post configuration function if there is one.
 		 */
-		if (*fn->post) {
+		if (*fn->post)
 			(*fn->post) (cookie);
-		}
 
 #ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
-		if (ret_val == FPGA_SUCCESS) {
+		if (ret_val == FPGA_SUCCESS)
 			puts ("Done.\n");
-		}
-		else {
+		else
 			puts ("Fail.\n");
-		}
 #endif
 
 	} else {
diff -Naur u-boot-2009.01/drivers/gpio/pca953x.c u-boot/drivers/gpio/pca953x.c
--- u-boot-2009.01/drivers/gpio/pca953x.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/gpio/pca953x.c	2009-02-26 14:03:58.000000000 +0100
@@ -164,7 +164,7 @@
 	if (!c || !((argc == (c->maxargs)) ||
 		(((int)c->cmd == PCA953X_CMD_DEVICE) &&
 		 (argc == (c->maxargs - 1))))) {
-		printf("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -209,7 +209,7 @@
 
 U_BOOT_CMD(
 	pca953x,	5,	1,	do_pca953x,
-	"pca953x	- pca953x gpio access\n",
+	"pca953x gpio access",
 	"device [dev]\n"
 	"	- show or set current device address\n"
 #ifdef CONFIG_CMD_PCA953X_INFO
diff -Naur u-boot-2009.01/drivers/i2c/bfin-twi_i2c.c u-boot/drivers/i2c/bfin-twi_i2c.c
--- u-boot-2009.01/drivers/i2c/bfin-twi_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/i2c/bfin-twi_i2c.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,285 @@
+/*
+ * i2c.c - driver for Blackfin on-chip TWI/I2C
+ *
+ * Copyright (c) 2006-2008 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <i2c.h>
+
+#include <asm/blackfin.h>
+#include <asm/mach-common/bits/twi.h>
+
+#ifdef DEBUG
+# define dmemset(s, c, n) memset(s, c, n)
+#else
+# define dmemset(s, c, n)
+#endif
+#define debugi(fmt, args...) \
+	debug( \
+		"MSTAT:0x%03x FSTAT:0x%x ISTAT:0x%02x\t" \
+		"%-20s:%-3i: " fmt "\n", \
+		bfin_read_TWI_MASTER_STAT(), bfin_read_TWI_FIFO_STAT(), bfin_read_TWI_INT_STAT(), \
+		__func__, __LINE__, ## args)
+
+#ifdef TWI0_CLKDIV
+#define bfin_write_TWI_CLKDIV(val)           bfin_write_TWI0_CLKDIV(val)
+#define bfin_write_TWI_CONTROL(val)          bfin_write_TWI0_CONTROL(val)
+#define bfin_read_TWI_CONTROL(val)           bfin_read_TWI0_CONTROL(val)
+#define bfin_write_TWI_MASTER_ADDR(val)      bfin_write_TWI0_MASTER_ADDR(val)
+#define bfin_write_TWI_XMT_DATA8(val)        bfin_write_TWI0_XMT_DATA8(val)
+#define bfin_read_TWI_RCV_DATA8()            bfin_read_TWI0_RCV_DATA8()
+#define bfin_read_TWI_INT_STAT()             bfin_read_TWI0_INT_STAT()
+#define bfin_write_TWI_INT_STAT(val)         bfin_write_TWI0_INT_STAT(val)
+#define bfin_read_TWI_MASTER_STAT()          bfin_read_TWI0_MASTER_STAT()
+#define bfin_write_TWI_MASTER_STAT(val)      bfin_write_TWI0_MASTER_STAT(val)
+#define bfin_read_TWI_MASTER_CTL()           bfin_read_TWI0_MASTER_CTL()
+#define bfin_write_TWI_MASTER_CTL(val)       bfin_write_TWI0_MASTER_CTL(val)
+#define bfin_write_TWI_INT_MASK(val)         bfin_write_TWI0_INT_MASK(val)
+#define bfin_write_TWI_FIFO_CTL(val)         bfin_write_TWI0_FIFO_CTL(val)
+#endif
+
+#ifdef CONFIG_TWICLK_KHZ
+# error do not define CONFIG_TWICLK_KHZ ... use CONFIG_SYS_I2C_SPEED
+#endif
+#if CONFIG_SYS_I2C_SPEED > 400000
+# error The Blackfin I2C hardware can only operate at 400KHz max
+#endif
+
+/* All transfers are described by this data structure */
+struct i2c_msg {
+	u8 flags;
+#define I2C_M_COMBO		0x4
+#define I2C_M_STOP		0x2
+#define I2C_M_READ		0x1
+	int len;		/* msg length */
+	u8 *buf;		/* pointer to msg data */
+	int alen;		/* addr length */
+	u8 *abuf;		/* addr buffer */
+};
+
+/**
+ * wait_for_completion - manage the actual i2c transfer
+ *	@msg: the i2c msg
+ */
+static int wait_for_completion(struct i2c_msg *msg)
+{
+	uint16_t int_stat;
+
+	while (!ctrlc()) {
+		int_stat = bfin_read_TWI_INT_STAT();
+
+		if (int_stat & XMTSERV) {
+			debugi("processing XMTSERV");
+			bfin_write_TWI_INT_STAT(XMTSERV);
+			SSYNC();
+			if (msg->alen) {
+				bfin_write_TWI_XMT_DATA8(*(msg->abuf++));
+				--msg->alen;
+			} else if (!(msg->flags & I2C_M_COMBO) && msg->len) {
+				bfin_write_TWI_XMT_DATA8(*(msg->buf++));
+				--msg->len;
+			} else {
+				bfin_write_TWI_MASTER_CTL(bfin_read_TWI_MASTER_CTL() |
+					(msg->flags & I2C_M_COMBO ? RSTART | MDIR : STOP));
+				SSYNC();
+			}
+		}
+		if (int_stat & RCVSERV) {
+			debugi("processing RCVSERV");
+			bfin_write_TWI_INT_STAT(RCVSERV);
+			SSYNC();
+			if (msg->len) {
+				*(msg->buf++) = bfin_read_TWI_RCV_DATA8();
+				--msg->len;
+			} else if (msg->flags & I2C_M_STOP) {
+				bfin_write_TWI_MASTER_CTL(bfin_read_TWI_MASTER_CTL() | STOP);
+				SSYNC();
+			}
+		}
+		if (int_stat & MERR) {
+			debugi("processing MERR");
+			bfin_write_TWI_INT_STAT(MERR);
+			SSYNC();
+			break;
+		}
+		if (int_stat & MCOMP) {
+			debugi("processing MCOMP");
+			bfin_write_TWI_INT_STAT(MCOMP);
+			SSYNC();
+			if (msg->flags & I2C_M_COMBO && msg->len) {
+				bfin_write_TWI_MASTER_CTL((bfin_read_TWI_MASTER_CTL() & ~RSTART) |
+					(min(msg->len, 0xff) << 6) | MEN | MDIR);
+				SSYNC();
+			} else
+				break;
+		}
+	}
+
+	return msg->len;
+}
+
+/**
+ * i2c_transfer - setup an i2c transfer
+ *	@return: 0 if things worked, non-0 if things failed
+ *
+ *	Here we just get the i2c stuff all prepped and ready, and then tail off
+ *	into wait_for_completion() for all the bits to go.
+ */
+static int i2c_transfer(uchar chip, uint addr, int alen, uchar *buffer, int len, u8 flags)
+{
+	uchar addr_buffer[] = {
+		(addr >>  0),
+		(addr >>  8),
+		(addr >> 16),
+	};
+	struct i2c_msg msg = {
+		.flags = flags | (len >= 0xff ? I2C_M_STOP : 0),
+		.buf   = buffer,
+		.len   = len,
+		.abuf  = addr_buffer,
+		.alen  = alen,
+	};
+	int ret;
+
+	dmemset(buffer, 0xff, len);
+	debugi("chip=0x%x addr=0x%02x alen=%i buf[0]=0x%02x len=%i flags=0x%02x[%s] ",
+		chip, addr, alen, buffer[0], len, flags, (flags & I2C_M_READ ? "rd" : "wr"));
+
+	/* wait for things to settle */
+	while (bfin_read_TWI_MASTER_STAT() & BUSBUSY)
+		if (ctrlc())
+			return 1;
+
+	/* Set Transmit device address */
+	bfin_write_TWI_MASTER_ADDR(chip);
+
+	/* Clear the FIFO before starting things */
+	bfin_write_TWI_FIFO_CTL(XMTFLUSH | RCVFLUSH);
+	SSYNC();
+	bfin_write_TWI_FIFO_CTL(0);
+	SSYNC();
+
+	/* prime the pump */
+	if (msg.alen) {
+		len = msg.alen;
+		debugi("first byte=0x%02x", *msg.abuf);
+		bfin_write_TWI_XMT_DATA8(*(msg.abuf++));
+		--msg.alen;
+	} else if (!(msg.flags & I2C_M_READ) && msg.len) {
+		debugi("first byte=0x%02x", *msg.buf);
+		bfin_write_TWI_XMT_DATA8(*(msg.buf++));
+		--msg.len;
+	}
+
+	/* clear int stat */
+	bfin_write_TWI_MASTER_STAT(-1);
+	bfin_write_TWI_INT_STAT(-1);
+	bfin_write_TWI_INT_MASK(0);
+	SSYNC();
+
+	/* Master enable */
+	bfin_write_TWI_MASTER_CTL(
+			(bfin_read_TWI_MASTER_CTL() & FAST) |
+			(min(len, 0xff) << 6) | MEN |
+			((msg.flags & I2C_M_READ) ? MDIR : 0)
+	);
+	SSYNC();
+	debugi("CTL=0x%04x", bfin_read_TWI_MASTER_CTL());
+
+	/* process the rest */
+	ret = wait_for_completion(&msg);
+	debugi("ret=%d", ret);
+
+	if (ret) {
+		bfin_write_TWI_MASTER_CTL(bfin_read_TWI_MASTER_CTL() & ~MEN);
+		bfin_write_TWI_CONTROL(bfin_read_TWI_CONTROL() & ~TWI_ENA);
+		SSYNC();
+		bfin_write_TWI_CONTROL(bfin_read_TWI_CONTROL() | TWI_ENA);
+		SSYNC();
+	}
+
+	return ret;
+}
+
+/*
+ * i2c_init - initialize the i2c bus
+ *	@speed: bus speed (in HZ)
+ *	@slaveaddr: address of device in slave mode (0 - not slave)
+ *
+ *	Slave mode isn't actually implemented.  It'll stay that way until
+ *	we get a real request for it.
+ */
+void i2c_init(int speed, int slaveaddr)
+{
+	uint8_t prescale = ((get_sclk() / 1024 / 1024 + 5) / 10) & 0x7F;
+
+	/* Set TWI internal clock as 10MHz */
+	bfin_write_TWI_CONTROL(prescale);
+
+	/* Set TWI interface clock as specified */
+	bfin_write_TWI_CLKDIV(
+		((5 * 1024 / (speed / 1000)) << 8) |
+		((5 * 1024 / (speed / 1000)) & 0xFF)
+	);
+
+	/* Don't turn it on */
+	bfin_write_TWI_MASTER_CTL(speed > 100000 ? FAST : 0);
+
+	/* But enable it */
+	bfin_write_TWI_CONTROL(TWI_ENA | prescale);
+	SSYNC();
+
+	debugi("CONTROL:0x%04x CLKDIV:0x%04x",
+		bfin_read_TWI_CONTROL(), bfin_read_TWI_CLKDIV());
+
+#if CONFIG_SYS_I2C_SLAVE
+# error I2C slave support not tested/supported
+	/* If they want us as a slave, do it */
+	if (slaveaddr) {
+		bfin_write_TWI_SLAVE_ADDR(slaveaddr);
+		bfin_write_TWI_SLAVE_CTL(SEN);
+	}
+#endif
+}
+
+/**
+ * i2c_probe - test if a chip exists at a given i2c address
+ *	@chip: i2c chip addr to search for
+ *	@return: 0 if found, non-0 if not found
+ */
+int i2c_probe(uchar chip)
+{
+	u8 byte;
+	return i2c_read(chip, 0, 0, &byte, 1);
+}
+
+/**
+ * i2c_read - read data from an i2c device
+ *	@chip: i2c chip addr
+ *	@addr: memory (register) address in the chip
+ *	@alen: byte size of address
+ *	@buffer: buffer to store data read from chip
+ *	@len: how many bytes to read
+ *	@return: 0 on success, non-0 on failure
+ */
+int i2c_read(uchar chip, uint addr, int alen, uchar *buffer, int len)
+{
+	return i2c_transfer(chip, addr, alen, buffer, len, (alen ? I2C_M_COMBO : I2C_M_READ));
+}
+
+/**
+ * i2c_write - write data to an i2c device
+ *	@chip: i2c chip addr
+ *	@addr: memory (register) address in the chip
+ *	@alen: byte size of address
+ *	@buffer: buffer to store data read from chip
+ *	@len: how many bytes to write
+ *	@return: 0 on success, non-0 on failure
+ */
+int i2c_write(uchar chip, uint addr, int alen, uchar *buffer, int len)
+{
+	return i2c_transfer(chip, addr, alen, buffer, len, 0);
+}
diff -Naur u-boot-2009.01/drivers/i2c/Makefile u-boot/drivers/i2c/Makefile
--- u-boot-2009.01/drivers/i2c/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/i2c/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -25,10 +25,12 @@
 
 LIB	:= $(obj)libi2c.a
 
+COBJS-$(CONFIG_BFIN_TWI_I2C) += bfin-twi_i2c.o
 COBJS-$(CONFIG_FSL_I2C) += fsl_i2c.o
 COBJS-$(CONFIG_I2C_MXC) += mxc_i2c.o
 COBJS-$(CONFIG_DRIVER_OMAP1510_I2C) += omap1510_i2c.o
 COBJS-$(CONFIG_DRIVER_OMAP24XX_I2C) += omap24xx_i2c.o
+COBJS-$(CONFIG_DRIVER_OMAP34XX_I2C) += omap24xx_i2c.o
 COBJS-$(CONFIG_SOFT_I2C) += soft_i2c.o
 COBJS-$(CONFIG_TSI108_I2C) += tsi108_i2c.o
 
diff -Naur u-boot-2009.01/drivers/i2c/mxc_i2c.c u-boot/drivers/i2c/mxc_i2c.c
--- u-boot-2009.01/drivers/i2c/mxc_i2c.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/i2c/mxc_i2c.c	2009-02-26 14:03:58.000000000 +0100
@@ -49,10 +49,13 @@
 
 #ifdef CONFIG_SYS_I2C_MX31_PORT1
 #define I2C_BASE	0x43f80000
+#define I2C_CLK_OFFSET	26
 #elif defined (CONFIG_SYS_I2C_MX31_PORT2)
 #define I2C_BASE	0x43f98000
+#define I2C_CLK_OFFSET	28
 #elif defined (CONFIG_SYS_I2C_MX31_PORT3)
 #define I2C_BASE	0x43f84000
+#define I2C_CLK_OFFSET	30
 #else
 #error "define CONFIG_SYS_I2C_MX31_PORTx to use the mx31 I2C driver"
 #endif
@@ -72,6 +75,9 @@
 	int freq = mx31_get_ipg_clk();
 	int i;
 
+	/* start the required I2C clock */
+	__REG(CCM_CGR0) = __REG(CCM_CGR0) | (3 << I2C_CLK_OFFSET);
+
 	for (i = 0; i < 0x1f; i++)
 		if (freq / div[i] <= speed)
 			break;
diff -Naur u-boot-2009.01/drivers/i2c/omap24xx_i2c.c u-boot/drivers/i2c/omap24xx_i2c.c
--- u-boot-2009.01/drivers/i2c/omap24xx_i2c.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/i2c/omap24xx_i2c.c	2009-02-26 14:03:58.000000000 +0100
@@ -109,7 +109,11 @@
 
 		status = wait_for_pin ();
 		if (status & I2C_STAT_RRDY) {
+#if defined(CONFIG_OMAP243X) || defined(CONFIG_OMAP34XX)
+			*value = readb (I2C_DATA);
+#else
 			*value = readw (I2C_DATA);
+#endif
 			udelay (20000);
 		} else {
 			i2c_error = 1;
@@ -150,8 +154,23 @@
 	status = wait_for_pin ();
 
 	if (status & I2C_STAT_XRDY) {
+#if defined(CONFIG_OMAP243X) || defined(CONFIG_OMAP34XX)
+		/* send out 1 byte */
+		writeb (regoffset, I2C_DATA);
+		writew (I2C_STAT_XRDY, I2C_STAT);
+
+		status = wait_for_pin ();
+		if ((status & I2C_STAT_XRDY)) {
+			/* send out next 1 byte */
+			writeb (value, I2C_DATA);
+			writew (I2C_STAT_XRDY, I2C_STAT);
+		} else {
+			i2c_error = 1;
+		}
+#else
 		/* send out two bytes */
 		writew ((value << 8) + regoffset, I2C_DATA);
+#endif
 		/* must have enough delay to allow BB bit to go low */
 		udelay (50000);
 		if (readw (I2C_STAT) & I2C_STAT_NACK) {
@@ -188,7 +207,11 @@
 	while(1){
 		stat = readw(I2C_STAT);
 		if(stat == I2C_STAT_RRDY){
+#if defined(CONFIG_OMAP243X) || defined(CONFIG_OMAP34XX)
+			readb(I2C_DATA);
+#else
 			readw(I2C_DATA);
+#endif
 			writew(I2C_STAT_RRDY,I2C_STAT);
 			udelay(1000);
 		}else
diff -Naur u-boot-2009.01/drivers/i2c/soft_i2c.c u-boot/drivers/i2c/soft_i2c.c
--- u-boot-2009.01/drivers/i2c/soft_i2c.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/i2c/soft_i2c.c	2009-02-26 14:03:58.000000000 +0100
@@ -385,8 +385,18 @@
 			}
 			shift -= 8;
 		}
-		send_stop();	/* reportedly some chips need a full stop */
+
+		/* Some I2C chips need a stop/start sequence here,
+		 * other chips don't work with a full stop and need
+		 * only a start.  Default behaviour is to send the
+		 * stop/start sequence.
+		 */
+#ifdef CONFIG_SOFT_I2C_READ_REPEATED_START
+		send_start();
+#else
+		send_stop();
 		send_start();
+#endif
 	}
 	/*
 	 * Send the chip address again, this time for a read cycle.
diff -Naur u-boot-2009.01/drivers/misc/ds4510.c u-boot/drivers/misc/ds4510.c
--- u-boot-2009.01/drivers/misc/ds4510.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/misc/ds4510.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,424 @@
+/*
+ * Copyright 2008 Extreme Engineering Solutions, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * Version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Driver for DS4510, a CPU supervisor with integrated EEPROM, SRAM,
+ * and 4 programmable non-volatile GPIO pins.
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <command.h>
+#include <ds4510.h>
+
+/* Default to an address that hopefully won't corrupt other i2c devices */
+#ifndef CONFIG_SYS_I2C_DS4510_ADDR
+#define CONFIG_SYS_I2C_DS4510_ADDR	(~0)
+#endif
+
+enum {
+	DS4510_CMD_INFO,
+	DS4510_CMD_DEVICE,
+	DS4510_CMD_NV,
+	DS4510_CMD_RSTDELAY,
+	DS4510_CMD_OUTPUT,
+	DS4510_CMD_INPUT,
+	DS4510_CMD_PULLUP,
+	DS4510_CMD_EEPROM,
+	DS4510_CMD_SEEPROM,
+	DS4510_CMD_SRAM,
+};
+
+/*
+ * Write to DS4510, taking page boundaries into account
+ */
+int ds4510_mem_write(uint8_t chip, int offset, uint8_t *buf, int count)
+{
+	int wrlen;
+	int i = 0;
+
+	do {
+		wrlen = DS4510_EEPROM_PAGE_SIZE -
+			DS4510_EEPROM_PAGE_OFFSET(offset);
+		if (count < wrlen)
+			wrlen = count;
+		if (i2c_write(chip, offset, 1, &buf[i], wrlen))
+			return -1;
+
+		/*
+		 * This delay isn't needed for SRAM writes but shouldn't delay
+		 * things too much, so do it unconditionally for simplicity
+		 */
+		udelay(DS4510_EEPROM_PAGE_WRITE_DELAY_MS * 1000);
+		count -= wrlen;
+		offset += wrlen;
+		i += wrlen;
+	} while (count > 0);
+
+	return 0;
+}
+
+/*
+ * General read from DS4510
+ */
+int ds4510_mem_read(uint8_t chip, int offset, uint8_t *buf, int count)
+{
+	return i2c_read(chip, offset, 1, buf, count);
+}
+
+/*
+ * Write SEE bit in config register.
+ * nv = 0 - Writes to SEEPROM registers behave like EEPROM
+ * nv = 1 - Writes to SEEPROM registers behave like SRAM
+ */
+int ds4510_see_write(uint8_t chip, uint8_t nv)
+{
+	uint8_t data;
+
+	if (i2c_read(chip, DS4510_CFG, 1, &data, 1))
+		return -1;
+
+	if (nv)	/* Treat SEEPROM bits as EEPROM */
+		data &= ~DS4510_CFG_SEE;
+	else	/* Treat SEEPROM bits as SRAM */
+		data |= DS4510_CFG_SEE;
+
+	return ds4510_mem_write(chip, DS4510_CFG, &data, 1);
+}
+
+/*
+ * Write de-assertion of reset signal delay
+ */
+int ds4510_rstdelay_write(uint8_t chip, uint8_t delay)
+{
+	uint8_t data;
+
+	if (i2c_read(chip, DS4510_RSTDELAY, 1, &data, 1))
+		return -1;
+
+	data &= ~DS4510_RSTDELAY_MASK;
+	data |= delay & DS4510_RSTDELAY_MASK;
+
+	return ds4510_mem_write(chip, DS4510_RSTDELAY, &data, 1);
+}
+
+/*
+ * Write pullup characteristics of IO pins
+ */
+int ds4510_pullup_write(uint8_t chip, uint8_t val)
+{
+	val &= DS4510_IO_MASK;
+
+	return ds4510_mem_write(chip, DS4510_PULLUP, (uint8_t *)&val, 1);
+}
+
+/*
+ * Read pullup characteristics of IO pins
+ */
+int ds4510_pullup_read(uint8_t chip)
+{
+	uint8_t val;
+
+	if (i2c_read(chip, DS4510_PULLUP, 1, &val, 1))
+		return -1;
+
+	return val & DS4510_IO_MASK;
+}
+
+/*
+ * Write drive level of IO pins
+ */
+int ds4510_gpio_write(uint8_t chip, uint8_t val)
+{
+	uint8_t data;
+	int i;
+
+	for (i = 0; i < DS4510_NUM_IO; i++) {
+		if (i2c_read(chip, DS4510_IO0 - i, 1, &data, 1))
+			return -1;
+
+		if (val & (0x1 << i))
+			data |= 0x1;
+		else
+			data &= ~0x1;
+
+		if (ds4510_mem_write(chip, DS4510_IO0 - i, &data, 1))
+			return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Read drive level of IO pins
+ */
+int ds4510_gpio_read(uint8_t chip)
+{
+	uint8_t data;
+	int val = 0;
+	int i;
+
+	for (i = 0; i < DS4510_NUM_IO; i++) {
+		if (i2c_read(chip, DS4510_IO0 - i, 1, &data, 1))
+			return -1;
+
+		if (data & 1)
+			val |= (1 << i);
+	}
+
+	return val;
+}
+
+/*
+ * Read physical level of IO pins
+ */
+int ds4510_gpio_read_val(uint8_t chip)
+{
+	uint8_t val;
+
+	if (i2c_read(chip, DS4510_IO_STATUS, 1, &val, 1))
+		return -1;
+
+	return val & DS4510_IO_MASK;
+}
+
+#ifdef CONFIG_CMD_DS4510
+#ifdef CONFIG_CMD_DS4510_INFO
+/*
+ * Display DS4510 information
+ */
+static int ds4510_info(uint8_t chip)
+{
+	int i;
+	int tmp;
+	uint8_t data;
+
+	printf("DS4510 @ 0x%x:\n\n", chip);
+
+	if (i2c_read(chip, DS4510_RSTDELAY, 1, &data, 1))
+		return -1;
+	printf("rstdelay = 0x%x\n\n", data & DS4510_RSTDELAY_MASK);
+
+	if (i2c_read(chip, DS4510_CFG, 1, &data, 1))
+		return -1;
+	printf("config   = 0x%x\n", data);
+	printf(" /ready  = %d\n", data & DS4510_CFG_READY ? 1 : 0);
+	printf(" trip pt = %d\n", data & DS4510_CFG_TRIP_POINT ? 1 : 0);
+	printf(" rst sts = %d\n", data & DS4510_CFG_RESET ? 1 : 0);
+	printf(" /see    = %d\n", data & DS4510_CFG_SEE ? 1 : 0);
+	printf(" swrst   = %d\n\n", data & DS4510_CFG_SWRST ? 1 : 0);
+
+	printf("gpio pins: 3210\n");
+	printf("---------------\n");
+	printf("pullup     ");
+
+	tmp = ds4510_pullup_read(chip);
+	if (tmp == -1)
+		return tmp;
+	for (i = DS4510_NUM_IO - 1; i >= 0; i--)
+		printf("%d", (tmp & (1 << i)) ? 1 : 0);
+	printf("\n");
+
+	printf("driven     ");
+	tmp = ds4510_gpio_read(chip);
+	if (tmp == -1)
+		return -1;
+	for (i = DS4510_NUM_IO - 1; i >= 0; i--)
+		printf("%d", (tmp & (1 << i)) ? 1 : 0);
+	printf("\n");
+
+	printf("read       ");
+	tmp = ds4510_gpio_read_val(chip);
+	if (tmp == -1)
+		return -1;
+	for (i = DS4510_NUM_IO - 1; i >= 0; i--)
+		printf("%d", (tmp & (1 << i)) ? 1 : 0);
+	printf("\n");
+
+	return 0;
+}
+#endif /* CONFIG_CMD_DS4510_INFO */
+
+cmd_tbl_t cmd_ds4510[] = {
+	U_BOOT_CMD_MKENT(device, 3, 0, (void *)DS4510_CMD_DEVICE, "", ""),
+	U_BOOT_CMD_MKENT(nv, 3, 0, (void *)DS4510_CMD_NV, "", ""),
+	U_BOOT_CMD_MKENT(output, 4, 0, (void *)DS4510_CMD_OUTPUT, "", ""),
+	U_BOOT_CMD_MKENT(input, 3, 0, (void *)DS4510_CMD_INPUT, "", ""),
+	U_BOOT_CMD_MKENT(pullup, 4, 0, (void *)DS4510_CMD_PULLUP, "", ""),
+#ifdef CONFIG_CMD_DS4510_INFO
+	U_BOOT_CMD_MKENT(info, 2, 0, (void *)DS4510_CMD_INFO, "", ""),
+#endif
+#ifdef CONFIG_CMD_DS4510_RST
+	U_BOOT_CMD_MKENT(rstdelay, 3, 0, (void *)DS4510_CMD_RSTDELAY, "", ""),
+#endif
+#ifdef CONFIG_CMD_DS4510_MEM
+	U_BOOT_CMD_MKENT(eeprom, 6, 0, (void *)DS4510_CMD_EEPROM, "", ""),
+	U_BOOT_CMD_MKENT(seeprom, 6, 0, (void *)DS4510_CMD_SEEPROM, "", ""),
+	U_BOOT_CMD_MKENT(sram, 6, 0, (void *)DS4510_CMD_SRAM, "", ""),
+#endif
+};
+
+int do_ds4510(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	static uint8_t chip = CONFIG_SYS_I2C_DS4510_ADDR;
+	cmd_tbl_t *c;
+	ulong ul_arg2 = 0;
+	ulong ul_arg3 = 0;
+	int tmp;
+#ifdef CONFIG_CMD_DS4510_MEM
+	ulong addr;
+	ulong off;
+	ulong cnt;
+	int end;
+	int (*rw_func)(uint8_t, int, uint8_t *, int);
+#endif
+
+	c = find_cmd_tbl(argv[1], cmd_ds4510, ARRAY_SIZE(cmd_ds4510));
+
+	/* All commands but "device" require 'maxargs' arguments */
+	if (!c || !((argc == (c->maxargs)) ||
+		(((int)c->cmd == DS4510_CMD_DEVICE) &&
+		 (argc == (c->maxargs - 1))))) {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+
+	/* arg2 used as chip addr and pin number */
+	if (argc > 2)
+		ul_arg2 = simple_strtoul(argv[2], NULL, 16);
+
+	/* arg3 used as output/pullup value */
+	if (argc > 3)
+		ul_arg3 = simple_strtoul(argv[3], NULL, 16);
+
+	switch ((int)c->cmd) {
+	case DS4510_CMD_DEVICE:
+		if (argc == 3)
+			chip = ul_arg2;
+		printf("Current device address: 0x%x\n", chip);
+		return 0;
+	case DS4510_CMD_NV:
+		return ds4510_see_write(chip, ul_arg2);
+	case DS4510_CMD_OUTPUT:
+		tmp = ds4510_gpio_read(chip);
+		if (tmp == -1)
+			return -1;
+		if (ul_arg3)
+			tmp |= (1 << ul_arg2);
+		else
+			tmp &= ~(1 << ul_arg2);
+		return ds4510_gpio_write(chip, tmp);
+	case DS4510_CMD_INPUT:
+		tmp = ds4510_gpio_read_val(chip);
+		if (tmp == -1)
+			return -1;
+		return (tmp & (1 << ul_arg2)) != 0;
+	case DS4510_CMD_PULLUP:
+		tmp = ds4510_pullup_read(chip);
+		if (tmp == -1)
+			return -1;
+		if (ul_arg3)
+			tmp |= (1 << ul_arg2);
+		else
+			tmp &= ~(1 << ul_arg2);
+		return ds4510_pullup_write(chip, tmp);
+#ifdef CONFIG_CMD_DS4510_INFO
+	case DS4510_CMD_INFO:
+		return ds4510_info(chip);
+#endif
+#ifdef CONFIG_CMD_DS4510_RST
+	case DS4510_CMD_RSTDELAY:
+		return ds4510_rstdelay_write(chip, ul_arg2);
+#endif
+#ifdef CONFIG_CMD_DS4510_MEM
+	case DS4510_CMD_EEPROM:
+		end = DS4510_EEPROM + DS4510_EEPROM_SIZE;
+		off = DS4510_EEPROM;
+		break;
+	case DS4510_CMD_SEEPROM:
+		end = DS4510_SEEPROM + DS4510_SEEPROM_SIZE;
+		off = DS4510_SEEPROM;
+		break;
+	case DS4510_CMD_SRAM:
+		end = DS4510_SRAM + DS4510_SRAM_SIZE;
+		off = DS4510_SRAM;
+		break;
+#endif
+	default:
+		/* We should never get here... */
+		return 1;
+	}
+
+#ifdef CONFIG_CMD_DS4510_MEM
+	/* Only eeprom, seeprom, and sram commands should make it here */
+	if (strcmp(argv[2], "read") == 0) {
+		rw_func = ds4510_mem_read;
+	} else if (strcmp(argv[2], "write") == 0) {
+		rw_func = ds4510_mem_write;
+	} else {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+
+	addr = simple_strtoul(argv[3], NULL, 16);
+	off += simple_strtoul(argv[4], NULL, 16);
+	cnt = simple_strtoul(argv[5], NULL, 16);
+
+	if ((off + cnt) > end) {
+		printf("ERROR: invalid len\n");
+		return -1;
+	}
+
+	return rw_func(chip, off, (uint8_t *)addr, cnt);
+#endif
+}
+
+U_BOOT_CMD(
+	ds4510,	6,	1,	do_ds4510,
+	"ds4510 eeprom/seeprom/sram/gpio access",
+	"device [dev]\n"
+	"	- show or set current device address\n"
+#ifdef CONFIG_CMD_DS4510_INFO
+	"ds4510 info\n"
+	"	- display ds4510 info\n"
+#endif
+	"ds4510 output pin 0|1\n"
+	"	- set pin low or high-Z\n"
+	"ds4510 input pin\n"
+	"	- read value of pin\n"
+	"ds4510 pullup pin 0|1\n"
+	"	- disable/enable pullup on specified pin\n"
+	"ds4510 nv 0|1\n"
+	"	- make gpio and seeprom writes volatile/non-volatile\n"
+#ifdef CONFIG_CMD_DS4510_RST
+	"ds4510 rstdelay 0-3\n"
+	"	- set reset output delay\n"
+#endif
+#ifdef CONFIG_CMD_DS4510_MEM
+	"ds4510 eeprom read addr off cnt\n"
+	"ds4510 eeprom write addr off cnt\n"
+	"	- read/write 'cnt' bytes at EEPROM offset 'off'\n"
+	"ds4510 seeprom read addr off cnt\n"
+	"ds4510 seeprom write addr off cnt\n"
+	"	- read/write 'cnt' bytes at SRAM-shadowed EEPROM offset 'off'\n"
+	"ds4510 sram read addr off cnt\n"
+	"ds4510 sram write addr off cnt\n"
+	"	- read/write 'cnt' bytes at SRAM offset 'off'\n"
+#endif
+);
+#endif /* CONFIG_CMD_DS4510 */
diff -Naur u-boot-2009.01/drivers/misc/fsl_law.c u-boot/drivers/misc/fsl_law.c
--- u-boot-2009.01/drivers/misc/fsl_law.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/misc/fsl_law.c	2009-02-26 14:03:58.000000000 +0100
@@ -38,7 +38,8 @@
       defined(CONFIG_MPC8568) || \
       defined(CONFIG_MPC8641) || defined(CONFIG_MPC8610)
 #define FSL_HW_NUM_LAWS 10
-#elif defined(CONFIG_MPC8536) || defined(CONFIG_MPC8572)
+#elif defined(CONFIG_MPC8536) || defined(CONFIG_MPC8572) || \
+      defined(CONFIG_P2020)
 #define FSL_HW_NUM_LAWS 12
 #else
 #error FSL_HW_NUM_LAWS not defined for this platform
diff -Naur u-boot-2009.01/drivers/misc/Makefile u-boot/drivers/misc/Makefile
--- u-boot-2009.01/drivers/misc/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/misc/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -26,6 +26,7 @@
 LIB	:= $(obj)libmisc.a
 
 COBJS-$(CONFIG_ALI152X) += ali512x.o
+COBJS-$(CONFIG_DS4510)  += ds4510.o
 COBJS-$(CONFIG_FSL_LAW) += fsl_law.o
 COBJS-$(CONFIG_NS87308) += ns87308.o
 COBJS-$(CONFIG_STATUS_LED) += status_led.o
diff -Naur u-boot-2009.01/drivers/mmc/atmel_mci.c u-boot/drivers/mmc/atmel_mci.c
--- u-boot-2009.01/drivers/mmc/atmel_mci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mmc/atmel_mci.c	2009-02-26 14:03:58.000000000 +0100
@@ -463,7 +463,7 @@
 	       dtocyc << shift, dtor);
 }
 
-int mmc_init(int verbose)
+int mmc_legacy_init(int verbose)
 {
 	struct mmc_cid cid;
 	struct mmc_csd csd;
@@ -531,18 +531,3 @@
 
 	return 0;
 }
-
-int mmc_read(ulong src, uchar *dst, int size)
-{
-	return -ENOSYS;
-}
-
-int mmc_write(uchar *src, ulong dst, int size)
-{
-	return -ENOSYS;
-}
-
-int mmc2info(ulong addr)
-{
-	return 0;
-}
diff -Naur u-boot-2009.01/drivers/mmc/bfin_sdh.c u-boot/drivers/mmc/bfin_sdh.c
--- u-boot-2009.01/drivers/mmc/bfin_sdh.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/mmc/bfin_sdh.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,546 @@
+/*
+ * Driver for Blackfin on-chip SDH controller
+ *
+ * Copyright (c) 2008 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <part.h>
+#include <mmc.h>
+
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <asm/byteorder.h>
+#include <asm/blackfin.h>
+#include <asm/mach-common/bits/sdh.h>
+#include <asm/mach-common/bits/dma.h>
+
+#include "bfin_sdh.h"
+
+/* SD_CLK frequency must be less than 400k in identification mode */
+#ifndef CONFIG_SYS_MMC_CLK_ID
+#define CONFIG_SYS_MMC_CLK_ID		200000
+#endif
+/* SD_CLK for normal working */
+#ifndef CONFIG_SYS_MMC_CLK_OP
+#define CONFIG_SYS_MMC_CLK_OP		25000000
+#endif
+/* support 3.2-3.3V and 3.3-3.4V */
+#define CONFIG_SYS_MMC_OP_COND		0x00300000
+#define MMC_DEFAULT_RCA		1
+
+#if defined(__ADSPBF51x__)
+# define bfin_read_SDH_PWR_CTL		bfin_read_RSI_PWR_CONTROL
+# define bfin_write_SDH_PWR_CTL		bfin_write_RSI_PWR_CONTROL
+# define bfin_read_SDH_CLK_CTL		bfin_read_RSI_CLK_CONTROL
+# define bfin_write_SDH_CLK_CTL		bfin_write_RSI_CLK_CONTROL
+# define bfin_write_SDH_ARGUMENT	bfin_write_RSI_ARGUMENT
+# define bfin_write_SDH_COMMAND		bfin_write_RSI_COMMAND
+# define bfin_read_SDH_RESPONSE0	bfin_read_RSI_RESPONSE0
+# define bfin_read_SDH_RESPONSE1	bfin_read_RSI_RESPONSE1
+# define bfin_read_SDH_RESPONSE2	bfin_read_RSI_RESPONSE2
+# define bfin_read_SDH_RESPONSE3	bfin_read_RSI_RESPONSE3
+# define bfin_write_SDH_DATA_TIMER	bfin_write_RSI_DATA_TIMER
+# define bfin_write_SDH_DATA_LGTH	bfin_write_RSI_DATA_LGTH
+# define bfin_read_SDH_DATA_CTL		bfin_read_RSI_DATA_CONTROL
+# define bfin_write_SDH_DATA_CTL	bfin_write_RSI_DATA_CONTROL
+# define bfin_read_SDH_STATUS		bfin_read_RSI_STATUS
+# define bfin_write_SDH_STATUS_CLR 	bfin_write_RSI_STATUSCL
+# define bfin_read_SDH_CFG		bfin_read_RSI_CONFIG
+# define bfin_write_SDH_CFG		bfin_write_RSI_CONFIG
+# define bfin_write_DMA_START_ADDR	bfin_write_DMA4_START_ADDR
+# define bfin_write_DMA_X_COUNT		bfin_write_DMA4_X_COUNT
+# define bfin_write_DMA_X_MODIFY	bfin_write_DMA4_X_MODIFY
+# define bfin_write_DMA_CONFIG		bfin_write_DMA4_CONFIG
+#elif defined(__ADSPBF54x__)
+# define bfin_write_DMA_START_ADDR	bfin_write_DMA22_START_ADDR
+# define bfin_write_DMA_X_COUNT		bfin_write_DMA22_X_COUNT
+# define bfin_write_DMA_X_MODIFY	bfin_write_DMA22_X_MODIFY
+# define bfin_write_DMA_CONFIG		bfin_write_DMA22_CONFIG
+#else
+# error no support for this proc yet
+#endif
+
+static unsigned int mmc_rca;
+static int mmc_card_is_sd;
+static block_dev_desc_t mmc_blkdev;
+struct mmc_cid cid;
+static __u32 csd[4];
+
+#define get_bits(resp, start, size)					\
+	({								\
+		const int __size = size;				\
+		const uint32_t __mask = (__size < 32 ? 1 << __size : 0) - 1;	\
+		const int32_t __off = 3 - ((start) / 32);			\
+		const int32_t __shft = (start) & 31;			\
+		uint32_t __res;						\
+									\
+		__res = resp[__off] >> __shft;				\
+		if (__size + __shft > 32)				\
+			__res |= resp[__off-1] << ((32 - __shft) % 32);	\
+		__res & __mask;						\
+	})
+
+
+block_dev_desc_t *mmc_get_dev(int dev)
+{
+	return &mmc_blkdev;
+}
+
+static void mci_set_clk(unsigned long clk)
+{
+	unsigned long sys_clk;
+	unsigned long clk_div;
+	__u16 clk_ctl = 0;
+
+	/* setting SD_CLK */
+	sys_clk = get_sclk();
+	bfin_write_SDH_CLK_CTL(0);
+	if (sys_clk % (2 * clk) == 0)
+		clk_div = sys_clk / (2 * clk) - 1;
+	else
+		clk_div = sys_clk / (2 * clk);
+
+	if (clk_div > 0xff)
+		clk_div = 0xff;
+	clk_ctl |= (clk_div & 0xff);
+	clk_ctl |= CLK_E;
+	bfin_write_SDH_CLK_CTL(clk_ctl);
+}
+
+static int
+mmc_cmd(unsigned long cmd, unsigned long arg, void *resp, unsigned long flags)
+{
+	unsigned int sdh_cmd;
+	unsigned int status;
+	int ret = 0;
+	sdh_cmd = 0;
+	unsigned long *response = resp;
+	sdh_cmd |= cmd;
+
+	if (flags & MMC_RSP_PRESENT)
+		sdh_cmd |= CMD_RSP;
+
+	if (flags & MMC_RSP_136)
+		sdh_cmd |= CMD_L_RSP;
+
+	bfin_write_SDH_ARGUMENT(arg);
+	bfin_write_SDH_COMMAND(sdh_cmd | CMD_E);
+
+	/* wait for a while */
+	do {
+		udelay(1);
+		status = bfin_read_SDH_STATUS();
+	} while (!(status & (CMD_SENT | CMD_RESP_END | CMD_TIME_OUT |
+		CMD_CRC_FAIL)));
+
+	if (flags & MMC_RSP_PRESENT) {
+		response[0] = bfin_read_SDH_RESPONSE0();
+		if (flags & MMC_RSP_136) {
+			response[1] = bfin_read_SDH_RESPONSE1();
+			response[2] = bfin_read_SDH_RESPONSE2();
+			response[3] = bfin_read_SDH_RESPONSE3();
+		}
+	}
+
+	if (status & CMD_TIME_OUT) {
+		printf("CMD%d timeout\n", (int)cmd);
+		ret |= -ETIMEDOUT;
+	} else if (status & CMD_CRC_FAIL && flags & MMC_RSP_CRC) {
+		printf("CMD%d CRC failure\n", (int)cmd);
+		ret |= -EILSEQ;
+	}
+	bfin_write_SDH_STATUS_CLR(CMD_SENT_STAT | CMD_RESP_END_STAT |
+				CMD_TIMEOUT_STAT | CMD_CRC_FAIL_STAT);
+	return ret;
+}
+
+static int
+mmc_acmd(unsigned long cmd, unsigned long arg, void *resp, unsigned long flags)
+{
+	unsigned long aresp[4];
+	int ret = 0;
+
+	ret = mmc_cmd(MMC_CMD_APP_CMD, 0, aresp,
+		      MMC_RSP_PRESENT);
+	if (ret)
+		return ret;
+
+	if ((aresp[0] & (ILLEGAL_COMMAND | APP_CMD)) != APP_CMD)
+		return -ENODEV;
+	ret = mmc_cmd(cmd, arg, resp, flags);
+	return ret;
+}
+
+static unsigned long
+mmc_bread(int dev, unsigned long start, lbaint_t blkcnt, void *buffer)
+{
+	int ret, i;
+	unsigned long resp[4];
+	unsigned long card_status;
+	__u8 *buf = buffer;
+	__u32 status;
+	__u16 data_ctl = 0;
+	__u16 dma_cfg = 0;
+
+	if (blkcnt == 0)
+		return 0;
+	debug("mmc_bread: dev %d, start %d, blkcnt %d\n", dev, start, blkcnt);
+	/* Force to use 512-byte block,because a lot of code depends on this */
+	data_ctl |= 9 << 4;
+	data_ctl |= DTX_DIR;
+	bfin_write_SDH_DATA_CTL(data_ctl);
+	dma_cfg |= WDSIZE_32 | RESTART | WNR | DMAEN;
+
+	/* FIXME later */
+	bfin_write_SDH_DATA_TIMER(0xFFFFFFFF);
+	for (i = 0; i < blkcnt; ++i, ++start) {
+		blackfin_dcache_flush_invalidate_range(buf + i * mmc_blkdev.blksz,
+			buf + (i + 1) * mmc_blkdev.blksz);
+		bfin_write_DMA_START_ADDR(buf + i * mmc_blkdev.blksz);
+		bfin_write_DMA_X_COUNT(mmc_blkdev.blksz / 4);
+		bfin_write_DMA_X_MODIFY(4);
+		bfin_write_DMA_CONFIG(dma_cfg);
+		bfin_write_SDH_DATA_LGTH(mmc_blkdev.blksz);
+		/* Put the device into Transfer state */
+		ret = mmc_cmd(MMC_CMD_SELECT_CARD, mmc_rca << 16, resp, MMC_RSP_R1);
+		if (ret) {
+			printf("MMC_CMD_SELECT_CARD failed\n");
+			goto out;
+		}
+		/* Set block length */
+		ret = mmc_cmd(MMC_CMD_SET_BLOCKLEN, mmc_blkdev.blksz, resp, MMC_RSP_R1);
+		if (ret) {
+			printf("MMC_CMD_SET_BLOCKLEN failed\n");
+			goto out;
+		}
+		ret = mmc_cmd(MMC_CMD_READ_SINGLE_BLOCK,
+			      start * mmc_blkdev.blksz, resp,
+			      MMC_RSP_R1);
+		if (ret) {
+			printf("MMC_CMD_READ_SINGLE_BLOCK failed\n");
+			goto out;
+		}
+		bfin_write_SDH_DATA_CTL(bfin_read_SDH_DATA_CTL() | DTX_DMA_E | DTX_E);
+
+		do {
+			udelay(1);
+			status = bfin_read_SDH_STATUS();
+		} while (!(status & (DAT_BLK_END | DAT_END | DAT_TIME_OUT | DAT_CRC_FAIL | RX_OVERRUN)));
+
+		if (status & (DAT_TIME_OUT | DAT_CRC_FAIL | RX_OVERRUN)) {
+			bfin_write_SDH_STATUS_CLR(DAT_TIMEOUT_STAT | \
+				DAT_CRC_FAIL_STAT | RX_OVERRUN_STAT);
+			goto read_error;
+		} else {
+			bfin_write_SDH_STATUS_CLR(DAT_BLK_END_STAT | DAT_END_STAT);
+			mmc_cmd(MMC_CMD_SELECT_CARD, 0, resp, 0);
+		}
+	}
+ out:
+
+	return i;
+
+ read_error:
+	mmc_cmd(MMC_CMD_SEND_STATUS, mmc_rca << 16, &card_status, MMC_RSP_R1);
+	printf("mmc: bread failed, status = %08x, card status = %08lx\n",
+	       status, card_status);
+	goto out;
+}
+
+static unsigned long
+mmc_bwrite(int dev, unsigned long start, lbaint_t blkcnt, const void *buffer)
+{
+	int ret, i = 0;
+	unsigned long resp[4];
+	unsigned long card_status;
+	const __u8 *buf = buffer;
+	__u32 status;
+	__u16 data_ctl = 0;
+	__u16 dma_cfg = 0;
+
+	if (blkcnt == 0)
+		return 0;
+
+	debug("mmc_bwrite: dev %d, start %lx, blkcnt %lx\n",
+		 dev, start, blkcnt);
+	/* Force to use 512-byte block,because a lot of code depends on this */
+	data_ctl |= 9 << 4;
+	data_ctl &= ~DTX_DIR;
+	bfin_write_SDH_DATA_CTL(data_ctl);
+	dma_cfg |= WDSIZE_32 | RESTART | DMAEN;
+	/* FIXME later */
+	bfin_write_SDH_DATA_TIMER(0xFFFFFFFF);
+	for (i = 0; i < blkcnt; ++i, ++start) {
+		bfin_write_DMA_START_ADDR(buf + i * mmc_blkdev.blksz);
+		bfin_write_DMA_X_COUNT(mmc_blkdev.blksz / 4);
+		bfin_write_DMA_X_MODIFY(4);
+		bfin_write_DMA_CONFIG(dma_cfg);
+		bfin_write_SDH_DATA_LGTH(mmc_blkdev.blksz);
+
+		/* Put the device into Transfer state */
+		ret = mmc_cmd(MMC_CMD_SELECT_CARD, mmc_rca << 16, resp, MMC_RSP_R1);
+		if (ret) {
+			printf("MMC_CMD_SELECT_CARD failed\n");
+			goto out;
+		}
+		/* Set block length */
+		ret = mmc_cmd(MMC_CMD_SET_BLOCKLEN, mmc_blkdev.blksz, resp, MMC_RSP_R1);
+		if (ret) {
+			printf("MMC_CMD_SET_BLOCKLEN failed\n");
+			goto out;
+		}
+		ret = mmc_cmd(MMC_CMD_WRITE_BLOCK,
+			      start * mmc_blkdev.blksz, resp,
+			      MMC_RSP_R1);
+		if (ret) {
+			printf("MMC_CMD_WRITE_SINGLE_BLOCK failed\n");
+			goto out;
+		}
+		bfin_write_SDH_DATA_CTL(bfin_read_SDH_DATA_CTL() | DTX_DMA_E | DTX_E);
+
+		do {
+			udelay(1);
+			status = bfin_read_SDH_STATUS();
+		} while (!(status & (DAT_BLK_END | DAT_END | DAT_TIME_OUT | DAT_CRC_FAIL | TX_UNDERRUN)));
+
+		if (status & (DAT_TIME_OUT | DAT_CRC_FAIL | TX_UNDERRUN)) {
+			bfin_write_SDH_STATUS_CLR(DAT_TIMEOUT_STAT |
+				DAT_CRC_FAIL_STAT | TX_UNDERRUN_STAT);
+			goto write_error;
+		} else {
+			bfin_write_SDH_STATUS_CLR(DAT_BLK_END_STAT | DAT_END_STAT);
+			mmc_cmd(MMC_CMD_SELECT_CARD, 0, resp, 0);
+		}
+	}
+ out:
+	return i;
+
+ write_error:
+	mmc_cmd(MMC_CMD_SEND_STATUS, mmc_rca << 16, &card_status, MMC_RSP_R1);
+	printf("mmc: bwrite failed, status = %08x, card status = %08lx\n",
+	       status, card_status);
+	goto out;
+}
+
+static void mmc_parse_cid(struct mmc_cid *cid, unsigned long *resp)
+{
+	cid->mid = resp[0] >> 24;
+	cid->oid = (resp[0] >> 8) & 0xffff;
+	cid->pnm[0] = resp[0];
+	cid->pnm[1] = resp[1] >> 24;
+	cid->pnm[2] = resp[1] >> 16;
+	cid->pnm[3] = resp[1] >> 8;
+	cid->pnm[4] = resp[1];
+	cid->pnm[5] = resp[2] >> 24;
+	cid->pnm[6] = 0;
+	cid->prv = resp[2] >> 16;
+	cid->psn = (resp[2] << 16) | (resp[3] >> 16);
+	cid->mdt = resp[3] >> 8;
+}
+
+static void sd_parse_cid(struct mmc_cid *cid, unsigned long *resp)
+{
+	cid->mid = resp[0] >> 24;
+	cid->oid = (resp[0] >> 8) & 0xffff;
+	cid->pnm[0] = resp[0];
+	cid->pnm[1] = resp[1] >> 24;
+	cid->pnm[2] = resp[1] >> 16;
+	cid->pnm[3] = resp[1] >> 8;
+	cid->pnm[4] = resp[1];
+	cid->pnm[5] = 0;
+	cid->pnm[6] = 0;
+	cid->prv = resp[2] >> 24;
+	cid->psn = (resp[2] << 8) | (resp[3] >> 24);
+	cid->mdt = (resp[3] >> 8) & 0x0fff;
+}
+
+static void mmc_dump_cid(const struct mmc_cid *cid)
+{
+	printf("CID information:\n");
+	printf("Manufacturer ID:       %02X\n", cid->mid);
+	printf("OEM/Application ID:    %04X\n", cid->oid);
+	printf("Product name:          %s\n", cid->pnm);
+	printf("Product Revision:      %u.%u\n",
+	       cid->prv >> 4, cid->prv & 0x0f);
+	printf("Product Serial Number: %lu\n", cid->psn);
+	printf("Manufacturing Date:    %02u/%02u\n",
+	       cid->mdt >> 4, cid->mdt & 0x0f);
+}
+
+static void mmc_dump_csd(__u32 *csd)
+{
+	printf("CSD information:\n");
+	printf("CSD structure version:   1.%u\n", get_bits(csd, 126, 2));
+	printf("Card command classes:    %03x\n", get_bits(csd, 84, 12));
+	printf("Max trans speed: %s\n", (get_bits(csd, 96, 8) == 0x32) ? "25MHz" : "50MHz");
+	printf("Read block length:       %d\n", 1 << get_bits(csd, 80, 4));
+	printf("Write block length:      %u\n", 1 << get_bits(csd, 22, 4));
+	printf("Card capacity:		%u bytes\n",
+	       (get_bits(csd, 62, 12) + 1) * (1 << (get_bits(csd, 47, 3) + 2)) *
+	       (1 << get_bits(csd, 80, 4)));
+	putc('\n');
+}
+
+static int mmc_idle_cards(void)
+{
+	int ret = 0;
+
+	/* Reset all cards */
+	ret = mmc_cmd(MMC_CMD_GO_IDLE_STATE, 0, NULL, 0);
+	if (ret)
+		return ret;
+	udelay(500);
+	return mmc_cmd(MMC_CMD_GO_IDLE_STATE, 0, NULL, 0);
+}
+
+static int sd_init_card(struct mmc_cid *cid, int verbose)
+{
+	unsigned long resp[4];
+	int i, ret = 0;
+
+	mmc_idle_cards();
+	for (i = 0; i < 1000; ++i) {
+		ret = mmc_acmd(SD_CMD_APP_SEND_OP_COND, CONFIG_SYS_MMC_OP_COND,
+			       resp, MMC_RSP_R3);
+		if (ret || (resp[0] & 0x80000000))
+			break;
+		ret = -ETIMEDOUT;
+	}
+	if (ret)
+		return ret;
+
+	ret = mmc_cmd(MMC_CMD_ALL_SEND_CID, 0, resp, MMC_RSP_R2);
+	if (ret)
+		return ret;
+	sd_parse_cid(cid, resp);
+	if (verbose)
+		mmc_dump_cid(cid);
+
+	/* Get RCA of the card that responded */
+	ret = mmc_cmd(SD_CMD_SEND_RELATIVE_ADDR, 0, resp, MMC_RSP_R6);
+	if (ret)
+		return ret;
+
+	mmc_rca = (resp[0] >> 16) & 0xffff;
+	if (verbose)
+		printf("SD Card detected (RCA %u)\n", mmc_rca);
+	mmc_card_is_sd = 1;
+	return 0;
+}
+
+static int mmc_init_card(struct mmc_cid *cid, int verbose)
+{
+	unsigned long resp[4];
+	int i, ret = 0;
+
+	mmc_idle_cards();
+	for (i = 0; i < 1000; ++i) {
+		ret = mmc_cmd(MMC_CMD_SEND_OP_COND, CONFIG_SYS_MMC_OP_COND, resp,
+			      MMC_RSP_R3);
+		if (ret || (resp[0] & 0x80000000))
+			break;
+		ret = -ETIMEDOUT;
+	}
+	if (ret)
+		return ret;
+
+	/* Get CID of all cards. FIXME: Support more than one card */
+	ret = mmc_cmd(MMC_CMD_ALL_SEND_CID, 0, resp, MMC_RSP_R2);
+	if (ret)
+		return ret;
+	mmc_parse_cid(cid, resp);
+	if (verbose)
+		mmc_dump_cid(cid);
+
+	/* Set Relative Address of the card that responded */
+	ret = mmc_cmd(MMC_CMD_SET_RELATIVE_ADDR, mmc_rca << 16, resp,
+		      MMC_RSP_R1);
+	return ret;
+}
+
+int mmc_init(int verbose)
+{
+	__u16 pwr_ctl = 0;
+	int ret;
+	unsigned int max_blksz;
+	/* Initialize sdh controller */
+#if defined(__ADSPBF54x__)
+	bfin_write_DMAC1_PERIMUX(bfin_read_DMAC1_PERIMUX() | 0x1);
+	bfin_write_PORTC_FER(bfin_read_PORTC_FER() | 0x3F00);
+	bfin_write_PORTC_MUX(bfin_read_PORTC_MUX() & ~0xFFF0000);
+#elif defined(__ADSPBF51x__)
+	bfin_write_PORTG_FER(bfin_read_PORTG_FER() | 0x01F8);
+	bfin_write_PORTG_MUX((bfin_read_PORTG_MUX() & ~0x3FC) | 0x154);
+#else
+# error no portmux for this proc yet
+#endif
+	bfin_write_SDH_CFG(bfin_read_SDH_CFG() | CLKS_EN);
+	/* Disable card detect pin */
+	bfin_write_SDH_CFG((bfin_read_SDH_CFG() & 0x1F) | 0x60);
+	mci_set_clk(CONFIG_SYS_MMC_CLK_ID);
+	/* setting power control */
+	pwr_ctl |= ROD_CTL;
+	pwr_ctl |= PWR_ON;
+	bfin_write_SDH_PWR_CTL(pwr_ctl);
+	mmc_card_is_sd = 0;
+	ret = sd_init_card(&cid, verbose);
+	if (ret) {
+		mmc_rca = MMC_DEFAULT_RCA;
+		ret = mmc_init_card(&cid, verbose);
+	}
+	if (ret)
+		return ret;
+	/* Get CSD from the card */
+	ret = mmc_cmd(MMC_CMD_SEND_CSD, mmc_rca << 16, csd, MMC_RSP_R2);
+	if (ret)
+		return ret;
+	if (verbose)
+		mmc_dump_csd(csd);
+	/* Initialize the blockdev structure */
+	mmc_blkdev.if_type = IF_TYPE_MMC;
+	mmc_blkdev.part_type = PART_TYPE_DOS;
+	mmc_blkdev.block_read = mmc_bread;
+	mmc_blkdev.block_write = mmc_bwrite;
+	sprintf(mmc_blkdev.vendor,
+		"Man %02x%04x Snr %08lx",
+		cid.mid, cid.oid, cid.psn);
+	strncpy(mmc_blkdev.product, cid.pnm,
+		sizeof(mmc_blkdev.product));
+	sprintf(mmc_blkdev.revision, "%x %x",
+		cid.prv >> 4, cid.prv & 0x0f);
+
+	max_blksz = 1 << get_bits(csd, 80, 4);
+	/*
+	 * If we can't use 512 byte blocks, refuse to deal with the
+	 * card. Tons of code elsewhere seems to depend on this.
+	 */
+	if (max_blksz < 512 || (max_blksz > 512 && !get_bits(csd, 79, 1))) {
+		printf("Card does not support 512 byte reads, aborting.\n");
+		return -ENODEV;
+	}
+
+	mmc_blkdev.blksz = 512;
+	mmc_blkdev.lba = (get_bits(csd, 62, 12) + 1) * (1 << (get_bits(csd, 47, 3) + 2));
+	mci_set_clk(CONFIG_SYS_MMC_CLK_OP);
+	init_part(&mmc_blkdev);
+	return 0;
+}
+
+int mmc_read(ulong src, uchar *dst, int size)
+{
+	return -ENOSYS;
+}
+
+int mmc_write(uchar *src, ulong dst, int size)
+{
+	return -ENOSYS;
+}
+
+int mmc2info(ulong addr)
+{
+	return 0;
+}
diff -Naur u-boot-2009.01/drivers/mmc/bfin_sdh.h u-boot/drivers/mmc/bfin_sdh.h
--- u-boot-2009.01/drivers/mmc/bfin_sdh.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/mmc/bfin_sdh.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2008 Analog Device Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __BLACKFIN_SDH_H__
+#define __BLACKFIN_SDH_H__
+
+#define MMC_RSP_PRESENT	(1 << 0)
+#define MMC_RSP_136	(1 << 1)		/* 136 bit response */
+#define MMC_RSP_CRC	(1 << 2)		/* expect valid crc */
+#define MMC_RSP_BUSY	(1 << 3)		/* card may send busy */
+#define MMC_RSP_OPCODE	(1 << 4)		/* response contains opcode */
+
+#define MMC_CMD_MASK	(3 << 5)		/* non-SPI command type */
+#define MMC_CMD_AC	(0 << 5)
+#define MMC_CMD_ADTC	(1 << 5)
+#define MMC_CMD_BC	(2 << 5)
+#define MMC_CMD_BCR	(3 << 5)
+
+#define MMC_RSP_SPI_S1	(1 << 7)		/* one status byte */
+#define MMC_RSP_SPI_S2	(1 << 8)		/* second byte */
+#define MMC_RSP_SPI_B4	(1 << 9)		/* four data bytes */
+#define MMC_RSP_SPI_BUSY (1 << 10)		/* card may send busy */
+
+/*
+ * These are the native response types, and correspond to valid bit
+ * patterns of the above flags.  One additional valid pattern
+ * is all zeros, which means we don't expect a response.
+ */
+#define MMC_RSP_NONE	(0)
+#define MMC_RSP_R1	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R1B	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE|MMC_RSP_BUSY)
+#define MMC_RSP_R2	(MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
+#define MMC_RSP_R3	(MMC_RSP_PRESENT)
+#define MMC_RSP_R4	(MMC_RSP_PRESENT)
+#define MMC_RSP_R5	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R7	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define ILLEGAL_COMMAND  (1 << 22)
+#define APP_CMD		 (1 << 5)
+
+#endif
diff -Naur u-boot-2009.01/drivers/mmc/fsl_esdhc.c u-boot/drivers/mmc/fsl_esdhc.c
--- u-boot-2009.01/drivers/mmc/fsl_esdhc.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/mmc/fsl_esdhc.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,348 @@
+/*
+ * Copyright 2007, Freescale Semiconductor, Inc
+ * Andy Fleming
+ *
+ * Based vaguely on the pxa mmc code:
+ * (C) Copyright 2003
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <mmc.h>
+#include <part.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/io.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct fsl_esdhc {
+	uint	dsaddr;
+	uint	blkattr;
+	uint	cmdarg;
+	uint	xfertyp;
+	uint	cmdrsp0;
+	uint	cmdrsp1;
+	uint	cmdrsp2;
+	uint	cmdrsp3;
+	uint	datport;
+	uint	prsstat;
+	uint	proctl;
+	uint	sysctl;
+	uint	irqstat;
+	uint	irqstaten;
+	uint	irqsigen;
+	uint	autoc12err;
+	uint	hostcapblt;
+	uint	wml;
+	char	reserved1[8];
+	uint	fevt;
+	char	reserved2[168];
+	uint	hostver;
+	char	reserved3[780];
+	uint	scr;
+};
+
+/* Return the XFERTYP flags for a given command and data packet */
+uint esdhc_xfertyp(struct mmc_cmd *cmd, struct mmc_data *data)
+{
+	uint xfertyp = 0;
+
+	if (data) {
+		xfertyp |= XFERTYP_DPSEL | XFERTYP_DMAEN;
+
+		if (data->blocks > 1) {
+			xfertyp |= XFERTYP_MSBSEL;
+			xfertyp |= XFERTYP_BCEN;
+		}
+
+		if (data->flags & MMC_DATA_READ)
+			xfertyp |= XFERTYP_DTDSEL;
+	}
+
+	if (cmd->resp_type & MMC_RSP_CRC)
+		xfertyp |= XFERTYP_CCCEN;
+	if (cmd->resp_type & MMC_RSP_OPCODE)
+		xfertyp |= XFERTYP_CICEN;
+	if (cmd->resp_type & MMC_RSP_136)
+		xfertyp |= XFERTYP_RSPTYP_136;
+	else if (cmd->resp_type & MMC_RSP_BUSY)
+		xfertyp |= XFERTYP_RSPTYP_48_BUSY;
+	else if (cmd->resp_type & MMC_RSP_PRESENT)
+		xfertyp |= XFERTYP_RSPTYP_48;
+
+	return XFERTYP_CMD(cmd->cmdidx) | xfertyp;
+}
+
+static int esdhc_setup_data(struct mmc *mmc, struct mmc_data *data)
+{
+	uint wml_value;
+	int timeout;
+	struct fsl_esdhc *regs = mmc->priv;
+
+	wml_value = data->blocksize/4;
+
+	if (data->flags & MMC_DATA_READ) {
+		if (wml_value > 0x10)
+			wml_value = 0x10;
+
+		wml_value = 0x100000 | wml_value;
+
+		out_be32(&regs->dsaddr, (u32)data->dest);
+	} else {
+		if (wml_value > 0x80)
+			wml_value = 0x80;
+		if ((in_be32(&regs->prsstat) & PRSSTAT_WPSPL) == 0) {
+			printf("\nThe SD card is locked. Can not write to a locked card.\n\n");
+			return TIMEOUT;
+		}
+		wml_value = wml_value << 16 | 0x10;
+		out_be32(&regs->dsaddr, (u32)data->src);
+	}
+
+	out_be32(&regs->wml, wml_value);
+
+	out_be32(&regs->blkattr, data->blocks << 16 | data->blocksize);
+
+	/* Calculate the timeout period for data transactions */
+	timeout = __ilog2(mmc->tran_speed/10);
+	timeout -= 13;
+
+	if (timeout > 14)
+		timeout = 14;
+
+	if (timeout < 0)
+		timeout = 0;
+
+	clrsetbits_be32(&regs->sysctl, SYSCTL_TIMEOUT_MASK, timeout << 16);
+
+	return 0;
+}
+
+
+/*
+ * Sends a command out on the bus.  Takes the mmc pointer,
+ * a command pointer, and an optional data pointer.
+ */
+static int
+esdhc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
+{
+	uint	xfertyp;
+	uint	irqstat;
+	volatile struct fsl_esdhc *regs = mmc->priv;
+
+	out_be32(&regs->irqstat, -1);
+
+	sync();
+
+	/* Wait for the bus to be idle */
+	while ((in_be32(&regs->prsstat) & PRSSTAT_CICHB) ||
+			(in_be32(&regs->prsstat) & PRSSTAT_CIDHB));
+
+	while (in_be32(&regs->prsstat) & PRSSTAT_DLA);
+
+	/* Wait at least 8 SD clock cycles before the next command */
+	/*
+	 * Note: This is way more than 8 cycles, but 1ms seems to
+	 * resolve timing issues with some cards
+	 */
+	udelay(1000);
+
+	/* Set up for a data transfer if we have one */
+	if (data) {
+		int err;
+
+		err = esdhc_setup_data(mmc, data);
+		if(err)
+			return err;
+	}
+
+	/* Figure out the transfer arguments */
+	xfertyp = esdhc_xfertyp(cmd, data);
+
+	/* Send the command */
+	out_be32(&regs->cmdarg, cmd->cmdarg);
+	out_be32(&regs->xfertyp, xfertyp);
+
+	/* Wait for the command to complete */
+	while (!(in_be32(&regs->irqstat) & IRQSTAT_CC));
+
+	irqstat = in_be32(&regs->irqstat);
+	out_be32(&regs->irqstat, irqstat);
+
+	if (irqstat & CMD_ERR)
+		return COMM_ERR;
+
+	if (irqstat & IRQSTAT_CTOE)
+		return TIMEOUT;
+
+	/* Copy the response to the response buffer */
+	if (cmd->resp_type & MMC_RSP_136) {
+		u32 cmdrsp3, cmdrsp2, cmdrsp1, cmdrsp0;
+
+		cmdrsp3 = in_be32(&regs->cmdrsp3);
+		cmdrsp2 = in_be32(&regs->cmdrsp2);
+		cmdrsp1 = in_be32(&regs->cmdrsp1);
+		cmdrsp0 = in_be32(&regs->cmdrsp0);
+		((uint *)(cmd->response))[0] = (cmdrsp3 << 8) | (cmdrsp2 >> 24);
+		((uint *)(cmd->response))[1] = (cmdrsp2 << 8) | (cmdrsp1 >> 24);
+		((uint *)(cmd->response))[2] = (cmdrsp1 << 8) | (cmdrsp0 >> 24);
+		((uint *)(cmd->response))[3] = (cmdrsp0 << 8);
+	} else
+		((uint *)(cmd->response))[0] = in_be32(&regs->cmdrsp0);
+
+	/* Wait until all of the blocks are transferred */
+	if (data) {
+		do {
+			irqstat = in_be32(&regs->irqstat);
+
+			if (irqstat & DATA_ERR)
+				return COMM_ERR;
+
+			if (irqstat & IRQSTAT_DTOE)
+				return TIMEOUT;
+		} while (!(irqstat & IRQSTAT_TC) &&
+				(in_be32(&regs->prsstat) & PRSSTAT_DLA));
+	}
+
+	out_be32(&regs->irqstat, -1);
+
+	return 0;
+}
+
+void set_sysctl(struct mmc *mmc, uint clock)
+{
+	int sdhc_clk = gd->sdhc_clk;
+	int div, pre_div;
+	volatile struct fsl_esdhc *regs = mmc->priv;
+	uint clk;
+
+	if (sdhc_clk / 16 > clock) {
+		for (pre_div = 2; pre_div < 256; pre_div *= 2)
+			if ((sdhc_clk / pre_div) <= (clock * 16))
+				break;
+	} else
+		pre_div = 2;
+
+	for (div = 1; div <= 16; div++)
+		if ((sdhc_clk / (div * pre_div)) <= clock)
+			break;
+
+	pre_div >>= 1;
+	div -= 1;
+
+	clk = (pre_div << 8) | (div << 4);
+
+	clrsetbits_be32(&regs->sysctl, SYSCTL_CLOCK_MASK, clk);
+
+	udelay(10000);
+
+	setbits_be32(&regs->sysctl, SYSCTL_PEREN);
+}
+
+static void esdhc_set_ios(struct mmc *mmc)
+{
+	struct fsl_esdhc *regs = mmc->priv;
+
+	/* Set the clock speed */
+	set_sysctl(mmc, mmc->clock);
+
+	/* Set the bus width */
+	clrbits_be32(&regs->proctl, PROCTL_DTW_4 | PROCTL_DTW_8);
+
+	if (mmc->bus_width == 4)
+		setbits_be32(&regs->proctl, PROCTL_DTW_4);
+	else if (mmc->bus_width == 8)
+		setbits_be32(&regs->proctl, PROCTL_DTW_8);
+}
+
+static int esdhc_init(struct mmc *mmc)
+{
+	struct fsl_esdhc *regs = mmc->priv;
+	int timeout = 1000;
+
+	/* Enable cache snooping */
+	out_be32(&regs->scr, 0x00000040);
+
+	out_be32(&regs->sysctl, SYSCTL_HCKEN | SYSCTL_IPGEN);
+
+	/* Set the initial clock speed */
+	set_sysctl(mmc, 400000);
+
+	/* Disable the BRR and BWR bits in IRQSTAT */
+	clrbits_be32(&regs->irqstaten, IRQSTATEN_BRR | IRQSTATEN_BWR);
+
+	/* Put the PROCTL reg back to the default */
+	out_be32(&regs->proctl, PROCTL_INIT);
+
+	while (!(in_be32(&regs->prsstat) & PRSSTAT_CINS) && --timeout)
+		udelay(1000);
+
+	if (timeout <= 0)
+		return NO_CARD_ERR;
+
+	return 0;
+}
+
+static int esdhc_initialize(bd_t *bis)
+{
+	struct fsl_esdhc *regs = (struct fsl_esdhc *)CONFIG_SYS_FSL_ESDHC_ADDR;
+	struct mmc *mmc;
+	u32 caps;
+
+	mmc = malloc(sizeof(struct mmc));
+
+	sprintf(mmc->name, "FSL_ESDHC");
+	mmc->priv = regs;
+	mmc->send_cmd = esdhc_send_cmd;
+	mmc->set_ios = esdhc_set_ios;
+	mmc->init = esdhc_init;
+
+	caps = regs->hostcapblt;
+
+	if (caps & ESDHC_HOSTCAPBLT_VS18)
+		mmc->voltages |= MMC_VDD_165_195;
+	if (caps & ESDHC_HOSTCAPBLT_VS30)
+		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
+	if (caps & ESDHC_HOSTCAPBLT_VS33)
+		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	mmc->host_caps = MMC_MODE_4BIT | MMC_MODE_8BIT;
+
+	if (caps & ESDHC_HOSTCAPBLT_HSS)
+		mmc->host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+
+	mmc->f_min = 400000;
+	mmc->f_max = MIN(gd->sdhc_clk, 50000000);
+
+	mmc_register(mmc);
+
+	return 0;
+}
+
+int fsl_esdhc_mmc_init(bd_t *bis)
+{
+	return esdhc_initialize(bis);
+}
diff -Naur u-boot-2009.01/drivers/mmc/Makefile u-boot/drivers/mmc/Makefile
--- u-boot-2009.01/drivers/mmc/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mmc/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -25,7 +25,12 @@
 
 LIB	:= $(obj)libmmc.a
 
+COBJS-$(CONFIG_GENERIC_MMC) += mmc.o
 COBJS-$(CONFIG_ATMEL_MCI) += atmel_mci.o
+COBJS-$(CONFIG_BFIN_SDH) += bfin_sdh.o
+COBJS-$(CONFIG_OMAP3_MMC) += omap3_mmc.o
+COBJS-$(CONFIG_FSL_ESDHC) += fsl_esdhc.o
+COBJS-$(CONFIG_PXA_MMC) += pxa_mmc.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff -Naur u-boot-2009.01/drivers/mmc/mmc.c u-boot/drivers/mmc/mmc.c
--- u-boot-2009.01/drivers/mmc/mmc.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/mmc/mmc.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,930 @@
+/*
+ * Copyright 2008, Freescale Semiconductor, Inc
+ * Andy Fleming
+ *
+ * Based vaguely on the Linux code
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <mmc.h>
+#include <part.h>
+#include <malloc.h>
+#include <linux/list.h>
+#include <mmc.h>
+
+static struct list_head mmc_devices;
+static int cur_dev_num = -1;
+
+int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
+{
+	return mmc->send_cmd(mmc, cmd, data);
+}
+
+int mmc_set_blocklen(struct mmc *mmc, int len)
+{
+	struct mmc_cmd cmd;
+
+	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = len;
+	cmd.flags = 0;
+
+	return mmc_send_cmd(mmc, &cmd, NULL);
+}
+
+struct mmc *find_mmc_device(int dev_num)
+{
+	struct mmc *m;
+	struct list_head *entry;
+
+	list_for_each(entry, &mmc_devices) {
+		m = list_entry(entry, struct mmc, link);
+
+		if (m->block_dev.dev == dev_num)
+			return m;
+	}
+
+	printf("MMC Device %d not found\n", dev_num);
+
+	return NULL;
+}
+
+static ulong
+mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	int err;
+	int stoperr = 0;
+	struct mmc *mmc = find_mmc_device(dev_num);
+	int blklen;
+
+	if (!mmc)
+		return -1;
+
+	blklen = mmc->write_bl_len;
+
+	err = mmc_set_blocklen(mmc, mmc->write_bl_len);
+
+	if (err) {
+		printf("set write bl len failed\n\r");
+		return err;
+	}
+
+	if (blkcnt > 1)
+		cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
+	else
+		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;
+
+	if (mmc->high_capacity)
+		cmd.cmdarg = start;
+	else
+		cmd.cmdarg = start * blklen;
+
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.flags = 0;
+
+	data.src = src;
+	data.blocks = blkcnt;
+	data.blocksize = blklen;
+	data.flags = MMC_DATA_WRITE;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+
+	if (err) {
+		printf("mmc write failed\n\r");
+		return err;
+	}
+
+	if (blkcnt > 1) {
+		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
+		cmd.cmdarg = 0;
+		cmd.resp_type = MMC_RSP_R1b;
+		cmd.flags = 0;
+		stoperr = mmc_send_cmd(mmc, &cmd, NULL);
+	}
+
+	return blkcnt;
+}
+
+int mmc_read_block(struct mmc *mmc, void *dst, uint blocknum)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+
+	cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
+
+	if (mmc->high_capacity)
+		cmd.cmdarg = blocknum;
+	else
+		cmd.cmdarg = blocknum * mmc->read_bl_len;
+
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.flags = 0;
+
+	data.dest = dst;
+	data.blocks = 1;
+	data.blocksize = mmc->read_bl_len;
+	data.flags = MMC_DATA_READ;
+
+	return mmc_send_cmd(mmc, &cmd, &data);
+}
+
+int mmc_read(struct mmc *mmc, u64 src, uchar *dst, int size)
+{
+	char *buffer;
+	int i;
+	int blklen = mmc->read_bl_len;
+	int startblock = src / blklen;
+	int endblock = (src + size - 1) / blklen;
+	int err = 0;
+
+	/* Make a buffer big enough to hold all the blocks we might read */
+	buffer = malloc(blklen);
+
+	if (!buffer) {
+		printf("Could not allocate buffer for MMC read!\n");
+		return -1;
+	}
+
+	/* We always do full block reads from the card */
+	err = mmc_set_blocklen(mmc, mmc->read_bl_len);
+
+	if (err)
+		return err;
+
+	for (i = startblock; i <= endblock; i++) {
+		int segment_size;
+		int offset;
+
+		err = mmc_read_block(mmc, buffer, i);
+
+		if (err)
+			goto free_buffer;
+
+		/*
+		 * The first block may not be aligned, so we
+		 * copy from the desired point in the block
+		 */
+		offset = (src & (blklen - 1));
+		segment_size = MIN(blklen - offset, size);
+
+		memcpy(dst, buffer + offset, segment_size);
+
+		dst += segment_size;
+		src += segment_size;
+		size -= segment_size;
+	}
+
+free_buffer:
+	free(buffer);
+
+	return err;
+}
+
+static ulong mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
+{
+	int err;
+	int i;
+	struct mmc *mmc = find_mmc_device(dev_num);
+
+	if (!mmc)
+		return 0;
+
+	/* We always do full block reads from the card */
+	err = mmc_set_blocklen(mmc, mmc->read_bl_len);
+
+	if (err) {
+		return 0;
+	}
+
+	for (i = start; i < start + blkcnt; i++, dst += mmc->read_bl_len) {
+		err = mmc_read_block(mmc, dst, i);
+
+		if (err) {
+			printf("block read failed: %d\n", err);
+			return i - start;
+		}
+	}
+
+	return blkcnt;
+}
+
+int mmc_go_idle(struct mmc* mmc)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	udelay(1000);
+
+	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
+	cmd.cmdarg = 0;
+	cmd.resp_type = MMC_RSP_NONE;
+	cmd.flags = 0;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	udelay(2000);
+
+	return 0;
+}
+
+int
+sd_send_op_cond(struct mmc *mmc)
+{
+	int timeout = 1000;
+	int err;
+	struct mmc_cmd cmd;
+
+	do {
+		cmd.cmdidx = MMC_CMD_APP_CMD;
+		cmd.resp_type = MMC_RSP_R1;
+		cmd.cmdarg = 0;
+		cmd.flags = 0;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+		if (err)
+			return err;
+
+		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
+		cmd.resp_type = MMC_RSP_R3;
+		cmd.cmdarg = mmc->voltages;
+
+		if (mmc->version == SD_VERSION_2)
+			cmd.cmdarg |= OCR_HCS;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+		if (err)
+			return err;
+
+		udelay(1000);
+	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);
+
+	if (timeout <= 0)
+		return UNUSABLE_ERR;
+
+	if (mmc->version != SD_VERSION_2)
+		mmc->version = SD_VERSION_1_0;
+
+	mmc->ocr = ((uint *)(cmd.response))[0];
+
+	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
+	mmc->rca = 0;
+
+	return 0;
+}
+
+int mmc_send_op_cond(struct mmc *mmc)
+{
+	int timeout = 1000;
+	struct mmc_cmd cmd;
+	int err;
+
+	/* Some cards seem to need this */
+	mmc_go_idle(mmc);
+
+	do {
+		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
+		cmd.resp_type = MMC_RSP_R3;
+		cmd.cmdarg = OCR_HCS | mmc->voltages;
+		cmd.flags = 0;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+		if (err)
+			return err;
+
+		udelay(1000);
+	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
+
+	if (timeout <= 0)
+		return UNUSABLE_ERR;
+
+	mmc->version = MMC_VERSION_UNKNOWN;
+	mmc->ocr = ((uint *)(cmd.response))[0];
+
+	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
+	mmc->rca = 0;
+
+	return 0;
+}
+
+
+int mmc_send_ext_csd(struct mmc *mmc, char *ext_csd)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	int err;
+
+	/* Get the Card Status Register */
+	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+	cmd.flags = 0;
+
+	data.dest = ext_csd;
+	data.blocks = 1;
+	data.blocksize = 512;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+
+	return err;
+}
+
+
+int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
+{
+	struct mmc_cmd cmd;
+
+	cmd.cmdidx = MMC_CMD_SWITCH;
+	cmd.resp_type = MMC_RSP_R1b;
+	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
+		(index << 16) |
+		(value << 8);
+	cmd.flags = 0;
+
+	return mmc_send_cmd(mmc, &cmd, NULL);
+}
+
+int mmc_change_freq(struct mmc *mmc)
+{
+	char ext_csd[512];
+	char cardtype;
+	int err;
+
+	mmc->card_caps = 0;
+
+	/* Only version 4 supports high-speed */
+	if (mmc->version < MMC_VERSION_4)
+		return 0;
+
+	mmc->card_caps |= MMC_MODE_4BIT;
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+
+	if (err)
+		return err;
+
+	if (ext_csd[212] || ext_csd[213] || ext_csd[214] || ext_csd[215])
+		mmc->high_capacity = 1;
+
+	cardtype = ext_csd[196] & 0xf;
+
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
+
+	if (err)
+		return err;
+
+	/* Now check to see that it worked */
+	err = mmc_send_ext_csd(mmc, ext_csd);
+
+	if (err)
+		return err;
+
+	/* No high-speed support */
+	if (!ext_csd[185])
+		return 0;
+
+	/* High Speed is set, there are two types: 52MHz and 26MHz */
+	if (cardtype & MMC_HS_52MHZ)
+		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+	else
+		mmc->card_caps |= MMC_MODE_HS;
+
+	return 0;
+}
+
+int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+
+	/* Switch the frequency */
+	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = (mode << 31) | 0xffffff;
+	cmd.cmdarg &= ~(0xf << (group * 4));
+	cmd.cmdarg |= value << (group * 4);
+	cmd.flags = 0;
+
+	data.dest = (char *)resp;
+	data.blocksize = 64;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	return mmc_send_cmd(mmc, &cmd, &data);
+}
+
+
+int sd_change_freq(struct mmc *mmc)
+{
+	int err;
+	struct mmc_cmd cmd;
+	uint scr[2];
+	uint switch_status[16];
+	struct mmc_data data;
+	int timeout;
+
+	mmc->card_caps = 0;
+
+	/* Read the SCR to find out if this card supports higher speeds */
+	cmd.cmdidx = MMC_CMD_APP_CMD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+	cmd.flags = 0;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+	cmd.flags = 0;
+
+	timeout = 3;
+
+retry_scr:
+	data.dest = (char *)&scr;
+	data.blocksize = 8;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+
+	if (err) {
+		if (timeout--)
+			goto retry_scr;
+
+		return err;
+	}
+
+	mmc->scr[0] = scr[0];
+	mmc->scr[1] = scr[1];
+
+	switch ((mmc->scr[0] >> 24) & 0xf) {
+		case 0:
+			mmc->version = SD_VERSION_1_0;
+			break;
+		case 1:
+			mmc->version = SD_VERSION_1_10;
+			break;
+		case 2:
+			mmc->version = SD_VERSION_2;
+			break;
+		default:
+			mmc->version = SD_VERSION_1_0;
+			break;
+	}
+
+	/* Version 1.0 doesn't support switching */
+	if (mmc->version == SD_VERSION_1_0)
+		return 0;
+
+	timeout = 4;
+	while (timeout--) {
+		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
+				(u8 *)&switch_status);
+
+		if (err)
+			return err;
+
+		/* The high-speed function is busy.  Try again */
+		if (!switch_status[7] & SD_HIGHSPEED_BUSY)
+			break;
+	}
+
+	if (mmc->scr[0] & SD_DATA_4BIT)
+		mmc->card_caps |= MMC_MODE_4BIT;
+
+	/* If high-speed isn't supported, we return */
+	if (!(switch_status[3] & SD_HIGHSPEED_SUPPORTED))
+		return 0;
+
+	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (u8 *)&switch_status);
+
+	if (err)
+		return err;
+
+	if ((switch_status[4] & 0x0f000000) == 0x01000000)
+		mmc->card_caps |= MMC_MODE_HS;
+
+	return 0;
+}
+
+/* frequency bases */
+/* divided by 10 to be nice to platforms without floating point */
+int fbase[] = {
+	10000,
+	100000,
+	1000000,
+	10000000,
+};
+
+/* Multiplier values for TRAN_SPEED.  Multiplied by 10 to be nice
+ * to platforms without floating point.
+ */
+int multipliers[] = {
+	0,	/* reserved */
+	10,
+	12,
+	13,
+	15,
+	20,
+	25,
+	30,
+	35,
+	40,
+	45,
+	50,
+	55,
+	60,
+	70,
+	80,
+};
+
+void mmc_set_ios(struct mmc *mmc)
+{
+	mmc->set_ios(mmc);
+}
+
+void mmc_set_clock(struct mmc *mmc, uint clock)
+{
+	if (clock > mmc->f_max)
+		clock = mmc->f_max;
+
+	if (clock < mmc->f_min)
+		clock = mmc->f_min;
+
+	mmc->clock = clock;
+
+	mmc_set_ios(mmc);
+}
+
+void mmc_set_bus_width(struct mmc *mmc, uint width)
+{
+	mmc->bus_width = width;
+
+	mmc_set_ios(mmc);
+}
+
+int mmc_startup(struct mmc *mmc)
+{
+	int err;
+	uint mult, freq;
+	u64 cmult, csize;
+	struct mmc_cmd cmd;
+
+	/* Put the Card in Identify Mode */
+	cmd.cmdidx = MMC_CMD_ALL_SEND_CID;
+	cmd.resp_type = MMC_RSP_R2;
+	cmd.cmdarg = 0;
+	cmd.flags = 0;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	memcpy(mmc->cid, cmd.response, 16);
+
+	/*
+	 * For MMC cards, set the Relative Address.
+	 * For SD cards, get the Relatvie Address.
+	 * This also puts the cards into Standby State
+	 */
+	cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
+	cmd.cmdarg = mmc->rca << 16;
+	cmd.resp_type = MMC_RSP_R6;
+	cmd.flags = 0;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	if (IS_SD(mmc))
+		mmc->rca = (((uint *)(cmd.response))[0] >> 16) & 0xffff;
+
+	/* Get the Card-Specific Data */
+	cmd.cmdidx = MMC_CMD_SEND_CSD;
+	cmd.resp_type = MMC_RSP_R2;
+	cmd.cmdarg = mmc->rca << 16;
+	cmd.flags = 0;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	mmc->csd[0] = ((uint *)(cmd.response))[0];
+	mmc->csd[1] = ((uint *)(cmd.response))[1];
+	mmc->csd[2] = ((uint *)(cmd.response))[2];
+	mmc->csd[3] = ((uint *)(cmd.response))[3];
+
+	if (mmc->version == MMC_VERSION_UNKNOWN) {
+		int version = (cmd.response[0] >> 2) & 0xf;
+
+		switch (version) {
+			case 0:
+				mmc->version = MMC_VERSION_1_2;
+				break;
+			case 1:
+				mmc->version = MMC_VERSION_1_4;
+				break;
+			case 2:
+				mmc->version = MMC_VERSION_2_2;
+				break;
+			case 3:
+				mmc->version = MMC_VERSION_3;
+				break;
+			case 4:
+				mmc->version = MMC_VERSION_4;
+				break;
+			default:
+				mmc->version = MMC_VERSION_1_2;
+				break;
+		}
+	}
+
+	/* divide frequency by 10, since the mults are 10x bigger */
+	freq = fbase[(cmd.response[3] & 0x7)];
+	mult = multipliers[((cmd.response[3] >> 3) & 0xf)];
+
+	mmc->tran_speed = freq * mult;
+
+	mmc->read_bl_len = 1 << ((((uint *)(cmd.response))[1] >> 16) & 0xf);
+
+	if (IS_SD(mmc))
+		mmc->write_bl_len = mmc->read_bl_len;
+	else
+		mmc->write_bl_len = 1 << ((((uint *)(cmd.response))[3] >> 22) & 0xf);
+
+	if (mmc->high_capacity) {
+		csize = (mmc->csd[1] & 0x3f) << 16
+			| (mmc->csd[2] & 0xffff0000) >> 16;
+		cmult = 8;
+	} else {
+		csize = (mmc->csd[1] & 0x3ff) << 2
+			| (mmc->csd[2] & 0xc0000000) >> 30;
+		cmult = (mmc->csd[2] & 0x00038000) >> 15;
+	}
+
+	mmc->capacity = (csize + 1) << (cmult + 2);
+	mmc->capacity *= mmc->read_bl_len;
+
+	if (mmc->read_bl_len > 512)
+		mmc->read_bl_len = 512;
+
+	if (mmc->write_bl_len > 512)
+		mmc->write_bl_len = 512;
+
+	/* Select the card, and put it into Transfer Mode */
+	cmd.cmdidx = MMC_CMD_SELECT_CARD;
+	cmd.resp_type = MMC_RSP_R1b;
+	cmd.cmdarg = mmc->rca << 16;
+	cmd.flags = 0;
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	if (IS_SD(mmc))
+		err = sd_change_freq(mmc);
+	else
+		err = mmc_change_freq(mmc);
+
+	if (err)
+		return err;
+
+	/* Restrict card's capabilities by what the host can do */
+	mmc->card_caps &= mmc->host_caps;
+
+	if (IS_SD(mmc)) {
+		if (mmc->card_caps & MMC_MODE_4BIT) {
+			cmd.cmdidx = MMC_CMD_APP_CMD;
+			cmd.resp_type = MMC_RSP_R1;
+			cmd.cmdarg = mmc->rca << 16;
+			cmd.flags = 0;
+
+			err = mmc_send_cmd(mmc, &cmd, NULL);
+			if (err)
+				return err;
+
+			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
+			cmd.resp_type = MMC_RSP_R1;
+			cmd.cmdarg = 2;
+			cmd.flags = 0;
+			err = mmc_send_cmd(mmc, &cmd, NULL);
+			if (err)
+				return err;
+
+			mmc_set_bus_width(mmc, 4);
+		}
+
+		if (mmc->card_caps & MMC_MODE_HS)
+			mmc_set_clock(mmc, 50000000);
+		else
+			mmc_set_clock(mmc, 25000000);
+	} else {
+		if (mmc->card_caps & MMC_MODE_4BIT) {
+			/* Set the card to use 4 bit*/
+			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+					EXT_CSD_BUS_WIDTH,
+					EXT_CSD_BUS_WIDTH_4);
+
+			if (err)
+				return err;
+
+			mmc_set_bus_width(mmc, 4);
+		} else if (mmc->card_caps & MMC_MODE_8BIT) {
+			/* Set the card to use 8 bit*/
+			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+					EXT_CSD_BUS_WIDTH,
+					EXT_CSD_BUS_WIDTH_8);
+
+			if (err)
+				return err;
+
+			mmc_set_bus_width(mmc, 8);
+		}
+
+		if (mmc->card_caps & MMC_MODE_HS) {
+			if (mmc->card_caps & MMC_MODE_HS_52MHz)
+				mmc_set_clock(mmc, 52000000);
+			else
+				mmc_set_clock(mmc, 26000000);
+		} else
+			mmc_set_clock(mmc, 20000000);
+	}
+
+	/* fill in device description */
+	mmc->block_dev.lun = 0;
+	mmc->block_dev.type = 0;
+	mmc->block_dev.blksz = mmc->read_bl_len;
+	mmc->block_dev.lba = mmc->capacity/mmc->read_bl_len;
+	sprintf(mmc->block_dev.vendor,"Man %02x%02x%02x Snr %02x%02x%02x%02x",
+			mmc->cid[0], mmc->cid[1], mmc->cid[2],
+			mmc->cid[9], mmc->cid[10], mmc->cid[11], mmc->cid[12]);
+	sprintf(mmc->block_dev.product,"%c%c%c%c%c", mmc->cid[3],
+			mmc->cid[4], mmc->cid[5], mmc->cid[6], mmc->cid[7]);
+	sprintf(mmc->block_dev.revision,"%d.%d", mmc->cid[8] >> 4,
+			mmc->cid[8] & 0xf);
+	init_part(&mmc->block_dev);
+
+	return 0;
+}
+
+int mmc_send_if_cond(struct mmc *mmc)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	cmd.cmdidx = SD_CMD_SEND_IF_COND;
+	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
+	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
+	cmd.resp_type = MMC_RSP_R7;
+	cmd.flags = 0;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	if ((((uint *)(cmd.response))[0] & 0xff) != 0xaa)
+		return UNUSABLE_ERR;
+	else
+		mmc->version = SD_VERSION_2;
+
+	return 0;
+}
+
+int mmc_register(struct mmc *mmc)
+{
+	/* Setup the universal parts of the block interface just once */
+	mmc->block_dev.if_type = IF_TYPE_MMC;
+	mmc->block_dev.dev = cur_dev_num++;
+	mmc->block_dev.removable = 1;
+	mmc->block_dev.block_read = mmc_bread;
+	mmc->block_dev.block_write = mmc_bwrite;
+
+	INIT_LIST_HEAD (&mmc->link);
+
+	list_add_tail (&mmc->link, &mmc_devices);
+
+	return 0;
+}
+
+block_dev_desc_t *mmc_get_dev(int dev)
+{
+	struct mmc *mmc = find_mmc_device(dev);
+
+	return &mmc->block_dev;
+}
+
+int mmc_init(struct mmc *mmc)
+{
+	int err;
+
+	err = mmc->init(mmc);
+
+	if (err)
+		return err;
+
+	/* Reset the Card */
+	err = mmc_go_idle(mmc);
+
+	if (err)
+		return err;
+
+	/* Test for SD version 2 */
+	err = mmc_send_if_cond(mmc);
+
+	/* If we got an error other than timeout, we bail */
+	if (err && err != TIMEOUT)
+		return err;
+
+	/* Now try to get the SD card's operating condition */
+	err = sd_send_op_cond(mmc);
+
+	/* If the command timed out, we check for an MMC card */
+	if (err == TIMEOUT) {
+		err = mmc_send_op_cond(mmc);
+
+		if (err) {
+			printf("Card did not respond to voltage select!\n");
+			return UNUSABLE_ERR;
+		}
+	}
+
+	return mmc_startup(mmc);
+}
+
+/*
+ * CPU and board-specific MMC initializations.  Aliased function
+ * signals caller to move on
+ */
+static int __def_mmc_init(bd_t *bis)
+{
+	return -1;
+}
+
+int cpu_mmc_init(bd_t *bis) __attribute((weak, alias("__def_mmc_init")));
+int board_mmc_init(bd_t *bis) __attribute((weak, alias("__def_mmc_init")));
+
+void print_mmc_devices(char separator)
+{
+	struct mmc *m;
+	struct list_head *entry;
+
+	list_for_each(entry, &mmc_devices) {
+		m = list_entry(entry, struct mmc, link);
+
+		printf("%s: %d", m->name, m->block_dev.dev);
+
+		if (entry->next != &mmc_devices)
+			printf("%c ", separator);
+	}
+
+	printf("\n");
+}
+
+int mmc_initialize(bd_t *bis)
+{
+	INIT_LIST_HEAD (&mmc_devices);
+	cur_dev_num = 0;
+
+	if (board_mmc_init(bis) < 0)
+		cpu_mmc_init(bis);
+
+	print_mmc_devices(',');
+
+	return 0;
+}
diff -Naur u-boot-2009.01/drivers/mmc/omap3_mmc.c u-boot/drivers/mmc/omap3_mmc.c
--- u-boot-2009.01/drivers/mmc/omap3_mmc.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/mmc/omap3_mmc.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,547 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation's version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <fat.h>
+#include <mmc.h>
+#include <part.h>
+#include <i2c.h>
+#include <asm/io.h>
+#include <asm/arch/mmc.h>
+
+const unsigned short mmc_transspeed_val[15][4] = {
+	{CLKD(10, 1), CLKD(10, 10), CLKD(10, 100), CLKD(10, 1000)},
+	{CLKD(12, 1), CLKD(12, 10), CLKD(12, 100), CLKD(12, 1000)},
+	{CLKD(13, 1), CLKD(13, 10), CLKD(13, 100), CLKD(13, 1000)},
+	{CLKD(15, 1), CLKD(15, 10), CLKD(15, 100), CLKD(15, 1000)},
+	{CLKD(20, 1), CLKD(20, 10), CLKD(20, 100), CLKD(20, 1000)},
+	{CLKD(26, 1), CLKD(26, 10), CLKD(26, 100), CLKD(26, 1000)},
+	{CLKD(30, 1), CLKD(30, 10), CLKD(30, 100), CLKD(30, 1000)},
+	{CLKD(35, 1), CLKD(35, 10), CLKD(35, 100), CLKD(35, 1000)},
+	{CLKD(40, 1), CLKD(40, 10), CLKD(40, 100), CLKD(40, 1000)},
+	{CLKD(45, 1), CLKD(45, 10), CLKD(45, 100), CLKD(45, 1000)},
+	{CLKD(52, 1), CLKD(52, 10), CLKD(52, 100), CLKD(52, 1000)},
+	{CLKD(55, 1), CLKD(55, 10), CLKD(55, 100), CLKD(55, 1000)},
+	{CLKD(60, 1), CLKD(60, 10), CLKD(60, 100), CLKD(60, 1000)},
+	{CLKD(70, 1), CLKD(70, 10), CLKD(70, 100), CLKD(70, 1000)},
+	{CLKD(80, 1), CLKD(80, 10), CLKD(80, 100), CLKD(80, 1000)}
+};
+
+mmc_card_data cur_card_data;
+static block_dev_desc_t mmc_blk_dev;
+static hsmmc_t *mmc_base = (hsmmc_t *)OMAP_HSMMC_BASE;
+
+block_dev_desc_t *mmc_get_dev(int dev)
+{
+	return (block_dev_desc_t *) &mmc_blk_dev;
+}
+
+void twl4030_mmc_config(void)
+{
+	unsigned char data;
+
+	data = DEV_GRP_P1;
+	i2c_write(PWRMGT_ADDR_ID4, VMMC1_DEV_GRP, 1, &data, 1);
+	data = VMMC1_VSEL_30;
+	i2c_write(PWRMGT_ADDR_ID4, VMMC1_DEDICATED, 1, &data, 1);
+}
+
+unsigned char mmc_board_init(void)
+{
+	t2_t *t2_base = (t2_t *)T2_BASE;
+
+	twl4030_mmc_config();
+
+	writel(readl(&t2_base->pbias_lite) | PBIASLITEPWRDNZ1 |
+		PBIASSPEEDCTRL0 | PBIASLITEPWRDNZ0,
+		&t2_base->pbias_lite);
+
+	writel(readl(&t2_base->devconf0) | MMCSDIO1ADPCLKISEL,
+		&t2_base->devconf0);
+
+	return 1;
+}
+
+void mmc_init_stream(void)
+{
+	writel(readl(&mmc_base->con) | INIT_INITSTREAM, &mmc_base->con);
+
+	writel(MMC_CMD0, &mmc_base->cmd);
+	while (!(readl(&mmc_base->stat) & CC_MASK));
+
+	writel(CC_MASK, &mmc_base->stat);
+
+	writel(MMC_CMD0, &mmc_base->cmd);
+	while (!(readl(&mmc_base->stat) & CC_MASK));
+
+	writel(readl(&mmc_base->con) & ~INIT_INITSTREAM, &mmc_base->con);
+}
+
+unsigned char mmc_clock_config(unsigned int iclk, unsigned short clk_div)
+{
+	unsigned int val;
+
+	mmc_reg_out(&mmc_base->sysctl, (ICE_MASK | DTO_MASK | CEN_MASK),
+			(ICE_STOP | DTO_15THDTO | CEN_DISABLE));
+
+	switch (iclk) {
+	case CLK_INITSEQ:
+		val = MMC_INIT_SEQ_CLK / 2;
+		break;
+	case CLK_400KHZ:
+		val = MMC_400kHz_CLK;
+		break;
+	case CLK_MISC:
+		val = clk_div;
+		break;
+	default:
+		return 0;
+	}
+	mmc_reg_out(&mmc_base->sysctl, ICE_MASK | CLKD_MASK,
+			(val << CLKD_OFFSET) | ICE_OSCILLATE);
+
+	while ((readl(&mmc_base->sysctl) & ICS_MASK) == ICS_NOTREADY);
+
+	writel(readl(&mmc_base->sysctl) | CEN_ENABLE, &mmc_base->sysctl);
+	return 1;
+}
+
+unsigned char mmc_init_setup(void)
+{
+	unsigned int reg_val;
+
+	mmc_board_init();
+
+	writel(readl(&mmc_base->sysconfig) | MMC_SOFTRESET,
+		&mmc_base->sysconfig);
+	while ((readl(&mmc_base->sysstatus) & RESETDONE) == 0);
+
+	writel(readl(&mmc_base->sysctl) | SOFTRESETALL, &mmc_base->sysctl);
+	while ((readl(&mmc_base->sysctl) & SOFTRESETALL) != 0x0);
+
+	writel(DTW_1_BITMODE | SDBP_PWROFF | SDVS_3V0, &mmc_base->hctl);
+	writel(readl(&mmc_base->capa) | VS30_3V0SUP | VS18_1V8SUP,
+		&mmc_base->capa);
+
+	reg_val = readl(&mmc_base->con) & RESERVED_MASK;
+
+	writel(CTPL_MMC_SD | reg_val | WPP_ACTIVEHIGH | CDP_ACTIVEHIGH |
+		MIT_CTO | DW8_1_4BITMODE | MODE_FUNC | STR_BLOCK |
+		HR_NOHOSTRESP | INIT_NOINIT | NOOPENDRAIN, &mmc_base->con);
+
+	mmc_clock_config(CLK_INITSEQ, 0);
+	writel(readl(&mmc_base->hctl) | SDBP_PWRON, &mmc_base->hctl);
+
+	writel(IE_BADA | IE_CERR | IE_DEB | IE_DCRC | IE_DTO | IE_CIE |
+		IE_CEB | IE_CCRC | IE_CTO | IE_BRR | IE_BWR | IE_TC | IE_CC,
+		&mmc_base->ie);
+
+	mmc_init_stream();
+	return 1;
+}
+
+unsigned char mmc_send_cmd(unsigned int cmd, unsigned int arg,
+				unsigned int *response)
+{
+	unsigned int mmc_stat;
+
+	while ((readl(&mmc_base->pstate) & DATI_MASK) == DATI_CMDDIS);
+
+	writel(BLEN_512BYTESLEN | NBLK_STPCNT, &mmc_base->blk);
+	writel(0xFFFFFFFF, &mmc_base->stat);
+	writel(arg, &mmc_base->arg);
+	writel(cmd | CMD_TYPE_NORMAL | CICE_NOCHECK | CCCE_NOCHECK |
+		MSBS_SGLEBLK | ACEN_DISABLE | BCE_DISABLE | DE_DISABLE,
+		&mmc_base->cmd);
+
+	while (1) {
+		do {
+			mmc_stat = readl(&mmc_base->stat);
+		} while (mmc_stat == 0);
+
+		if ((mmc_stat & ERRI_MASK) != 0)
+			return (unsigned char) mmc_stat;
+
+		if (mmc_stat & CC_MASK) {
+			writel(CC_MASK, &mmc_base->stat);
+			response[0] = readl(&mmc_base->rsp10);
+			if ((cmd & RSP_TYPE_MASK) == RSP_TYPE_LGHT136) {
+				response[1] = readl(&mmc_base->rsp32);
+				response[2] = readl(&mmc_base->rsp54);
+				response[3] = readl(&mmc_base->rsp76);
+			}
+			break;
+		}
+	}
+	return 1;
+}
+
+unsigned char mmc_read_data(unsigned int *output_buf)
+{
+	unsigned int mmc_stat;
+	unsigned int read_count = 0;
+
+	/*
+	 * Start Polled Read
+	 */
+	while (1) {
+		do {
+			mmc_stat = readl(&mmc_base->stat);
+		} while (mmc_stat == 0);
+
+		if ((mmc_stat & ERRI_MASK) != 0)
+			return (unsigned char) mmc_stat;
+
+		if (mmc_stat & BRR_MASK) {
+			unsigned int k;
+
+			writel(readl(&mmc_base->stat) | BRR_MASK,
+				&mmc_base->stat);
+			for (k = 0; k < MMCSD_SECTOR_SIZE / 4; k++) {
+				*output_buf = readl(&mmc_base->data);
+				output_buf++;
+				read_count += 4;
+			}
+		}
+
+		if (mmc_stat & BWR_MASK)
+			writel(readl(&mmc_base->stat) | BWR_MASK,
+				&mmc_base->stat);
+
+		if (mmc_stat & TC_MASK) {
+			writel(readl(&mmc_base->stat) | TC_MASK,
+				&mmc_base->stat);
+			break;
+		}
+	}
+	return 1;
+}
+
+unsigned char mmc_detect_card(mmc_card_data *mmc_card_cur)
+{
+	unsigned char err;
+	unsigned int argument = 0;
+	unsigned int ocr_value, ocr_recvd, ret_cmd41, hcs_val;
+	unsigned int resp[4];
+	unsigned short retry_cnt = 2000;
+
+	/* Set to Initialization Clock */
+	err = mmc_clock_config(CLK_400KHZ, 0);
+	if (err != 1)
+		return err;
+
+	mmc_card_cur->RCA = MMC_RELATIVE_CARD_ADDRESS;
+	argument = 0x00000000;
+
+	ocr_value = (0x1FF << 15);
+	err = mmc_send_cmd(MMC_CMD0, argument, resp);
+	if (err != 1)
+		return err;
+
+	argument = SD_CMD8_CHECK_PATTERN | SD_CMD8_2_7_3_6_V_RANGE;
+	err = mmc_send_cmd(MMC_SDCMD8, argument, resp);
+	hcs_val = (err == 1) ?
+		MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR :
+		MMC_OCR_REG_HOST_CAPACITY_SUPPORT_BYTE;
+
+	argument = 0x0000 << 16;
+	err = mmc_send_cmd(MMC_CMD55, argument, resp);
+	if (err == 1) {
+		mmc_card_cur->card_type = SD_CARD;
+		ocr_value |= hcs_val;
+		ret_cmd41 = MMC_ACMD41;
+	} else {
+		mmc_card_cur->card_type = MMC_CARD;
+		ocr_value |= MMC_OCR_REG_ACCESS_MODE_SECTOR;
+		ret_cmd41 = MMC_CMD1;
+		writel(readl(&mmc_base->con) & ~OD, &mmc_base->con);
+		writel(readl(&mmc_base->con) | OPENDRAIN, &mmc_base->con);
+	}
+
+	argument = ocr_value;
+	err = mmc_send_cmd(ret_cmd41, argument, resp);
+	if (err != 1)
+		return err;
+
+	ocr_recvd = ((mmc_resp_r3 *) resp)->ocr;
+
+	while (!(ocr_recvd & (0x1 << 31)) && (retry_cnt > 0)) {
+		retry_cnt--;
+		if (mmc_card_cur->card_type == SD_CARD) {
+			argument = 0x0000 << 16;
+			err = mmc_send_cmd(MMC_CMD55, argument, resp);
+		}
+
+		argument = ocr_value;
+		err = mmc_send_cmd(ret_cmd41, argument, resp);
+		if (err != 1)
+			return err;
+		ocr_recvd = ((mmc_resp_r3 *) resp)->ocr;
+	}
+
+	if (!(ocr_recvd & (0x1 << 31)))
+		return 0;
+
+	if (mmc_card_cur->card_type == MMC_CARD) {
+		if ((ocr_recvd & MMC_OCR_REG_ACCESS_MODE_MASK) ==
+			MMC_OCR_REG_ACCESS_MODE_SECTOR) {
+			mmc_card_cur->mode = SECTOR_MODE;
+		} else {
+			mmc_card_cur->mode = BYTE_MODE;
+		}
+
+		ocr_recvd &= ~MMC_OCR_REG_ACCESS_MODE_MASK;
+	} else {
+		if ((ocr_recvd & MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK)
+			== MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR) {
+			mmc_card_cur->mode = SECTOR_MODE;
+		} else {
+			mmc_card_cur->mode = BYTE_MODE;
+		}
+		ocr_recvd &= ~MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK;
+	}
+
+	ocr_recvd &= ~(0x1 << 31);
+	if (!(ocr_recvd & ocr_value))
+		return 0;
+
+	err = mmc_send_cmd(MMC_CMD2, argument, resp);
+	if (err != 1)
+		return err;
+
+	if (mmc_card_cur->card_type == MMC_CARD) {
+		argument = mmc_card_cur->RCA << 16;
+		err = mmc_send_cmd(MMC_CMD3, argument, resp);
+		if (err != 1)
+			return err;
+	} else {
+		argument = 0x00000000;
+		err = mmc_send_cmd(MMC_SDCMD3, argument, resp);
+		if (err != 1)
+			return err;
+
+		mmc_card_cur->RCA = ((mmc_resp_r6 *) resp)->newpublishedrca;
+	}
+
+	writel(readl(&mmc_base->con) & ~OD, &mmc_base->con);
+	writel(readl(&mmc_base->con) | NOOPENDRAIN, &mmc_base->con);
+	return 1;
+}
+
+unsigned char mmc_read_cardsize(mmc_card_data *mmc_dev_data,
+				mmc_csd_reg_t *cur_csd)
+{
+	mmc_extended_csd_reg_t ext_csd;
+	unsigned int size, count, blk_len, blk_no, card_size, argument;
+	unsigned char err;
+	unsigned int resp[4];
+
+	if (mmc_dev_data->mode == SECTOR_MODE) {
+		if (mmc_dev_data->card_type == SD_CARD) {
+			card_size =
+				(((mmc_sd2_csd_reg_t *) cur_csd)->
+				c_size_lsb & MMC_SD2_CSD_C_SIZE_LSB_MASK) |
+				((((mmc_sd2_csd_reg_t *) cur_csd)->
+				c_size_msb & MMC_SD2_CSD_C_SIZE_MSB_MASK)
+				<< MMC_SD2_CSD_C_SIZE_MSB_OFFSET);
+			mmc_dev_data->size = card_size * 1024;
+			if (mmc_dev_data->size == 0)
+				return 0;
+		} else {
+			argument = 0x00000000;
+			err = mmc_send_cmd(MMC_CMD8, argument, resp);
+			if (err != 1)
+				return err;
+			err = mmc_read_data((unsigned int *) &ext_csd);
+			if (err != 1)
+				return err;
+			mmc_dev_data->size = ext_csd.sectorcount;
+
+			if (mmc_dev_data->size == 0)
+				mmc_dev_data->size = 8388608;
+		}
+	} else {
+		if (cur_csd->c_size_mult >= 8)
+			return 0;
+
+		if (cur_csd->read_bl_len >= 12)
+			return 0;
+
+		/* Compute size */
+		count = 1 << (cur_csd->c_size_mult + 2);
+		card_size = (cur_csd->c_size_lsb & MMC_CSD_C_SIZE_LSB_MASK) |
+			((cur_csd->c_size_msb & MMC_CSD_C_SIZE_MSB_MASK)
+			<< MMC_CSD_C_SIZE_MSB_OFFSET);
+		blk_no = (card_size + 1) * count;
+		blk_len = 1 << cur_csd->read_bl_len;
+		size = blk_no * blk_len;
+		mmc_dev_data->size = size / MMCSD_SECTOR_SIZE;
+		if (mmc_dev_data->size == 0)
+			return 0;
+	}
+	return 1;
+}
+
+unsigned char omap_mmc_read_sect(unsigned int start_sec, unsigned int num_bytes,
+				 mmc_card_data *mmc_c,
+				 unsigned long *output_buf)
+{
+	unsigned char err;
+	unsigned int argument;
+	unsigned int resp[4];
+	unsigned int num_sec_val =
+		(num_bytes + (MMCSD_SECTOR_SIZE - 1)) / MMCSD_SECTOR_SIZE;
+	unsigned int sec_inc_val;
+
+	if (num_sec_val == 0)
+		return 1;
+
+	if (mmc_c->mode == SECTOR_MODE) {
+		argument = start_sec;
+		sec_inc_val = 1;
+	} else {
+		argument = start_sec * MMCSD_SECTOR_SIZE;
+		sec_inc_val = MMCSD_SECTOR_SIZE;
+	}
+
+	while (num_sec_val) {
+		err = mmc_send_cmd(MMC_CMD17, argument, resp);
+		if (err != 1)
+			return err;
+
+		err = mmc_read_data((unsigned int *) output_buf);
+		if (err != 1)
+			return err;
+
+		output_buf += (MMCSD_SECTOR_SIZE / 4);
+		argument += sec_inc_val;
+		num_sec_val--;
+	}
+	return 1;
+}
+
+unsigned char configure_mmc(mmc_card_data *mmc_card_cur)
+{
+	unsigned char ret_val;
+	unsigned int argument;
+	unsigned int resp[4];
+	unsigned int trans_clk, trans_fact, trans_unit, retries = 2;
+	mmc_csd_reg_t Card_CSD;
+	unsigned char trans_speed;
+
+	ret_val = mmc_init_setup();
+
+	if (ret_val != 1)
+		return ret_val;
+
+	do {
+		ret_val = mmc_detect_card(mmc_card_cur);
+		retries--;
+	} while ((retries > 0) && (ret_val != 1));
+
+	argument = mmc_card_cur->RCA << 16;
+	ret_val = mmc_send_cmd(MMC_CMD9, argument, resp);
+	if (ret_val != 1)
+		return ret_val;
+
+	((unsigned int *) &Card_CSD)[3] = resp[3];
+	((unsigned int *) &Card_CSD)[2] = resp[2];
+	((unsigned int *) &Card_CSD)[1] = resp[1];
+	((unsigned int *) &Card_CSD)[0] = resp[0];
+
+	if (mmc_card_cur->card_type == MMC_CARD)
+		mmc_card_cur->version = Card_CSD.spec_vers;
+
+	trans_speed = Card_CSD.tran_speed;
+
+	ret_val = mmc_send_cmd(MMC_CMD4, MMC_DSR_DEFAULT << 16, resp);
+	if (ret_val != 1)
+		return ret_val;
+
+	trans_unit = trans_speed & MMC_CSD_TRAN_SPEED_UNIT_MASK;
+	trans_fact = trans_speed & MMC_CSD_TRAN_SPEED_FACTOR_MASK;
+
+	if (trans_unit > MMC_CSD_TRAN_SPEED_UNIT_100MHZ)
+		return 0;
+
+	if ((trans_fact < MMC_CSD_TRAN_SPEED_FACTOR_1_0) ||
+		(trans_fact > MMC_CSD_TRAN_SPEED_FACTOR_8_0))
+		return 0;
+
+	trans_unit >>= 0;
+	trans_fact >>= 3;
+
+	trans_clk = mmc_transspeed_val[trans_fact - 1][trans_unit] * 2;
+	ret_val = mmc_clock_config(CLK_MISC, trans_clk);
+
+	if (ret_val != 1)
+		return ret_val;
+
+	argument = mmc_card_cur->RCA << 16;
+	ret_val = mmc_send_cmd(MMC_CMD7_SELECT, argument, resp);
+	if (ret_val != 1)
+		return ret_val;
+
+	/* Configure the block length to 512 bytes */
+	argument = MMCSD_SECTOR_SIZE;
+	ret_val = mmc_send_cmd(MMC_CMD16, argument, resp);
+	if (ret_val != 1)
+		return ret_val;
+
+	/* get the card size in sectors */
+	ret_val = mmc_read_cardsize(mmc_card_cur, &Card_CSD);
+	if (ret_val != 1)
+		return ret_val;
+
+	return 1;
+}
+unsigned long mmc_bread(int dev_num, unsigned long blknr, lbaint_t blkcnt,
+			void *dst)
+{
+	omap_mmc_read_sect(blknr, (blkcnt * MMCSD_SECTOR_SIZE), &cur_card_data,
+				(unsigned long *) dst);
+	return 1;
+}
+
+int mmc_legacy_init(int verbose)
+{
+	if (configure_mmc(&cur_card_data) != 1)
+		return 1;
+
+	mmc_blk_dev.if_type = IF_TYPE_MMC;
+	mmc_blk_dev.part_type = PART_TYPE_DOS;
+	mmc_blk_dev.dev = 0;
+	mmc_blk_dev.lun = 0;
+	mmc_blk_dev.type = 0;
+
+	/* FIXME fill in the correct size (is set to 32MByte) */
+	mmc_blk_dev.blksz = MMCSD_SECTOR_SIZE;
+	mmc_blk_dev.lba = 0x10000;
+	mmc_blk_dev.removable = 0;
+	mmc_blk_dev.block_read = mmc_bread;
+
+	fat_register_device(&mmc_blk_dev, 1);
+	return 0;
+}
diff -Naur u-boot-2009.01/drivers/mmc/pxa_mmc.c u-boot/drivers/mmc/pxa_mmc.c
--- u-boot-2009.01/drivers/mmc/pxa_mmc.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/mmc/pxa_mmc.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,646 @@
+/*
+ * (C) Copyright 2003
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <mmc.h>
+#include <asm/errno.h>
+#include <asm/arch/hardware.h>
+#include <part.h>
+
+#include "pxa_mmc.h"
+
+extern int fat_register_device(block_dev_desc_t * dev_desc, int part_no);
+
+static block_dev_desc_t mmc_dev;
+
+block_dev_desc_t *mmc_get_dev(int dev)
+{
+	return ((block_dev_desc_t *) & mmc_dev);
+}
+
+/*
+ * FIXME needs to read cid and csd info to determine block size
+ * and other parameters
+ */
+static uchar mmc_buf[MMC_BLOCK_SIZE];
+static uchar spec_ver;
+static int mmc_ready = 0;
+static int wide = 0;
+
+static uint32_t *
+/****************************************************/
+mmc_cmd(ushort cmd, ushort argh, ushort argl, ushort cmdat)
+/****************************************************/
+{
+	static uint32_t resp[4], a, b, c;
+	ulong status;
+	int i;
+
+	debug("mmc_cmd %u 0x%04x 0x%04x 0x%04x\n", cmd, argh, argl,
+	      cmdat | wide);
+	MMC_STRPCL = MMC_STRPCL_STOP_CLK;
+	MMC_I_MASK = ~MMC_I_MASK_CLK_IS_OFF;
+	while (!(MMC_I_REG & MMC_I_REG_CLK_IS_OFF)) ;
+	MMC_CMD = cmd;
+	MMC_ARGH = argh;
+	MMC_ARGL = argl;
+	MMC_CMDAT = cmdat | wide;
+	MMC_I_MASK = ~MMC_I_MASK_END_CMD_RES;
+	MMC_STRPCL = MMC_STRPCL_START_CLK;
+	while (!(MMC_I_REG & MMC_I_REG_END_CMD_RES)) ;
+
+	status = MMC_STAT;
+	debug("MMC status 0x%08x\n", status);
+	if (status & MMC_STAT_TIME_OUT_RESPONSE) {
+		return 0;
+	}
+
+	/* Linux says:
+	 * Did I mention this is Sick.  We always need to
+	 * discard the upper 8 bits of the first 16-bit word.
+	 */
+	a = (MMC_RES & 0xffff);
+	for (i = 0; i < 4; i++) {
+		b = (MMC_RES & 0xffff);
+		c = (MMC_RES & 0xffff);
+		resp[i] = (a << 24) | (b << 8) | (c >> 8);
+		a = c;
+		debug("MMC resp[%d] = %#08x\n", i, resp[i]);
+	}
+
+	return resp;
+}
+
+int
+/****************************************************/
+mmc_block_read(uchar * dst, ulong src, ulong len)
+/****************************************************/
+{
+	ushort argh, argl;
+	ulong status;
+
+	if (len == 0) {
+		return 0;
+	}
+
+	debug("mmc_block_rd dst %lx src %lx len %d\n", (ulong) dst, src, len);
+
+	argh = len >> 16;
+	argl = len & 0xffff;
+
+	/* set block len */
+	mmc_cmd(MMC_CMD_SET_BLOCKLEN, argh, argl, MMC_CMDAT_R1);
+
+	/* send read command */
+	argh = src >> 16;
+	argl = src & 0xffff;
+	MMC_STRPCL = MMC_STRPCL_STOP_CLK;
+	MMC_RDTO = 0xffff;
+	MMC_NOB = 1;
+	MMC_BLKLEN = len;
+	mmc_cmd(MMC_CMD_READ_SINGLE_BLOCK, argh, argl,
+		MMC_CMDAT_R1 | MMC_CMDAT_READ | MMC_CMDAT_BLOCK |
+		MMC_CMDAT_DATA_EN);
+
+	MMC_I_MASK = ~MMC_I_MASK_RXFIFO_RD_REQ;
+	while (len) {
+		if (MMC_I_REG & MMC_I_REG_RXFIFO_RD_REQ) {
+#ifdef CONFIG_PXA27X
+			int i;
+			for (i = min(len, 32); i; i--) {
+				*dst++ = *((volatile uchar *)&MMC_RXFIFO);
+				len--;
+			}
+#else
+			*dst++ = MMC_RXFIFO;
+			len--;
+#endif
+		}
+		status = MMC_STAT;
+		if (status & MMC_STAT_ERRORS) {
+			printf("MMC_STAT error %lx\n", status);
+			return -1;
+		}
+	}
+	MMC_I_MASK = ~MMC_I_MASK_DATA_TRAN_DONE;
+	while (!(MMC_I_REG & MMC_I_REG_DATA_TRAN_DONE)) ;
+	status = MMC_STAT;
+	if (status & MMC_STAT_ERRORS) {
+		printf("MMC_STAT error %lx\n", status);
+		return -1;
+	}
+	return 0;
+}
+
+int
+/****************************************************/
+mmc_block_write(ulong dst, uchar * src, int len)
+/****************************************************/
+{
+	ushort argh, argl;
+	ulong status;
+
+	if (len == 0) {
+		return 0;
+	}
+
+	debug("mmc_block_wr dst %lx src %lx len %d\n", dst, (ulong) src, len);
+
+	argh = len >> 16;
+	argl = len & 0xffff;
+
+	/* set block len */
+	mmc_cmd(MMC_CMD_SET_BLOCKLEN, argh, argl, MMC_CMDAT_R1);
+
+	/* send write command */
+	argh = dst >> 16;
+	argl = dst & 0xffff;
+	MMC_STRPCL = MMC_STRPCL_STOP_CLK;
+	MMC_NOB = 1;
+	MMC_BLKLEN = len;
+	mmc_cmd(MMC_CMD_WRITE_SINGLE_BLOCK, argh, argl,
+		MMC_CMDAT_R1 | MMC_CMDAT_WRITE | MMC_CMDAT_BLOCK |
+		MMC_CMDAT_DATA_EN);
+
+	MMC_I_MASK = ~MMC_I_MASK_TXFIFO_WR_REQ;
+	while (len) {
+		if (MMC_I_REG & MMC_I_REG_TXFIFO_WR_REQ) {
+			int i, bytes = min(32, len);
+
+			for (i = 0; i < bytes; i++) {
+				MMC_TXFIFO = *src++;
+			}
+			if (bytes < 32) {
+				MMC_PRTBUF = MMC_PRTBUF_BUF_PART_FULL;
+			}
+			len -= bytes;
+		}
+		status = MMC_STAT;
+		if (status & MMC_STAT_ERRORS) {
+			printf("MMC_STAT error %lx\n", status);
+			return -1;
+		}
+	}
+	MMC_I_MASK = ~MMC_I_MASK_DATA_TRAN_DONE;
+	while (!(MMC_I_REG & MMC_I_REG_DATA_TRAN_DONE)) ;
+	MMC_I_MASK = ~MMC_I_MASK_PRG_DONE;
+	while (!(MMC_I_REG & MMC_I_REG_PRG_DONE)) ;
+	status = MMC_STAT;
+	if (status & MMC_STAT_ERRORS) {
+		printf("MMC_STAT error %lx\n", status);
+		return -1;
+	}
+	return 0;
+}
+
+int
+/****************************************************/
+pxa_mmc_read(long src, uchar * dst, int size)
+/****************************************************/
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("Please initial the MMC first\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	src -= CONFIG_SYS_MMC_BASE;
+	end = src + size;
+	part_start = ~mmc_block_address & src;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & src;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug
+	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	     src, (ulong) dst, end, part_start, part_end, aligned_start,
+	     aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug
+		    ("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		     src, (ulong) dst, end, part_start, part_end, aligned_start,
+		     aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) <
+		    0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf + part_start, part_len);
+		dst += part_len;
+		src += part_len;
+	}
+	debug
+	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	     src, (ulong) dst, end, part_start, part_end, aligned_start,
+	     aligned_end);
+	for (; src < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug
+		    ("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		     src, (ulong) dst, end, part_start, part_end, aligned_start,
+		     aligned_end);
+		if ((mmc_block_read((uchar *) (dst), src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug
+	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	     src, (ulong) dst, end, part_start, part_end, aligned_start,
+	     aligned_end);
+	if (part_end && src < end) {
+		debug
+		    ("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		     src, (ulong) dst, end, part_start, part_end, aligned_start,
+		     aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf, part_end);
+	}
+	return 0;
+}
+
+int
+/****************************************************/
+pxa_mmc_write(uchar * src, ulong dst, int size)
+/****************************************************/
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("Please initial the MMC first\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	dst -= CONFIG_SYS_MMC_BASE;
+	end = dst + size;
+	part_start = ~mmc_block_address & dst;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & dst;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug
+	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	     src, (ulong) dst, end, part_start, part_end, aligned_start,
+	     aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug
+		    ("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		     (ulong) src, dst, end, part_start, part_end, aligned_start,
+		     aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) <
+		    0) {
+			return -1;
+		}
+		memcpy(mmc_buf + part_start, src, part_len);
+		if ((mmc_block_write(aligned_start, mmc_buf, mmc_block_size)) <
+		    0) {
+			return -1;
+		}
+		dst += part_len;
+		src += part_len;
+	}
+	debug
+	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	     src, (ulong) dst, end, part_start, part_end, aligned_start,
+	     aligned_end);
+	for (; dst < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug
+		    ("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		     src, (ulong) dst, end, part_start, part_end, aligned_start,
+		     aligned_end);
+		if ((mmc_block_write(dst, (uchar *) src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug
+	    ("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	     src, (ulong) dst, end, part_start, part_end, aligned_start,
+	     aligned_end);
+	if (part_end && dst < end) {
+		debug
+		    ("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		     src, (ulong) dst, end, part_start, part_end, aligned_start,
+		     aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(mmc_buf, src, part_end);
+		if ((mmc_block_write(aligned_end, mmc_buf, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	return 0;
+}
+
+static ulong
+/****************************************************/
+mmc_bread(int dev_num, ulong blknr, lbaint_t blkcnt, void *dst)
+/****************************************************/
+{
+	int mmc_block_size = MMC_BLOCK_SIZE;
+	ulong src = blknr * mmc_block_size + CONFIG_SYS_MMC_BASE;
+
+	pxa_mmc_read(src, (uchar *) dst, blkcnt * mmc_block_size);
+	return blkcnt;
+}
+
+#ifdef __GNUC__
+#define likely(x)       __builtin_expect(!!(x), 1)
+#define unlikely(x)     __builtin_expect(!!(x), 0)
+#else
+#define likely(x)	(x)
+#define unlikely(x)	(x)
+#endif
+
+#define UNSTUFF_BITS(resp,start,size)					\
+	({								\
+		const int __size = size;				\
+		const uint32_t __mask = (__size < 32 ? 1 << __size : 0) - 1;	\
+		const int32_t __off = 3 - ((start) / 32);			\
+		const int32_t __shft = (start) & 31;			\
+		uint32_t __res;						\
+									\
+		__res = resp[__off] >> __shft;				\
+		if (__size + __shft > 32)				\
+			__res |= resp[__off-1] << ((32 - __shft) % 32);	\
+		__res & __mask;						\
+	})
+
+/*
+ * Given the decoded CSD structure, decode the raw CID to our CID structure.
+ */
+static void mmc_decode_cid(uint32_t * resp)
+{
+	if (IF_TYPE_SD == mmc_dev.if_type) {
+		/*
+		 * SD doesn't currently have a version field so we will
+		 * have to assume we can parse this.
+		 */
+		sprintf((char *)mmc_dev.vendor,
+			"Man %02x OEM %c%c \"%c%c%c%c%c\" Date %02u/%04u",
+			UNSTUFF_BITS(resp, 120, 8), UNSTUFF_BITS(resp, 112, 8),
+			UNSTUFF_BITS(resp, 104, 8), UNSTUFF_BITS(resp, 96, 8),
+			UNSTUFF_BITS(resp, 88, 8), UNSTUFF_BITS(resp, 80, 8),
+			UNSTUFF_BITS(resp, 72, 8), UNSTUFF_BITS(resp, 64, 8),
+			UNSTUFF_BITS(resp, 8, 4), UNSTUFF_BITS(resp, 12,
+							       8) + 2000);
+		sprintf((char *)mmc_dev.revision, "%d.%d",
+			UNSTUFF_BITS(resp, 60, 4), UNSTUFF_BITS(resp, 56, 4));
+		sprintf((char *)mmc_dev.product, "%u",
+			UNSTUFF_BITS(resp, 24, 32));
+	} else {
+		/*
+		 * The selection of the format here is based upon published
+		 * specs from sandisk and from what people have reported.
+		 */
+		switch (spec_ver) {
+		case 0:	/* MMC v1.0 - v1.2 */
+		case 1:	/* MMC v1.4 */
+			sprintf((char *)mmc_dev.vendor,
+				"Man %02x%02x%02x \"%c%c%c%c%c%c%c\" Date %02u/%04u",
+				UNSTUFF_BITS(resp, 120, 8), UNSTUFF_BITS(resp,
+									 112,
+									 8),
+				UNSTUFF_BITS(resp, 104, 8), UNSTUFF_BITS(resp,
+									 96, 8),
+				UNSTUFF_BITS(resp, 88, 8), UNSTUFF_BITS(resp,
+									80, 8),
+				UNSTUFF_BITS(resp, 72, 8), UNSTUFF_BITS(resp,
+									64, 8),
+				UNSTUFF_BITS(resp, 56, 8), UNSTUFF_BITS(resp,
+									48, 8),
+				UNSTUFF_BITS(resp, 12, 4), UNSTUFF_BITS(resp, 8,
+									4) +
+				1997);
+			sprintf((char *)mmc_dev.revision, "%d.%d",
+				UNSTUFF_BITS(resp, 44, 4), UNSTUFF_BITS(resp,
+									40, 4));
+			sprintf((char *)mmc_dev.product, "%u",
+				UNSTUFF_BITS(resp, 16, 24));
+			break;
+
+		case 2:	/* MMC v2.0 - v2.2 */
+		case 3:	/* MMC v3.1 - v3.3 */
+		case 4:	/* MMC v4 */
+			sprintf((char *)mmc_dev.vendor,
+				"Man %02x OEM %04x \"%c%c%c%c%c%c\" Date %02u/%04u",
+				UNSTUFF_BITS(resp, 120, 8), UNSTUFF_BITS(resp,
+									 104,
+									 16),
+				UNSTUFF_BITS(resp, 96, 8), UNSTUFF_BITS(resp,
+									88, 8),
+				UNSTUFF_BITS(resp, 80, 8), UNSTUFF_BITS(resp,
+									72, 8),
+				UNSTUFF_BITS(resp, 64, 8), UNSTUFF_BITS(resp,
+									56, 8),
+				UNSTUFF_BITS(resp, 12, 4), UNSTUFF_BITS(resp, 8,
+									4) +
+				1997);
+			sprintf((char *)mmc_dev.product, "%u",
+				UNSTUFF_BITS(resp, 16, 32));
+			sprintf((char *)mmc_dev.revision, "N/A");
+			break;
+
+		default:
+			printf("MMC card has unknown MMCA version %d\n",
+			       spec_ver);
+			break;
+		}
+	}
+	printf("%s card.\nVendor: %s\nProduct: %s\nRevision: %s\n",
+	       (IF_TYPE_SD == mmc_dev.if_type) ? "SD" : "MMC", mmc_dev.vendor,
+	       mmc_dev.product, mmc_dev.revision);
+}
+
+/*
+ * Given a 128-bit response, decode to our card CSD structure.
+ */
+static void mmc_decode_csd(uint32_t * resp)
+{
+	unsigned int mult, csd_struct;
+
+	if (IF_TYPE_SD == mmc_dev.if_type) {
+		csd_struct = UNSTUFF_BITS(resp, 126, 2);
+		if (csd_struct != 0) {
+			printf("SD: unrecognised CSD structure version %d\n",
+			       csd_struct);
+			return;
+		}
+	} else {
+		/*
+		 * We only understand CSD structure v1.1 and v1.2.
+		 * v1.2 has extra information in bits 15, 11 and 10.
+		 */
+		csd_struct = UNSTUFF_BITS(resp, 126, 2);
+		if (csd_struct != 1 && csd_struct != 2) {
+			printf("MMC: unrecognised CSD structure version %d\n",
+			       csd_struct);
+			return;
+		}
+
+		spec_ver = UNSTUFF_BITS(resp, 122, 4);
+		mmc_dev.if_type = IF_TYPE_MMC;
+	}
+
+	mult = 1 << (UNSTUFF_BITS(resp, 47, 3) + 2);
+	mmc_dev.lba = (1 + UNSTUFF_BITS(resp, 62, 12)) * mult;
+	mmc_dev.blksz = 1 << UNSTUFF_BITS(resp, 80, 4);
+
+	/* FIXME: The following just makes assumes that's the partition type -- should really read it */
+	mmc_dev.part_type = PART_TYPE_DOS;
+	mmc_dev.dev = 0;
+	mmc_dev.lun = 0;
+	mmc_dev.type = DEV_TYPE_HARDDISK;
+	mmc_dev.removable = 0;
+	mmc_dev.block_read = mmc_bread;
+
+	printf("Detected: %lu blocks of %lu bytes (%luMB) ",
+		mmc_dev.lba,
+		mmc_dev.blksz,
+		mmc_dev.lba * mmc_dev.blksz / (1024 * 1024));
+}
+
+int
+/****************************************************/
+mmc_legacy_init(int verbose)
+/****************************************************/
+{
+	int retries, rc = -ENODEV;
+	uint32_t cid_resp[4];
+	uint32_t *resp;
+	uint16_t rca = 0;
+
+	/* Reset device interface type */
+	mmc_dev.if_type = IF_TYPE_UNKNOWN;
+
+#if defined (CONFIG_LUBBOCK) || (defined (CONFIG_GUMSTIX) && !defined(CONFIG_PXA27X))
+	set_GPIO_mode(GPIO6_MMCCLK_MD);
+	set_GPIO_mode(GPIO8_MMCCS0_MD);
+#endif
+	CKEN |= CKEN12_MMC;	/* enable MMC unit clock */
+
+	MMC_CLKRT = MMC_CLKRT_0_3125MHZ;
+	MMC_RESTO = MMC_RES_TO_MAX;
+	MMC_SPI = MMC_SPI_DISABLE;
+
+	/* reset */
+	mmc_cmd(MMC_CMD_GO_IDLE_STATE, 0, 0, MMC_CMDAT_INIT | MMC_CMDAT_R0);
+	udelay(200000);
+	retries = 3;
+	while (retries--) {
+		resp = mmc_cmd(MMC_CMD_APP_CMD, 0, 0, MMC_CMDAT_R1);
+		if (!(resp[0] & 0x00000020)) {	/* Card does not support APP_CMD */
+			debug("Card does not support APP_CMD\n");
+			break;
+		}
+
+		/* Select 3.2-3.3V and 3.3-3.4V */
+		resp = mmc_cmd(SD_CMD_APP_SEND_OP_COND, 0x0030, 0x0000,
+				MMC_CMDAT_R3 | (retries < 2 ? 0
+					: MMC_CMDAT_INIT));
+		if (resp[0] & 0x80000000) {
+			mmc_dev.if_type = IF_TYPE_SD;
+			debug("Detected SD card\n");
+			break;
+		}
+#ifdef CONFIG_PXA27X
+		udelay(10000);
+#else
+		udelay(200000);
+#endif
+	}
+
+	if (retries <= 0 || !(IF_TYPE_SD == mmc_dev.if_type)) {
+		debug("Failed to detect SD Card, trying MMC\n");
+		resp =
+		    mmc_cmd(MMC_CMD_SEND_OP_COND, 0x00ff, 0x8000, MMC_CMDAT_R3);
+
+		retries = 10;
+		while (retries-- && resp && !(resp[0] & 0x80000000)) {
+#ifdef CONFIG_PXA27X
+			udelay(10000);
+#else
+			udelay(200000);
+#endif
+			resp =
+			    mmc_cmd(MMC_CMD_SEND_OP_COND, 0x00ff, 0x8000,
+				    MMC_CMDAT_R3);
+		}
+	}
+
+	/* try to get card id */
+	resp =
+	    mmc_cmd(MMC_CMD_ALL_SEND_CID, 0, 0, MMC_CMDAT_R2 | MMC_CMDAT_BUSY);
+	if (resp) {
+		memcpy(cid_resp, resp, sizeof(cid_resp));
+
+		/* MMC exists, get CSD too */
+		resp = mmc_cmd(MMC_CMD_SET_RELATIVE_ADDR, 0, 0, MMC_CMDAT_R1);
+		if (IF_TYPE_SD == mmc_dev.if_type)
+			rca = ((resp[0] & 0xffff0000) >> 16);
+		resp = mmc_cmd(MMC_CMD_SEND_CSD, rca, 0, MMC_CMDAT_R2);
+		if (resp) {
+			mmc_decode_csd(resp);
+			rc = 0;
+			mmc_ready = 1;
+		}
+
+		mmc_decode_cid(cid_resp);
+	}
+
+	MMC_CLKRT = 0;		/* 20 MHz */
+	resp = mmc_cmd(MMC_CMD_SELECT_CARD, rca, 0, MMC_CMDAT_R1);
+
+#ifdef CONFIG_PXA27X
+	if (IF_TYPE_SD == mmc_dev.if_type) {
+		resp = mmc_cmd(MMC_CMD_APP_CMD, rca, 0, MMC_CMDAT_R1);
+		resp = mmc_cmd(SD_CMD_APP_SET_BUS_WIDTH, 0, 2, MMC_CMDAT_R1);
+		wide = MMC_CMDAT_SD_4DAT;
+	}
+#endif
+
+	fat_register_device(&mmc_dev, 1);	/* partitions start counting with 1 */
+
+	return rc;
+}
diff -Naur u-boot-2009.01/drivers/mmc/pxa_mmc.h u-boot/drivers/mmc/pxa_mmc.h
--- u-boot-2009.01/drivers/mmc/pxa_mmc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/mmc/pxa_mmc.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,138 @@
+/*
+ *  linux/drivers/mmc/mmc_pxa.h
+ *
+ *  Author: Vladimir Shebordaev, Igor Oblakov
+ *  Copyright:  MontaVista Software Inc.
+ *
+ *  $Id: mmc_pxa.h,v 0.3.1.6 2002/09/25 19:25:48 ted Exp ted $
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#ifndef __MMC_PXA_P_H__
+#define __MMC_PXA_P_H__
+
+/* PXA-250 MMC controller registers */
+
+/* MMC_STRPCL */
+#define MMC_STRPCL_STOP_CLK		(0x0001UL)
+#define MMC_STRPCL_START_CLK		(0x0002UL)
+
+/* MMC_STAT */
+#define MMC_STAT_END_CMD_RES		(0x0001UL << 13)
+#define MMC_STAT_PRG_DONE		(0x0001UL << 12)
+#define MMC_STAT_DATA_TRAN_DONE		(0x0001UL << 11)
+#define MMC_STAT_CLK_EN			(0x0001UL << 8)
+#define MMC_STAT_RECV_FIFO_FULL		(0x0001UL << 7)
+#define MMC_STAT_XMIT_FIFO_EMPTY	(0x0001UL << 6)
+#define MMC_STAT_RES_CRC_ERROR		(0x0001UL << 5)
+#define MMC_STAT_SPI_READ_ERROR_TOKEN   (0x0001UL << 4)
+#define MMC_STAT_CRC_READ_ERROR		(0x0001UL << 3)
+#define MMC_STAT_CRC_WRITE_ERROR	(0x0001UL << 2)
+#define MMC_STAT_TIME_OUT_RESPONSE	(0x0001UL << 1)
+#define MMC_STAT_READ_TIME_OUT		(0x0001UL)
+
+#define MMC_STAT_ERRORS (MMC_STAT_RES_CRC_ERROR|MMC_STAT_SPI_READ_ERROR_TOKEN\
+	|MMC_STAT_CRC_READ_ERROR|MMC_STAT_TIME_OUT_RESPONSE\
+	|MMC_STAT_READ_TIME_OUT|MMC_STAT_CRC_WRITE_ERROR)
+
+/* MMC_CLKRT */
+#define MMC_CLKRT_20MHZ			(0x0000UL)
+#define MMC_CLKRT_10MHZ			(0x0001UL)
+#define MMC_CLKRT_5MHZ			(0x0002UL)
+#define MMC_CLKRT_2_5MHZ		(0x0003UL)
+#define MMC_CLKRT_1_25MHZ		(0x0004UL)
+#define MMC_CLKRT_0_625MHZ		(0x0005UL)
+#define MMC_CLKRT_0_3125MHZ		(0x0006UL)
+
+/* MMC_SPI */
+#define MMC_SPI_DISABLE			(0x00UL)
+#define MMC_SPI_EN			(0x01UL)
+#define MMC_SPI_CS_EN			(0x01UL << 2)
+#define MMC_SPI_CS_ADDRESS		(0x01UL << 3)
+#define MMC_SPI_CRC_ON			(0x01UL << 1)
+
+/* MMC_CMDAT */
+#define MMC_CMDAT_SD_4DAT		(0x0001UL << 8)
+#define MMC_CMDAT_MMC_DMA_EN		(0x0001UL << 7)
+#define MMC_CMDAT_INIT			(0x0001UL << 6)
+#define MMC_CMDAT_BUSY			(0x0001UL << 5)
+#define MMC_CMDAT_BCR			(0x0003UL << 5)
+#define MMC_CMDAT_STREAM		(0x0001UL << 4)
+#define MMC_CMDAT_BLOCK			(0x0000UL << 4)
+#define MMC_CMDAT_WRITE			(0x0001UL << 3)
+#define MMC_CMDAT_READ			(0x0000UL << 3)
+#define MMC_CMDAT_DATA_EN		(0x0001UL << 2)
+#define MMC_CMDAT_R0			(0)
+#define MMC_CMDAT_R1			(0x0001UL)
+#define MMC_CMDAT_R2			(0x0002UL)
+#define MMC_CMDAT_R3			(0x0003UL)
+
+/* MMC_RESTO */
+#define MMC_RES_TO_MAX			(0x007fUL) /* [6:0] */
+
+/* MMC_RDTO */
+#define MMC_READ_TO_MAX			(0x0ffffUL) /* [15:0] */
+
+/* MMC_BLKLEN */
+#define MMC_BLK_LEN_MAX			(0x03ffUL) /* [9:0] */
+
+/* MMC_PRTBUF */
+#define MMC_PRTBUF_BUF_PART_FULL	(0x01UL)
+#define MMC_PRTBUF_BUF_FULL		(0x00UL    )
+
+/* MMC_I_MASK */
+#define MMC_I_MASK_TXFIFO_WR_REQ	(0x01UL << 6)
+#define MMC_I_MASK_RXFIFO_RD_REQ	(0x01UL << 5)
+#define MMC_I_MASK_CLK_IS_OFF		(0x01UL << 4)
+#define MMC_I_MASK_STOP_CMD		(0x01UL << 3)
+#define MMC_I_MASK_END_CMD_RES		(0x01UL << 2)
+#define MMC_I_MASK_PRG_DONE		(0x01UL << 1)
+#define MMC_I_MASK_DATA_TRAN_DONE       (0x01UL)
+#define MMC_I_MASK_ALL			(0x07fUL)
+
+
+/* MMC_I_REG */
+#define MMC_I_REG_TXFIFO_WR_REQ		(0x01UL << 6)
+#define MMC_I_REG_RXFIFO_RD_REQ		(0x01UL << 5)
+#define MMC_I_REG_CLK_IS_OFF		(0x01UL << 4)
+#define MMC_I_REG_STOP_CMD		(0x01UL << 3)
+#define MMC_I_REG_END_CMD_RES		(0x01UL << 2)
+#define MMC_I_REG_PRG_DONE		(0x01UL << 1)
+#define MMC_I_REG_DATA_TRAN_DONE	(0x01UL)
+#define MMC_I_REG_ALL			(0x007fUL)
+
+/* MMC_CMD */
+#define MMC_CMD_INDEX_MAX		(0x006fUL)  /* [5:0] */
+#define CMD(x)  (x)
+
+#define MMC_DEFAULT_RCA			1
+
+#define MMC_BLOCK_SIZE			512
+#define MMC_MAX_BLOCK_SIZE		512
+
+#define MMC_R1_IDLE_STATE		0x01
+#define MMC_R1_ERASE_STATE		0x02
+#define MMC_R1_ILLEGAL_CMD		0x04
+#define MMC_R1_COM_CRC_ERR		0x08
+#define MMC_R1_ERASE_SEQ_ERR		0x01
+#define MMC_R1_ADDR_ERR			0x02
+#define MMC_R1_PARAM_ERR		0x04
+
+#define MMC_R1B_WP_ERASE_SKIP		0x0002
+#define MMC_R1B_ERR			0x0004
+#define MMC_R1B_CC_ERR			0x0008
+#define MMC_R1B_CARD_ECC_ERR		0x0010
+#define MMC_R1B_WP_VIOLATION		0x0020
+#define MMC_R1B_ERASE_PARAM		0x0040
+#define MMC_R1B_OOR			0x0080
+#define MMC_R1B_IDLE_STATE		0x0100
+#define MMC_R1B_ERASE_RESET		0x0200
+#define MMC_R1B_ILLEGAL_CMD		0x0400
+#define MMC_R1B_COM_CRC_ERR		0x0800
+#define MMC_R1B_ERASE_SEQ_ERR		0x1000
+#define MMC_R1B_ADDR_ERR		0x2000
+#define MMC_R1B_PARAM_ERR		0x4000
+
+#endif /* __MMC_PXA_P_H__ */
diff -Naur u-boot-2009.01/drivers/mtd/cfi_flash.c u-boot/drivers/mtd/cfi_flash.c
--- u-boot-2009.01/drivers/mtd/cfi_flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/cfi_flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -273,7 +273,7 @@
 /*-----------------------------------------------------------------------
  */
 #if defined(CONFIG_ENV_IS_IN_FLASH) || defined(CONFIG_ENV_ADDR_REDUND) || (CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
-static flash_info_t *flash_get_info(ulong base)
+flash_info_t *flash_get_info(ulong base)
 {
 	int i;
 	flash_info_t * info = 0;
@@ -305,17 +305,12 @@
 {
 	unsigned int byte_offset = offset * info->portwidth;
 
-	return map_physmem(info->start[sect] + byte_offset,
-			flash_sector_size(info, sect) - byte_offset,
-			MAP_NOCACHE);
+	return (void *)(info->start[sect] + byte_offset);
 }
 
 static inline void flash_unmap(flash_info_t *info, flash_sect_t sect,
 		unsigned int offset, void *addr)
 {
-	unsigned int byte_offset = offset * info->portwidth;
-
-	unmap_physmem(addr, flash_sector_size(info, sect) - byte_offset);
 }
 
 /*-----------------------------------------------------------------------
@@ -354,7 +349,7 @@
 	int i;
 	char *cp;
 
-	cp = (unsigned char *) &data;
+	cp = (char *) &data;
 	for (i = 0; i < 8; i++)
 		sprintf (&str[i * 2], "%2.2x", *cp++);
 }
@@ -774,17 +769,26 @@
 	}
 }
 
-/* loop through the sectors from the highest address when the passed
- * address is greater or equal to the sector address we have a match
+/*
+ * Loop through the sector table starting from the previously found sector.
+ * Searches forwards or backwards, dependent on the passed address.
  */
 static flash_sect_t find_sector (flash_info_t * info, ulong addr)
 {
-	flash_sect_t sector;
+	static flash_sect_t saved_sector = 0; /* previously found sector */
+	flash_sect_t sector = saved_sector;
 
-	for (sector = info->sector_count - 1; sector >= 0; sector--) {
-		if (addr >= info->start[sector])
-			break;
-	}
+	while ((info->start[sector] < addr)
+			&& (sector < info->sector_count - 1))
+		sector++;
+	while ((info->start[sector] > addr) && (sector > 0))
+		/*
+		 * also decrements the sector in case of an overshot
+		 * in the first loop
+		 */
+		sector--;
+
+	saved_sector = sector;
 	return sector;
 }
 
@@ -793,11 +797,10 @@
 static int flash_write_cfiword (flash_info_t * info, ulong dest,
 				cfiword_t cword)
 {
-	void *dstaddr;
+	void *dstaddr = (void *)dest;
 	int flag;
-	flash_sect_t sect;
-
-	dstaddr = map_physmem(dest, info->portwidth, MAP_NOCACHE);
+	flash_sect_t sect = 0;
+	char sect_found = 0;
 
 	/* Check if Flash is (sufficiently) erased */
 	switch (info->portwidth) {
@@ -817,10 +820,8 @@
 		flag = 0;
 		break;
 	}
-	if (!flag) {
-		unmap_physmem(dstaddr, info->portwidth);
+	if (!flag)
 		return ERR_NOT_ERASED;
-	}
 
 	/* Disable interrupts which might cause a timeout here */
 	flag = disable_interrupts ();
@@ -840,6 +841,7 @@
 		sect = find_sector(info, dest);
 		flash_unlock_seq (info, sect);
 		flash_write_cmd (info, sect, info->addr_unlock1, AMD_CMD_WRITE);
+		sect_found = 1;
 		break;
 	}
 
@@ -862,10 +864,10 @@
 	if (flag)
 		enable_interrupts ();
 
-	unmap_physmem(dstaddr, info->portwidth);
+	if (!sect_found)
+		sect = find_sector (info, dest);
 
-	return flash_full_status_check (info, find_sector (info, dest),
-					info->write_tout, "write");
+	return flash_full_status_check (info, sect, info->write_tout, "write");
 }
 
 #ifdef CONFIG_SYS_FLASH_USE_BUFFER_WRITE
@@ -877,7 +879,7 @@
 	int cnt;
 	int retcode;
 	void *src = cp;
-	void *dst = map_physmem(dest, len, MAP_NOCACHE);
+	void *dst = (void *)dest;
 	void *dst2 = dst;
 	int flag = 0;
 	uint offset = 0;
@@ -1039,7 +1041,6 @@
 	}
 
 out_unmap:
-	unmap_physmem(dst, len);
 	return retcode;
 }
 #endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */
@@ -1288,7 +1289,7 @@
 	/* handle unaligned start */
 	if ((aln = addr - wp) != 0) {
 		cword.l = 0;
-		p = map_physmem(wp, info->portwidth, MAP_NOCACHE);
+		p = (uchar *)wp;
 		for (i = 0; i < aln; ++i)
 			flash_add_byte (info, &cword, flash_read8(p + i));
 
@@ -1300,7 +1301,6 @@
 			flash_add_byte (info, &cword, flash_read8(p + i));
 
 		rc = flash_write_cfiword (info, wp, cword);
-		unmap_physmem(p, info->portwidth);
 		if (rc != 0)
 			return rc;
 
@@ -1359,14 +1359,13 @@
 	 * handle unaligned tail bytes
 	 */
 	cword.l = 0;
-	p = map_physmem(wp, info->portwidth, MAP_NOCACHE);
+	p = (uchar *)wp;
 	for (i = 0; (i < info->portwidth) && (cnt > 0); ++i) {
 		flash_add_byte (info, &cword, *src++);
 		--cnt;
 	}
 	for (; i < info->portwidth; ++i)
 		flash_add_byte (info, &cword, flash_read8(p + i));
-	unmap_physmem(p, info->portwidth);
 
 	return flash_write_cfiword (info, wp, cword);
 }
@@ -1605,7 +1604,7 @@
  * board_flash_get_legacy needs to fill in at least:
  * info->portwidth, info->chipwidth and info->interface for Jedec probing.
  */
-static int flash_detect_legacy(ulong base, int banknum)
+static int flash_detect_legacy(phys_addr_t base, int banknum)
 {
 	flash_info_t *info = &flash_info[banknum];
 
@@ -1621,7 +1620,10 @@
 
 			for (i = 0; i < sizeof(modes) / sizeof(modes[0]); i++) {
 				info->vendor = modes[i];
-				info->start[0] = base;
+				info->start[0] =
+					(ulong)map_physmem(base,
+							   info->portwidth,
+							   MAP_NOCACHE);
 				if (info->portwidth == FLASH_CFI_8BIT
 					&& info->interface == FLASH_CFI_X8X16) {
 					info->addr_unlock1 = 0x2AAA;
@@ -1635,8 +1637,11 @@
 						info->manufacturer_id,
 						info->device_id,
 						info->device_id2);
-				if (jedec_flash_match(info, base))
+				if (jedec_flash_match(info, info->start[0]))
 					break;
+				else
+					unmap_physmem((void *)info->start[0],
+						      MAP_NOCACHE);
 			}
 		}
 
@@ -1658,7 +1663,7 @@
 	return 0; /* use CFI */
 }
 #else
-static inline int flash_detect_legacy(ulong base, int banknum)
+static inline int flash_detect_legacy(phys_addr_t base, int banknum)
 {
 	return 0; /* use CFI */
 }
@@ -1795,16 +1800,30 @@
 		cfi_reverse_geometry(qry);
 }
 
+static void flash_fixup_stm(flash_info_t *info, struct cfi_qry *qry)
+{
+	/* check if flash geometry needs reversal */
+	if (qry->num_erase_regions > 1) {
+		/* reverse geometry if top boot part */
+		if (info->cfi_version < 0x3131) {
+			/* CFI < 1.1, guess by device id (only M29W320ET now) */
+			if (info->device_id == 0x2256) {
+				cfi_reverse_geometry(qry);
+			}
+		}
+	}
+}
+
 /*
  * The following code cannot be run from FLASH!
  *
  */
-ulong flash_get_size (ulong base, int banknum)
+ulong flash_get_size (phys_addr_t base, int banknum)
 {
 	flash_info_t *info = &flash_info[banknum];
 	int i, j;
 	flash_sect_t sect_cnt;
-	unsigned long sector;
+	phys_addr_t sector;
 	unsigned long tmp;
 	int size_ratio;
 	uchar num_erase_regions;
@@ -1820,7 +1839,7 @@
 	info->legacy_unlock = 0;
 #endif
 
-	info->start[0] = base;
+	info->start[0] = (ulong)map_physmem(base, info->portwidth, MAP_NOCACHE);
 
 	if (flash_detect_cfi (info, &qry)) {
 		info->vendor = le16_to_cpu(qry.p_id);
@@ -1868,6 +1887,9 @@
 		case 0x001f:
 			flash_fixup_atmel(info, &qry);
 			break;
+		case 0x0020:
+			flash_fixup_stm(info, &qry);
+			break;
 		}
 
 		debug ("manufacturer is %d\n", info->vendor);
@@ -1909,7 +1931,10 @@
 					printf("ERROR: too many flash sectors\n");
 					break;
 				}
-				info->start[sect_cnt] = sector;
+				info->start[sect_cnt] =
+					(ulong)map_physmem(sector,
+							   info->portwidth,
+							   MAP_NOCACHE);
 				sector += (erase_region_size * size_ratio);
 
 				/*
@@ -1986,7 +2011,7 @@
 	char *s = getenv("unlock");
 #endif
 
-#define BANK_BASE(i)	(((unsigned long [CFI_MAX_FLASH_BANKS])CONFIG_SYS_FLASH_BANKS_LIST)[i])
+#define BANK_BASE(i)	(((phys_addr_t [CFI_MAX_FLASH_BANKS])CONFIG_SYS_FLASH_BANKS_LIST)[i])
 
 	/* Init: no FLASHes known */
 	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; ++i) {
diff -Naur u-boot-2009.01/drivers/mtd/jedec_flash.c u-boot/drivers/mtd/jedec_flash.c
--- u-boot-2009.01/drivers/mtd/jedec_flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/jedec_flash.c	2009-02-26 14:03:58.000000000 +0100
@@ -37,10 +37,6 @@
 
 #define P_ID_AMD_STD CFI_CMDSET_AMD_LEGACY
 
-/* Manufacturers */
-#define MANUFACTURER_AMD	0x0001
-#define MANUFACTURER_SST	0x00BF
-
 /* AMD */
 #define AM29DL800BB	0x22CB
 #define AM29DL800BT	0x224A
@@ -172,7 +168,7 @@
 static const struct amd_flash_info jedec_table[] = {
 #ifdef CONFIG_SYS_FLASH_LEGACY_256Kx8
 	{
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= (u16)SST_MANUFACT,
 		.dev_id		= SST39LF020,
 		.name		= "SST 39LF020",
 		.uaddr		= {
@@ -188,7 +184,7 @@
 #endif
 #ifdef CONFIG_SYS_FLASH_LEGACY_512Kx8
 	{
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= (u16)AMD_MANUFACT,
 		.dev_id		= AM29LV040B,
 		.name		= "AMD AM29LV040B",
 		.uaddr		= {
@@ -202,7 +198,7 @@
 		}
 	},
 	{
-		.mfr_id		= MANUFACTURER_SST,
+		.mfr_id		= (u16)SST_MANUFACT,
 		.dev_id		= SST39LF040,
 		.name		= "SST 39LF040",
 		.uaddr		= {
@@ -215,10 +211,24 @@
 			ERASEINFO(0x01000,128),
 		}
 	},
+	{
+		.mfr_id		= (u16)STM_MANUFACT,
+		.dev_id		= STM_ID_M29W040B,
+		.name		= "ST Micro M29W040B",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA /* x8 */
+		},
+		.DevSize	= SIZE_512KiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 1,
+		.regions	= {
+			ERASEINFO(0x10000,8),
+		}
+	},
 #endif
 #ifdef CONFIG_SYS_FLASH_LEGACY_512Kx16
 	{
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= (u16)AMD_MANUFACT,
 		.dev_id		= AM29LV400BB,
 		.name		= "AMD AM29LV400BB",
 		.uaddr		= {
@@ -235,7 +245,7 @@
 		}
 	},
 	{
-		.mfr_id		= MANUFACTURER_AMD,
+		.mfr_id		= (u16)AMD_MANUFACT,
 		.dev_id		= AM29LV800BB,
 		.name		= "AMD AM29LV800BB",
 		.uaddr		= {
diff -Naur u-boot-2009.01/drivers/mtd/nand/bfin_nand.c u-boot/drivers/mtd/nand/bfin_nand.c
--- u-boot-2009.01/drivers/mtd/nand/bfin_nand.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/mtd/nand/bfin_nand.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,385 @@
+/*
+ * Driver for Blackfin on-chip NAND controller.
+ *
+ * Enter bugs at http://blackfin.uclinux.org/
+ *
+ * Copyright (c) 2007-2008 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+/* TODO:
+ * - move bit defines into mach-common/bits/nand.h
+ * - try and replace all IRQSTAT usage with STAT polling
+ * - have software ecc mode use same algo as hw ecc ?
+ */
+
+#include <common.h>
+#include <asm/io.h>
+
+#ifdef DEBUG
+# define pr_stamp() printf("%s:%s:%i: here i am\n", __FILE__, __func__, __LINE__)
+#else
+# define pr_stamp()
+#endif
+
+#include <nand.h>
+
+#include <asm/blackfin.h>
+
+/* Bit masks for NFC_CTL */
+
+#define                    WR_DLY  0xf        /* Write Strobe Delay */
+#define                    RD_DLY  0xf0       /* Read Strobe Delay */
+#define                    NWIDTH  0x100      /* NAND Data Width */
+#define                   PG_SIZE  0x200      /* Page Size */
+
+/* Bit masks for NFC_STAT */
+
+#define                     NBUSY  0x1        /* Not Busy */
+#define                   WB_FULL  0x2        /* Write Buffer Full */
+#define                PG_WR_STAT  0x4        /* Page Write Pending */
+#define                PG_RD_STAT  0x8        /* Page Read Pending */
+#define                  WB_EMPTY  0x10       /* Write Buffer Empty */
+
+/* Bit masks for NFC_IRQSTAT */
+
+#define                  NBUSYIRQ  0x1        /* Not Busy IRQ */
+#define                    WB_OVF  0x2        /* Write Buffer Overflow */
+#define                   WB_EDGE  0x4        /* Write Buffer Edge Detect */
+#define                    RD_RDY  0x8        /* Read Data Ready */
+#define                   WR_DONE  0x10       /* Page Write Done */
+
+#define NAND_IS_512() (CONFIG_BFIN_NFC_CTL_VAL & 0x200)
+
+/*
+ * hardware specific access to control-lines
+ */
+static void bfin_nfc_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	pr_stamp();
+
+	if (cmd == NAND_CMD_NONE)
+		return;
+
+	while (bfin_read_NFC_STAT() & WB_FULL)
+		continue;
+
+	if (ctrl & NAND_CLE)
+		bfin_write_NFC_CMD(cmd);
+	else
+		bfin_write_NFC_ADDR(cmd);
+	SSYNC();
+}
+
+int bfin_nfc_devready(struct mtd_info *mtd)
+{
+	pr_stamp();
+	return (bfin_read_NFC_STAT() & NBUSY ? 1 : 0);
+}
+
+/*
+ * PIO mode for buffer writing and reading
+ */
+static void bfin_nfc_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	pr_stamp();
+
+	int i;
+
+	/*
+	 * Data reads are requested by first writing to NFC_DATA_RD
+	* and then reading back from NFC_READ.
+	*/
+	for (i = 0; i < len; ++i) {
+		while (bfin_read_NFC_STAT() & WB_FULL)
+			if (ctrlc())
+				return;
+
+		/* Contents do not matter */
+		bfin_write_NFC_DATA_RD(0x0000);
+
+		while (!(bfin_read_NFC_IRQSTAT() & RD_RDY))
+			if (ctrlc())
+				return;
+
+		buf[i] = bfin_read_NFC_READ();
+
+		bfin_write_NFC_IRQSTAT(RD_RDY);
+	}
+}
+
+static uint8_t bfin_nfc_read_byte(struct mtd_info *mtd)
+{
+	pr_stamp();
+
+	uint8_t val;
+	bfin_nfc_read_buf(mtd, &val, 1);
+	return val;
+}
+
+static void bfin_nfc_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	pr_stamp();
+
+	int i;
+
+	for (i = 0; i < len; ++i) {
+		while (bfin_read_NFC_STAT() & WB_FULL)
+			if (ctrlc())
+				return;
+
+		bfin_write_NFC_DATA_WR(buf[i]);
+	}
+}
+
+/*
+ * ECC functions
+ * These allow the bfin to use the controller's ECC
+ * generator block to ECC the data as it passes through
+ */
+
+/*
+ * ECC error correction function
+ */
+static int bfin_nfc_correct_data_256(struct mtd_info *mtd, u_char *dat,
+					u_char *read_ecc, u_char *calc_ecc)
+{
+	u32 syndrome[5];
+	u32 calced, stored;
+	unsigned short failing_bit, failing_byte;
+	u_char data;
+
+	pr_stamp();
+
+	calced = calc_ecc[0] | (calc_ecc[1] << 8) | (calc_ecc[2] << 16);
+	stored = read_ecc[0] | (read_ecc[1] << 8) | (read_ecc[2] << 16);
+
+	syndrome[0] = (calced ^ stored);
+
+	/*
+	 * syndrome 0: all zero
+	 * No error in data
+	 * No action
+	 */
+	if (!syndrome[0] || !calced || !stored)
+		return 0;
+
+	/*
+	 * sysdrome 0: only one bit is one
+	 * ECC data was incorrect
+	 * No action
+	 */
+	if (hweight32(syndrome[0]) == 1)
+		return 1;
+
+	syndrome[1] = (calced & 0x7FF) ^ (stored & 0x7FF);
+	syndrome[2] = (calced & 0x7FF) ^ ((calced >> 11) & 0x7FF);
+	syndrome[3] = (stored & 0x7FF) ^ ((stored >> 11) & 0x7FF);
+	syndrome[4] = syndrome[2] ^ syndrome[3];
+
+	/*
+	 * sysdrome 0: exactly 11 bits are one, each parity
+	 * and parity' pair is 1 & 0 or 0 & 1.
+	 * 1-bit correctable error
+	 * Correct the error
+	 */
+	if (hweight32(syndrome[0]) == 11 && syndrome[4] == 0x7FF) {
+		failing_bit = syndrome[1] & 0x7;
+		failing_byte = syndrome[1] >> 0x3;
+		data = *(dat + failing_byte);
+		data = data ^ (0x1 << failing_bit);
+		*(dat + failing_byte) = data;
+
+		return 0;
+	}
+
+	/*
+	 * sysdrome 0: random data
+	 * More than 1-bit error, non-correctable error
+	 * Discard data, mark bad block
+	 */
+
+	return 1;
+}
+
+static int bfin_nfc_correct_data(struct mtd_info *mtd, u_char *dat,
+					u_char *read_ecc, u_char *calc_ecc)
+{
+	int ret;
+
+	pr_stamp();
+
+	ret = bfin_nfc_correct_data_256(mtd, dat, read_ecc, calc_ecc);
+
+	/* If page size is 512, correct second 256 bytes */
+	if (NAND_IS_512()) {
+		dat += 256;
+		read_ecc += 8;
+		calc_ecc += 8;
+		ret |= bfin_nfc_correct_data_256(mtd, dat, read_ecc, calc_ecc);
+	}
+
+	return ret;
+}
+
+static void reset_ecc(void)
+{
+	bfin_write_NFC_RST(0x1);
+	while (bfin_read_NFC_RST() & 1)
+		continue;
+}
+
+static void bfin_nfc_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	reset_ecc();
+}
+
+static int bfin_nfc_calculate_ecc(struct mtd_info *mtd,
+		const u_char *dat, u_char *ecc_code)
+{
+	u16 ecc0, ecc1;
+	u32 code[2];
+	u8 *p;
+
+	pr_stamp();
+
+	/* first 4 bytes ECC code for 256 page size */
+	ecc0 = bfin_read_NFC_ECC0();
+	ecc1 = bfin_read_NFC_ECC1();
+
+	code[0] = (ecc0 & 0x7FF) | ((ecc1 & 0x7FF) << 11);
+
+	/* first 3 bytes in ecc_code for 256 page size */
+	p = (u8 *) code;
+	memcpy(ecc_code, p, 3);
+
+	/* second 4 bytes ECC code for 512 page size */
+	if (NAND_IS_512()) {
+		ecc0 = bfin_read_NFC_ECC2();
+		ecc1 = bfin_read_NFC_ECC3();
+		code[1] = (ecc0 & 0x7FF) | ((ecc1 & 0x7FF) << 11);
+
+		/* second 3 bytes in ecc_code for second 256
+		 * bytes of 512 page size
+		 */
+		p = (u8 *) (code + 1);
+		memcpy((ecc_code + 3), p, 3);
+	}
+
+	reset_ecc();
+
+	return 0;
+}
+
+#ifdef CONFIG_BFIN_NFC_BOOTROM_ECC
+# define BOOTROM_ECC 1
+#else
+# define BOOTROM_ECC 0
+#endif
+
+static uint8_t bbt_pattern[] = { 0xff };
+
+static struct nand_bbt_descr bootrom_bbt = {
+	.options = 0,
+	.offs = 63,
+	.len = 1,
+	.pattern = bbt_pattern,
+};
+
+static struct nand_ecclayout bootrom_ecclayout = {
+	.eccbytes = 24,
+	.eccpos = {
+		0x8 * 0, 0x8 * 0 + 1, 0x8 * 0 + 2,
+		0x8 * 1, 0x8 * 1 + 1, 0x8 * 1 + 2,
+		0x8 * 2, 0x8 * 2 + 1, 0x8 * 2 + 2,
+		0x8 * 3, 0x8 * 3 + 1, 0x8 * 3 + 2,
+		0x8 * 4, 0x8 * 4 + 1, 0x8 * 4 + 2,
+		0x8 * 5, 0x8 * 5 + 1, 0x8 * 5 + 2,
+		0x8 * 6, 0x8 * 6 + 1, 0x8 * 6 + 2,
+		0x8 * 7, 0x8 * 7 + 1, 0x8 * 7 + 2
+	},
+	.oobfree = {
+		{ 0x8 * 0 + 3, 5 },
+		{ 0x8 * 1 + 3, 5 },
+		{ 0x8 * 2 + 3, 5 },
+		{ 0x8 * 3 + 3, 5 },
+		{ 0x8 * 4 + 3, 5 },
+		{ 0x8 * 5 + 3, 5 },
+		{ 0x8 * 6 + 3, 5 },
+		{ 0x8 * 7 + 3, 5 },
+	}
+};
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - cmd_ctrl: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - ecc.mode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *chip)
+{
+	pr_stamp();
+
+	/* set width/ecc/timings/etc... */
+	bfin_write_NFC_CTL(CONFIG_BFIN_NFC_CTL_VAL);
+
+	/* clear interrupt status */
+	bfin_write_NFC_IRQMASK(0x0);
+	bfin_write_NFC_IRQSTAT(0xffff);
+
+	/* enable GPIO function enable register */
+#ifdef __ADSPBF54x__
+	bfin_write_PORTJ_FER(bfin_read_PORTJ_FER() | 6);
+#elif defined(__ADSPBF52x__)
+	bfin_write_PORTH_FER(bfin_read_PORTH_FER() | 0xFCFF);
+	bfin_write_PORTH_MUX(0);
+#else
+# error no support for this variant
+#endif
+
+	chip->cmd_ctrl = bfin_nfc_cmd_ctrl;
+	chip->read_buf = bfin_nfc_read_buf;
+	chip->write_buf = bfin_nfc_write_buf;
+	chip->read_byte = bfin_nfc_read_byte;
+
+#ifdef CONFIG_BFIN_NFC_NO_HW_ECC
+# define ECC_HW 0
+#else
+# define ECC_HW 1
+#endif
+	if (ECC_HW) {
+		if (BOOTROM_ECC) {
+			chip->badblock_pattern = &bootrom_bbt;
+			chip->ecc.layout = &bootrom_ecclayout;
+		}
+		if (!NAND_IS_512()) {
+			chip->ecc.bytes = 3;
+			chip->ecc.size = 256;
+		} else {
+			chip->ecc.bytes = 6;
+			chip->ecc.size = 512;
+		}
+		chip->ecc.mode = NAND_ECC_HW;
+		chip->ecc.calculate = bfin_nfc_calculate_ecc;
+		chip->ecc.correct   = bfin_nfc_correct_data;
+		chip->ecc.hwctl     = bfin_nfc_enable_hwecc;
+	} else
+		chip->ecc.mode = NAND_ECC_SOFT;
+	chip->dev_ready = bfin_nfc_devready;
+	chip->chip_delay = 0;
+
+	return 0;
+}
diff -Naur u-boot-2009.01/drivers/mtd/nand/Makefile u-boot/drivers/mtd/nand/Makefile
--- u-boot-2009.01/drivers/mtd/nand/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/nand/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -35,9 +35,12 @@
 COBJS-y += nand_util.o
 endif
 
+COBJS-$(CONFIG_DRIVER_NAND_BFIN) += bfin_nand.o
 COBJS-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_nand.o
 COBJS-$(CONFIG_NAND_FSL_UPM) += fsl_upm.o
+COBJS-$(CONFIG_NAND_NOMADIK) += nomadik.o
 COBJS-$(CONFIG_NAND_S3C64XX) += s3c64xx.o
+COBJS-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o
 endif
 
 COBJS	:= $(COBJS-y)
diff -Naur u-boot-2009.01/drivers/mtd/nand/nand_base.c u-boot/drivers/mtd/nand/nand_base.c
--- u-boot-2009.01/drivers/mtd/nand/nand_base.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/nand/nand_base.c	2009-03-11 10:10:40.000000000 +0100
@@ -75,6 +75,17 @@
 #include <jffs2/jffs2.h>
 #endif
 
+/*
+ * CONFIG_SYS_NAND_RESET_CNT is used as a timeout mechanism when resetting
+ * a flash.  NAND flash is initialized prior to interrupts so standard timers
+ * can't be used.  CONFIG_SYS_NAND_RESET_CNT should be set to a value
+ * which is greater than (max NAND reset time / NAND status read time).
+ * A conservative default of 200000 (500 us / 25 ns) is used as a default.
+ */
+#ifndef CONFIG_SYS_NAND_RESET_CNT
+#define CONFIG_SYS_NAND_RESET_CNT 200000
+#endif
+
 /* Define default oob placement schemes for large and small page devices */
 static struct nand_ecclayout nand_oob_8 = {
 	.eccbytes = 3,
@@ -176,7 +187,8 @@
 static uint8_t nand_read_byte(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
-	return readb(chip->IO_ADDR_R);
+	//printf("nand_read_byte\n");
+	return readb(uncached(chip->IO_ADDR_R));
 }
 
 /**
@@ -216,6 +228,7 @@
 {
 	struct nand_chip *chip = mtd->priv;
 
+	//printf("nand_select_chip %i\n", chipnr); 
 	switch (chipnr) {
 	case -1:
 		chip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);
@@ -258,8 +271,14 @@
 	int i;
 	struct nand_chip *chip = mtd->priv;
 
-	for (i = 0; i < len; i++)
-		buf[i] = readb(chip->IO_ADDR_R);
+	//udelay(500);
+	//printf("Reading %i bytes @ %p: ", len, buf);
+	for (i = 0; i < len; i++) {
+		buf[i] = readb(uncached(chip->IO_ADDR_R));
+		//udelay(50);
+		//printf("%02x",buf[i]);
+	}
+	//printf("\n");
 }
 
 /**
@@ -276,7 +295,7 @@
 	struct nand_chip *chip = mtd->priv;
 
 	for (i = 0; i < len; i++)
-		if (buf[i] != readb(chip->IO_ADDR_R))
+		if (buf[i] != readb(uncached(chip->IO_ADDR_R)))
 			return -EFAULT;
 	return 0;
 }
@@ -496,7 +515,7 @@
 void nand_wait_ready(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
-	u32 timeo = (CONFIG_SYS_HZ * 20) / 1000;
+	u32 timeo = (CONFIG_SYS_HZ * chip->chip_delay) / 1000;
 
 	reset_timer();
 
@@ -506,6 +525,7 @@
 			if (chip->dev_ready(mtd))
 				break;
 	}
+	//printf("nand_wait_ready %i us\n", get_timer(0));
 }
 #endif
 
@@ -524,10 +544,12 @@
 {
 	register struct nand_chip *chip = mtd->priv;
 	int ctrl = NAND_CTRL_CLE | NAND_CTRL_CHANGE;
+	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;
 
 	/*
 	 * Write out the command to the device.
 	 */
+	//printf("nand_command\n");
 	if (command == NAND_CMD_SEQIN) {
 		int readcmd;
 
@@ -590,7 +612,8 @@
 			       NAND_CTRL_CLE | NAND_CTRL_CHANGE);
 		chip->cmd_ctrl(mtd,
 			       NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
-		while (!(chip->read_byte(mtd) & NAND_STATUS_READY)) ;
+		while (!(chip->read_byte(mtd) & NAND_STATUS_READY) &&
+			(rst_sts_cnt--));
 		return;
 
 		/* This applies to read commands */
@@ -626,7 +649,9 @@
 			    int column, int page_addr)
 {
 	register struct nand_chip *chip = mtd->priv;
+	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;
 
+	//printf("nand_command_lp\n");
 	/* Emulate NAND_CMD_READOOB */
 	if (command == NAND_CMD_READOOB) {
 		column += mtd->writesize;
@@ -658,6 +683,10 @@
 				chip->cmd_ctrl(mtd, page_addr >> 16,
 					       NAND_NCE | NAND_ALE);
 		}
+		//printf("%02x%02x", column & 0x00FF, column >> 8);
+		/*printf("%02x%02x%02x",page_addr &0x00FF,
+					(page_addr >> 8) & 0x00FF,
+					page_addr>>16);*/
 	}
 	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
 
@@ -675,7 +704,7 @@
 	case NAND_CMD_RNDIN:
 	case NAND_CMD_STATUS:
 	case NAND_CMD_DEPLETE1:
-		return;
+		break;
 
 		/*
 		 * read error status commands require only a short delay
@@ -686,7 +715,7 @@
 	case NAND_CMD_STATUS_ERROR2:
 	case NAND_CMD_STATUS_ERROR3:
 		udelay(chip->chip_delay);
-		return;
+		break;
 
 	case NAND_CMD_RESET:
 		if (chip->dev_ready)
@@ -696,8 +725,9 @@
 			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
 		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
 			       NAND_NCE | NAND_CTRL_CHANGE);
-		while (!(chip->read_byte(mtd) & NAND_STATUS_READY)) ;
-		return;
+		while (!(chip->read_byte(mtd) & NAND_STATUS_READY) &&
+			(rst_sts_cnt--));
+		break;
 
 	case NAND_CMD_RNDOUT:
 		/* No ready / busy check necessary */
@@ -705,7 +735,7 @@
 			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
 		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
 			       NAND_NCE | NAND_CTRL_CHANGE);
-		return;
+		break;
 
 	case NAND_CMD_READ0:
 		chip->cmd_ctrl(mtd, NAND_CMD_READSTART,
@@ -721,7 +751,7 @@
 		 */
 		if (!chip->dev_ready) {
 			udelay(chip->chip_delay);
-			return;
+			break;
 		}
 	}
 
@@ -1279,11 +1309,15 @@
 	if (oob)
 		ops->oobretlen = ops->ooblen - oobreadlen;
 
-	if (ret)
+	if (ret) {
+		printf("Read failed\n");
 		return ret;
+	}
 
-	if (mtd->ecc_stats.failed - stats.failed)
+	if (mtd->ecc_stats.failed - stats.failed) {
+		printf("ECC failed\n");
 		return -EBADMSG;
+	}
 
 	return  mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;
 }
@@ -1305,8 +1339,11 @@
 	int ret;
 
 	/* Do not allow reads past end of device */
-	if ((from + len) > mtd->size)
+	if ((from + len) > mtd->size) {
+		printf("Reading %i bytes from %i excesses end of device (%i bytes)\n",
+				from, len, mtd->size);
 		return -EINVAL;
+	}
 	if (!len)
 		return 0;
 
@@ -2144,7 +2181,7 @@
 {
 	int page, len, status, pages_per_block, ret, chipnr;
 	struct nand_chip *chip = mtd->priv;
-	int rewrite_bbt[NAND_MAX_CHIPS]={0};
+	int rewrite_bbt[CONFIG_SYS_NAND_MAX_CHIPS]={0};
 	unsigned int bbt_masked_page = 0xffffffff;
 
 	MTDDEBUG (MTD_DEBUG_LEVEL3, "nand_erase: start = 0x%08x, len = %i\n",
@@ -2618,7 +2655,9 @@
 	type = nand_get_flash_type(mtd, chip, busw, &nand_maf_id);
 
 	if (IS_ERR(type)) {
+#ifndef CONFIG_SYS_NAND_QUIET_TEST
 		printk(KERN_WARNING "No NAND device found!!!\n");
+#endif
 		chip->select_chip(mtd, -1);
 		return PTR_ERR(type);
 	}
diff -Naur u-boot-2009.01/drivers/mtd/nand/nand.c u-boot/drivers/mtd/nand/nand.c
--- u-boot-2009.01/drivers/mtd/nand/nand.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/nand/nand.c	2009-02-26 14:03:58.000000000 +0100
@@ -28,6 +28,8 @@
 #define CONFIG_SYS_NAND_BASE_LIST { CONFIG_SYS_NAND_BASE }
 #endif
 
+DECLARE_GLOBAL_DATA_PTR;
+
 int nand_curr_device = -1;
 nand_info_t nand_info[CONFIG_SYS_MAX_NAND_DEVICE];
 
@@ -36,8 +38,6 @@
 
 static const char default_nand_name[] = "nand";
 
-extern int board_nand_init(struct nand_chip *nand);
-
 static void nand_init_chip(struct mtd_info *mtd, struct nand_chip *nand,
 			   ulong base_addr)
 {
@@ -48,6 +48,8 @@
 		if (nand_scan(mtd, 1) == 0) {
 			if (!mtd->name)
 				mtd->name = (char *)default_nand_name;
+			else
+				mtd->name += gd->reloc_off;
 		} else
 			mtd->name = NULL;
 	} else {
diff -Naur u-boot-2009.01/drivers/mtd/nand/nand_util.c u-boot/drivers/mtd/nand/nand_util.c
--- u-boot-2009.01/drivers/mtd/nand/nand_util.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/nand/nand_util.c	2009-02-26 14:03:58.000000000 +0100
@@ -238,7 +238,8 @@
 #endif
 
 /* XXX U-BOOT XXX */
-#if 0
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+
 /******************************************************************************
  * Support for locking / unlocking operations of some NAND devices
  *****************************************************************************/
@@ -253,7 +254,7 @@
  * nand_lock: Set all pages of NAND flash chip to the LOCK or LOCK-TIGHT
  *	      state
  *
- * @param meminfo	nand mtd instance
+ * @param mtd		nand mtd instance
  * @param tight		bring device in lock tight mode
  *
  * @return		0 on success, -1 in case of error
@@ -270,21 +271,21 @@
  *   calls will fail. It is only posible to leave lock-tight state by
  *   an hardware signal (low pulse on _WP pin) or by power down.
  */
-int nand_lock(nand_info_t *meminfo, int tight)
+int nand_lock(struct mtd_info *mtd, int tight)
 {
 	int ret = 0;
 	int status;
-	struct nand_chip *this = meminfo->priv;
+	struct nand_chip *chip = mtd->priv;
 
 	/* select the NAND device */
-	this->select_chip(meminfo, 0);
+	chip->select_chip(mtd, 0);
 
-	this->cmdfunc(meminfo,
+	chip->cmdfunc(mtd,
 		      (tight ? NAND_CMD_LOCK_TIGHT : NAND_CMD_LOCK),
 		      -1, -1);
 
 	/* call wait ready function */
-	status = this->waitfunc(meminfo, this, FL_WRITING);
+	status = chip->waitfunc(mtd, chip);
 
 	/* see if device thinks it succeeded */
 	if (status & 0x01) {
@@ -292,7 +293,7 @@
 	}
 
 	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
+	chip->select_chip(mtd, -1);
 	return ret;
 }
 
@@ -300,7 +301,7 @@
  * nand_get_lock_status: - query current lock state from one page of NAND
  *			   flash
  *
- * @param meminfo	nand mtd instance
+ * @param mtd		nand mtd instance
  * @param offset	page address to query (muss be page aligned!)
  *
  * @return		-1 in case of error
@@ -311,19 +312,19 @@
  *			  NAND_LOCK_STATUS_UNLOCK: page unlocked
  *
  */
-int nand_get_lock_status(nand_info_t *meminfo, ulong offset)
+int nand_get_lock_status(struct mtd_info *mtd, ulong offset)
 {
 	int ret = 0;
 	int chipnr;
 	int page;
-	struct nand_chip *this = meminfo->priv;
+	struct nand_chip *chip = mtd->priv;
 
 	/* select the NAND device */
-	chipnr = (int)(offset >> this->chip_shift);
-	this->select_chip(meminfo, chipnr);
+	chipnr = (int)(offset >> chip->chip_shift);
+	chip->select_chip(mtd, chipnr);
 
 
-	if ((offset & (meminfo->writesize - 1)) != 0) {
+	if ((offset & (mtd->writesize - 1)) != 0) {
 		printf ("nand_get_lock_status: "
 			"Start address must be beginning of "
 			"nand page!\n");
@@ -332,16 +333,16 @@
 	}
 
 	/* check the Lock Status */
-	page = (int)(offset >> this->page_shift);
-	this->cmdfunc(meminfo, NAND_CMD_LOCK_STATUS, -1, page & this->pagemask);
+	page = (int)(offset >> chip->page_shift);
+	chip->cmdfunc(mtd, NAND_CMD_LOCK_STATUS, -1, page & chip->pagemask);
 
-	ret = this->read_byte(meminfo) & (NAND_LOCK_STATUS_TIGHT
+	ret = chip->read_byte(mtd) & (NAND_LOCK_STATUS_TIGHT
 					  | NAND_LOCK_STATUS_LOCK
 					  | NAND_LOCK_STATUS_UNLOCK);
 
  out:
 	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
+	chip->select_chip(mtd, -1);
 	return ret;
 }
 
@@ -349,59 +350,65 @@
  * nand_unlock: - Unlock area of NAND pages
  *		  only one consecutive area can be unlocked at one time!
  *
- * @param meminfo	nand mtd instance
+ * @param mtd		nand mtd instance
  * @param start		start byte address
  * @param length	number of bytes to unlock (must be a multiple of
  *			page size nand->writesize)
  *
  * @return		0 on success, -1 in case of error
  */
-int nand_unlock(nand_info_t *meminfo, ulong start, ulong length)
+int nand_unlock(struct mtd_info *mtd, ulong start, ulong length)
 {
 	int ret = 0;
 	int chipnr;
 	int status;
 	int page;
-	struct nand_chip *this = meminfo->priv;
+	struct nand_chip *chip = mtd->priv;
 	printf ("nand_unlock: start: %08x, length: %d!\n",
 		(int)start, (int)length);
 
 	/* select the NAND device */
-	chipnr = (int)(start >> this->chip_shift);
-	this->select_chip(meminfo, chipnr);
+	chipnr = (int)(start >> chip->chip_shift);
+	chip->select_chip(mtd, chipnr);
 
 	/* check the WP bit */
-	this->cmdfunc(meminfo, NAND_CMD_STATUS, -1, -1);
-	if ((this->read_byte(meminfo) & 0x80) == 0) {
+	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(chip->read_byte(mtd) & NAND_STATUS_WP)) {
 		printf ("nand_unlock: Device is write protected!\n");
 		ret = -1;
 		goto out;
 	}
 
-	if ((start & (meminfo->writesize - 1)) != 0) {
+	if ((start & (mtd->erasesize - 1)) != 0) {
 		printf ("nand_unlock: Start address must be beginning of "
-			"nand page!\n");
+			"nand block!\n");
 		ret = -1;
 		goto out;
 	}
 
-	if (length == 0 || (length & (meminfo->writesize - 1)) != 0) {
-		printf ("nand_unlock: Length must be a multiple of nand page "
-			"size!\n");
+	if (length == 0 || (length & (mtd->erasesize - 1)) != 0) {
+		printf ("nand_unlock: Length must be a multiple of nand block "
+			"size %08x!\n", mtd->erasesize);
 		ret = -1;
 		goto out;
 	}
 
+	/*
+	 * Set length so that the last address is set to the
+	 * starting address of the last block
+	 */
+	length -= mtd->erasesize;
+
 	/* submit address of first page to unlock */
-	page = (int)(start >> this->page_shift);
-	this->cmdfunc(meminfo, NAND_CMD_UNLOCK1, -1, page & this->pagemask);
+	page = (int)(start >> chip->page_shift);
+	chip->cmdfunc(mtd, NAND_CMD_UNLOCK1, -1, page & chip->pagemask);
 
 	/* submit ADDRESS of LAST page to unlock */
-	page += (int)(length >> this->page_shift) - 1;
-	this->cmdfunc(meminfo, NAND_CMD_UNLOCK2, -1, page & this->pagemask);
+	page += (int)(length >> chip->page_shift);
+	chip->cmdfunc(mtd, NAND_CMD_UNLOCK2, -1, page & chip->pagemask);
 
 	/* call wait ready function */
-	status = this->waitfunc(meminfo, this, FL_WRITING);
+	status = chip->waitfunc(mtd, chip);
 	/* see if device thinks it succeeded */
 	if (status & 0x01) {
 		/* there was an error */
@@ -411,7 +418,7 @@
 
  out:
 	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
+	chip->select_chip(mtd, -1);
 	return ret;
 }
 #endif
@@ -488,7 +495,7 @@
 	if (len_incl_bad == *length) {
 		rval = nand_write (nand, offset, length, buffer);
 		if (rval != 0)
-			printf ("NAND write to offset %x failed %d\n",
+			printf ("NAND write to offset %zx failed %d\n",
 				offset, rval);
 
 		return rval;
@@ -499,7 +506,7 @@
 		size_t write_size;
 
 		if (nand_block_isbad (nand, offset & ~(nand->erasesize - 1))) {
-			printf ("Skip bad block 0x%08x\n",
+			printf ("Skip bad block 0x%08zx\n",
 				offset & ~(nand->erasesize - 1));
 			offset += nand->erasesize - block_offset;
 			continue;
@@ -512,7 +519,7 @@
 
 		rval = nand_write (nand, offset, &write_size, p_buffer);
 		if (rval != 0) {
-			printf ("NAND write to offset %x failed %d\n",
+			printf ("NAND write to offset %zx failed %d\n",
 				offset, rval);
 			*length -= left_to_write;
 			return rval;
@@ -558,7 +565,7 @@
 	if (len_incl_bad == *length) {
 		rval = nand_read (nand, offset, length, buffer);
 		if (rval != 0)
-			printf ("NAND read from offset %x failed %d\n",
+			printf ("NAND read from offset %zx failed %d\n",
 				offset, rval);
 
 		return rval;
@@ -569,7 +576,7 @@
 		size_t read_length;
 
 		if (nand_block_isbad (nand, offset & ~(nand->erasesize - 1))) {
-			printf ("Skipping bad block 0x%08x\n",
+			printf ("Skipping bad block 0x%08zx\n",
 				offset & ~(nand->erasesize - 1));
 			offset += nand->erasesize - block_offset;
 			continue;
@@ -582,7 +589,7 @@
 
 		rval = nand_read (nand, offset, &read_length, p_buffer);
 		if (rval != 0) {
-			printf ("NAND read from offset %x failed %d\n",
+			printf ("NAND read from offset %zx failed %d\n",
 				offset, rval);
 			*length -= left_to_read;
 			return rval;
diff -Naur u-boot-2009.01/drivers/mtd/nand/nomadik.c u-boot/drivers/mtd/nand/nomadik.c
--- u-boot-2009.01/drivers/mtd/nand/nomadik.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/mtd/nand/nomadik.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,221 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics, <www.st.com>
+ * (C) Copyright 2009 Alessandro Rubini <rubini@unipv.it>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+
+static inline int parity(int b) /* b is really a byte; returns 0 or ~0 */
+{
+	__asm__ __volatile__(
+		"eor   %0, %0, %0, lsr #4\n\t"
+		"eor   %0, %0, %0, lsr #2\n\t"
+		"eor   %0, %0, %0, lsr #1\n\t"
+		"ands  %0, %0, #1\n\t"
+		"subne %0, %0, #2\t"
+		: "=r" (b) : "0" (b));
+	return b;
+}
+
+/*
+ * This is the ECC routine used in hardware, according to the manual.
+ * HW claims to make the calculation but not the correction; so we must
+ * recalculate the bytes for a comparison.
+ */
+static int ecc512(const unsigned char *data, unsigned char *ecc)
+{
+	int gpar = 0;
+	int i, val, par;
+	int pbits = 0;		/* P8, P16, ... P2048 */
+	int pprime = 0;		/* P8', P16', ... P2048' */
+	int lowbits;		/* P1, P2, P4 and primes */
+
+	for (i = 0; i < 512; i++) {
+		par = parity((val = data[i]));
+		gpar ^= val;
+		pbits ^= (i & par);
+	}
+	/*
+	 * Ok, now gpar is global parity (xor of all bytes)
+	 * pbits are all the parity bits (non-prime ones)
+	 */
+	par = parity(gpar);
+	pprime = pbits ^ par;
+	/* Put low bits in the right position for ecc[2] (bits 7..2) */
+	lowbits = 0
+		| (parity(gpar & 0xf0) & 0x80)	/* P4  */
+		| (parity(gpar & 0x0f) & 0x40)	/* P4' */
+		| (parity(gpar & 0xcc) & 0x20)	/* P2  */
+		| (parity(gpar & 0x33) & 0x10)	/* P2' */
+		| (parity(gpar & 0xaa) & 0x08)	/* P1  */
+		| (parity(gpar & 0x55) & 0x04);	/* P1' */
+
+	ecc[2] = ~(lowbits | ((pbits & 0x100) >> 7) | ((pprime & 0x100) >> 8));
+	/* now intermix bits for ecc[1] (P1024..P128') and ecc[0] (P64..P8') */
+	ecc[1] = ~(    (pbits & 0x80) >> 0  | ((pprime & 0x80) >> 1)
+		    | ((pbits & 0x40) >> 1) | ((pprime & 0x40) >> 2)
+		    | ((pbits & 0x20) >> 2) | ((pprime & 0x20) >> 3)
+		    | ((pbits & 0x10) >> 3) | ((pprime & 0x10) >> 4));
+
+	ecc[0] = ~(    (pbits & 0x8) << 4  | ((pprime & 0x8) << 3)
+		    | ((pbits & 0x4) << 3) | ((pprime & 0x4) << 2)
+		    | ((pbits & 0x2) << 2) | ((pprime & 0x2) << 1)
+		    | ((pbits & 0x1) << 1) | ((pprime & 0x1) << 0));
+	return 0;
+}
+
+/* This is the method in the chip->ecc field */
+static int nomadik_ecc_calculate(struct mtd_info *mtd, const uint8_t *dat,
+				 uint8_t *ecc_code)
+{
+	return ecc512(dat, ecc_code);
+}
+
+static int nomadik_ecc_correct(struct mtd_info *mtd, uint8_t *dat,
+				uint8_t *r_ecc, uint8_t *c_ecc)
+{
+	struct nand_chip *chip = mtd->priv;
+	uint32_t r, c, d, diff; /*read, calculated, xor of them */
+
+	if (!memcmp(r_ecc, c_ecc, chip->ecc.bytes))
+		return 0;
+
+	/* Reorder the bytes into ascending-order 24 bits -- see manual */
+	r = r_ecc[2] << 22 | r_ecc[1] << 14 | r_ecc[0] << 6 | r_ecc[2] >> 2;
+	c = c_ecc[2] << 22 | c_ecc[1] << 14 | c_ecc[0] << 6 | c_ecc[2] >> 2;
+	diff = (r ^ c) & ((1<<24)-1); /* use 24 bits only */
+
+	/* If 12 bits are different, one per pair, it's correctable */
+	if (((diff | (diff>>1)) & 0x555555) == 0x555555) {
+		int bit = ((diff & 2) >> 1)
+			| ((diff & 0x8) >> 2) | ((diff & 0x20) >> 3);
+		int byte;
+
+		d = diff >> 6; /* remove bit-order info */
+		byte =  ((d & 2) >> 1)
+			| ((d & 0x8) >> 2) | ((d & 0x20) >> 3)
+			| ((d & 0x80) >> 4) | ((d & 0x200) >> 5)
+			| ((d & 0x800) >> 6) | ((d & 0x2000) >> 7)
+			| ((d & 0x8000) >> 8) | ((d & 0x20000) >> 9);
+		/* correct the single bit */
+		dat[byte] ^= 1<<bit;
+		return 0;
+	}
+	/* If 1 bit only differs, it's one bit error in ECC, ignore */
+	if ((diff ^ (1 << (ffs(diff) - 1))) == 0)
+		return 0;
+	/* Otherwise, uncorrectable */
+	return -1;
+}
+
+static void nomadik_ecc_hwctl(struct mtd_info *mtd, int mode)
+{ /* mandatory in the structure but not used here */ }
+
+
+/* This is the layout used by older installations, we keep compatible */
+struct nand_ecclayout nomadik_ecc_layout = {
+	.eccbytes = 3 * 4,
+	.eccpos = { /* each subpage has 16 bytes: pos 2,3,4 hosts ECC */
+		0x02, 0x03, 0x04,
+		0x12, 0x13, 0x14,
+		0x22, 0x23, 0x24,
+		0x32, 0x33, 0x34},
+	.oobfree = { {0x08, 0x08}, {0x18, 0x08}, {0x28, 0x08}, {0x38, 0x08} },
+};
+
+#define MASK_ALE	(1 << 24)	/* our ALE is AD21 */
+#define MASK_CLE	(1 << 23)	/* our CLE is AD22 */
+
+/* This is copied from the AT91SAM9 devices (Stelian Pop, Lead Tech Design) */
+static void nomadik_nand_hwcontrol(struct mtd_info *mtd,
+				   int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+	u32 pcr0 = readl(REG_FSMC_PCR0);
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		ulong IO_ADDR_W = (ulong) this->IO_ADDR_W;
+		IO_ADDR_W &= ~(MASK_ALE | MASK_CLE);
+
+		if (ctrl & NAND_CLE)
+			IO_ADDR_W |= MASK_CLE;
+		if (ctrl & NAND_ALE)
+			IO_ADDR_W |= MASK_ALE;
+
+		if (ctrl & NAND_NCE)
+			writel(pcr0 | 0x4, REG_FSMC_PCR0);
+		else
+			writel(pcr0 & ~0x4, REG_FSMC_PCR0);
+
+		this->IO_ADDR_W = (void *) IO_ADDR_W;
+		this->IO_ADDR_R = (void *) IO_ADDR_W;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, this->IO_ADDR_W);
+}
+
+/* Returns 1 when ready; upper layers timeout at 20ms with timer routines */
+static int nomadik_nand_ready(struct mtd_info *mtd)
+{
+	return 1; /* The ready bit is handled in hardware */
+}
+
+/* Copy a buffer 32bits at a time: faster than defualt method which is 8bit */
+static void nomadik_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+	u32 *p = (u32 *) buf;
+
+	len >>= 2;
+	writel(0, REG_FSMC_ECCR0);
+	for (i = 0; i < len; i++)
+		p[i] = readl(chip->IO_ADDR_R);
+}
+
+int board_nand_init(struct nand_chip *chip)
+{
+	/* Set up the FSMC_PCR0 for nand access*/
+	writel(0x0000004a, REG_FSMC_PCR0);
+	/* Set up FSMC_PMEM0, FSMC_PATT0 with timing data for access */
+	writel(0x00020401, REG_FSMC_PMEM0);
+	writel(0x00020404, REG_FSMC_PATT0);
+
+	chip->options = NAND_COPYBACK |	NAND_CACHEPRG | NAND_NO_PADDING;
+	chip->cmd_ctrl = nomadik_nand_hwcontrol;
+	chip->dev_ready = nomadik_nand_ready;
+	/* The chip allows 32bit reads, so avoid the default 8bit copy */
+	chip->read_buf = nomadik_nand_read_buf;
+
+	/* ECC: follow the hardware-defined rulse, but do it in sw */
+	chip->ecc.mode = NAND_ECC_HW;
+	chip->ecc.bytes = 3;
+	chip->ecc.size = 512;
+	chip->ecc.layout = &nomadik_ecc_layout;
+	chip->ecc.calculate = nomadik_ecc_calculate;
+	chip->ecc.hwctl = nomadik_ecc_hwctl;
+	chip->ecc.correct = nomadik_ecc_correct;
+
+	return 0;
+}
diff -Naur u-boot-2009.01/drivers/mtd/nand/omap_gpmc.c u-boot/drivers/mtd/nand/omap_gpmc.c
--- u-boot-2009.01/drivers/mtd/nand/omap_gpmc.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/mtd/nand/omap_gpmc.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,353 @@
+/*
+ * (C) Copyright 2004-2008 Texas Instruments, <www.ti.com>
+ * Rohit Choraria <rohitkc@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/omap_gpmc.h>
+#include <linux/mtd/nand_ecc.h>
+#include <nand.h>
+
+static uint8_t cs;
+static gpmc_t *gpmc_base = (gpmc_t *)GPMC_BASE;
+static gpmc_csx_t *gpmc_cs_base;
+static struct nand_ecclayout hw_nand_oob = GPMC_NAND_HW_ECC_LAYOUT;
+
+/*
+ * omap_nand_hwcontrol - Set the address pointers corretly for the
+ *			following address/data/command operation
+ */
+static void omap_nand_hwcontrol(struct mtd_info *mtd, int32_t cmd,
+				uint32_t ctrl)
+{
+	register struct nand_chip *this = mtd->priv;
+
+	/*
+	 * Point the IO_ADDR to DATA and ADDRESS registers instead
+	 * of chip address
+	 */
+	switch (ctrl) {
+	case NAND_CTRL_CHANGE | NAND_CTRL_CLE:
+		this->IO_ADDR_W = (void __iomem *)&gpmc_cs_base->nand_cmd;
+		break;
+	case NAND_CTRL_CHANGE | NAND_CTRL_ALE:
+		this->IO_ADDR_W = (void __iomem *)&gpmc_cs_base->nand_adr;
+		break;
+	case NAND_CTRL_CHANGE | NAND_NCE:
+		this->IO_ADDR_W = (void __iomem *)&gpmc_cs_base->nand_dat;
+		break;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, this->IO_ADDR_W);
+}
+
+/*
+ * omap_hwecc_init - Initialize the Hardware ECC for NAND flash in
+ *                   GPMC controller
+ * @mtd:        MTD device structure
+ *
+ */
+static void omap_hwecc_init(struct nand_chip *chip)
+{
+	/*
+	 * Init ECC Control Register
+	 * Clear all ECC | Enable Reg1
+	 */
+	writel(ECCCLEAR | ECCRESULTREG1, &gpmc_base->ecc_control);
+	writel(ECCSIZE1 | ECCSIZE0 | ECCSIZE0SEL, &gpmc_base->ecc_size_config);
+}
+
+/*
+ * gen_true_ecc - This function will generate true ECC value, which
+ * can be used when correcting data read from NAND flash memory core
+ *
+ * @ecc_buf:	buffer to store ecc code
+ *
+ * @return:	re-formatted ECC value
+ */
+static uint32_t gen_true_ecc(uint8_t *ecc_buf)
+{
+	return ecc_buf[0] | (ecc_buf[1] << 16) | ((ecc_buf[2] & 0xF0) << 20) |
+		((ecc_buf[2] & 0x0F) << 8);
+}
+
+/*
+ * omap_correct_data - Compares the ecc read from nand spare area with ECC
+ * registers values and corrects one bit error if it has occured
+ * Further details can be had from OMAP TRM and the following selected links:
+ * http://en.wikipedia.org/wiki/Hamming_code
+ * http://www.cs.utexas.edu/users/plaxton/c/337/05f/slides/ErrorCorrection-4.pdf
+ *
+ * @mtd:		 MTD device structure
+ * @dat:		 page data
+ * @read_ecc:		 ecc read from nand flash
+ * @calc_ecc:		 ecc read from ECC registers
+ *
+ * @return 0 if data is OK or corrected, else returns -1
+ */
+static int omap_correct_data(struct mtd_info *mtd, uint8_t *dat,
+				uint8_t *read_ecc, uint8_t *calc_ecc)
+{
+	uint32_t orig_ecc, new_ecc, res, hm;
+	uint16_t parity_bits, byte;
+	uint8_t bit;
+
+	/* Regenerate the orginal ECC */
+	orig_ecc = gen_true_ecc(read_ecc);
+	new_ecc = gen_true_ecc(calc_ecc);
+	/* Get the XOR of real ecc */
+	res = orig_ecc ^ new_ecc;
+	if (res) {
+		/* Get the hamming width */
+		hm = hweight32(res);
+		/* Single bit errors can be corrected! */
+		if (hm == 12) {
+			/* Correctable data! */
+			parity_bits = res >> 16;
+			bit = (parity_bits & 0x7);
+			byte = (parity_bits >> 3) & 0x1FF;
+			/* Flip the bit to correct */
+			dat[byte] ^= (0x1 << bit);
+		} else if (hm == 1) {
+			printf("Error: Ecc is wrong\n");
+			/* ECC itself is corrupted */
+			return 2;
+		} else {
+			/*
+			 * hm distance != parity pairs OR one, could mean 2 bit
+			 * error OR potentially be on a blank page..
+			 * orig_ecc: contains spare area data from nand flash.
+			 * new_ecc: generated ecc while reading data area.
+			 * Note: if the ecc = 0, all data bits from which it was
+			 * generated are 0xFF.
+			 * The 3 byte(24 bits) ecc is generated per 512byte
+			 * chunk of a page. If orig_ecc(from spare area)
+			 * is 0xFF && new_ecc(computed now from data area)=0x0,
+			 * this means that data area is 0xFF and spare area is
+			 * 0xFF. A sure sign of a erased page!
+			 */
+			if ((orig_ecc == 0x0FFF0FFF) && (new_ecc == 0x00000000))
+				return 0;
+			printf("Error: Bad compare! failed\n");
+			/* detected 2 bit error */
+			return -1;
+		}
+	}
+	return 0;
+}
+
+/*
+ *  omap_calculate_ecc - Generate non-inverted ECC bytes.
+ *
+ *  Using noninverted ECC can be considered ugly since writing a blank
+ *  page ie. padding will clear the ECC bytes. This is no problem as
+ *  long nobody is trying to write data on the seemingly unused page.
+ *  Reading an erased page will produce an ECC mismatch between
+ *  generated and read ECC bytes that has to be dealt with separately.
+ *  E.g. if page is 0xFF (fresh erased), and if HW ECC engine within GPMC
+ *  is used, the result of read will be 0x0 while the ECC offsets of the
+ *  spare area will be 0xFF which will result in an ECC mismatch.
+ *  @mtd:	MTD structure
+ *  @dat:	unused
+ *  @ecc_code:	ecc_code buffer
+ */
+static int omap_calculate_ecc(struct mtd_info *mtd, const uint8_t *dat,
+				uint8_t *ecc_code)
+{
+	u_int32_t val;
+
+	/* Start Reading from HW ECC1_Result = 0x200 */
+	val = readl(&gpmc_base->ecc1_result);
+
+	ecc_code[0] = val & 0xFF;
+	ecc_code[1] = (val >> 16) & 0xFF;
+	ecc_code[2] = ((val >> 8) & 0x0F) | ((val >> 20) & 0xF0);
+
+	/*
+	 * Stop reading anymore ECC vals and clear old results
+	 * enable will be called if more reads are required
+	 */
+	writel(0x000, &gpmc_base->ecc_config);
+
+	return 0;
+}
+
+/*
+ * omap_enable_ecc - This function enables the hardware ecc functionality
+ * @mtd:        MTD device structure
+ * @mode:       Read/Write mode
+ */
+static void omap_enable_hwecc(struct mtd_info *mtd, int32_t mode)
+{
+	struct nand_chip *chip = mtd->priv;
+	uint32_t val, dev_width = (chip->options & NAND_BUSWIDTH_16) >> 1;
+
+	switch (mode) {
+	case NAND_ECC_READ:
+	case NAND_ECC_WRITE:
+		/* Clear the ecc result registers, select ecc reg as 1 */
+		writel(ECCCLEAR | ECCRESULTREG1, &gpmc_base->ecc_control);
+
+		/*
+		 * Size 0 = 0xFF, Size1 is 0xFF - both are 512 bytes
+		 * tell all regs to generate size0 sized regs
+		 * we just have a single ECC engine for all CS
+		 */
+		writel(ECCSIZE1 | ECCSIZE0 | ECCSIZE0SEL,
+			&gpmc_base->ecc_size_config);
+		val = (dev_width << 7) | (cs << 1) | (0x1);
+		writel(val, &gpmc_base->ecc_config);
+		break;
+	default:
+		printf("Error: Unrecognized Mode[%d]!\n", mode);
+		break;
+	}
+}
+
+/*
+ * omap_nand_switch_ecc - switch the ECC operation b/w h/w ecc and s/w ecc.
+ * The default is to come up on s/w ecc
+ *
+ * @hardware - 1 -switch to h/w ecc, 0 - s/w ecc
+ *
+ */
+void omap_nand_switch_ecc(int32_t hardware)
+{
+	struct nand_chip *nand;
+	struct mtd_info *mtd;
+
+	if (nand_curr_device < 0 ||
+	    nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE ||
+	    !nand_info[nand_curr_device].name) {
+		printf("Error: Can't switch ecc, no devices available\n");
+		return;
+	}
+
+	mtd = &nand_info[nand_curr_device];
+	nand = mtd->priv;
+
+	nand->options |= NAND_OWN_BUFFERS;
+
+	/* Reset ecc interface */
+	nand->ecc.read_page = NULL;
+	nand->ecc.write_page = NULL;
+	nand->ecc.read_oob = NULL;
+	nand->ecc.write_oob = NULL;
+	nand->ecc.hwctl = NULL;
+	nand->ecc.correct = NULL;
+	nand->ecc.calculate = NULL;
+
+	/* Setup the ecc configurations again */
+	if (hardware) {
+		nand->ecc.mode = NAND_ECC_HW;
+		nand->ecc.layout = &hw_nand_oob;
+		nand->ecc.size = 512;
+		nand->ecc.bytes = 3;
+		nand->ecc.hwctl = omap_enable_hwecc;
+		nand->ecc.correct = omap_correct_data;
+		nand->ecc.calculate = omap_calculate_ecc;
+		omap_hwecc_init(nand);
+		printf("HW ECC selected\n");
+	} else {
+		nand->ecc.mode = NAND_ECC_SOFT;
+		/* Use mtd default settings */
+		nand->ecc.layout = NULL;
+		printf("SW ECC selected\n");
+	}
+
+	/* Update NAND handling after ECC mode switch */
+	nand_scan_tail(mtd);
+
+	nand->options &= ~NAND_OWN_BUFFERS;
+}
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific:
+ * - IO_ADDR_R: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W: address to write the 8 I/O lines of the flash device
+ * - cmd_ctrl: hardwarespecific function for accesing control-lines
+ * - waitfunc: hardwarespecific function for accesing device ready/busy line
+ * - ecc.hwctl: function to enable (reset) hardware ecc generator
+ * - ecc.mode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+	int32_t gpmc_config = 0;
+	cs = 0;
+
+	/*
+	 * xloader/Uboot's gpmc configuration would have configured GPMC for
+	 * nand type of memory. The following logic scans and latches on to the
+	 * first CS with NAND type memory.
+	 * TBD: need to make this logic generic to handle multiple CS NAND
+	 * devices.
+	 */
+	while (cs < GPMC_MAX_CS) {
+		/*
+		 * Each GPMC set for a single CS is at offset 0x30
+		 * - already remapped for us
+		 */
+		gpmc_cs_base = (gpmc_csx_t *)(GPMC_CONFIG_CS0_BASE +
+				(cs * GPMC_CONFIG_WIDTH));
+		/* Check if NAND type is set */
+		if ((readl(&gpmc_cs_base->config1) & 0xC00) ==
+		     0x800) {
+			/* Found it!! */
+			break;
+		}
+		cs++;
+	}
+	if (cs >= GPMC_MAX_CS) {
+		printf("NAND: Unable to find NAND settings in "
+			"GPMC Configuration - quitting\n");
+		return -ENODEV;
+	}
+
+	gpmc_config = readl(&gpmc_base->config);
+	/* Disable Write protect */
+	gpmc_config |= 0x10;
+	writel(gpmc_config, &gpmc_base->config);
+
+	nand->IO_ADDR_R = (void __iomem *)&gpmc_cs_base->nand_dat;
+	nand->IO_ADDR_W = (void __iomem *)&gpmc_cs_base->nand_cmd;
+
+	nand->cmd_ctrl = omap_nand_hwcontrol;
+	nand->options = NAND_NO_PADDING | NAND_CACHEPRG | NAND_NO_AUTOINCR;
+	/* If we are 16 bit dev, our gpmc config tells us that */
+	if ((readl(gpmc_cs_base) & 0x3000) == 0x1000)
+		nand->options |= NAND_BUSWIDTH_16;
+
+	nand->chip_delay = 100;
+	/* Default ECC mode */
+	nand->ecc.mode = NAND_ECC_SOFT;
+
+	return 0;
+}
diff -Naur u-boot-2009.01/drivers/mtd/nand_legacy/nand_legacy.c u-boot/drivers/mtd/nand_legacy/nand_legacy.c
--- u-boot-2009.01/drivers/mtd/nand_legacy/nand_legacy.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/nand_legacy/nand_legacy.c	2009-02-26 14:03:58.000000000 +0100
@@ -457,7 +457,7 @@
 {
 	int floor, chip;
 	int numchips[NAND_MAX_FLOORS];
-	int maxchips = NAND_MAX_CHIPS;
+	int maxchips = CONFIG_SYS_NAND_MAX_CHIPS;
 	int ret = 1;
 
 	nand->numchips = 0;
diff -Naur u-boot-2009.01/drivers/mtd/onenand/onenand_base.c u-boot/drivers/mtd/onenand/onenand_base.c
--- u-boot-2009.01/drivers/mtd/onenand/onenand_base.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/onenand/onenand_base.c	2009-02-26 14:03:58.000000000 +0100
@@ -36,6 +36,35 @@
 	return ret;
 }
 
+/**
+ * onenand_oob_64 - oob info for large (2KB) page
+ */
+static struct nand_ecclayout onenand_oob_64 = {
+	.eccbytes	= 20,
+	.eccpos		= {
+		8, 9, 10, 11, 12,
+		24, 25, 26, 27, 28,
+		40, 41, 42, 43, 44,
+		56, 57, 58, 59, 60,
+		},
+	.oobfree	= {
+		{2, 3}, {14, 2}, {18, 3}, {30, 2},
+		{34, 3}, {46, 2}, {50, 3}, {62, 2}
+	}
+};
+
+/**
+ * onenand_oob_32 - oob info for middle (1KB) page
+ */
+static struct nand_ecclayout onenand_oob_32 = {
+	.eccbytes	= 10,
+	.eccpos		= {
+		8, 9, 10, 11, 12,
+		24, 25, 26, 27, 28,
+		},
+	.oobfree	= { {2, 3}, {14, 2}, {18, 3}, {30, 2} }
+};
+
 static const unsigned char ffchars[] = {
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,	/* 16 */
@@ -78,20 +107,11 @@
  *
  * Setup Start Address 1 Register (F100h)
  */
-static int onenand_block_address(int device, int block)
+static int onenand_block_address(struct onenand_chip *this, int block)
 {
-	if (device & ONENAND_DEVICE_IS_DDP) {
-		/* Device Flash Core select, NAND Flash Block Address */
-		int dfs = 0, density, mask;
-
-		density = device >> ONENAND_DEVICE_DENSITY_SHIFT;
-		mask = (1 << (density + 6));
-
-		if (block & mask)
-			dfs = 1;
-
-		return (dfs << ONENAND_DDP_SHIFT) | (block & (mask - 1));
-	}
+	/* Device Flash Core select, NAND Flash Block Address */
+	if (block & this->density_mask)
+		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
 
 	return block;
 }
@@ -104,22 +124,13 @@
  *
  * Setup Start Address 2 Register (F101h) for DDP
  */
-static int onenand_bufferram_address(int device, int block)
+static int onenand_bufferram_address(struct onenand_chip *this, int block)
 {
-	if (device & ONENAND_DEVICE_IS_DDP) {
-		/* Device BufferRAM Select */
-		int dbs = 0, density, mask;
-
-		density = device >> ONENAND_DEVICE_DENSITY_SHIFT;
-		mask = (1 << (density + 6));
-
-		if (block & mask)
-			dbs = 1;
+	/* Device BufferRAM Select */
+	if (block & this->density_mask)
+		return ONENAND_DDP_CHIP1;
 
-		return (dbs << ONENAND_DDP_SHIFT);
-	}
-
-	return 0;
+	return ONENAND_DDP_CHIP0;
 }
 
 /**
@@ -169,6 +180,18 @@
 }
 
 /**
+ * onenand_get_density - [DEFAULT] Get OneNAND density
+ * @param dev_id        OneNAND device ID
+ *
+ * Get OneNAND density from device ID
+ */
+static inline int onenand_get_density(int dev_id)
+{
+	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
+	return (density & ONENAND_DEVICE_DENSITY_MASK);
+}
+
+/**
  * onenand_command - [DEFAULT] Send command to OneNAND device
  * @param mtd		MTD device structure
  * @param cmd		the command to be sent
@@ -192,6 +215,7 @@
 	case ONENAND_CMD_UNLOCK:
 	case ONENAND_CMD_LOCK:
 	case ONENAND_CMD_LOCK_TIGHT:
+	case ONENAND_CMD_UNLOCK_ALL:
 		block = -1;
 		page = -1;
 		break;
@@ -212,7 +236,7 @@
 	/* NOTE: The setting order of the registers is very important! */
 	if (cmd == ONENAND_CMD_BUFFERRAM) {
 		/* Select DataRAM for DDP */
-		value = onenand_bufferram_address(this->device_id, block);
+		value = onenand_bufferram_address(this, block);
 		this->write_word(value,
 				 this->base + ONENAND_REG_START_ADDRESS2);
 
@@ -224,9 +248,14 @@
 
 	if (block != -1) {
 		/* Write 'DFS, FBA' of Flash */
-		value = onenand_block_address(this->device_id, block);
+		value = onenand_block_address(this, block);
 		this->write_word(value,
 				 this->base + ONENAND_REG_START_ADDRESS1);
+
+		/* Write 'DFS, FBA' of Flash */
+		value = onenand_bufferram_address(this, block);
+		this->write_word(value,
+				 this->base + ONENAND_REG_START_ADDRESS2);
 	}
 
 	if (page != -1) {
@@ -252,15 +281,6 @@
 		/* Write 'BSA, BSC' of DataRAM */
 		value = onenand_buffer_address(dataram, sectors, count);
 		this->write_word(value, this->base + ONENAND_REG_START_BUFFER);
-
-		if (readcmd) {
-			/* Select DataRAM for DDP */
-			value =
-			    onenand_bufferram_address(this->device_id, block);
-			this->write_word(value,
-					 this->base +
-					 ONENAND_REG_START_ADDRESS2);
-		}
 	}
 
 	/* Interrupt clear */
@@ -296,14 +316,11 @@
 	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
 
 	if (ctrl & ONENAND_CTRL_ERROR) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-			  "onenand_wait: controller error = 0x%04x\n", ctrl);
-		return -EAGAIN;
-	}
+		printk("onenand_wait: controller error = 0x%04x\n", ctrl);
+		if (ctrl & ONENAND_CTRL_LOCK)
+			printk("onenand_wait: it's locked error = 0x%04x\n",
+				ctrl);
 
-	if (ctrl & ONENAND_CTRL_LOCK) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-			  "onenand_wait: it's locked error = 0x%04x\n", ctrl);
 		return -EIO;
 	}
 
@@ -351,7 +368,7 @@
  *
  * Read the BufferRAM area
  */
-static int onenand_read_bufferram(struct mtd_info *mtd, int area,
+static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
 				  unsigned char *buffer, int offset,
 				  size_t count)
 {
@@ -376,7 +393,7 @@
  *
  * Read the BufferRAM area with Sync. Burst Mode
  */
-static int onenand_sync_read_bufferram(struct mtd_info *mtd, int area,
+static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
 				       unsigned char *buffer, int offset,
 				       size_t count)
 {
@@ -405,7 +422,7 @@
  *
  * Write the BufferRAM area
  */
-static int onenand_write_bufferram(struct mtd_info *mtd, int area,
+static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
 				   const unsigned char *buffer, int offset,
 				   size_t count)
 {
@@ -421,6 +438,30 @@
 }
 
 /**
+ * onenand_get_2x_blockpage - [GENERIC] Get blockpage at 2x program mode
+ * @param mtd		MTD data structure
+ * @param addr		address to check
+ * @return		blockpage address
+ *
+ * Get blockpage address at 2x program mode
+ */
+static int onenand_get_2x_blockpage(struct mtd_info *mtd, loff_t addr)
+{
+	struct onenand_chip *this = mtd->priv;
+	int blockpage, block, page;
+
+	/* Calculate the even block number */
+	block = (int) (addr >> this->erase_shift) & ~1;
+	/* Is it the odd plane? */
+	if (addr & this->writesize)
+		block++;
+	page = (int) (addr >> (this->page_shift + 1)) & this->page_mask;
+	blockpage = (block << 7) | page;
+
+	return blockpage;
+}
+
+/**
  * onenand_check_bufferram - [GENERIC] Check BufferRAM information
  * @param mtd		MTD data structure
  * @param addr		address to check
@@ -431,21 +472,39 @@
 static int onenand_check_bufferram(struct mtd_info *mtd, loff_t addr)
 {
 	struct onenand_chip *this = mtd->priv;
-	int block, page;
-	int i;
+	int blockpage, found = 0;
+	unsigned int i;
 
-	block = (int)(addr >> this->erase_shift);
-	page = (int)(addr >> this->page_shift);
-	page &= this->page_mask;
+#ifdef CONFIG_S3C64XX
+	return 0;
+#endif
 
-	i = ONENAND_CURRENT_BUFFERRAM(this);
+	if (ONENAND_IS_2PLANE(this))
+		blockpage = onenand_get_2x_blockpage(mtd, addr);
+	else
+		blockpage = (int) (addr >> this->page_shift);
 
 	/* Is there valid data? */
-	if (this->bufferram[i].block == block &&
-	    this->bufferram[i].page == page && this->bufferram[i].valid)
-		return 1;
+	i = ONENAND_CURRENT_BUFFERRAM(this);
+	if (this->bufferram[i].blockpage == blockpage)
+		found = 1;
+	else {
+		/* Check another BufferRAM */
+		i = ONENAND_NEXT_BUFFERRAM(this);
+		if (this->bufferram[i].blockpage == blockpage) {
+			ONENAND_SET_NEXT_BUFFERRAM(this);
+			found = 1;
+		}
+	}
 
-	return 0;
+	if (found && ONENAND_IS_DDP(this)) {
+		/* Select DataRAM for DDP */
+		int block = (int) (addr >> this->erase_shift);
+		int value = onenand_bufferram_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
+	}
+
+	return found;
 }
 
 /**
@@ -460,25 +519,25 @@
 				    int valid)
 {
 	struct onenand_chip *this = mtd->priv;
-	int block, page;
-	int i;
+	int blockpage;
+	unsigned int i;
 
-	block = (int)(addr >> this->erase_shift);
-	page = (int)(addr >> this->page_shift);
-	page &= this->page_mask;
+	if (ONENAND_IS_2PLANE(this))
+		blockpage = onenand_get_2x_blockpage(mtd, addr);
+	else
+		blockpage = (int)(addr >> this->page_shift);
 
-	/* Invalidate BufferRAM */
-	for (i = 0; i < MAX_BUFFERRAM; i++) {
-		if (this->bufferram[i].block == block &&
-		    this->bufferram[i].page == page)
-			this->bufferram[i].valid = 0;
-	}
+	/* Invalidate another BufferRAM */
+	i = ONENAND_NEXT_BUFFERRAM(this);
+	if (this->bufferram[i].blockpage == blockpage)
+		this->bufferram[i].blockpage = -1;
 
 	/* Update BufferRAM */
 	i = ONENAND_CURRENT_BUFFERRAM(this);
-	this->bufferram[i].block = block;
-	this->bufferram[i].page = page;
-	this->bufferram[i].valid = valid;
+	if (valid)
+		this->bufferram[i].blockpage = blockpage;
+	else
+		this->bufferram[i].blockpage = -1;
 
 	return 0;
 }
@@ -500,10 +559,10 @@
 
 	/* Invalidate BufferRAM */
 	for (i = 0; i < MAX_BUFFERRAM; i++) {
-		loff_t buf_addr = this->bufferram[i].block << this->erase_shift;
+		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
 
 		if (buf_addr >= addr && buf_addr < end_addr)
-			this->bufferram[i].valid = 0;
+			this->bufferram[i].blockpage = -1;
 	}
 }
 
@@ -556,7 +615,7 @@
 			readend += free->offset - lastgap;
 		lastgap = free->offset + free->length;
 	}
-	this->read_bufferram(mtd, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
+	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
 	free = this->ecclayout->oobfree;
 	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
 		int free_end = free->offset + free->length;
@@ -594,9 +653,7 @@
 	int ret = 0, boundary = 0;
 	int writesize = this->writesize;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3,
-		"onenand_read_ops_nolock: from = 0x%08x, len = %i\n",
-		(unsigned int) from, (int) len);
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
 
 	if (ops->mode == MTD_OOB_AUTO)
 		oobsize = this->ecclayout->oobavail;
@@ -620,6 +677,7 @@
 	/* Do first load to bufferRAM */
 	if (read < len) {
 		if (!onenand_check_bufferram(mtd, from)) {
+			this->main_buf = buf;
 			this->command(mtd, ONENAND_CMD_READ, from, writesize);
 			ret = this->wait(mtd, FL_READING);
 			onenand_update_bufferram(mtd, from, !ret);
@@ -637,6 +695,7 @@
 		/* If there is more to load then start next load */
 		from += thislen;
 		if (read + thislen < len) {
+			this->main_buf = buf + thislen;
 			this->command(mtd, ONENAND_CMD_READ, from, writesize);
 			/*
 			 * Chip boundary handling in DDP
@@ -653,7 +712,7 @@
 		}
 
 		/* While load is going, read from last bufferRAM */
-		this->read_bufferram(mtd, ONENAND_DATARAM, buf, column, thislen);
+		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);
 
 		/* Read oob area if needed */
 		if (oobbuf) {
@@ -663,7 +722,7 @@
 			if (ops->mode == MTD_OOB_AUTO)
 				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
 			else
-				this->read_bufferram(mtd, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
+				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
 			oobread += thisooblen;
 			oobbuf += thisooblen;
 			oobcolumn = 0;
@@ -726,9 +785,7 @@
 
 	from += ops->ooboffs;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3,
-		"onenand_read_oob_nolock: from = 0x%08x, len = %i\n",
-		(unsigned int) from, (int) len);
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
 
 	/* Initialize return length value */
 	ops->oobretlen = 0;
@@ -759,6 +816,7 @@
 		thislen = oobsize - column;
 		thislen = min_t(int, thislen, len);
 
+		this->spare_buf = buf;
 		this->command(mtd, ONENAND_CMD_READOOB, from, mtd->oobsize);
 
 		onenand_update_bufferram(mtd, from, 0);
@@ -772,7 +830,7 @@
 		if (mode == MTD_OOB_AUTO)
 			onenand_transfer_auto_oob(mtd, buf, column, thislen);
 		else
-			this->read_bufferram(mtd, ONENAND_SPARERAM, buf, column, thislen);
+			this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
 
 		read += thislen;
 
@@ -886,12 +944,6 @@
 	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
 	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
 
-	/* Initial bad block case: 0x2400 or 0x0400 */
-	if (ctrl & ONENAND_CTRL_ERROR) {
-		printk(KERN_DEBUG "onenand_bbt_wait: controller error = 0x%04x\n", ctrl);
-		return ONENAND_BBT_READ_ERROR;
-	}
-
 	if (interrupt & ONENAND_INT_READ) {
 		int ecc = this->read_word(this->base + ONENAND_REG_ECC_STATUS);
 		if (ecc & ONENAND_ECC_2BIT_ALL)
@@ -902,6 +954,12 @@
 		return ONENAND_BBT_READ_FATAL_ERROR;
 	}
 
+	/* Initial bad block case: 0x2400 or 0x0400 */
+	if (ctrl & ONENAND_CTRL_ERROR) {
+		printk(KERN_DEBUG "onenand_bbt_wait: controller error = 0x%04x\n", ctrl);
+		return ONENAND_BBT_READ_ERROR;
+	}
+
 	return 0;
 }
 
@@ -922,9 +980,7 @@
 	size_t len = ops->ooblen;
 	u_char *buf = ops->oobbuf;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3,
-		"onenand_bbt_read_oob: from = 0x%08x, len = %zi\n",
-		(unsigned int) from, len);
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);
 
 	/* Initialize return value */
 	ops->oobretlen = 0;
@@ -945,15 +1001,16 @@
 		thislen = mtd->oobsize - column;
 		thislen = min_t(int, thislen, len);
 
+		this->spare_buf = buf;
 		this->command(mtd, ONENAND_CMD_READOOB, from, mtd->oobsize);
 
 		onenand_update_bufferram(mtd, from, 0);
 
-		ret = onenand_bbt_wait(mtd, FL_READING);
+		ret = this->bbt_wait(mtd, FL_READING);
 		if (ret)
 			break;
 
-		this->read_bufferram(mtd, ONENAND_SPARERAM, buf, column, thislen);
+		this->read_spareram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
 		read += thislen;
 		if (read == len)
 			break;
@@ -995,7 +1052,7 @@
 	if (status)
 		return status;
 
-	this->read_bufferram(mtd, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
+	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
 	for (i = 0; i < mtd->oobsize; i++)
 		if (buf[i] != 0xFF && buf[i] != oob_buf[i])
 			return -EBADMSG;
@@ -1051,7 +1108,7 @@
 #define onenand_verify_oob(...)         (0)
 #endif
 
-#define NOTALIGNED(x)	((x & (mtd->writesize - 1)) != 0)
+#define NOTALIGNED(x)	((x & (this->subpagesize - 1)) != 0)
 
 /**
  * onenand_fill_auto_oob - [Internal] oob auto-placement transfer
@@ -1115,9 +1172,7 @@
 	u_char *oobbuf;
 	int ret = 0;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3,
-		"onenand_write_ops_nolock: to = 0x%08x, len = %i\n",
-		(unsigned int) to, (int) len);
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_ops_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
 
 	/* Initialize retlen, in case of early exit */
 	ops->retlen = 0;
@@ -1161,7 +1216,7 @@
 			wbuf = this->page_buf;
 		}
 
-		this->write_bufferram(mtd, ONENAND_DATARAM, wbuf, 0, mtd->writesize);
+		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);
 
 		if (oob) {
 			oobbuf = this->oob_buf;
@@ -1180,7 +1235,7 @@
 		} else
 			oobbuf = (u_char *) ffchars;
 
-		this->write_bufferram(mtd, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
+		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
 
 		this->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);
 
@@ -1244,9 +1299,7 @@
 
 	to += ops->ooboffs;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3,
-		"onenand_write_oob_nolock: to = 0x%08x, len = %i\n",
-		(unsigned int) to, (int) len);
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
 
 	/* Initialize retlen, in case of early exit */
 	ops->oobretlen = 0;
@@ -1293,7 +1346,7 @@
 			onenand_fill_auto_oob(mtd, oobbuf, buf, column, thislen);
 		else
 			memcpy(oobbuf + column, buf, thislen);
-		this->write_bufferram(mtd, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
+		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
 
 		this->command(mtd, ONENAND_CMD_PROGOOB, to, mtd->oobsize);
 
@@ -1466,7 +1519,14 @@
 
 	while (len) {
 
-		/* TODO Check badblock */
+		/* Check if we have a bad block, we do not erase bad blocks */
+		if (instr->priv == 0 && onenand_block_isbad_nolock(mtd, addr, 0)) {
+			printk(KERN_WARNING "onenand_erase: attempt to erase"
+				" a bad block at addr 0x%08x\n",
+				(unsigned int) addr);
+			instr->state = MTD_ERASE_FAILED;
+			goto erase_exit;
+		}
 
 		this->command(mtd, ONENAND_CMD_ERASE, addr, block_size);
 
@@ -1482,8 +1542,16 @@
 				MTDDEBUG (MTD_DEBUG_LEVEL0, "onenand_erase: "
 					  "Failed erase, block %d\n",
 					  (unsigned)(addr >> this->erase_shift));
+			if (ret == -EPERM)
+				printk("onenand_erase: "
+					  "Device is write protected!!!\n");
+			else
+				printk("onenand_erase: "
+					  "Failed erase, block %d\n",
+					  (unsigned)(addr >> this->erase_shift));
 			instr->state = MTD_ERASE_FAILED;
 			instr->fail_addr = addr;
+
 			goto erase_exit;
 		}
 
@@ -1493,7 +1561,7 @@
 
 	instr->state = MTD_ERASE_DONE;
 
-      erase_exit:
+erase_exit:
 
 	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
 	/* Do call back function */
@@ -1545,6 +1613,37 @@
 }
 
 /**
+ * onenand_default_block_markbad - [DEFAULT] mark a block bad
+ * @param mtd           MTD device structure
+ * @param ofs           offset from device start
+ *
+ * This is the default implementation, which can be overridden by
+ * a hardware specific driver.
+ */
+static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct onenand_chip *this = mtd->priv;
+	struct bbm_info *bbm = this->bbm;
+	u_char buf[2] = {0, 0};
+	struct mtd_oob_ops ops = {
+		.mode = MTD_OOB_PLACE,
+		.ooblen = 2,
+		.oobbuf = buf,
+		.ooboffs = 0,
+	};
+	int block;
+
+	/* Get block number */
+	block = ((int) ofs) >> bbm->bbt_erase_shift;
+	if (bbm->bbt)
+		bbm->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+
+	/* We write two bytes, so we dont have to mess with 16 bit access */
+	ofs += mtd->oobsize + (bbm->badblockpos & ~0x01);
+	return onenand_write_oob_nolock(mtd, ofs, &ops);
+}
+
+/**
  * onenand_block_markbad - [MTD Interface] Mark the block at the given offset as bad
  * @param mtd		MTD device structure
  * @param ofs		offset relative to mtd start
@@ -1569,23 +1668,30 @@
 }
 
 /**
- * onenand_unlock - [MTD Interface] Unlock block(s)
- * @param mtd		MTD device structure
- * @param ofs		offset relative to mtd start
- * @param len		number of bytes to unlock
+ * onenand_do_lock_cmd - [OneNAND Interface] Lock or unlock block(s)
+ * @param mtd           MTD device structure
+ * @param ofs           offset relative to mtd start
+ * @param len           number of bytes to lock or unlock
+ * @param cmd           lock or unlock command
  *
- * Unlock one or more blocks
+ * Lock or unlock one or more blocks
  */
-int onenand_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
+static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
 {
 	struct onenand_chip *this = mtd->priv;
 	int start, end, block, value, status;
+	int wp_status_mask;
 
 	start = ofs >> this->erase_shift;
 	end = len >> this->erase_shift;
 
+	if (cmd == ONENAND_CMD_LOCK)
+		wp_status_mask = ONENAND_WP_LS;
+	else
+		wp_status_mask = ONENAND_WP_US;
+
 	/* Continuous lock scheme */
-	if (this->options & ONENAND_CONT_LOCK) {
+	if (this->options & ONENAND_HAS_CONT_LOCK) {
 		/* Set start block address */
 		this->write_word(start,
 				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
@@ -1593,7 +1699,7 @@
 		this->write_word(end - 1,
 				 this->base + ONENAND_REG_END_BLOCK_ADDRESS);
 		/* Write unlock command */
-		this->command(mtd, ONENAND_CMD_UNLOCK, 0, 0);
+		this->command(mtd, cmd, 0, 0);
 
 		/* There's no return value */
 		this->wait(mtd, FL_UNLOCKING);
@@ -1612,7 +1718,14 @@
 	}
 
 	/* Block lock scheme */
-	for (block = start; block < end; block++) {
+	for (block = start; block < start + end; block++) {
+		/* Set block address */
+		value = onenand_block_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
+		/* Select DataRAM for DDP */
+		value = onenand_bufferram_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
+
 		/* Set start block address */
 		this->write_word(block,
 				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
@@ -1627,11 +1740,6 @@
 		       & ONENAND_CTRL_ONGO)
 			continue;
 
-		/* Set block address for read block status */
-		value = onenand_block_address(this->device_id, block);
-		this->write_word(value,
-				 this->base + ONENAND_REG_START_ADDRESS1);
-
 		/* Check lock status */
 		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
 		if (!(status & ONENAND_WP_US))
@@ -1642,32 +1750,199 @@
 	return 0;
 }
 
+#ifdef ONENAND_LINUX
+/**
+ * onenand_lock - [MTD Interface] Lock block(s)
+ * @param mtd           MTD device structure
+ * @param ofs           offset relative to mtd start
+ * @param len           number of bytes to unlock
+ *
+ * Lock one or more blocks
+ */
+static int onenand_lock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	int ret;
+
+	onenand_get_device(mtd, FL_LOCKING);
+	ret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_LOCK);
+	onenand_release_device(mtd);
+	return ret;
+}
+
+/**
+ * onenand_unlock - [MTD Interface] Unlock block(s)
+ * @param mtd           MTD device structure
+ * @param ofs           offset relative to mtd start
+ * @param len           number of bytes to unlock
+ *
+ * Unlock one or more blocks
+ */
+static int onenand_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	int ret;
+
+	onenand_get_device(mtd, FL_LOCKING);
+	ret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
+	onenand_release_device(mtd);
+	return ret;
+}
+#endif
+
+/**
+ * onenand_check_lock_status - [OneNAND Interface] Check lock status
+ * @param this          onenand chip data structure
+ *
+ * Check lock status
+ */
+static int onenand_check_lock_status(struct onenand_chip *this)
+{
+	unsigned int value, block, status;
+	unsigned int end;
+
+	end = this->chipsize >> this->erase_shift;
+	for (block = 0; block < end; block++) {
+		/* Set block address */
+		value = onenand_block_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
+		/* Select DataRAM for DDP */
+		value = onenand_bufferram_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
+		/* Set start block address */
+		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
+
+		/* Check lock status */
+		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
+		if (!(status & ONENAND_WP_US)) {
+			printk(KERN_ERR "block = %d, wp status = 0x%x\n", block, status);
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+/**
+ * onenand_unlock_all - [OneNAND Interface] unlock all blocks
+ * @param mtd           MTD device structure
+ *
+ * Unlock all blocks
+ */
+static void onenand_unlock_all(struct mtd_info *mtd)
+{
+	struct onenand_chip *this = mtd->priv;
+	loff_t ofs = 0;
+	size_t len = this->chipsize;
+
+	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
+		/* Set start block address */
+		this->write_word(0, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
+		/* Write unlock command */
+		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
+
+		/* There's no return value */
+		this->wait(mtd, FL_LOCKING);
+
+		/* Sanity check */
+		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
+				& ONENAND_CTRL_ONGO)
+			continue;
+
+		return;
+
+		/* Check lock status */
+		if (onenand_check_lock_status(this))
+			return;
+
+		/* Workaround for all block unlock in DDP */
+		if (ONENAND_IS_DDP(this)) {
+			/* All blocks on another chip */
+			ofs = this->chipsize >> 1;
+			len = this->chipsize >> 1;
+		}
+	}
+
+	onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
+}
+
+
+/**
+ * onenand_check_features - Check and set OneNAND features
+ * @param mtd           MTD data structure
+ *
+ * Check and set OneNAND features
+ * - lock scheme
+ * - two plane
+ */
+static void onenand_check_features(struct mtd_info *mtd)
+{
+	struct onenand_chip *this = mtd->priv;
+	unsigned int density, process;
+
+	/* Lock scheme depends on density and process */
+	density = onenand_get_density(this->device_id);
+	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
+
+	/* Lock scheme */
+	switch (density) {
+	case ONENAND_DEVICE_DENSITY_4Gb:
+		this->options |= ONENAND_HAS_2PLANE;
+
+	case ONENAND_DEVICE_DENSITY_2Gb:
+		/* 2Gb DDP don't have 2 plane */
+		if (!ONENAND_IS_DDP(this))
+			this->options |= ONENAND_HAS_2PLANE;
+		this->options |= ONENAND_HAS_UNLOCK_ALL;
+
+	case ONENAND_DEVICE_DENSITY_1Gb:
+		/* A-Die has all block unlock */
+		if (process)
+			this->options |= ONENAND_HAS_UNLOCK_ALL;
+		break;
+
+	default:
+		/* Some OneNAND has continuous lock scheme */
+		if (!process)
+			this->options |= ONENAND_HAS_CONT_LOCK;
+		break;
+	}
+
+	if (this->options & ONENAND_HAS_CONT_LOCK)
+		printk(KERN_DEBUG "Lock scheme is Continuous Lock\n");
+	if (this->options & ONENAND_HAS_UNLOCK_ALL)
+		printk(KERN_DEBUG "Chip support all block unlock\n");
+	if (this->options & ONENAND_HAS_2PLANE)
+		printk(KERN_DEBUG "Chip has 2 plane\n");
+}
+
 /**
  * onenand_print_device_info - Print device ID
  * @param device        device ID
  *
  * Print device ID
  */
-char * onenand_print_device_info(int device)
+char *onenand_print_device_info(int device, int version)
 {
 	int vcc, demuxed, ddp, density;
 	char *dev_info = malloc(80);
+	char *p = dev_info;
 
 	vcc = device & ONENAND_DEVICE_VCC_MASK;
 	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
 	ddp = device & ONENAND_DEVICE_IS_DDP;
 	density = device >> ONENAND_DEVICE_DENSITY_SHIFT;
-	sprintf(dev_info, "%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
+	p += sprintf(dev_info, "%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
 	       demuxed ? "" : "Muxed ",
 	       ddp ? "(DDP)" : "",
 	       (16 << density), vcc ? "2.65/3.3" : "1.8", device);
 
+	sprintf(p, "\nOneNAND version = 0x%04x", version);
+	printk("%s\n", dev_info);
+
 	return dev_info;
 }
 
 static const struct onenand_manufacturers onenand_manuf_ids[] = {
 	{ONENAND_MFR_SAMSUNG, "Samsung"},
-	{ONENAND_MFR_UNKNOWN, "Unknown"}
 };
 
 /**
@@ -1678,19 +1953,24 @@
  */
 static int onenand_check_maf(int manuf)
 {
+	int size = ARRAY_SIZE(onenand_manuf_ids);
+	char *name;
 	int i;
 
-	for (i = 0; onenand_manuf_ids[i].id; i++) {
+	for (i = 0; size; i++)
 		if (manuf == onenand_manuf_ids[i].id)
 			break;
-	}
+
+	if (i < size)
+		name = onenand_manuf_ids[i].name;
+	else
+		name = "Unknown";
 
 #ifdef ONENAND_DEBUG
-	printk(KERN_DEBUG "OneNAND Manufacturer: %s (0x%0x)\n",
-	       onenand_manuf_ids[i].name, manuf);
+	printk(KERN_DEBUG "OneNAND Manufacturer: %s (0x%0x)\n", name, manuf);
 #endif
 
-	return (i != ONENAND_MFR_UNKNOWN);
+	return i == size;
 }
 
 /**
@@ -1703,9 +1983,14 @@
 static int onenand_probe(struct mtd_info *mtd)
 {
 	struct onenand_chip *this = mtd->priv;
-	int bram_maf_id, bram_dev_id, maf_id, dev_id;
-	int version_id;
+	int bram_maf_id, bram_dev_id, maf_id, dev_id, ver_id;
 	int density;
+	int syscfg;
+
+	/* Save system configuration 1 */
+	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
+	/* Clear Sync. Burst Read mode to read BootRAM */
+	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ), this->base + ONENAND_REG_SYS_CFG1);
 
 	/* Send the command for reading device ID from BootRAM */
 	this->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);
@@ -1714,19 +1999,23 @@
 	bram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);
 	bram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);
 
-	/* Check manufacturer ID */
-	if (onenand_check_maf(bram_maf_id))
-		return -ENXIO;
-
 	/* Reset OneNAND to read default register values */
 	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);
 
 	/* Wait reset */
 	this->wait(mtd, FL_RESETING);
 
+	/* Restore system configuration 1 */
+	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
+
+	/* Check manufacturer ID */
+	if (onenand_check_maf(bram_maf_id))
+		return -ENXIO;
+
 	/* Read manufacturer and device IDs from Register */
 	maf_id = this->read_word(this->base + ONENAND_REG_MANUFACTURER_ID);
 	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
+	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
 
 	/* Check OneNAND device */
 	if (maf_id != bram_maf_id || dev_id != bram_dev_id)
@@ -1739,11 +2028,17 @@
 	}
 
 	/* Flash device information */
-	mtd->name = onenand_print_device_info(dev_id);
+	mtd->name = onenand_print_device_info(dev_id, ver_id);
 	this->device_id = dev_id;
+	this->version_id = ver_id;
 
-	density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
+	density = onenand_get_density(dev_id);
 	this->chipsize = (16 << density) << 20;
+	/* Set density mask. it is used for DDP */
+	if (ONENAND_IS_DDP(this))
+		this->density_mask = (1 << (density + 6));
+	else
+		this->density_mask = 0;
 
 	/* OneNAND page size & block size */
 	/* The data buffer size is equal to page size */
@@ -1764,18 +2059,8 @@
 
 	mtd->size = this->chipsize;
 
-	/* Version ID */
-	version_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
-#ifdef ONENAND_DEBUG
-	printk(KERN_DEBUG "OneNAND version = 0x%04x\n", version_id);
-#endif
-
-	/* Lock scheme */
-	if (density <= ONENAND_DEVICE_DENSITY_512Mb &&
-	    !(version_id >> ONENAND_VERSION_PROCESS_SHIFT)) {
-		printk(KERN_INFO "Lock scheme is Continues Lock\n");
-		this->options |= ONENAND_CONT_LOCK;
-	}
+	/* Check OneNAND features */
+	onenand_check_features(mtd);
 
 	mtd->flags = MTD_CAP_NANDFLASH;
 	mtd->erase = onenand_erase;
@@ -1802,6 +2087,7 @@
  */
 int onenand_scan(struct mtd_info *mtd, int maxchips)
 {
+	int i;
 	struct onenand_chip *this = mtd->priv;
 
 	if (!this->read_word)
@@ -1813,12 +2099,21 @@
 		this->command = onenand_command;
 	if (!this->wait)
 		this->wait = onenand_wait;
+	if (!this->bbt_wait)
+		this->bbt_wait = onenand_bbt_wait;
 
 	if (!this->read_bufferram)
 		this->read_bufferram = onenand_read_bufferram;
+	if (!this->read_spareram)
+		this->read_spareram = onenand_read_bufferram;
 	if (!this->write_bufferram)
 		this->write_bufferram = onenand_write_bufferram;
 
+	if (!this->block_markbad)
+		this->block_markbad = onenand_default_block_markbad;
+	if (!this->scan_bbt)
+		this->scan_bbt = onenand_default_bbt;
+
 	if (onenand_probe(mtd))
 		return -ENXIO;
 
@@ -1850,9 +2145,50 @@
 		this->options |= ONENAND_OOBBUF_ALLOC;
 	}
 
-	onenand_unlock(mtd, 0, mtd->size);
+	this->state = FL_READY;
+
+	/*
+	 * Allow subpage writes up to oobsize.
+	 */
+	switch (mtd->oobsize) {
+	case 64:
+		this->ecclayout = &onenand_oob_64;
+		mtd->subpage_sft = 2;
+		break;
+
+	case 32:
+		this->ecclayout = &onenand_oob_32;
+		mtd->subpage_sft = 1;
+		break;
+
+	default:
+		printk(KERN_WARNING "No OOB scheme defined for oobsize %d\n",
+			mtd->oobsize);
+		mtd->subpage_sft = 0;
+		/* To prevent kernel oops */
+		this->ecclayout = &onenand_oob_32;
+		break;
+	}
+
+	this->subpagesize = mtd->writesize >> mtd->subpage_sft;
+
+	/*
+	 * The number of bytes available for a client to place data into
+	 * the out of band area
+	 */
+	this->ecclayout->oobavail = 0;
+	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
+	    this->ecclayout->oobfree[i].length; i++)
+		this->ecclayout->oobavail +=
+			this->ecclayout->oobfree[i].length;
+	mtd->oobavail = this->ecclayout->oobavail;
+
+	mtd->ecclayout = this->ecclayout;
+
+	/* Unlock whole block */
+	onenand_unlock_all(mtd);
 
-	return onenand_default_bbt(mtd);
+	return this->scan_bbt(mtd);
 }
 
 /**
diff -Naur u-boot-2009.01/drivers/mtd/onenand/onenand_bbt.c u-boot/drivers/mtd/onenand/onenand_bbt.c
--- u-boot-2009.01/drivers/mtd/onenand/onenand_bbt.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/onenand/onenand_bbt.c	2009-02-26 14:03:58.000000000 +0100
@@ -3,7 +3,7 @@
  *
  *  Bad Block Table support for the OneNAND driver
  *
- *  Copyright(c) 2005-2007 Samsung Electronics
+ *  Copyright(c) 2005-2008 Samsung Electronics
  *  Kyungmin Park <kyungmin.park@samsung.com>
  *
  *  TODO:
@@ -54,7 +54,7 @@
  * @param buf		temporary buffer
  * @param bd		descriptor for the good/bad block search pattern
  * @param chip		create the table for a specific chip, -1 read all chips.
- *		Applies only if NAND_BBT_PERCHIP option is set
+ *              Applies only if NAND_BBT_PERCHIP option is set
  *
  * Create a bad block table by scanning the device
  * for the given good/bad block identify pattern
@@ -156,8 +156,8 @@
 	res = (bbm->bbt[block >> 3] >> (block & 0x06)) & 0x03;
 
 	MTDDEBUG (MTD_DEBUG_LEVEL2,
-		  "onenand_isbad_bbt: bbt info for offs 0x%08x: (block %d) 0x%02x\n",
-		  (unsigned int)offs, block >> 1, res);
+		"onenand_isbad_bbt: bbt info for offs 0x%08x: (block %d) 0x%02x\n",
+		(unsigned int)offs, block >> 1, res);
 
 	switch ((int)res) {
 	case 0x00:
diff -Naur u-boot-2009.01/drivers/mtd/onenand/onenand_uboot.c u-boot/drivers/mtd/onenand/onenand_uboot.c
--- u-boot-2009.01/drivers/mtd/onenand/onenand_uboot.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/onenand/onenand_uboot.c	2009-02-26 14:03:58.000000000 +0100
@@ -26,9 +26,17 @@
 	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
 	memset(&onenand_chip, 0, sizeof(struct onenand_chip));
 
-	onenand_chip.base = (void *) CONFIG_SYS_ONENAND_BASE;
 	onenand_mtd.priv = &onenand_chip;
 
+#ifdef CONFIG_USE_ONENAND_BOARD_INIT
+	/*
+	 * It's used for some board init required
+	 */
+	onenand_board_init(&onenand_mtd);
+#else
+	onenand_chip.base = (void *) CONFIG_SYS_ONENAND_BASE;
+#endif
+
 	onenand_scan(&onenand_mtd, 1);
 
 	puts("OneNAND: ");
diff -Naur u-boot-2009.01/drivers/mtd/spi/atmel.c u-boot/drivers/mtd/spi/atmel.c
--- u-boot-2009.01/drivers/mtd/spi/atmel.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/spi/atmel.c	2009-02-26 14:03:58.000000000 +0100
@@ -39,9 +39,10 @@
 	const char	*name;
 };
 
+/* spi_flash needs to be first so upper layers can free() it */
 struct atmel_spi_flash {
-	const struct atmel_spi_flash_params *params;
 	struct spi_flash flash;
+	const struct atmel_spi_flash_params *params;
 };
 
 static inline struct atmel_spi_flash *
diff -Naur u-boot-2009.01/drivers/mtd/spi/stmicro.c u-boot/drivers/mtd/spi/stmicro.c
--- u-boot-2009.01/drivers/mtd/spi/stmicro.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/mtd/spi/stmicro.c	2009-02-26 14:03:58.000000000 +0100
@@ -64,9 +64,10 @@
 	const char *name;
 };
 
+/* spi_flash needs to be first so upper layers can free() it */
 struct stmicro_spi_flash {
-	const struct stmicro_spi_flash_params *params;
 	struct spi_flash flash;
+	const struct stmicro_spi_flash_params *params;
 };
 
 static inline struct stmicro_spi_flash *to_stmicro_spi_flash(struct spi_flash
diff -Naur u-boot-2009.01/drivers/net/bfin_mac.c u-boot/drivers/net/bfin_mac.c
--- u-boot-2009.01/drivers/net/bfin_mac.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/net/bfin_mac.c	2009-02-26 14:03:58.000000000 +0100
@@ -12,6 +12,8 @@
 #include <netdev.h>
 #include <command.h>
 #include <malloc.h>
+#include <miiphy.h>
+#include <linux/mii.h>
 
 #include <asm/blackfin.h>
 #include <asm/mach-common/bits/dma.h>
@@ -20,16 +22,15 @@
 
 #include "bfin_mac.h"
 
-#ifdef CONFIG_POST
-#include <post.h>
+#ifndef CONFIG_PHY_ADDR
+# define CONFIG_PHY_ADDR 1
+#endif
+#ifndef CONFIG_PHY_CLOCK_FREQ
+# define CONFIG_PHY_CLOCK_FREQ 2500000
 #endif
 
-#undef DEBUG_ETHERNET
-
-#ifdef DEBUG_ETHERNET
-#define DEBUGF(fmt, args...) printf(fmt, ##args)
-#else
-#define DEBUGF(fmt, args...)
+#ifdef CONFIG_POST
+#include <post.h>
 #endif
 
 #define RXBUF_BASE_ADDR		0xFF900000
@@ -38,42 +39,61 @@
 
 #define TOUT_LOOP		1000000
 
-ADI_ETHER_BUFFER *txbuf[TX_BUF_CNT];
-ADI_ETHER_BUFFER *rxbuf[PKTBUFSRX];
+static ADI_ETHER_BUFFER *txbuf[TX_BUF_CNT];
+static ADI_ETHER_BUFFER *rxbuf[PKTBUFSRX];
 static u16 txIdx;		/* index of the current RX buffer */
 static u16 rxIdx;		/* index of the current TX buffer */
 
-u16 PHYregs[NO_PHY_REGS];	/* u16 PHYADDR; */
-
 /* DMAx_CONFIG values at DMA Restart */
-const ADI_DMA_CONFIG_REG rxdmacfg = {
-	.b_DMA_EN  = 1,	/* enabled */
-	.b_WNR     = 1,	/* write to memory */
-	.b_WDSIZE  = 2,	/* wordsize is 32 bits */
-	.b_DMA2D   = 0,
-	.b_RESTART = 0,
-	.b_DI_SEL  = 0,
-	.b_DI_EN   = 0,	/* no interrupt */
-	.b_NDSIZE  = 5,	/* 5 half words is desc size */
-	.b_FLOW    = 7	/* large desc flow */
+static const union {
+	u16 data;
+	ADI_DMA_CONFIG_REG reg;
+} txdmacfg = {
+	.reg = {
+		.b_DMA_EN  = 1,	/* enabled */
+		.b_WNR     = 0,	/* read from memory */
+		.b_WDSIZE  = 2,	/* wordsize is 32 bits */
+		.b_DMA2D   = 0,
+		.b_RESTART = 0,
+		.b_DI_SEL  = 0,
+		.b_DI_EN   = 0,	/* no interrupt */
+		.b_NDSIZE  = 5,	/* 5 half words is desc size */
+		.b_FLOW    = 7	/* large desc flow */
+	},
 };
 
-const ADI_DMA_CONFIG_REG txdmacfg = {
-	.b_DMA_EN  = 1,	/* enabled */
-	.b_WNR     = 0,	/* read from memory */
-	.b_WDSIZE  = 2,	/* wordsize is 32 bits */
-	.b_DMA2D   = 0,
-	.b_RESTART = 0,
-	.b_DI_SEL  = 0,
-	.b_DI_EN   = 0,	/* no interrupt */
-	.b_NDSIZE  = 5,	/* 5 half words is desc size */
-	.b_FLOW    = 7	/* large desc flow */
-};
+static int bfin_miiphy_wait(void)
+{
+	/* poll the STABUSY bit */
+	while (bfin_read_EMAC_STAADD() & STABUSY)
+		continue;
+	return 0;
+}
+
+static int bfin_miiphy_read(char *devname, uchar addr, uchar reg, ushort *val)
+{
+	if (bfin_miiphy_wait())
+		return 1;
+	bfin_write_EMAC_STAADD(SET_PHYAD(addr) | SET_REGAD(reg) | STABUSY);
+	if (bfin_miiphy_wait())
+		return 1;
+	*val = bfin_read_EMAC_STADAT();
+	return 0;
+}
+
+static int bfin_miiphy_write(char *devname, uchar addr, uchar reg, ushort val)
+{
+	if (bfin_miiphy_wait())
+		return 1;
+	bfin_write_EMAC_STADAT(val);
+	bfin_write_EMAC_STAADD(SET_PHYAD(addr) | SET_REGAD(reg) | STAOP | STABUSY);
+	return 0;
+}
 
 int bfin_EMAC_initialize(bd_t *bis)
 {
 	struct eth_device *dev;
-	dev = (struct eth_device *)malloc(sizeof(*dev));
+	dev = malloc(sizeof(*dev));
 	if (dev == NULL)
 		hang();
 
@@ -89,6 +109,10 @@
 
 	eth_register(dev);
 
+#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
+	miiphy_register(dev->name, bfin_miiphy_read, bfin_miiphy_write);
+#endif
+
 	return 0;
 }
 
@@ -119,8 +143,8 @@
 	txbuf[txIdx]->FrmData->NoBytes = length;
 	memcpy(txbuf[txIdx]->FrmData->Dest, (void *)packet, length);
 	txbuf[txIdx]->Dma[0].START_ADDR = (u32) txbuf[txIdx]->FrmData;
-	*pDMA2_NEXT_DESC_PTR = &txbuf[txIdx]->Dma[0];
-	*pDMA2_CONFIG = *(u16 *) (void *)(&txdmacfg);
+	*pDMA2_NEXT_DESC_PTR = txbuf[txIdx]->Dma;
+	*pDMA2_CONFIG = txdmacfg.data;
 	*pEMAC_OPMODE |= TE;
 
 	for (i = 0; (txbuf[txIdx]->StatusWord & TX_COMP) == 0; i++) {
@@ -136,7 +160,7 @@
 	else
 		txIdx++;
  out:
-	DEBUGF("BFIN EMAC send: length = %d\n", length);
+	debug("BFIN EMAC send: length = %d\n", length);
 	return result;
 }
 
@@ -182,51 +206,141 @@
  *
  *************************************************************/
 
+/* MDC = SCLK / MDC_freq / 2 - 1 */
+#define MDC_FREQ_TO_DIV(mdc_freq) (get_sclk() / (mdc_freq) / 2 - 1)
+
+static int bfin_miiphy_init(struct eth_device *dev, int *opmode)
+{
+	u16 phydat;
+	size_t count;
+
+	/* Enable PHY output */
+	*pVR_CTL |= CLKBUFOE;
+
+	/* Set all the pins to peripheral mode */
+#ifdef CONFIG_RMII
+	/* grab RMII pins */
+# if defined(__ADSPBF51x__)
+	*pPORTF_MUX = (*pPORTF_MUX & \
+		~(PORT_x_MUX_3_MASK | PORT_x_MUX_4_MASK | PORT_x_MUX_5_MASK)) | \
+		PORT_x_MUX_3_FUNC_1 | PORT_x_MUX_4_FUNC_1 | PORT_x_MUX_5_FUNC_1;
+	*pPORTF_FER |= PF8 | PF9 | PF10 | PF11 | PF12 | PF13 | PF14 | PF15;
+	*pPORTG_MUX = (*pPORTG_MUX & ~PORT_x_MUX_0_MASK) | PORT_x_MUX_0_FUNC_1;
+	*pPORTG_FER |= PG0 | PG1 | PG2;
+# elif defined(__ADSPBF52x__)
+	*pPORTG_MUX = (*pPORTG_MUX & ~PORT_x_MUX_6_MASK) | PORT_x_MUX_6_FUNC_2;
+	*pPORTG_FER |= PG14 | PG15;
+	*pPORTH_MUX = (*pPORTH_MUX & ~(PORT_x_MUX_0_MASK | PORT_x_MUX_1_MASK)) | \
+		PORT_x_MUX_0_FUNC_2 | PORT_x_MUX_1_FUNC_2;
+	*pPORTH_FER |= PH0 | PH1 | PH2 | PH3 | PH4 | PH5 | PH6 | PH7 | PH8;
+# else
+	*pPORTH_FER |= PH0 | PH1 | PH4 | PH5 | PH6 | PH8 | PH9 | PH14 | PH15;
+# endif
+#else
+	/* grab MII & RMII pins */
+# if defined(__ADSPBF51x__)
+	*pPORTF_MUX = (*pPORTF_MUX & \
+		~(PORT_x_MUX_0_MASK | PORT_x_MUX_1_MASK | PORT_x_MUX_3_MASK | PORT_x_MUX_4_MASK | PORT_x_MUX_5_MASK)) | \
+		PORT_x_MUX_0_FUNC_1 | PORT_x_MUX_1_FUNC_1 | PORT_x_MUX_3_FUNC_1 | PORT_x_MUX_4_FUNC_1 | PORT_x_MUX_5_FUNC_1;
+	*pPORTF_FER |= PF0 | PF1 | PF2 | PF3 | PF4 | PF5 | PF6 | PF8 | PF9 | PF10 | PF11 | PF12 | PF13 | PF14 | PF15;
+	*pPORTG_MUX = (*pPORTG_MUX & ~PORT_x_MUX_0_MASK) | PORT_x_MUX_0_FUNC_1;
+	*pPORTG_FER |= PG0 | PG1 | PG2;
+# elif defined(__ADSPBF52x__)
+	*pPORTG_MUX = (*pPORTG_MUX & ~PORT_x_MUX_6_MASK) | PORT_x_MUX_6_FUNC_2;
+	*pPORTG_FER |= PG14 | PG15;
+	*pPORTH_MUX = PORT_x_MUX_0_FUNC_2 | PORT_x_MUX_1_FUNC_2 | PORT_x_MUX_2_FUNC_2;
+	*pPORTH_FER = -1; /* all pins */
+# else
+	*pPORTH_FER = -1; /* all pins */
+# endif
+#endif
+
+	/* Odd word alignment for Receive Frame DMA word */
+	/* Configure checksum support and rcve frame word alignment */
+	bfin_write_EMAC_SYSCTL(RXDWA | RXCKS | SET_MDCDIV(MDC_FREQ_TO_DIV(CONFIG_PHY_CLOCK_FREQ)));
+
+	/* turn on auto-negotiation and wait for link to come up */
+	bfin_miiphy_write(dev->name, CONFIG_PHY_ADDR, MII_BMCR, BMCR_ANENABLE);
+	count = 0;
+	while (1) {
+		++count;
+		if (bfin_miiphy_read(dev->name, CONFIG_PHY_ADDR, MII_BMSR, &phydat))
+			return -1;
+		if (phydat & BMSR_LSTATUS)
+			break;
+		if (count > 30000) {
+			printf("%s: link down, check cable\n", dev->name);
+			return -1;
+		}
+		udelay(100);
+	}
+
+	/* see what kind of link we have */
+	if (bfin_miiphy_read(dev->name, CONFIG_PHY_ADDR, MII_LPA, &phydat))
+		return -1;
+	if (phydat & LPA_DUPLEX)
+		*opmode = FDMODE;
+	else
+		*opmode = 0;
+
+	bfin_write_EMAC_MMC_CTL(RSTC | CROLL);
+
+	/* Initialize the TX DMA channel registers */
+	*pDMA2_X_COUNT = 0;
+	*pDMA2_X_MODIFY = 4;
+	*pDMA2_Y_COUNT = 0;
+	*pDMA2_Y_MODIFY = 0;
+
+	/* Initialize the RX DMA channel registers */
+	*pDMA1_X_COUNT = 0;
+	*pDMA1_X_MODIFY = 4;
+	*pDMA1_Y_COUNT = 0;
+	*pDMA1_Y_MODIFY = 0;
+
+	return 0;
+}
+
 static int bfin_EMAC_init(struct eth_device *dev, bd_t *bd)
 {
 	u32 opmode;
 	int dat;
 	int i;
-	DEBUGF("Eth_init: ......\n");
+	debug("Eth_init: ......\n");
 
 	txIdx = 0;
 	rxIdx = 0;
 
-/* Initialize System Register */
-	if (SetupSystemRegs(&dat) < 0)
+	/* Initialize System Register */
+	if (bfin_miiphy_init(dev, &dat) < 0)
 		return -1;
 
-/* Initialize EMAC address */
+	/* Initialize EMAC address */
 	bfin_EMAC_setup_addr(bd);
 
-/* Initialize TX and RX buffer */
+	/* Initialize TX and RX buffer */
 	for (i = 0; i < PKTBUFSRX; i++) {
 		rxbuf[i] = SetupRxBuffer(i);
 		if (i > 0) {
-			rxbuf[i - 1]->Dma[1].NEXT_DESC_PTR =
-			    &(rxbuf[i]->Dma[0]);
+			rxbuf[i - 1]->Dma[1].NEXT_DESC_PTR = rxbuf[i]->Dma;
 			if (i == (PKTBUFSRX - 1))
-				rxbuf[i]->Dma[1].NEXT_DESC_PTR =
-				    &(rxbuf[0]->Dma[0]);
+				rxbuf[i]->Dma[1].NEXT_DESC_PTR = rxbuf[0]->Dma;
 		}
 	}
 	for (i = 0; i < TX_BUF_CNT; i++) {
 		txbuf[i] = SetupTxBuffer(i);
 		if (i > 0) {
-			txbuf[i - 1]->Dma[1].NEXT_DESC_PTR =
-			    &(txbuf[i]->Dma[0]);
+			txbuf[i - 1]->Dma[1].NEXT_DESC_PTR = txbuf[i]->Dma;
 			if (i == (TX_BUF_CNT - 1))
-				txbuf[i]->Dma[1].NEXT_DESC_PTR =
-				    &(txbuf[0]->Dma[0]);
+				txbuf[i]->Dma[1].NEXT_DESC_PTR = txbuf[0]->Dma;
 		}
 	}
 
 	/* Set RX DMA */
-	*pDMA1_NEXT_DESC_PTR = &rxbuf[0]->Dma[0];
-	*pDMA1_CONFIG = *((u16 *) (void *)&rxbuf[0]->Dma[0].CONFIG);
+	*pDMA1_NEXT_DESC_PTR = rxbuf[0]->Dma;
+	*pDMA1_CONFIG = rxbuf[0]->Dma[0].CONFIG_DATA;
 
 	/* Wait MII done */
-	PollMdcDone();
+	bfin_miiphy_wait();
 
 	/* We enable only RX here */
 	/* ASTP   : Enable Automatic Pad Stripping
@@ -240,7 +354,7 @@
 	else
 		opmode = ASTP | PSF;
 	opmode |= RE;
-#ifdef CONFIG_BFIN_MAC_RMII
+#ifdef CONFIG_RMII
 	opmode |= TE | RMII;
 #endif
 	/* Turn on the EMAC */
@@ -250,7 +364,7 @@
 
 static void bfin_EMAC_halt(struct eth_device *dev)
 {
-	DEBUGF("Eth_halt: ......\n");
+	debug("Eth_halt: ......\n");
 	/* Turn off the EMAC */
 	*pEMAC_OPMODE = 0x00000000;
 	/* Turn off the EMAC RX DMA */
@@ -271,125 +385,6 @@
 		bd->bi_enetaddr[5] << 8;
 }
 
-static void PollMdcDone(void)
-{
-	/* poll the STABUSY bit */
-	while (*pEMAC_STAADD & STABUSY) ;
-}
-
-static void WrPHYReg(u16 PHYAddr, u16 RegAddr, u16 Data)
-{
-	PollMdcDone();
-
-	*pEMAC_STADAT = Data;
-
-	*pEMAC_STAADD = SET_PHYAD(PHYAddr) | SET_REGAD(RegAddr) |
-	    STAOP | STAIE | STABUSY;
-}
-
-/*********************************************************************************
- *		Read an off-chip register in a PHY through the MDC/MDIO port     *
- *********************************************************************************/
-static u16 RdPHYReg(u16 PHYAddr, u16 RegAddr)
-{
-	u16 Data;
-
-	PollMdcDone();
-
-	*pEMAC_STAADD = SET_PHYAD(PHYAddr) | SET_REGAD(RegAddr) |
-	    STAIE | STABUSY;
-
-	PollMdcDone();
-
-	Data = (u16) * pEMAC_STADAT;
-
-	PHYregs[RegAddr] = Data;	/* save shadow copy */
-
-	return Data;
-}
-
-#if 0 /* dead code ? */
-static void SoftResetPHY(void)
-{
-	u16 phydat;
-	/* set the reset bit */
-	WrPHYReg(PHYADDR, PHY_MODECTL, PHY_RESET);
-	/* and clear it again */
-	WrPHYReg(PHYADDR, PHY_MODECTL, 0x0000);
-	do {
-		/* poll until reset is complete */
-		phydat = RdPHYReg(PHYADDR, PHY_MODECTL);
-	} while ((phydat & PHY_RESET) != 0);
-}
-#endif
-
-static int SetupSystemRegs(int *opmode)
-{
-	u16 sysctl, phydat;
-	int count = 0;
-	/* Enable PHY output */
-	*pVR_CTL |= CLKBUFOE;
-	/* Set all the pins to peripheral mode */
-
-#ifndef CONFIG_BFIN_MAC_RMII
-	*pPORTH_FER = 0xFFFF;
-#ifdef __ADSPBF52x__
-	*pPORTH_MUX = PORT_x_MUX_0_FUNC_2 | PORT_x_MUX_1_FUNC_2 | PORT_x_MUX_2_FUNC_2;
-#endif
-#else
-#if defined(__ADSPBF536__) || defined(__ADSPBF537__)
-	*pPORTH_FER = 0xC373;
-#endif
-#ifdef __ADSPBF52x__
-	*pPORTH_FER = 0x01FF;
-	*pPORTH_MUX = PORT_x_MUX_0_FUNC_2 | PORT_x_MUX_1_FUNC_2;
-#endif
-#endif
-	/* MDC  = 2.5 MHz */
-	sysctl = SET_MDCDIV(24);
-	/* Odd word alignment for Receive Frame DMA word */
-	/* Configure checksum support and rcve frame word alignment */
-	sysctl |= RXDWA | RXCKS;
-	*pEMAC_SYSCTL = sysctl;
-	/* auto negotiation on  */
-	/* full duplex */
-	/* 100 Mbps */
-	phydat = PHY_ANEG_EN | PHY_DUPLEX | PHY_SPD_SET;
-	WrPHYReg(PHYADDR, PHY_MODECTL, phydat);
-	do {
-		udelay(1000);
-		phydat = RdPHYReg(PHYADDR, PHY_MODESTAT);
-		if (count > 3000) {
-			printf
-			    ("Link is down, please check your network connection\n");
-			return -1;
-		}
-		count++;
-	} while (!(phydat & 0x0004));
-
-	phydat = RdPHYReg(PHYADDR, PHY_ANLPAR);
-
-	if ((phydat & 0x0100) || (phydat & 0x0040))
-		*opmode = FDMODE;
-	else
-		*opmode = 0;
-
-	*pEMAC_MMC_CTL = RSTC | CROLL;
-
-	/* Initialize the TX DMA channel registers */
-	*pDMA2_X_COUNT = 0;
-	*pDMA2_X_MODIFY = 4;
-	*pDMA2_Y_COUNT = 0;
-	*pDMA2_Y_MODIFY = 0;
-
-	/* Initialize the RX DMA channel registers */
-	*pDMA1_X_COUNT = 0;
-	*pDMA1_X_MODIFY = 4;
-	*pDMA1_Y_COUNT = 0;
-	*pDMA1_Y_MODIFY = 0;
-	return 0;
-}
-
 ADI_ETHER_BUFFER *SetupRxBuffer(int no)
 {
 	ADI_ETHER_FRAME_BUFFER *frmbuf;
@@ -397,10 +392,8 @@
 	int nobytes_buffer = sizeof(ADI_ETHER_BUFFER[2]) / 2;	/* ensure a multi. of 4 */
 	int total_size = nobytes_buffer + RECV_BUFSIZE;
 
-	buf = (ADI_ETHER_BUFFER *) (RXBUF_BASE_ADDR + no * total_size);
-	frmbuf =
-	    (ADI_ETHER_FRAME_BUFFER *) (RXBUF_BASE_ADDR + no * total_size +
-					nobytes_buffer);
+	buf = (void *) (RXBUF_BASE_ADDR + no * total_size);
+	frmbuf = (void *) (RXBUF_BASE_ADDR + no * total_size + nobytes_buffer);
 
 	memset(buf, 0x00, nobytes_buffer);
 	buf->FrmData = frmbuf;
@@ -416,7 +409,7 @@
 	buf->Dma[0].CONFIG.b_FLOW = 7;	/* large desc flow */
 
 	/* set up second desc to point to status word */
-	buf->Dma[1].NEXT_DESC_PTR = &(buf->Dma[0]);
+	buf->Dma[1].NEXT_DESC_PTR = buf->Dma;
 	buf->Dma[1].START_ADDR = (u32) & buf->IPHdrChksum;
 	buf->Dma[1].CONFIG.b_DMA_EN = 1;	/* enabled */
 	buf->Dma[1].CONFIG.b_WNR = 1;	/* Write to memory */
@@ -435,10 +428,8 @@
 	int nobytes_buffer = sizeof(ADI_ETHER_BUFFER[2]) / 2;	/* ensure a multi. of 4 */
 	int total_size = nobytes_buffer + RECV_BUFSIZE;
 
-	buf = (ADI_ETHER_BUFFER *) (TXBUF_BASE_ADDR + no * total_size);
-	frmbuf =
-	    (ADI_ETHER_FRAME_BUFFER *) (TXBUF_BASE_ADDR + no * total_size +
-					nobytes_buffer);
+	buf = (void *) (TXBUF_BASE_ADDR + no * total_size);
+	frmbuf = (void *) (TXBUF_BASE_ADDR + no * total_size + nobytes_buffer);
 
 	memset(buf, 0x00, nobytes_buffer);
 	buf->FrmData = frmbuf;
diff -Naur u-boot-2009.01/drivers/net/bfin_mac.h u-boot/drivers/net/bfin_mac.h
--- u-boot-2009.01/drivers/net/bfin_mac.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/net/bfin_mac.h	2009-02-26 14:03:58.000000000 +0100
@@ -9,29 +9,8 @@
 #ifndef __BFIN_MAC_H__
 #define __BFIN_MAC_H__
 
-#define PHYADDR			0x01
-#define NO_PHY_REGS		0x20
-
-#define DEFAULT_PHY_PHYID1	0x0007
-#define DEFAULT_PHY_PHYID2	0xC0A3
-#define PHY_MODECTL		0x00
-#define PHY_MODESTAT		0x01
-#define PHY_PHYID1		0x02
-#define PHY_PHYID2		0x03
-#define PHY_ANAR		0x04
-#define PHY_ANLPAR		0x05
-#define PHY_ANER		0x06
-
-#define PHY_RESET		0x8000
-#define PHY_ANEG_EN		0x1000
-#define PHY_DUPLEX		0x0100
-#define PHY_SPD_SET		0x2000
-
 #define RECV_BUFSIZE		(0x614)
 
-typedef volatile u32 reg32;
-typedef volatile u16 reg16;
-
 typedef struct ADI_DMA_CONFIG_REG {
 	u16 b_DMA_EN:1;		/* 0	Enabled				*/
 	u16 b_WNR:1;		/* 1	Direction			*/
@@ -56,7 +35,10 @@
 typedef struct dma_descriptor {
 	struct dma_descriptor *NEXT_DESC_PTR;
 	u32 START_ADDR;
-	ADI_DMA_CONFIG_REG CONFIG;
+	union {
+		u16 CONFIG_DATA;
+		ADI_DMA_CONFIG_REG CONFIG;
+	};
 } DMA_DESCRIPTOR;
 /* 10 bytes/struct in 12 bytes */
 
@@ -79,11 +61,6 @@
 static int bfin_EMAC_send(struct eth_device *dev, volatile void *packet, int length);
 static int bfin_EMAC_recv(struct eth_device *dev);
 
-static void PollMdcDone(void);
-static void WrPHYReg(u16 PHYAddr, u16 RegAddr, u16 Data);
-static u16 RdPHYReg(u16 PHYAddr, u16 RegAddr);
-static int SetupSystemRegs(int *opmode);
-
 static void bfin_EMAC_setup_addr(bd_t *bd);
 
 #endif
diff -Naur u-boot-2009.01/drivers/net/dnet.c u-boot/drivers/net/dnet.c
--- u-boot-2009.01/drivers/net/dnet.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/net/dnet.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,395 @@
+/*
+ * Dave Ethernet Controller driver
+ *
+ * Copyright (C) 2008 Dave S.r.l. <www.dave.eu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <common.h>
+
+#ifndef CONFIG_DNET_AUTONEG_TIMEOUT
+#define CONFIG_DNET_AUTONEG_TIMEOUT	5000000	/* default value */
+#endif
+
+#include <net.h>
+#include <malloc.h>
+#include <linux/mii.h>
+
+#include <miiphy.h>
+#include <asm/io.h>
+
+#include "dnet.h"
+
+struct dnet_device {
+	struct dnet_registers	*regs;
+	const struct device	*dev;
+	struct eth_device	netdev;
+	unsigned short		phy_addr;
+};
+
+/* get struct dnet_device from given struct netdev */
+#define to_dnet(_nd) container_of(_nd, struct dnet_device, netdev)
+
+/* function for reading internal MAC register */
+u16 dnet_readw_mac(struct dnet_device *dnet, u16 reg)
+{
+	u16 data_read;
+
+	/* issue a read */
+	writel(reg, &dnet->regs->MACREG_ADDR);
+
+	/* since a read/write op to the MAC is very slow,
+	 * we must wait before reading the data */
+	udelay(1);
+
+	/* read data read from the MAC register */
+	data_read = readl(&dnet->regs->MACREG_DATA);
+
+	/* all done */
+	return data_read;
+}
+
+/* function for writing internal MAC register */
+void dnet_writew_mac(struct dnet_device *dnet, u16 reg, u16 val)
+{
+	/* load data to write */
+	writel(val, &dnet->regs->MACREG_DATA);
+
+	/* issue a write */
+	writel(reg | DNET_INTERNAL_WRITE, &dnet->regs->MACREG_ADDR);
+
+	/* since a read/write op to the MAC is very slow,
+	 * we must wait before exiting */
+	udelay(1);
+}
+
+static void dnet_mdio_write(struct dnet_device *dnet, u8 reg, u16 value)
+{
+	u16 tmp;
+
+	debug(DRIVERNAME "dnet_mdio_write %02x:%02x <- %04x\n",
+			dnet->phy_addr, reg, value);
+
+	while (!(dnet_readw_mac(dnet, DNET_INTERNAL_GMII_MNG_CTL_REG) &
+				DNET_INTERNAL_GMII_MNG_CMD_FIN))
+		;
+
+	/* prepare for a write operation */
+	tmp = (1 << 13);
+
+	/* only 5 bits allowed for register offset */
+	reg &= 0x1f;
+
+	/* prepare reg_value for a write */
+	tmp |= (dnet->phy_addr << 8);
+	tmp |= reg;
+
+	/* write data to write first */
+	dnet_writew_mac(dnet, DNET_INTERNAL_GMII_MNG_DAT_REG, value);
+
+	/* write control word */
+	dnet_writew_mac(dnet, DNET_INTERNAL_GMII_MNG_CTL_REG, tmp);
+
+	while (!(dnet_readw_mac(dnet, DNET_INTERNAL_GMII_MNG_CTL_REG) &
+				DNET_INTERNAL_GMII_MNG_CMD_FIN))
+		;
+}
+
+static u16 dnet_mdio_read(struct dnet_device *dnet, u8 reg)
+{
+	u16 value;
+
+	while (!(dnet_readw_mac(dnet, DNET_INTERNAL_GMII_MNG_CTL_REG) &
+				DNET_INTERNAL_GMII_MNG_CMD_FIN))
+		;
+
+	/* only 5 bits allowed for register offset*/
+	reg &= 0x1f;
+
+	/* prepare reg_value for a read */
+	value = (dnet->phy_addr << 8);
+	value |= reg;
+
+	/* write control word */
+	dnet_writew_mac(dnet, DNET_INTERNAL_GMII_MNG_CTL_REG, value);
+
+	/* wait for end of transfer */
+	while (!(dnet_readw_mac(dnet, DNET_INTERNAL_GMII_MNG_CTL_REG) &
+				DNET_INTERNAL_GMII_MNG_CMD_FIN))
+		;
+
+	value = dnet_readw_mac(dnet, DNET_INTERNAL_GMII_MNG_DAT_REG);
+
+	debug(DRIVERNAME "dnet_mdio_read %02x:%02x <- %04x\n",
+		dnet->phy_addr, reg, value);
+
+	return value;
+}
+
+static int dnet_send(struct eth_device *netdev, volatile void *packet,
+		     int length)
+{
+	struct dnet_device *dnet = to_dnet(netdev);
+	int i, len, wrsz;
+	unsigned int *bufp;
+	unsigned int tx_cmd;
+
+	debug(DRIVERNAME "[%s] Sending %u bytes\n", __func__, length);
+
+	/* frame size (words) */
+	len = (length + 3) >> 2;
+
+	bufp = (unsigned int *) (((u32)packet) & 0xFFFFFFFC);
+	wrsz = (u32)length + 3;
+	wrsz += ((u32)packet) & 0x3;
+	wrsz >>= 2;
+	tx_cmd = ((((unsigned int)(packet)) & 0x03) << 16) | (u32)length;
+
+	/* check if there is enough room for the current frame */
+	if (wrsz < (DNET_FIFO_SIZE - readl(&dnet->regs->TX_FIFO_WCNT))) {
+		for (i = 0; i < wrsz; i++)
+			writel(*bufp++, &dnet->regs->TX_DATA_FIFO);
+		/*
+		 * inform MAC that a packet's written and ready
+		 * to be shipped out
+		 */
+		writel(tx_cmd, &dnet->regs->TX_LEN_FIFO);
+	} else {
+		printf(DRIVERNAME "No free space (actual %d, required %d "
+				"(words))\n", DNET_FIFO_SIZE -
+				readl(&dnet->regs->TX_FIFO_WCNT), wrsz);
+	}
+
+	/* No one cares anyway */
+	return 0;
+}
+
+
+static int dnet_recv(struct eth_device *netdev)
+{
+	struct dnet_device *dnet = to_dnet(netdev);
+	unsigned int *data_ptr;
+	int pkt_len, poll, i;
+	u32 cmd_word;
+
+	debug("Waiting for pkt (polling)\n");
+	poll = 50;
+	while ((readl(&dnet->regs->RX_FIFO_WCNT) >> 16) == 0) {
+		udelay(10);  /* wait 10 usec */
+		if (--poll == 0)
+			return 0;	/* no pkt available */
+	}
+
+	cmd_word = readl(&dnet->regs->RX_LEN_FIFO);
+	pkt_len = cmd_word & 0xFFFF;
+
+	debug("Got pkt with size %d bytes\n", pkt_len);
+
+	if (cmd_word & 0xDF180000)
+		printf("%s packet receive error %x\n", __func__, cmd_word);
+
+	data_ptr = (unsigned int *) NetRxPackets[0];
+
+	for (i = 0; i < (pkt_len + 3) >> 2; i++)
+		*data_ptr++ = readl(&dnet->regs->RX_DATA_FIFO);
+
+	NetReceive(NetRxPackets[0], pkt_len + 5); /* ok + 5 ?? */
+
+	return 0;
+}
+
+static void dnet_set_hwaddr(struct eth_device *netdev)
+{
+	struct dnet_device *dnet = to_dnet(netdev);
+	u16 tmp;
+
+	tmp = cpu_to_be16(*((u16 *)netdev->enetaddr));
+	dnet_writew_mac(dnet, DNET_INTERNAL_MAC_ADDR_0_REG, tmp);
+	tmp = cpu_to_be16(*((u16 *)(netdev->enetaddr + 2)));
+	dnet_writew_mac(dnet, DNET_INTERNAL_MAC_ADDR_1_REG, tmp);
+	tmp = cpu_to_be16(*((u16 *)(netdev->enetaddr + 4)));
+	dnet_writew_mac(dnet, DNET_INTERNAL_MAC_ADDR_2_REG, tmp);
+}
+
+static void dnet_phy_reset(struct dnet_device *dnet)
+{
+	struct eth_device *netdev = &dnet->netdev;
+	int i;
+	u16 status, adv;
+
+	adv = ADVERTISE_CSMA | ADVERTISE_ALL;
+	dnet_mdio_write(dnet, MII_ADVERTISE, adv);
+	printf("%s: Starting autonegotiation...\n", netdev->name);
+	dnet_mdio_write(dnet, MII_BMCR, (BMCR_ANENABLE
+					 | BMCR_ANRESTART));
+
+	for (i = 0; i < CONFIG_DNET_AUTONEG_TIMEOUT / 100; i++) {
+		status = dnet_mdio_read(dnet, MII_BMSR);
+		if (status & BMSR_ANEGCOMPLETE)
+			break;
+		udelay(100);
+	}
+
+	if (status & BMSR_ANEGCOMPLETE)
+		printf("%s: Autonegotiation complete\n", netdev->name);
+	else
+		printf("%s: Autonegotiation timed out (status=0x%04x)\n",
+		       netdev->name, status);
+}
+
+static int dnet_phy_init(struct dnet_device *dnet)
+{
+	struct eth_device *netdev = &dnet->netdev;
+	u16 phy_id, status, adv, lpa;
+	int media, speed, duplex;
+	int i;
+	u32 ctl_reg;
+
+	/* Find a PHY */
+	for (i = 0; i < 32; i++) {
+		dnet->phy_addr = i;
+		phy_id = dnet_mdio_read(dnet, MII_PHYSID1);
+		if (phy_id != 0xffff) {
+			/* ok we found it */
+			printf("Found PHY at address %d PHYID (%04x:%04x)\n",
+					i, phy_id,
+					dnet_mdio_read(dnet, MII_PHYSID2));
+			break;
+		}
+	}
+
+	/* Check if the PHY is up to snuff... */
+	phy_id = dnet_mdio_read(dnet, MII_PHYSID1);
+	if (phy_id == 0xffff) {
+		printf("%s: No PHY present\n", netdev->name);
+		return -1;
+	}
+
+	status = dnet_mdio_read(dnet, MII_BMSR);
+	if (!(status & BMSR_LSTATUS)) {
+		/* Try to re-negotiate if we don't have link already. */
+		dnet_phy_reset(dnet);
+
+		for (i = 0; i < CONFIG_DNET_AUTONEG_TIMEOUT / 100; i++) {
+			status = dnet_mdio_read(dnet, MII_BMSR);
+			if (status & BMSR_LSTATUS)
+				break;
+			udelay(100);
+		}
+	}
+
+	if (!(status & BMSR_LSTATUS)) {
+		printf("%s: link down (status: 0x%04x)\n",
+		       netdev->name, status);
+		return -1;
+	} else {
+		adv = dnet_mdio_read(dnet, MII_ADVERTISE);
+		lpa = dnet_mdio_read(dnet, MII_LPA);
+		media = mii_nway_result(lpa & adv);
+		speed = (media & (ADVERTISE_100FULL | ADVERTISE_100HALF)
+			 ? 1 : 0);
+		duplex = (media & ADVERTISE_FULL) ? 1 : 0;
+		/* 1000BaseT ethernet is not supported */
+		printf("%s: link up, %sMbps %s-duplex (lpa: 0x%04x)\n",
+		       netdev->name,
+		       speed ? "100" : "10",
+		       duplex ? "full" : "half",
+		       lpa);
+
+		ctl_reg = dnet_readw_mac(dnet, DNET_INTERNAL_RXTX_CONTROL_REG);
+
+		if (duplex)
+			ctl_reg &= ~(DNET_INTERNAL_RXTX_CONTROL_ENABLEHALFDUP);
+		else
+			ctl_reg |= DNET_INTERNAL_RXTX_CONTROL_ENABLEHALFDUP;
+
+		dnet_writew_mac(dnet, DNET_INTERNAL_RXTX_CONTROL_REG, ctl_reg);
+
+		return 0;
+	}
+}
+
+static int dnet_init(struct eth_device *netdev, bd_t *bd)
+{
+	struct dnet_device *dnet = to_dnet(netdev);
+	u32 config;
+
+	/*
+	 * dnet_halt should have been called at some point before now,
+	 * so we'll assume the controller is idle.
+	 */
+
+	/* set hardware address */
+	dnet_set_hwaddr(netdev);
+
+	if (dnet_phy_init(dnet) < 0)
+		return -1;
+
+	/* flush rx/tx fifos */
+	writel(DNET_SYS_CTL_RXFIFOFLUSH | DNET_SYS_CTL_TXFIFOFLUSH,
+			&dnet->regs->SYS_CTL);
+	udelay(1000);
+	writel(0, &dnet->regs->SYS_CTL);
+
+	config = dnet_readw_mac(dnet, DNET_INTERNAL_RXTX_CONTROL_REG);
+
+	config |= DNET_INTERNAL_RXTX_CONTROL_RXPAUSE |
+			DNET_INTERNAL_RXTX_CONTROL_RXBROADCAST |
+			DNET_INTERNAL_RXTX_CONTROL_DROPCONTROL |
+			DNET_INTERNAL_RXTX_CONTROL_DISCFXFCS;
+
+	dnet_writew_mac(dnet, DNET_INTERNAL_RXTX_CONTROL_REG, config);
+
+	/* Enable TX and RX */
+	dnet_writew_mac(dnet, DNET_INTERNAL_MODE_REG,
+			DNET_INTERNAL_MODE_RXEN | DNET_INTERNAL_MODE_TXEN);
+
+	return 0;
+}
+
+static void dnet_halt(struct eth_device *netdev)
+{
+	struct dnet_device *dnet = to_dnet(netdev);
+
+	/* Disable TX and RX */
+	dnet_writew_mac(dnet, DNET_INTERNAL_MODE_REG, 0);
+}
+
+int dnet_eth_initialize(int id, void *regs, unsigned int phy_addr)
+{
+	struct dnet_device *dnet;
+	struct eth_device *netdev;
+	unsigned int dev_capa;
+
+	dnet = malloc(sizeof(struct dnet_device));
+	if (!dnet) {
+		printf("Error: Failed to allocate memory for DNET%d\n", id);
+		return -1;
+	}
+	memset(dnet, 0, sizeof(struct dnet_device));
+
+	netdev = &dnet->netdev;
+
+	dnet->regs = (struct dnet_registers *)regs;
+	dnet->phy_addr = phy_addr;
+
+	sprintf(netdev->name, "dnet%d", id);
+	netdev->init = dnet_init;
+	netdev->halt = dnet_halt;
+	netdev->send = dnet_send;
+	netdev->recv = dnet_recv;
+
+	dev_capa = readl(&dnet->regs->VERCAPS) & 0xFFFF;
+	debug("%s: has %smdio, %sirq, %sgigabit, %sdma \n", netdev->name,
+		(dev_capa & DNET_HAS_MDIO) ? "" : "no ",
+		(dev_capa & DNET_HAS_IRQ) ? "" : "no ",
+		(dev_capa & DNET_HAS_GIGABIT) ? "" : "no ",
+		(dev_capa & DNET_HAS_DMA) ? "" : "no ");
+
+	eth_register(netdev);
+
+	return 0;
+}
diff -Naur u-boot-2009.01/drivers/net/dnet.h u-boot/drivers/net/dnet.h
--- u-boot-2009.01/drivers/net/dnet.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/net/dnet.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,166 @@
+/*
+ * Dave Ethernet Controller driver
+ *
+ * Copyright (C) 2008 Dave S.r.l. <www.dave.eu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __DRIVERS_DNET_H__
+#define __DRIVERS_DNET_H__
+
+#define DRIVERNAME "dnet"
+
+struct dnet_registers {
+	/* ALL DNET FIFO REGISTERS */
+	u32 RX_LEN_FIFO;
+	u32 RX_DATA_FIFO;
+	u32 TX_LEN_FIFO;
+	u32 TX_DATA_FIFO;
+	u32 pad1[0x3c];
+	/* ALL DNET CONTROL/STATUS REGISTERS */
+	u32 VERCAPS;
+	u32 INTR_SRC;
+	u32 INTR_ENB;
+	u32 RX_STATUS;
+	u32 TX_STATUS;
+	u32 RX_FRAMES_CNT;
+	u32 TX_FRAMES_CNT;
+	u32 RX_FIFO_TH;
+	u32 TX_FIFO_TH;
+	u32 SYS_CTL;
+	u32 PAUSE_TMR;
+	u32 RX_FIFO_WCNT;
+	u32 TX_FIFO_WCNT;
+	u32 pad2[0x33];
+	/* ALL DNET MAC REGISTERS */
+	u32 MACREG_DATA;	/* Mac-Reg Data */
+	u32 MACREG_ADDR;	/* Mac-Reg Addr */
+	u32 pad3[0x3e];
+	/* ALL DNET RX STATISTICS COUNTERS  */
+	u32 RX_PKT_IGNR_CNT;
+	u32 RX_LEN_CHK_ERR_CNT;
+	u32 RX_LNG_FRM_CNT;
+	u32 RX_SHRT_FRM_CNT;
+	u32 RX_IPG_VIOL_CNT;
+	u32 RX_CRC_ERR_CNT;
+	u32 RX_OK_PKT_CNT;
+	u32 RX_CTL_FRM_CNT;
+	u32 RX_PAUSE_FRM_CNT;
+	u32 RX_MULTICAST_CNT;
+	u32 RX_BROADCAST_CNT;
+	u32 RX_VLAN_TAG_CNT;
+	u32 RX_PRE_SHRINK_CNT;
+	u32 RX_DRIB_NIB_CNT;
+	u32 RX_UNSUP_OPCD_CNT;
+	u32 RX_BYTE_CNT;
+	u32 pad4[0x30];
+	/* DNET TX STATISTICS COUNTERS */
+	u32 TX_UNICAST_CNT;
+	u32 TX_PAUSE_FRM_CNT;
+	u32 TX_MULTICAST_CNT;
+	u32 TX_BRDCAST_CNT;
+	u32 TX_VLAN_TAG_CNT;
+	u32 TX_BAD_FCS_CNT;
+	u32 TX_JUMBO_CNT;
+	u32 TX_BYTE_CNT;
+};
+
+/* SOME INTERNAL MAC-CORE REGISTER */
+#define DNET_INTERNAL_MODE_REG			0x0
+#define DNET_INTERNAL_RXTX_CONTROL_REG		0x2
+#define DNET_INTERNAL_MAX_PKT_SIZE_REG		0x4
+#define DNET_INTERNAL_IGP_REG			0x8
+#define DNET_INTERNAL_MAC_ADDR_0_REG		0xa
+#define DNET_INTERNAL_MAC_ADDR_1_REG		0xc
+#define DNET_INTERNAL_MAC_ADDR_2_REG		0xe
+#define DNET_INTERNAL_TX_RX_STS_REG		0x12
+#define DNET_INTERNAL_GMII_MNG_CTL_REG		0x14
+#define DNET_INTERNAL_GMII_MNG_DAT_REG		0x16
+
+#define DNET_INTERNAL_GMII_MNG_CMD_FIN		(1 << 14)
+
+#define DNET_INTERNAL_WRITE			(1 << 31)
+
+/* MAC-CORE REGISTER FIELDS */
+
+/* MAC-CORE MODE REGISTER FIELDS */
+#define DNET_INTERNAL_MODE_GBITEN			(1 << 0)
+#define DNET_INTERNAL_MODE_FCEN				(1 << 1)
+#define DNET_INTERNAL_MODE_RXEN				(1 << 2)
+#define DNET_INTERNAL_MODE_TXEN				(1 << 3)
+
+/* MAC-CORE RXTX CONTROL REGISTER FIELDS */
+#define DNET_INTERNAL_RXTX_CONTROL_RXSHORTFRAME		(1 << 8)
+#define DNET_INTERNAL_RXTX_CONTROL_RXBROADCAST		(1 << 7)
+#define DNET_INTERNAL_RXTX_CONTROL_RXMULTICAST		(1 << 4)
+#define DNET_INTERNAL_RXTX_CONTROL_RXPAUSE		(1 << 3)
+#define DNET_INTERNAL_RXTX_CONTROL_DISTXFCS		(1 << 2)
+#define DNET_INTERNAL_RXTX_CONTROL_DISCFXFCS		(1 << 1)
+#define DNET_INTERNAL_RXTX_CONTROL_ENPROMISC		(1 << 0)
+#define DNET_INTERNAL_RXTX_CONTROL_DROPCONTROL		(1 << 6)
+#define DNET_INTERNAL_RXTX_CONTROL_ENABLEHALFDUP	(1 << 5)
+
+/* SYSTEM CONTROL REGISTER FIELDS */
+#define DNET_SYS_CTL_IGNORENEXTPKT			(1 << 0)
+#define DNET_SYS_CTL_SENDPAUSE				(1 << 2)
+#define DNET_SYS_CTL_RXFIFOFLUSH			(1 << 3)
+#define DNET_SYS_CTL_TXFIFOFLUSH			(1 << 4)
+
+/* TX STATUS REGISTER FIELDS */
+#define DNET_TX_STATUS_FIFO_ALMOST_EMPTY		(1 << 2)
+#define DNET_TX_STATUS_FIFO_ALMOST_FULL			(1 << 1)
+
+/* INTERRUPT SOURCE REGISTER FIELDS */
+#define DNET_INTR_SRC_TX_PKTSENT			(1 << 0)
+#define DNET_INTR_SRC_TX_FIFOAF				(1 << 1)
+#define DNET_INTR_SRC_TX_FIFOAE				(1 << 2)
+#define DNET_INTR_SRC_TX_DISCFRM			(1 << 3)
+#define DNET_INTR_SRC_TX_FIFOFULL			(1 << 4)
+#define DNET_INTR_SRC_RX_CMDFIFOAF			(1 << 8)
+#define DNET_INTR_SRC_RX_CMDFIFOFF			(1 << 9)
+#define DNET_INTR_SRC_RX_DATAFIFOFF			(1 << 10)
+#define DNET_INTR_SRC_TX_SUMMARY			(1 << 16)
+#define DNET_INTR_SRC_RX_SUMMARY			(1 << 17)
+#define DNET_INTR_SRC_PHY				(1 << 19)
+
+/* INTERRUPT ENABLE REGISTER FIELDS */
+#define DNET_INTR_ENB_TX_PKTSENT			(1 << 0)
+#define DNET_INTR_ENB_TX_FIFOAF				(1 << 1)
+#define DNET_INTR_ENB_TX_FIFOAE				(1 << 2)
+#define DNET_INTR_ENB_TX_DISCFRM			(1 << 3)
+#define DNET_INTR_ENB_TX_FIFOFULL			(1 << 4)
+#define DNET_INTR_ENB_RX_PKTRDY				(1 << 8)
+#define DNET_INTR_ENB_RX_FIFOAF				(1 << 9)
+#define DNET_INTR_ENB_RX_FIFOERR			(1 << 10)
+#define DNET_INTR_ENB_RX_ERROR				(1 << 11)
+#define DNET_INTR_ENB_RX_FIFOFULL			(1 << 12)
+#define DNET_INTR_ENB_RX_FIFOAE				(1 << 13)
+#define DNET_INTR_ENB_TX_SUMMARY			(1 << 16)
+#define DNET_INTR_ENB_RX_SUMMARY			(1 << 17)
+#define DNET_INTR_ENB_GLOBAL_ENABLE			(1 << 18)
+
+/*
+ * Capabilities. Used by the driver to know the capabilities that
+ * the ethernet controller inside the FPGA have.
+ */
+
+#define DNET_HAS_MDIO		(1 << 0)
+#define DNET_HAS_IRQ		(1 << 1)
+#define DNET_HAS_GIGABIT	(1 << 2)
+#define DNET_HAS_DMA		(1 << 3)
+
+#define DNET_HAS_MII		(1 << 4) /* or GMII */
+#define DNET_HAS_RMII		(1 << 5) /* or RGMII */
+
+#define DNET_CAPS_MASK		0xFFFF
+
+#define DNET_FIFO_SIZE		2048 /* 2K x 32 bit */
+#define DNET_FIFO_TX_DATA_AF_TH	(DNET_FIFO_SIZE - 384) /* 384 = 1536 / 4 */
+#define DNET_FIFO_TX_DATA_AE_TH	(384)
+
+#define DNET_FIFO_RX_CMD_AF_TH	(1 << 16) /* just one frame inside the FIFO */
+
+#endif
diff -Naur u-boot-2009.01/drivers/net/e1000.c u-boot/drivers/net/e1000.c
--- u-boot-2009.01/drivers/net/e1000.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/net/e1000.c	2009-02-26 14:03:58.000000000 +0100
@@ -82,6 +82,7 @@
 	{PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82540EM_LOM},
 	{PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82541ER},
 	{PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82541GI_LF},
+	{}
 };
 
 /* Function forward declarations */
diff -Naur u-boot-2009.01/drivers/net/macb.c u-boot/drivers/net/macb.c
--- u-boot-2009.01/drivers/net/macb.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/net/macb.c	2009-02-26 14:03:58.000000000 +0100
@@ -317,6 +317,30 @@
 		       netdev->name, status);
 }
 
+#ifdef CONFIG_MACB_SEARCH_PHY
+static int macb_phy_find(struct macb_device *macb)
+{
+	int i;
+	u16 phy_id;
+
+	/* Search for PHY... */
+	for (i = 0; i < 32; i++) {
+		macb->phy_addr = i;
+		phy_id = macb_mdio_read(macb, MII_PHYSID1);
+		if (phy_id != 0xffff) {
+			printf("%s: PHY present at %d\n", macb->netdev.name, i);
+			return 1;
+		}
+	}
+
+	/* PHY isn't up to snuff */
+	printf("%s: PHY not found", macb->netdev.name);
+
+	return 0;
+}
+#endif /* CONFIG_MACB_SEARCH_PHY */
+
+
 static int macb_phy_init(struct macb_device *macb)
 {
 	struct eth_device *netdev = &macb->netdev;
@@ -325,6 +349,13 @@
 	int media, speed, duplex;
 	int i;
 
+#ifdef CONFIG_MACB_SEARCH_PHY
+	/* Auto-detect phy_addr */
+	if (!macb_phy_find(macb)) {
+		return 0;
+	}
+#endif /* CONFIG_MACB_SEARCH_PHY */
+
 	/* Check if the PHY is up to snuff... */
 	phy_id = macb_mdio_read(macb, MII_PHYSID1);
 	if (phy_id == 0xffff) {
diff -Naur u-boot-2009.01/drivers/net/Makefile u-boot/drivers/net/Makefile
--- u-boot-2009.01/drivers/net/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/net/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -26,12 +26,14 @@
 LIB	:= $(obj)libnet.a
 
 COBJS-$(CONFIG_DRIVER_3C589) += 3c589.o
+COBJS-$(CONFIG_PPC4xx_EMAC) += 4xx_enet.o
 COBJS-$(CONFIG_DRIVER_AX88180) += ax88180.o
 COBJS-$(CONFIG_BCM570x) += bcm570x.o bcm570x_autoneg.o 5701rls.o
 COBJS-$(CONFIG_BFIN_MAC) += bfin_mac.o
 COBJS-$(CONFIG_DRIVER_CS8900) += cs8900.o
 COBJS-$(CONFIG_TULIP) += dc2114x.o
 COBJS-$(CONFIG_DRIVER_DM9000) += dm9000x.o
+COBJS-$(CONFIG_DNET) += dnet.o
 COBJS-$(CONFIG_E1000) += e1000.o
 COBJS-$(CONFIG_EEPRO100) += eepro100.o
 COBJS-$(CONFIG_ENC28J60) += enc28j60.o
@@ -54,11 +56,11 @@
 COBJS-$(CONFIG_DRIVER_NS9750_ETHERNET) += ns9750_eth.o
 COBJS-$(CONFIG_PCNET) += pcnet.o
 COBJS-$(CONFIG_PLB2800_ETHER) += plb2800_eth.o
-COBJS-$(CONFIG_PPC4xx_EMAC) += 4xx_enet.o
 COBJS-$(CONFIG_DRIVER_RTL8019) += rtl8019.o
 COBJS-$(CONFIG_RTL8139) += rtl8139.o
 COBJS-$(CONFIG_RTL8169) += rtl8169.o
 COBJS-$(CONFIG_DRIVER_S3C4510_ETH) += s3c4510b_eth.o
+COBJS-$(CONFIG_SH_ETHER) += sh_eth.o
 COBJS-$(CONFIG_DRIVER_SMC91111) += smc91111.o
 COBJS-$(CONFIG_DRIVER_SMC911X) += smc911x.o
 COBJS-$(CONFIG_TIGON3) += tigon3.o bcm570x_autoneg.o 5701rls.o
@@ -68,7 +70,6 @@
 COBJS-$(CONFIG_VSC7385_ENET) += vsc7385.o
 COBJS-$(CONFIG_XILINX_EMAC) += xilinx_emac.o
 COBJS-$(CONFIG_XILINX_EMACLITE) += xilinx_emaclite.o
-COBJS-$(CONFIG_SH_ETHER) += sh_eth.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff -Naur u-boot-2009.01/drivers/net/mcfmii.c u-boot/drivers/net/mcfmii.c
--- u-boot-2009.01/drivers/net/mcfmii.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/net/mcfmii.c	2009-02-26 14:03:58.000000000 +0100
@@ -226,7 +226,8 @@
 	volatile FEC_T *fecp;
 	struct eth_device *dev;
 	int miispd = 0, i = 0;
-	u16 autoneg = 0;
+	u16 status = 0;
+	u16 linkgood = 0;
 
 	/* retrieve from register structure */
 	dev = eth_get_dev();
@@ -250,22 +251,32 @@
 
 	info->phy_addr = mii_discover_phy(dev);
 
-#define AUTONEGLINK		(PHY_BMSR_AUTN_COMP | PHY_BMSR_LS)
 	while (i < MCFFEC_TOUT_LOOP) {
-		autoneg = 0;
-		miiphy_read(dev->name, info->phy_addr, PHY_BMSR, &autoneg);
+		status = 0;
 		i++;
+		/* Read PHY control register */
+		miiphy_read(dev->name, info->phy_addr, PHY_BMCR, &status);
 
-		if ((autoneg & AUTONEGLINK) == AUTONEGLINK)
+		/* If phy set to autonegotiate, wait for autonegotiation done,
+		 * if phy is not autonegotiating, just wait for link up.
+		 */
+		if ((status & PHY_BMCR_AUTON) == PHY_BMCR_AUTON) {
+			linkgood = (PHY_BMSR_AUTN_COMP | PHY_BMSR_LS);
+		} else {
+			linkgood = PHY_BMSR_LS;
+		}
+		/* Read PHY status register */
+		miiphy_read(dev->name, info->phy_addr, PHY_BMSR, &status);
+		if ((status & linkgood) == linkgood)
 			break;
 
 		udelay(500);
 	}
 	if (i >= MCFFEC_TOUT_LOOP) {
-		printf("Auto Negotiation not complete\n");
+		printf("Link UP timeout\n");
 	}
 
-	/* adapt to the half/full speed settings */
+	/* adapt to the duplex and speed settings of the phy */
 	info->dup_spd = miiphy_duplex(dev->name, info->phy_addr) << 16;
 	info->dup_spd |= miiphy_speed(dev->name, info->phy_addr);
 }
diff -Naur u-boot-2009.01/drivers/net/mpc5xxx_fec.c u-boot/drivers/net/mpc5xxx_fec.c
--- u-boot-2009.01/drivers/net/mpc5xxx_fec.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/net/mpc5xxx_fec.c	2009-02-26 14:03:58.000000000 +0100
@@ -19,9 +19,6 @@
 
 /* #define DEBUG	0x28 */
 
-#if defined(CONFIG_CMD_NET) && defined(CONFIG_NET_MULTI) && \
-	defined(CONFIG_MPC5xxx_FEC)
-
 #if !(defined(CONFIG_MII) || defined(CONFIG_CMD_MII))
 #error "CONFIG_MII has to be defined!"
 #endif
@@ -891,28 +888,11 @@
 	fec->eth = (ethernet_regs *)MPC5XXX_FEC;
 	fec->tbdBase = (FEC_TBD *)FEC_BD_BASE;
 	fec->rbdBase = (FEC_RBD *)(FEC_BD_BASE + FEC_TBD_NUM * sizeof(FEC_TBD));
-#if defined(CONFIG_CANMB)		|| \
-	defined(CONFIG_CM5200)		|| \
-	defined(CONFIG_HMI1001)		|| \
-	defined(CONFIG_ICECUBE)		|| \
-	defined(CONFIG_INKA4X0)		|| \
-	defined(CONFIG_JUPITER)		|| \
-	defined(CONFIG_MCC200)		|| \
-	defined(CONFIG_MOTIONPRO)	|| \
-	defined(CONFIG_MUCMC52)		|| \
-	defined(CONFIG_O2DNT)		|| \
-	defined(CONFIG_PM520)		|| \
-	defined(CONFIG_TOP5200)		|| \
-	defined(CONFIG_TQM5200)		|| \
-	defined(CONFIG_UC101)		|| \
-	defined(CONFIG_V38B)		|| \
-	defined(CONFIG_MUNICES)
-# ifndef CONFIG_FEC_10MBIT
+#if defined(CONFIG_MPC5xxx_FEC_MII100)
 	fec->xcv_type = MII100;
-# else
+#elif defined(CONFIG_MPC5xxx_FEC_MII10)
 	fec->xcv_type = MII10;
-# endif
-#elif defined(CONFIG_TOTAL5200)
+#elif defined(CONFIG_MPC5xxx_FEC_SEVENWIRE)
 	fec->xcv_type = SEVENWIRE;
 #else
 #error fec->xcv_type not initialized.
@@ -1064,5 +1044,3 @@
 	 /**/ return crc;
 }
 #endif	/* DEBUG */
-
-#endif /* CONFIG_MPC5xxx_FEC */
diff -Naur u-boot-2009.01/drivers/net/sh_eth.c u-boot/drivers/net/sh_eth.c
--- u-boot-2009.01/drivers/net/sh_eth.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/net/sh_eth.c	2009-02-26 14:03:58.000000000 +0100
@@ -24,6 +24,7 @@
 #include <common.h>
 #include <malloc.h>
 #include <net.h>
+#include <netdev.h>
 #include <asm/errno.h>
 #include <asm/io.h>
 
@@ -36,12 +37,7 @@
 # error "Please define CONFIG_SH_ETHER_PHY_ADDR"
 #endif
 
-extern int eth_init(bd_t *bd);
-extern void eth_halt(void);
-extern int eth_rx(void);
-extern int eth_send(volatile void *packet, int length);
-
-static struct dev_info_s *dev;
+#define SH_ETH_PHY_DELAY 50000
 
 /*
  * Bits are written to the PHY serially using the
@@ -89,7 +85,7 @@
 	udelay(1);
 }
 
-static int sh_eth_mii_read_phy_bits(int port, u32 * val, int len)
+static void sh_eth_mii_read_phy_bits(int port, u32 *val, int len)
 {
 	int i;
 	u32 pir;
@@ -106,8 +102,6 @@
 		outl(0, PIR(port));
 		udelay(1);
 	}
-
-	return 0;
 }
 
 #define PHY_INIT	0xFFFFFFFF
@@ -183,26 +177,23 @@
 	sh_eth_mii_ind_bus_release(port);
 }
 
-void eth_halt(void)
-{
-}
-
-int eth_send(volatile void *packet, int len)
+int sh_eth_send(struct eth_device *dev, volatile void *packet, int len)
 {
-	int port = dev->port;
-	struct port_info_s *port_info = &dev->port_info[port];
-	int timeout;
-	int rc = 0;
+	struct sh_eth_dev *eth = dev->priv;
+	int port = eth->port, ret = 0, timeout;
+	struct sh_eth_info *port_info = &eth->port_info[port];
 
 	if (!packet || len > 0xffff) {
-		printf("eth_send: Invalid argument\n");
-		return -EINVAL;
+		printf(SHETHER_NAME ": %s: Invalid argument\n", __func__);
+		ret = -EINVAL;
+		goto err;
 	}
 
 	/* packet must be a 4 byte boundary */
 	if ((int)packet & (4 - 1)) {
-		printf("eth_send: packet not 4 byte alligned\n");
-		return -EFAULT;
+		printf(SHETHER_NAME ": %s: packet not 4 byte alligned\n", __func__);
+		ret = -EFAULT;
+		goto err;
 	}
 
 	/* Update tx descriptor */
@@ -224,24 +215,25 @@
 		udelay(100);
 
 	if (timeout < 0) {
-		printf("eth_send: transmit timeout\n");
-		rc = -1;
+		printf(SHETHER_NAME ": transmit timeout\n");
+		ret = -ETIMEDOUT;
 		goto err;
 	}
 
-err:
 	port_info->tx_desc_cur++;
 	if (port_info->tx_desc_cur >= port_info->tx_desc_base + NUM_TX_DESC)
 		port_info->tx_desc_cur = port_info->tx_desc_base;
 
-	return rc;
+	return ret;
+err:
+	return ret;
 }
 
-int eth_rx(void)
+int sh_eth_recv(struct eth_device *dev)
 {
-	int port = dev->port;
-	struct port_info_s *port_info = &dev->port_info[port];
-	int len = 0;
+	struct sh_eth_dev *eth = dev->priv;
+	int port = eth->port, len = 0;
+	struct sh_eth_info *port_info = &eth->port_info[port];
 	volatile u8 *packet;
 
 	/* Check if the rx descriptor is ready */
@@ -275,10 +267,10 @@
 }
 
 #define EDMR_INIT_CNT 1000
-static int sh_eth_reset(struct dev_info_s *dev)
+static int sh_eth_reset(struct sh_eth_dev *eth)
 {
-	int port = dev->port;
-	int i;
+	int port = eth->port;
+	int ret = 0, i;
 
 	/* Start e-dmac transmitter and receiver */
 	outl(EDSR_ENALL, EDSR(port));
@@ -292,33 +284,36 @@
 	}
 
 	if (i == EDMR_INIT_CNT) {
-		printf("Error: Software reset timeout\n");
-		return -1;
+		printf(SHETHER_NAME  ": Software reset timeout\n");
+		ret = -EIO;
 	}
-	return 0;
+
+	return ret;
 }
 
-static int sh_eth_tx_desc_init(struct dev_info_s *dev)
+static int sh_eth_tx_desc_init(struct sh_eth_dev *eth)
 {
-	int port = dev->port;
-	struct port_info_s *port_info = &dev->port_info[port];
+	int port = eth->port, i, ret = 0;
 	u32 tmp_addr;
+	struct sh_eth_info *port_info = &eth->port_info[port];
 	struct tx_desc_s *cur_tx_desc;
-	int i;
 
-	/* Allocate tx descriptors. They must be TX_DESC_SIZE bytes
-	   aligned */
-	if (!(port_info->tx_desc_malloc = malloc(NUM_TX_DESC *
+	/*
+	 * Allocate tx descriptors. They must be TX_DESC_SIZE bytes aligned
+	 */
+	port_info->tx_desc_malloc = malloc(NUM_TX_DESC *
 						 sizeof(struct tx_desc_s) +
-						 TX_DESC_SIZE - 1))) {
-		printf("Error: malloc failed\n");
-		return -ENOMEM;
+						 TX_DESC_SIZE - 1);
+	if (!port_info->tx_desc_malloc) {
+		printf(SHETHER_NAME ": malloc failed\n");
+		ret = -ENOMEM;
+		goto err;
 	}
+
 	tmp_addr = (u32) (((int)port_info->tx_desc_malloc + TX_DESC_SIZE - 1) &
 			  ~(TX_DESC_SIZE - 1));
 	/* Make sure we use a P2 address (non-cacheable) */
 	port_info->tx_desc_base = (struct tx_desc_s *)ADDR_TO_P2(tmp_addr);
-
 	port_info->tx_desc_cur = port_info->tx_desc_base;
 
 	/* Initialize all descriptors */
@@ -340,26 +335,30 @@
 	outl(ADDR_TO_PHY(cur_tx_desc), TDFXR(port));
 	outl(0x01, TDFFR(port));/* Last discriptor bit */
 
-	return 0;
+err:
+	return ret;
 }
 
-static int sh_eth_rx_desc_init(struct dev_info_s *dev)
+static int sh_eth_rx_desc_init(struct sh_eth_dev *eth)
 {
-	int port = dev->port;
-	struct port_info_s *port_info = &dev->port_info[port];
-	u32 tmp_addr;
+	int port = eth->port, i , ret = 0;
+	struct sh_eth_info *port_info = &eth->port_info[port];
 	struct rx_desc_s *cur_rx_desc;
+	u32 tmp_addr;
 	u8 *rx_buf;
-	int i;
 
-	/* Allocate rx descriptors. They must be RX_DESC_SIZE bytes
-	   aligned */
-	if (!(port_info->rx_desc_malloc = malloc(NUM_RX_DESC *
+	/*
+	 * Allocate rx descriptors. They must be RX_DESC_SIZE bytes aligned
+	 */
+	port_info->rx_desc_malloc = malloc(NUM_RX_DESC *
 						 sizeof(struct rx_desc_s) +
-						 RX_DESC_SIZE - 1))) {
-		printf("Error: malloc failed\n");
-		return -ENOMEM;
+						 RX_DESC_SIZE - 1);
+	if (!port_info->rx_desc_malloc) {
+		printf(SHETHER_NAME ": malloc failed\n");
+		ret = -ENOMEM;
+		goto err;
 	}
+
 	tmp_addr = (u32) (((int)port_info->rx_desc_malloc + RX_DESC_SIZE - 1) &
 			  ~(RX_DESC_SIZE - 1));
 	/* Make sure we use a P2 address (non-cacheable) */
@@ -367,15 +366,17 @@
 
 	port_info->rx_desc_cur = port_info->rx_desc_base;
 
-	/* Allocate rx data buffers. They must be 32 bytes aligned  and in
-	   P2 area */
-	if (!(port_info->rx_buf_malloc = malloc(NUM_RX_DESC * MAX_BUF_SIZE +
-						31))) {
-		printf("Error: malloc failed\n");
-		free(port_info->rx_desc_malloc);
-		port_info->rx_desc_malloc = NULL;
-		return -ENOMEM;
+	/*
+	 * Allocate rx data buffers. They must be 32 bytes aligned  and in
+	 * P2 area
+	 */
+	port_info->rx_buf_malloc = malloc(NUM_RX_DESC * MAX_BUF_SIZE + 31);
+	if (!port_info->rx_buf_malloc) {
+		printf(SHETHER_NAME ": malloc failed\n");
+		ret = -ENOMEM;
+		goto err_buf_malloc;
 	}
+
 	tmp_addr = (u32)(((int)port_info->rx_buf_malloc + (32 - 1)) &
 			  ~(32 - 1));
 	port_info->rx_buf_base = (u8 *)ADDR_TO_P2(tmp_addr);
@@ -399,18 +400,31 @@
 	outl(ADDR_TO_PHY(cur_rx_desc), RDFXR(port));
 	outl(RDFFR_RDLF, RDFFR(port));
 
-	return 0;
+	return ret;
+
+err_buf_malloc:
+	free(port_info->rx_desc_malloc);
+	port_info->rx_desc_malloc = NULL;
+
+err:
+	return ret;
 }
 
-static void sh_eth_desc_free(struct dev_info_s *dev)
+static void sh_eth_tx_desc_free(struct sh_eth_dev *eth)
 {
-	int port = dev->port;
-	struct port_info_s *port_info = &dev->port_info[port];
+	int port = eth->port;
+	struct sh_eth_info *port_info = &eth->port_info[port];
 
 	if (port_info->tx_desc_malloc) {
 		free(port_info->tx_desc_malloc);
 		port_info->tx_desc_malloc = NULL;
 	}
+}
+
+static void sh_eth_rx_desc_free(struct sh_eth_dev *eth)
+{
+	int port = eth->port;
+	struct sh_eth_info *port_info = &eth->port_info[port];
 
 	if (port_info->rx_desc_malloc) {
 		free(port_info->rx_desc_malloc);
@@ -423,36 +437,48 @@
 	}
 }
 
-static int sh_eth_desc_init(struct dev_info_s *dev)
+static int sh_eth_desc_init(struct sh_eth_dev *eth)
 {
-	int rc;
+	int ret = 0;
 
-	if ((rc = sh_eth_tx_desc_init(dev)) || (rc = sh_eth_rx_desc_init(dev))) {
-		sh_eth_desc_free(dev);
-		return rc;
-	}
+	ret = sh_eth_tx_desc_init(eth);
+	if (ret)
+		goto err_tx_init;
 
-	return 0;
+	ret = sh_eth_rx_desc_init(eth);
+	if (ret)
+		goto err_rx_init;
+
+	return ret;
+err_rx_init:
+	sh_eth_tx_desc_free(eth);
+
+err_tx_init:
+	return ret;
 }
 
-static int sh_eth_phy_config(struct dev_info_s *dev)
+static int sh_eth_phy_config(struct sh_eth_dev *eth)
 {
-	int port = dev->port;
-	struct port_info_s *port_info = &dev->port_info[port];
-	int timeout;
+	int port = eth->port, timeout, ret = 0;
+	struct sh_eth_info *port_info = &eth->port_info[port];
 	u32 val;
+
 	/* Reset phy */
-	sh_eth_mii_write_phy_reg(port, port_info->phy_addr, PHY_CTRL, PHY_C_RESET);
+	sh_eth_mii_write_phy_reg
+		(port, port_info->phy_addr, PHY_CTRL, PHY_C_RESET);
 	timeout = 10;
 	while (timeout--) {
-		val = sh_eth_mii_read_phy_reg(port, port_info->phy_addr, PHY_CTRL);
+		val = sh_eth_mii_read_phy_reg(port,
+				port_info->phy_addr, PHY_CTRL);
 		if (!(val & PHY_C_RESET))
 			break;
-		udelay(50000);
+		udelay(SH_ETH_PHY_DELAY);
 	}
+
 	if (timeout < 0) {
-		printf("%s phy reset timeout\n", __func__);
-		return -1;
+		printf(SHETHER_NAME ": phy reset timeout\n");
+		ret = -EIO;
+		goto err_tout;
 	}
 
 	/* Advertise 100/10 baseT full/half duplex */
@@ -467,23 +493,27 @@
 		val = sh_eth_mii_read_phy_reg(port, port_info->phy_addr, 1);
 		if (val & PHY_S_ANEGC)
 			break;
-		udelay(50000);
+
+		udelay(SH_ETH_PHY_DELAY);
 	}
+
 	if (timeout < 0) {
-		printf("sh_eth_phy_config() phy auto-negotiation failed\n");
-		return -1;
+		printf(SHETHER_NAME ": phy auto-negotiation failed\n");
+		ret = -ETIMEDOUT;
+		goto err_tout;
 	}
 
-	return 0;
+	return ret;
+
+err_tout:
+	return ret;
 }
 
-static int sh_eth_config(struct dev_info_s *dev, bd_t * bd)
+static int sh_eth_config(struct sh_eth_dev *eth, bd_t *bd)
 {
-	int port = dev->port;
-	struct port_info_s *port_info = &dev->port_info[port];
-	u32 val;
-	u32 phy_status;
-	int rc;
+	int port = eth->port, ret = 0;
+	u32 val,  phy_status;
+	struct sh_eth_info *port_info = &eth->port_info[port];
 
 	/* Configure e-dmac registers */
 	outl((inl(EDMR(port)) & ~EMDR_DESC_R) | EDMR_EL, EDMR(port));
@@ -513,20 +543,20 @@
 	outl(TPAUSER_TPAUSE, TPAUSER(port));
 
 	/* Configure phy */
-	if ((rc = sh_eth_phy_config(dev)))
-		return rc;
-
+	ret = sh_eth_phy_config(eth);
+	if (ret) {
+		printf(SHETHER_NAME ":i phy config timeout\n");
+		goto err_phy_cfg;
+	}
 	/* Read phy status to finish configuring the e-mac */
-	phy_status = sh_eth_mii_read_phy_reg(dev->port,
-					     dev->port_info[dev->port].phy_addr,
-					     1);
+	phy_status = sh_eth_mii_read_phy_reg(port, port_info->phy_addr, 1);
 
 	/* Set the transfer speed */
 	if (phy_status & (PHY_S_100X_F|PHY_S_100X_H)) {
-		printf("100Base/");
+		printf(SHETHER_NAME ": 100Base/");
 		outl(GECMR_100B, GECMR(port));
 	} else {
-		printf("10Base/");
+		printf(SHETHER_NAME ": 10Base/");
 		outl(GECMR_10B, GECMR(port));
 	}
 
@@ -538,27 +568,34 @@
 		printf("Half\n");
 		outl((ECMR_CHG_DM|ECMR_RE|ECMR_TE),  ECMR(port));
 	}
-	return 0;
+
+	return ret;
+
+err_phy_cfg:
+	return ret;
 }
 
-static int sh_eth_start(struct dev_info_s *dev)
+static void sh_eth_start(struct sh_eth_dev *eth)
 {
 	/*
 	 * Enable the e-dmac receiver only. The transmitter will be enabled when
 	 * we have something to transmit
 	 */
-	outl(EDRRR_R, EDRRR(dev->port));
+	outl(EDRRR_R, EDRRR(eth->port));
+}
 
-	return 0;
+static void sh_eth_stop(struct sh_eth_dev *eth)
+{
+	outl(~EDRRR_R, EDRRR(eth->port));
 }
 
 static int sh_eth_get_mac(bd_t *bd)
 {
 	char *s, *e;
-	int i;
 
 	s = getenv("ethaddr");
 	if (s != NULL) {
+		int i;
 		for (i = 0; i < 6; ++i) {
 			bd->bi_enetaddr[i] = s ? simple_strtoul(s, &e, 16) : 0;
 			if (s)
@@ -570,34 +607,92 @@
 	return 0;
 }
 
-int eth_init(bd_t *bd)
+int sh_eth_init(struct eth_device *dev, bd_t *bd)
 {
-	int rc;
-	/* Allocate main device information structure */
-	if (!(dev = malloc(sizeof(*dev)))) {
-		printf("eth_init: malloc failed\n");
-		return -ENOMEM;
-	}
+	int ret = 0;
+	struct sh_eth_dev *eth = dev->priv;
 
-	memset(dev, 0, sizeof(*dev));
+	ret = sh_eth_reset(eth);
+	if (ret)
+		goto err;
 
-	dev->port = CONFIG_SH_ETHER_USE_PORT;
-	dev->port_info[dev->port].phy_addr = CONFIG_SH_ETHER_PHY_ADDR;
+	ret = sh_eth_desc_init(eth);
+	if (ret)
+		goto err;
 
-	sh_eth_get_mac(bd);
+	ret = sh_eth_config(eth, bd);
+	if (ret)
+		goto err_config;
+
+	sh_eth_start(eth);
+
+	return ret;
 
-	if ((rc = sh_eth_reset(dev)) || (rc = sh_eth_desc_init(dev)))
+err_config:
+	sh_eth_tx_desc_free(eth);
+	sh_eth_rx_desc_free(eth);
+
+err:
+	return ret;
+}
+
+void sh_eth_halt(struct eth_device *dev)
+{
+	struct sh_eth_dev *eth = dev->priv;
+
+	sh_eth_reset(eth);
+	sh_eth_stop(eth);
+}
+
+int sh_eth_initialize(bd_t *bd)
+{
+    int ret = 0;
+	struct sh_eth_dev *eth = NULL;
+    struct eth_device *dev = NULL;
+
+    eth = (struct sh_eth_dev *)malloc(sizeof(struct sh_eth_dev));
+	if (!eth) {
+		printf(SHETHER_NAME ": %s: malloc failed\n", __func__);
+		ret = -ENOMEM;
+		goto err;
+	}
+
+    dev = (struct eth_device *)malloc(sizeof(struct eth_device));
+	if (!dev) {
+		printf(SHETHER_NAME ": %s: malloc failed\n", __func__);
+		ret = -ENOMEM;
 		goto err;
+	}
+    memset(dev, 0, sizeof(struct eth_device));
+    memset(eth, 0, sizeof(struct sh_eth_dev));
 
-	if ((rc = sh_eth_config(dev, bd)) || (rc = sh_eth_start(dev)))
-		goto err_desc;
+	eth->port = CONFIG_SH_ETHER_USE_PORT;
+	eth->port_info[eth->port].phy_addr = CONFIG_SH_ETHER_PHY_ADDR;
 
-	return 0;
+    dev->priv = (void *)eth;
+    dev->iobase = 0;
+    dev->init = sh_eth_init;
+    dev->halt = sh_eth_halt;
+    dev->send = sh_eth_send;
+    dev->recv = sh_eth_recv;
+    eth->port_info[eth->port].dev = dev;
+
+	sprintf(dev->name, SHETHER_NAME);
+
+    /* Register Device to EtherNet subsystem  */
+    eth_register(dev);
+
+	sh_eth_get_mac(bd);
+
+	return ret;
 
-err_desc:
-	sh_eth_desc_free(dev);
 err:
-	free(dev);
-	printf("eth_init: Failed\n");
-	return rc;
+	if (dev)
+		free(dev);
+
+	if (eth)
+		free(eth);
+
+	printf(SHETHER_NAME ": Failed\n");
+	return ret;
 }
diff -Naur u-boot-2009.01/drivers/net/sh_eth.h u-boot/drivers/net/sh_eth.h
--- u-boot-2009.01/drivers/net/sh_eth.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/net/sh_eth.h	2009-02-26 14:03:58.000000000 +0100
@@ -20,6 +20,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <netdev.h>
 #include <asm/types.h>
 
 #define SHETHER_NAME "sh_eth"
@@ -48,7 +49,7 @@
 #define TX_DESC_PADDING		4
 #define TX_DESC_SIZE		(12 + TX_DESC_PADDING)
 
-/* Tx descriptor. We always use 4 bytes of padding */
+/* Tx descriptor. We always use 3 bytes of padding */
 struct tx_desc_s {
 	volatile u32 td0;
 	u32 td1;
@@ -72,7 +73,7 @@
 	u32 padding;
 };
 
-struct port_info_s {
+struct sh_eth_info {
 	struct tx_desc_s *tx_desc_malloc;
 	struct tx_desc_s *tx_desc_base;
 	struct tx_desc_s *tx_desc_cur;
@@ -83,11 +84,12 @@
 	u8 *rx_buf_base;
 	u8 mac_addr[6];
 	u8 phy_addr;
+	struct eth_device *dev;
 };
 
-struct dev_info_s {
+struct sh_eth_dev {
 	int port;
-	struct port_info_s port_info[MAX_PORT_NUM];
+	struct sh_eth_info port_info[MAX_PORT_NUM];
 };
 
 /* Register Address */
@@ -166,7 +168,7 @@
 
 /* GECMR */
 enum GECMR_BIT {
-	GECMR_1000B = 0x01, GECMR_100B = 0x40, GECMR_10B = 0x00,
+	GECMR_1000B = 0x01, GECMR_100B = 0x04, GECMR_10B = 0x00,
 };
 
 /* EDRRR*/
diff -Naur u-boot-2009.01/drivers/net/smc911x.c u-boot/drivers/net/smc911x.c
--- u-boot-2009.01/drivers/net/smc911x.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/net/smc911x.c	2009-02-26 14:03:58.000000000 +0100
@@ -34,21 +34,24 @@
 #endif
 
 #if defined (CONFIG_DRIVER_SMC911X_32_BIT)
-static inline u32 reg_read(u32 addr)
+static inline u32 __smc911x_reg_read(u32 addr)
 {
 	return *(volatile u32*)addr;
 }
-static inline void reg_write(u32 addr, u32 val)
+u32 smc911x_reg_read(u32 addr) __attribute__((weak, alias("__smc911x_reg_read")));
+
+static inline void __smc911x_reg_write(u32 addr, u32 val)
 {
 	*(volatile u32*)addr = val;
 }
+void smc911x_reg_write(u32 addr, u32 val) __attribute__((weak, alias("__smc911x_reg_write")));
 #elif defined (CONFIG_DRIVER_SMC911X_16_BIT)
-static inline u32 reg_read(u32 addr)
+static inline u32 smc911x_reg_read(u32 addr)
 {
 	volatile u16 *addr_16 = (u16 *)addr;
 	return ((*addr_16 & 0x0000ffff) | (*(addr_16 + 1) << 16));
 }
-static inline void reg_write(u32 addr, u32 val)
+static inline void smc911x_reg_write(u32 addr, u32 val)
 {
 	*(volatile u16*)addr = (u16)val;
 	*(volatile u16*)(addr + 2) = (u16)(val >> 16);
@@ -58,9 +61,9 @@
 #endif /* CONFIG_DRIVER_SMC911X_16_BIT */
 
 u32 pkt_data_pull(u32 addr) \
-	__attribute__ ((weak, alias ("reg_read")));
+	__attribute__ ((weak, alias ("smc911x_reg_read")));
 void pkt_data_push(u32 addr, u32 val) \
-	__attribute__ ((weak, alias ("reg_write")));
+	__attribute__ ((weak, alias ("smc911x_reg_write")));
 
 #define mdelay(n)       udelay((n)*1000)
 
@@ -381,6 +384,7 @@
 #define CHIP_9116	0x116
 #define CHIP_9117	0x117
 #define CHIP_9118	0x118
+#define CHIP_9211	0x9211
 #define CHIP_9215	0x115a
 #define CHIP_9216	0x116a
 #define CHIP_9217	0x117a
@@ -396,6 +400,7 @@
 	{ CHIP_9116, "LAN9116" },
 	{ CHIP_9117, "LAN9117" },
 	{ CHIP_9118, "LAN9118" },
+	{ CHIP_9211, "LAN9211" },
 	{ CHIP_9215, "LAN9215" },
 	{ CHIP_9216, "LAN9216" },
 	{ CHIP_9217, "LAN9217" },
@@ -407,22 +412,22 @@
 
 u32 smc911x_get_mac_csr(u8 reg)
 {
-	while (reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
+	while (smc911x_reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
 		;
-	reg_write(MAC_CSR_CMD, MAC_CSR_CMD_CSR_BUSY | MAC_CSR_CMD_R_NOT_W | reg);
-	while (reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
+	smc911x_reg_write(MAC_CSR_CMD, MAC_CSR_CMD_CSR_BUSY | MAC_CSR_CMD_R_NOT_W | reg);
+	while (smc911x_reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
 		;
 
-	return reg_read(MAC_CSR_DATA);
+	return smc911x_reg_read(MAC_CSR_DATA);
 }
 
 void smc911x_set_mac_csr(u8 reg, u32 data)
 {
-	while (reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
+	while (smc911x_reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
 		;
-	reg_write(MAC_CSR_DATA, data);
-	reg_write(MAC_CSR_CMD, MAC_CSR_CMD_CSR_BUSY | reg);
-	while (reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
+	smc911x_reg_write(MAC_CSR_DATA, data);
+	smc911x_reg_write(MAC_CSR_CMD, MAC_CSR_CMD_CSR_BUSY | reg);
+	while (smc911x_reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
 		;
 }
 
@@ -496,10 +501,10 @@
 {
 	u32 reg;
 
-	reg = reg_read(PMT_CTRL);
+	reg = smc911x_reg_read(PMT_CTRL);
 	reg &= ~0xfffff030;
 	reg |= PMT_CTRL_PHY_RST;
-	reg_write(PMT_CTRL, reg);
+	smc911x_reg_write(PMT_CTRL, reg);
 
 	mdelay(100);
 
@@ -541,13 +546,13 @@
 	int timeout;
 
 	/* Take out of PM setting first */
-	if (reg_read(PMT_CTRL) & PMT_CTRL_READY) {
+	if (smc911x_reg_read(PMT_CTRL) & PMT_CTRL_READY) {
 		/* Write to the bytetest will take out of powerdown */
-		reg_write(BYTE_TEST, 0x0);
+		smc911x_reg_write(BYTE_TEST, 0x0);
 
 		timeout = 10;
 
-		while (timeout-- && !(reg_read(PMT_CTRL) & PMT_CTRL_READY))
+		while (timeout-- && !(smc911x_reg_read(PMT_CTRL) & PMT_CTRL_READY))
 			udelay(10);
 		if (!timeout) {
 			printf(DRIVERNAME
@@ -557,12 +562,12 @@
 	}
 
 	/* Disable interrupts */
-	reg_write(INT_EN, 0);
+	smc911x_reg_write(INT_EN, 0);
 
-	reg_write(HW_CFG, HW_CFG_SRST);
+	smc911x_reg_write(HW_CFG, HW_CFG_SRST);
 
 	timeout = 1000;
-	while (timeout-- && reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY)
+	while (timeout-- && smc911x_reg_read(E2P_CMD) & E2P_CMD_EPC_BUSY)
 		udelay(10);
 
 	if (!timeout) {
@@ -572,23 +577,23 @@
 
 	/* Reset the FIFO level and flow control settings */
 	smc911x_set_mac_csr(FLOW, FLOW_FCPT | FLOW_FCEN);
-	reg_write(AFC_CFG, 0x0050287F);
+	smc911x_reg_write(AFC_CFG, 0x0050287F);
 
 	/* Set to LED outputs */
-	reg_write(GPIO_CFG, 0x70070000);
+	smc911x_reg_write(GPIO_CFG, 0x70070000);
 }
 
 static void smc911x_enable(void)
 {
 	/* Enable TX */
-	reg_write(HW_CFG, 8 << 16 | HW_CFG_SF);
+	smc911x_reg_write(HW_CFG, 8 << 16 | HW_CFG_SF);
 
-	reg_write(GPT_CFG, GPT_CFG_TIMER_EN | 10000);
+	smc911x_reg_write(GPT_CFG, GPT_CFG_TIMER_EN | 10000);
 
-	reg_write(TX_CFG, TX_CFG_TX_ON);
+	smc911x_reg_write(TX_CFG, TX_CFG_TX_ON);
 
 	/* no padding to start of packets */
-	reg_write(RX_CFG, 0);
+	smc911x_reg_write(RX_CFG, 0);
 
 	smc911x_set_mac_csr(MAC_CR, MAC_CR_TXEN | MAC_CR_RXEN | MAC_CR_HBDIS);
 
@@ -600,13 +605,13 @@
 
 	printf(DRIVERNAME ": initializing\n");
 
-	val = reg_read(BYTE_TEST);
+	val = smc911x_reg_read(BYTE_TEST);
 	if (val != 0x87654321) {
 		printf(DRIVERNAME ": Invalid chip endian 0x%08lx\n", val);
 		goto err_out;
 	}
 
-	val = reg_read(ID_REV) >> 16;
+	val = smc911x_reg_read(ID_REV) >> 16;
 	for (i = 0; chip_ids[i].id != 0; i++) {
 		if (chip_ids[i].id == val) break;
 	}
@@ -640,8 +645,8 @@
 	u32 tmplen;
 	u32 status;
 
-	reg_write(TX_DATA_FIFO, TX_CMD_A_INT_FIRST_SEG | TX_CMD_A_INT_LAST_SEG | length);
-	reg_write(TX_DATA_FIFO, length);
+	smc911x_reg_write(TX_DATA_FIFO, TX_CMD_A_INT_FIRST_SEG | TX_CMD_A_INT_LAST_SEG | length);
+	smc911x_reg_write(TX_DATA_FIFO, length);
 
 	tmplen = (length + 3) / 4;
 
@@ -649,12 +654,12 @@
 		pkt_data_push(TX_DATA_FIFO, *data++);
 
 	/* wait for transmission */
-	while (!((reg_read(TX_FIFO_INF) & TX_FIFO_INF_TSUSED) >> 16));
+	while (!((smc911x_reg_read(TX_FIFO_INF) & TX_FIFO_INF_TSUSED) >> 16));
 
 	/* get status. Ignore 'no carrier' error, it has no meaning for
 	 * full duplex operation
 	 */
-	status = reg_read(TX_STATUS_FIFO) & (TX_STS_LOC | TX_STS_LATE_COLL |
+	status = smc911x_reg_read(TX_STATUS_FIFO) & (TX_STS_LOC | TX_STS_LATE_COLL |
 		TX_STS_MANY_COLL | TX_STS_MANY_DEFER | TX_STS_UNDERRUN);
 
 	if (!status)
@@ -681,11 +686,11 @@
 	u32 pktlen, tmplen;
 	u32 status;
 
-	if ((reg_read(RX_FIFO_INF) & RX_FIFO_INF_RXSUSED) >> 16) {
-		status = reg_read(RX_STATUS_FIFO);
+	if ((smc911x_reg_read(RX_FIFO_INF) & RX_FIFO_INF_RXSUSED) >> 16) {
+		status = smc911x_reg_read(RX_STATUS_FIFO);
 		pktlen = (status & RX_STS_PKT_LEN) >> 16;
 
-		reg_write(RX_CFG, 0);
+		smc911x_reg_write(RX_CFG, 0);
 
 		tmplen = (pktlen + 2+ 3) / 4;
 		while (tmplen--)
diff -Naur u-boot-2009.01/drivers/net/tsec.c u-boot/drivers/net/tsec.c
--- u-boot-2009.01/drivers/net/tsec.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/net/tsec.c	2009-02-26 14:03:58.000000000 +0100
@@ -158,6 +158,7 @@
 
 	/* Reset the MAC */
 	priv->regs->maccfg1 |= MACCFG1_SOFT_RESET;
+	udelay(2);  /* Soft Reset must be asserted for 3 TX clocks */
 	priv->regs->maccfg1 &= ~(MACCFG1_SOFT_RESET);
 
 #if defined(CONFIG_MII) || defined(CONFIG_CMD_MII) \
@@ -1141,6 +1142,9 @@
 		{MIIM_CONTROL, MIIM_CONTROL_RESET, NULL},
 		{0x16, 0x0002, NULL}, /* Change Page Number */
 		{0x15, 0x1070, NULL}, /* Delay RGMII TX and RX */
+		{0x16, 0x0003, NULL}, /* Change Page Number */
+		{0x10, 0x021e, NULL}, /* Adjust LED control */
+		{0x16, 0x0000, NULL}, /* Change Page Number */
 		{MIIM_GBIT_CONTROL, MIIM_GBIT_CONTROL_INIT, NULL},
 		{MIIM_ANAR, MIIM_ANAR_INIT, NULL},
 		{MIIM_CONTROL, MIIM_CONTROL_RESET, NULL},
@@ -1152,6 +1156,7 @@
 		/* Status is read once to clear old link state */
 		{MIIM_STATUS, miim_read, NULL},
 		/* Auto-negotiate */
+		{MIIM_STATUS, miim_read, &mii_parse_sr},
 		/* Read the status */
 		{MIIM_88E1011_PHY_STATUS, miim_read,
 		 &mii_parse_88E1011_psr},
diff -Naur u-boot-2009.01/drivers/pci/fsl_pci_init.c u-boot/drivers/pci/fsl_pci_init.c
--- u-boot-2009.01/drivers/pci/fsl_pci_init.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/pci/fsl_pci_init.c	2009-02-26 14:03:58.000000000 +0100
@@ -72,7 +72,7 @@
 	debug ("R0 bus_start: %llx phys_start: %llx size: %llx\n",
 		(u64)bus_start, (u64)phys_start, (u64)pci_sz);
 	pci_set_region(r++, bus_start, phys_start, pci_sz,
-			PCI_REGION_MEM | PCI_REGION_MEMORY |
+			PCI_REGION_MEM | PCI_REGION_SYS_MEMORY |
 			PCI_REGION_PREFETCH);
 
 	sz -= pci_sz;
@@ -84,7 +84,7 @@
 		debug ("R1 bus_start: %llx phys_start: %llx size: %llx\n",
 			(u64)bus_start, (u64)phys_start, (u64)pci_sz);
 		pci_set_region(r++, bus_start, phys_start, pci_sz,
-				PCI_REGION_MEM | PCI_REGION_MEMORY |
+				PCI_REGION_MEM | PCI_REGION_SYS_MEMORY |
 				PCI_REGION_PREFETCH);
 		sz -= pci_sz;
 		bus_start += pci_sz;
@@ -108,7 +108,7 @@
 			CONFIG_SYS_PCI64_MEMORY_BUS,
 			CONFIG_SYS_PCI_MEMORY_PHYS,
 			pci_sz,
-			PCI_REGION_MEM | PCI_REGION_MEMORY |
+			PCI_REGION_MEM | PCI_REGION_SYS_MEMORY |
 			PCI_REGION_PREFETCH);
 #else
 	pci_sz = 1ull << __ilog2_u64(sz);
@@ -116,7 +116,7 @@
 		debug ("R2 bus_start: %llx phys_start: %llx size: %llx\n",
 			(u64)bus_start, (u64)phys_start, (u64)pci_sz);
 		pci_set_region(r++, bus_start, phys_start, pci_sz,
-				PCI_REGION_MEM | PCI_REGION_MEMORY |
+				PCI_REGION_MEM | PCI_REGION_SYS_MEMORY |
 				PCI_REGION_PREFETCH);
 		sz -= pci_sz;
 		bus_start += pci_sz;
@@ -157,7 +157,7 @@
 
 	for (r=0; r<hose->region_count; r++) {
 		u32 sz = (__ilog2_u64((u64)hose->regions[r].size) - 1);
-		if (hose->regions[r].flags & PCI_REGION_MEMORY) { /* inbound */
+		if (hose->regions[r].flags & PCI_REGION_SYS_MEMORY) { /* inbound */
 			u32 flag = PIWAR_EN | PIWAR_LOCAL |
 					PIWAR_READ_SNOOP | PIWAR_WRITE_SNOOP;
 			pi->pitar = (hose->regions[r].phys_start >> 12);
diff -Naur u-boot-2009.01/drivers/pci/Makefile u-boot/drivers/pci/Makefile
--- u-boot-2009.01/drivers/pci/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/pci/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -27,6 +27,7 @@
 
 COBJS-$(CONFIG_FSL_PCI_INIT) += fsl_pci_init.o
 COBJS-$(CONFIG_PCI) += pci.o pci_auto.o pci_indirect.o
+COBJS-$(CONFIG_IXP_PCI) += pci_ixp.o
 COBJS-$(CONFIG_SH4_PCI) += pci_sh4.o
 COBJS-$(CONFIG_SH7751_PCI) +=pci_sh7751.o
 COBJS-$(CONFIG_SH7780_PCI) +=pci_sh7780.o
diff -Naur u-boot-2009.01/drivers/pci/pci.c u-boot/drivers/pci/pci.c
--- u-boot-2009.01/drivers/pci/pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/pci/pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -116,6 +116,25 @@
 PCI_WRITE_VIA_DWORD_OP(byte, u8, 0x03, 0x000000ff)
 PCI_WRITE_VIA_DWORD_OP(word, u16, 0x02, 0x0000ffff)
 
+/* Get a virtual address associated with a BAR region */
+void *pci_map_bar(pci_dev_t pdev, int bar, int flags)
+{
+	pci_addr_t pci_bus_addr;
+	u32 bar_response;
+
+	/* read BAR address */
+	pci_read_config_dword(pdev, bar, &bar_response);
+	pci_bus_addr = (pci_addr_t)(bar_response & ~0xf);
+
+	/*
+	 * Pass "0" as the length argument to pci_bus_to_virt.  The arg
+	 * isn't actualy used on any platform because u-boot assumes a static
+	 * linear mapping.  In the future, this could read the BAR size
+	 * and pass that as the size if needed.
+	 */
+	return pci_bus_to_virt(pdev, pci_bus_addr, flags, 0, MAP_NOCACHE);
+}
+
 /*
  *
  */
@@ -218,67 +237,121 @@
  *
  */
 
-pci_addr_t pci_hose_phys_to_bus (struct pci_controller *hose,
-				    phys_addr_t phys_addr,
-				    unsigned long flags)
+int __pci_hose_phys_to_bus (struct pci_controller *hose,
+				phys_addr_t phys_addr,
+				unsigned long flags,
+				unsigned long skip_mask,
+				pci_addr_t *ba)
 {
 	struct pci_region *res;
 	pci_addr_t bus_addr;
 	int i;
 
-	if (!hose) {
-		printf ("pci_hose_phys_to_bus: %s\n", "invalid hose");
-		goto Done;
-	}
-
 	for (i = 0; i < hose->region_count; i++) {
 		res = &hose->regions[i];
 
 		if (((res->flags ^ flags) & PCI_REGION_TYPE) != 0)
 			continue;
 
+		if (res->flags & skip_mask)
+			continue;
+
 		bus_addr = phys_addr - res->phys_start + res->bus_start;
 
 		if (bus_addr >= res->bus_start &&
 			bus_addr < res->bus_start + res->size) {
-			return bus_addr;
+			*ba = bus_addr;
+			return 0;
 		}
 	}
 
-	printf ("pci_hose_phys_to_bus: %s\n", "invalid physical address");
-
-Done:
-	return 0;
+	return 1;
 }
 
-phys_addr_t pci_hose_bus_to_phys(struct pci_controller* hose,
-				 pci_addr_t bus_addr,
-				 unsigned long flags)
+pci_addr_t pci_hose_phys_to_bus (struct pci_controller *hose,
+				    phys_addr_t phys_addr,
+				    unsigned long flags)
 {
-	struct pci_region *res;
-	int i;
+	pci_addr_t bus_addr = 0;
+	int ret;
 
 	if (!hose) {
-		printf ("pci_hose_bus_to_phys: %s\n", "invalid hose");
-		goto Done;
+		puts ("pci_hose_phys_to_bus: invalid hose\n");
+		return bus_addr;
 	}
 
+	/* if PCI_REGION_MEM is set we do a two pass search with preference
+	 * on matches that don't have PCI_REGION_SYS_MEMORY set */
+	if ((flags & PCI_REGION_MEM) == PCI_REGION_MEM) {
+		ret = __pci_hose_phys_to_bus(hose, phys_addr,
+				flags, PCI_REGION_SYS_MEMORY, &bus_addr);
+		if (!ret)
+			return bus_addr;
+	}
+
+	ret = __pci_hose_phys_to_bus(hose, phys_addr, flags, 0, &bus_addr);
+
+	if (ret)
+		puts ("pci_hose_phys_to_bus: invalid physical address\n");
+
+	return bus_addr;
+}
+
+int __pci_hose_bus_to_phys (struct pci_controller *hose,
+				pci_addr_t bus_addr,
+				unsigned long flags,
+				unsigned long skip_mask,
+				phys_addr_t *pa)
+{
+	struct pci_region *res;
+	int i;
+
 	for (i = 0; i < hose->region_count; i++) {
 		res = &hose->regions[i];
 
 		if (((res->flags ^ flags) & PCI_REGION_TYPE) != 0)
 			continue;
 
+		if (res->flags & skip_mask)
+			continue;
+
 		if (bus_addr >= res->bus_start &&
 			bus_addr < res->bus_start + res->size) {
-			return bus_addr - res->bus_start + res->phys_start;
+			*pa = (bus_addr - res->bus_start + res->phys_start);
+			return 0;
 		}
 	}
 
-	printf ("pci_hose_bus_to_phys: %s\n", "invalid physical address");
+	return 1;
+}
 
-Done:
-	return 0;
+phys_addr_t pci_hose_bus_to_phys(struct pci_controller* hose,
+				 pci_addr_t bus_addr,
+				 unsigned long flags)
+{
+	phys_addr_t phys_addr = 0;
+	int ret;
+
+	if (!hose) {
+		puts ("pci_hose_bus_to_phys: invalid hose\n");
+		return phys_addr;
+	}
+
+	/* if PCI_REGION_MEM is set we do a two pass search with preference
+	 * on matches that don't have PCI_REGION_SYS_MEMORY set */
+	if ((flags & PCI_REGION_MEM) == PCI_REGION_MEM) {
+		ret = __pci_hose_bus_to_phys(hose, bus_addr,
+				flags, PCI_REGION_SYS_MEMORY, &phys_addr);
+		if (!ret)
+			return phys_addr;
+	}
+
+	ret = __pci_hose_bus_to_phys(hose, bus_addr, flags, 0, &phys_addr);
+
+	if (ret)
+		puts ("pci_hose_bus_to_phys: invalid physical address\n");
+
+	return phys_addr;
 }
 
 /*
diff -Naur u-boot-2009.01/drivers/pci/pci_ixp.c u-boot/drivers/pci/pci_ixp.c
--- u-boot-2009.01/drivers/pci/pci_ixp.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/pci/pci_ixp.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,571 @@
+/*
+ * IXP PCI Init
+ * (C) Copyright 2004 eslab.whut.edu.cn
+ * Yue Hu(huyue_whut@yahoo.com.cn), Ligong Xue(lgxue@hotmail.com)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/io.h>
+#include <pci.h>
+#include <asm/arch/ixp425.h>
+#include <asm/arch/ixp425pci.h>
+
+static void non_prefetch_read (unsigned int addr, unsigned int cmd,
+			       unsigned int *data);
+static void non_prefetch_write (unsigned int addr, unsigned int cmd,
+				unsigned int data);
+static void configure_pins (void);
+static void sys_pci_gpio_clock_config (void);
+static void pci_bus_scan (void);
+static int pci_device_exists (unsigned int deviceNo);
+static void sys_pci_bar_info_get (unsigned int devnum, unsigned int bus,
+				  unsigned int dev, unsigned int func);
+static void sys_pci_device_bars_write (void);
+static void calc_bars (PciBar * Bars[], unsigned int nBars,
+		       unsigned int startAddr);
+
+#define PCI_MEMORY_BUS		0x00000000
+#define PCI_MEMORY_PHY		0x48000000
+#define PCI_MEMORY_SIZE		0x04000000
+
+#define PCI_MEM_BUS		0x40000000
+#define PCI_MEM_PHY		0x00000000
+#define PCI_MEM_SIZE		0x04000000
+
+#define	PCI_IO_BUS		0x40000000
+#define PCI_IO_PHY		0x50000000
+#define PCI_IO_SIZE		0x10000000
+
+struct pci_controller hose;
+
+unsigned int nDevices;
+unsigned int nMBars;
+unsigned int nIOBars;
+PciBar *memBars[IXP425_PCI_MAX_BAR];
+PciBar *ioBars[IXP425_PCI_MAX_BAR];
+PciDevice devices[IXP425_PCI_MAX_FUNC_ON_BUS];
+
+int pci_read_config_dword (pci_dev_t dev, int where, unsigned int *val)
+{
+	unsigned int retval;
+	unsigned int addr;
+
+	/*address bits 31:28 specify the device 10:8 specify the function */
+	/*Set the address to be read */
+	addr = BIT ((31 - dev)) | (where & ~3);
+	non_prefetch_read (addr, NP_CMD_CONFIGREAD, &retval);
+
+	*val = retval;
+
+	return (OK);
+}
+
+int pci_read_config_word (pci_dev_t dev, int where, unsigned short *val)
+{
+	unsigned int n;
+	unsigned int retval;
+	unsigned int addr;
+	unsigned int byteEnables;
+
+	n = where % 4;
+	/*byte enables are 4 bits active low, the position of each
+	   bit maps to the byte that it enables */
+	byteEnables =
+		(~(BIT (n) | BIT ((n + 1)))) &
+		IXP425_PCI_BOTTOM_NIBBLE_OF_LONG_MASK;
+	byteEnables = byteEnables << PCI_NP_CBE_BESL;
+	/*address bits 31:28 specify the device 10:8 specify the function */
+	/*Set the address to be read */
+	addr = BIT ((31 - dev)) | (where & ~3);
+	non_prefetch_read (addr, byteEnables | NP_CMD_CONFIGREAD, &retval);
+
+	/*Pick out the word we are interested in */
+	*val = (retval >> (8 * n));
+
+	return (OK);
+}
+
+int pci_read_config_byte (pci_dev_t dev, int where, unsigned char *val)
+{
+	unsigned int retval;
+	unsigned int n;
+	unsigned int byteEnables;
+	unsigned int addr;
+
+	n = where % 4;
+	/*byte enables are 4 bits, active low, the position of each
+	   bit maps to the byte that it enables */
+	byteEnables = (~BIT (n)) & IXP425_PCI_BOTTOM_NIBBLE_OF_LONG_MASK;
+	byteEnables = byteEnables << PCI_NP_CBE_BESL;
+
+	/*address bits 31:28 specify the device, 10:8 specify the function */
+	/*Set the address to be read */
+	addr = BIT ((31 - dev)) | (where & ~3);
+	non_prefetch_read (addr, byteEnables | NP_CMD_CONFIGREAD, &retval);
+	/*Pick out the byte we are interested in */
+	*val = (retval >> (8 * n));
+
+	return (OK);
+}
+
+int pci_write_config_byte (pci_dev_t dev, int where, unsigned char val)
+{
+	unsigned int addr;
+	unsigned int byteEnables;
+	unsigned int n;
+	unsigned int ldata;
+
+	n = where % 4;
+	/*byte enables are 4 bits active low, the position of each
+	   bit maps to the byte that it enables */
+	byteEnables = (~BIT (n)) & IXP425_PCI_BOTTOM_NIBBLE_OF_LONG_MASK;
+	byteEnables = byteEnables << PCI_NP_CBE_BESL;
+	ldata = val << (8 * n);
+	/*address bits 31:28 specify the device 10:8 specify the function */
+	/*Set the address to be written */
+	addr = BIT ((31 - dev)) | (where & ~3);
+	non_prefetch_write (addr, byteEnables | NP_CMD_CONFIGWRITE, ldata);
+
+	return (OK);
+}
+
+int pci_write_config_word (pci_dev_t dev, int where, unsigned short val)
+{
+	unsigned int addr;
+	unsigned int byteEnables;
+	unsigned int n;
+	unsigned int ldata;
+
+	n = where % 4;
+	/*byte enables are 4 bits active low, the position of each
+	   bit maps to the byte that it enables */
+	byteEnables =
+		(~(BIT (n) | BIT ((n + 1)))) &
+		IXP425_PCI_BOTTOM_NIBBLE_OF_LONG_MASK;
+	byteEnables = byteEnables << PCI_NP_CBE_BESL;
+	ldata = val << (8 * n);
+	/*address bits 31:28 specify the device 10:8 specify the function */
+	/*Set the address to be written */
+	addr = BIT (31 - dev) | (where & ~3);
+	non_prefetch_write (addr, byteEnables | NP_CMD_CONFIGWRITE, ldata);
+
+	return (OK);
+}
+
+int pci_write_config_dword (pci_dev_t dev, int where, unsigned int val)
+{
+	unsigned int addr;
+
+	/*address bits 31:28 specify the device 10:8 specify the function */
+	/*Set the address to be written */
+	addr = BIT (31 - dev) | (where & ~3);
+	non_prefetch_write (addr, NP_CMD_CONFIGWRITE, val);
+
+	return (OK);
+}
+
+void non_prefetch_read (unsigned int addr,
+			unsigned int cmd, unsigned int *data)
+{
+	REG_WRITE (PCI_CSR_BASE, PCI_NP_AD_OFFSET, addr);
+
+	/*set up and execute the read */
+	REG_WRITE (PCI_CSR_BASE, PCI_NP_CBE_OFFSET, cmd);
+
+	/*The result of the read is now in np_rdata */
+	REG_READ (PCI_CSR_BASE, PCI_NP_RDATA_OFFSET, *data);
+
+	return;
+}
+
+void non_prefetch_write (unsigned int addr,
+			 unsigned int cmd, unsigned int data)
+{
+
+	REG_WRITE (PCI_CSR_BASE, PCI_NP_AD_OFFSET, addr);
+	/*set up the write */
+	REG_WRITE (PCI_CSR_BASE, PCI_NP_CBE_OFFSET, cmd);
+	/*Execute the write by writing to NP_WDATA */
+	REG_WRITE (PCI_CSR_BASE, PCI_NP_WDATA_OFFSET, data);
+
+	return;
+}
+
+/*
+ * PCI controller config registers are accessed through these functions
+ * i.e. these allow us to set up our own BARs etc.
+ */
+void crp_read (unsigned int offset, unsigned int *data)
+{
+	REG_WRITE (PCI_CSR_BASE, PCI_CRP_AD_CBE_OFFSET, offset);
+	REG_READ (PCI_CSR_BASE, PCI_CRP_RDATA_OFFSET, *data);
+}
+
+void crp_write (unsigned int offset, unsigned int data)
+{
+	/*The CRP address register bit 16 indicates that we want to do a write */
+	REG_WRITE (PCI_CSR_BASE, PCI_CRP_AD_CBE_OFFSET,
+		   PCI_CRP_WRITE | offset);
+	REG_WRITE (PCI_CSR_BASE, PCI_CRP_WDATA_OFFSET, data);
+}
+
+/*struct pci_controller *hose*/
+void pci_ixp_init (struct pci_controller *hose)
+{
+	unsigned int regval;
+
+	hose->first_busno = 0;
+	hose->last_busno = 0x00;
+
+	/* System memory space */
+	pci_set_region (hose->regions + 0,
+			PCI_MEMORY_BUS,
+			PCI_MEMORY_PHY, PCI_MEMORY_SIZE, PCI_REGION_SYS_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region (hose->regions + 1,
+			PCI_MEM_BUS,
+			PCI_MEM_PHY, PCI_MEM_SIZE, PCI_REGION_MEM);
+	/* PCI I/O space */
+	pci_set_region (hose->regions + 2,
+			PCI_IO_BUS, PCI_IO_PHY, PCI_IO_SIZE, PCI_REGION_IO);
+
+	hose->region_count = 3;
+
+	pci_register_hose (hose);
+
+/*
+ ==========================================================
+		Init IXP PCI
+ ==========================================================
+*/
+	REG_READ (PCI_CSR_BASE, PCI_CSR_OFFSET, regval);
+	regval |= 1 << 2;
+	REG_WRITE (PCI_CSR_BASE, PCI_CSR_OFFSET, regval);
+
+	configure_pins ();
+
+	READ_GPIO_REG (IXP425_GPIO_GPOUTR, regval);
+	WRITE_GPIO_REG (IXP425_GPIO_GPOUTR, regval & (~(1 << 13)));
+	udelay (533);
+	sys_pci_gpio_clock_config ();
+	REG_WRITE (PCI_CSR_BASE, PCI_INTEN_OFFSET, 0);
+	udelay (100);
+	READ_GPIO_REG (IXP425_GPIO_GPOUTR, regval);
+	WRITE_GPIO_REG (IXP425_GPIO_GPOUTR, regval | (1 << 13));
+	udelay (533);
+	crp_write (PCI_CFG_BASE_ADDRESS_0, IXP425_PCI_BAR_0_DEFAULT);
+	crp_write (PCI_CFG_BASE_ADDRESS_1, IXP425_PCI_BAR_1_DEFAULT);
+	crp_write (PCI_CFG_BASE_ADDRESS_2, IXP425_PCI_BAR_2_DEFAULT);
+	crp_write (PCI_CFG_BASE_ADDRESS_3, IXP425_PCI_BAR_3_DEFAULT);
+	crp_write (PCI_CFG_BASE_ADDRESS_4, IXP425_PCI_BAR_4_DEFAULT);
+	crp_write (PCI_CFG_BASE_ADDRESS_5, IXP425_PCI_BAR_5_DEFAULT);
+	/*Setup PCI-AHB and AHB-PCI address mappings */
+	REG_WRITE (PCI_CSR_BASE, PCI_AHBMEMBASE_OFFSET,
+		   IXP425_PCI_AHBMEMBASE_DEFAULT);
+
+	REG_WRITE (PCI_CSR_BASE, PCI_AHBIOBASE_OFFSET,
+		   IXP425_PCI_AHBIOBASE_DEFAULT);
+
+	REG_WRITE (PCI_CSR_BASE, PCI_PCIMEMBASE_OFFSET,
+		   IXP425_PCI_PCIMEMBASE_DEFAULT);
+
+	crp_write (PCI_CFG_SUB_VENDOR_ID, IXP425_PCI_SUB_VENDOR_SYSTEM);
+
+	REG_READ (PCI_CSR_BASE, PCI_CSR_OFFSET, regval);
+	regval |= PCI_CSR_IC | PCI_CSR_ABE | PCI_CSR_PDS;
+	REG_WRITE (PCI_CSR_BASE, PCI_CSR_OFFSET, regval);
+	crp_write (PCI_CFG_COMMAND, PCI_CFG_CMD_MAE | PCI_CFG_CMD_BME);
+	udelay (1000);
+
+	pci_write_config_word (0, PCI_CFG_COMMAND, INITIAL_PCI_CMD);
+	REG_WRITE (PCI_CSR_BASE, PCI_ISR_OFFSET, PCI_ISR_PSE
+		   | PCI_ISR_PFE | PCI_ISR_PPE | PCI_ISR_AHBE);
+#ifdef CONFIG_PCI_SCAN_SHOW
+	printf ("Device  bus  dev  func  deviceID  vendorID \n");
+#endif
+	pci_bus_scan ();
+}
+
+void configure_pins (void)
+{
+	unsigned int regval;
+
+	/* Disable clock on GPIO PIN 14 */
+	READ_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
+	WRITE_GPIO_REG (IXP425_GPIO_GPCLKR, regval & (~(1 << 8)));
+	READ_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
+
+	READ_GPIO_REG (IXP425_GPIO_GPOER, regval);
+	WRITE_GPIO_REG (IXP425_GPIO_GPOER,
+			(((~(3 << 13)) & regval) | (0xf << 8)));
+	READ_GPIO_REG (IXP425_GPIO_GPOER, regval);
+
+	READ_GPIO_REG (IXP425_GPIO_GPIT2R, regval);
+	WRITE_GPIO_REG (IXP425_GPIO_GPIT2R,
+			(regval &
+			 ((0x1 << 9) | (0x1 << 6) | (0x1 << 3) | 0x1)));
+	READ_GPIO_REG (IXP425_GPIO_GPIT2R, regval);
+
+	READ_GPIO_REG (IXP425_GPIO_GPISR, regval);
+	WRITE_GPIO_REG (IXP425_GPIO_GPISR, (regval | (0xf << 8)));
+	READ_GPIO_REG (IXP425_GPIO_GPISR, regval);
+}
+
+void sys_pci_gpio_clock_config (void)
+{
+	unsigned int regval;
+
+	READ_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
+	regval |= 0x1 << 4;
+	WRITE_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
+	READ_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
+	regval |= 0x1 << 8;
+	WRITE_GPIO_REG (IXP425_GPIO_GPCLKR, regval);
+}
+
+void pci_bus_scan (void)
+{
+	unsigned int bus = 0, dev, func = 0;
+	unsigned short data16;
+	unsigned int data32;
+	unsigned char intPin;
+
+	/* Assign first device to ourselves */
+	devices[0].bus = 0;
+	devices[0].device = 0;
+	devices[0].func = 0;
+
+	crp_read (PCI_CFG_VENDOR_ID, &data32);
+
+	devices[0].vendor_id = data32 & IXP425_PCI_BOTTOM_WORD_OF_LONG_MASK;
+	devices[0].device_id = data32 >> 16;
+	devices[0].error = FALSE;
+	devices[0].bar[NO_BAR].size = 0;	/*dummy - required */
+
+	nDevices = 1;
+
+	nMBars = 0;
+	nIOBars = 0;
+
+	for (dev = 0; dev < IXP425_PCI_MAX_DEV; dev++) {
+
+		/*Check whether a device is present */
+		if (pci_device_exists (dev) != TRUE) {
+
+			/*Clear error bits in ISR, write 1 to clear */
+			REG_WRITE (PCI_CSR_BASE, PCI_ISR_OFFSET, PCI_ISR_PSE
+				   | PCI_ISR_PFE | PCI_ISR_PPE |
+				   PCI_ISR_AHBE);
+			continue;
+		}
+
+		/*A device is present, add an entry to the array */
+		devices[nDevices].bus = bus;
+		devices[nDevices].device = dev;
+		devices[nDevices].func = func;
+
+		pci_read_config_word (dev, PCI_CFG_VENDOR_ID, &data16);
+
+		devices[nDevices].vendor_id = data16;
+
+		pci_read_config_word (dev, PCI_CFG_DEVICE_ID, &data16);
+		devices[nDevices].device_id = data16;
+
+		/*The device is functioning correctly, set error to FALSE */
+		devices[nDevices].error = FALSE;
+
+		/*Figure out what BARs are on this device */
+		sys_pci_bar_info_get (nDevices, bus, dev, func);
+		/*Figure out what INTX# line the card uses */
+		pci_read_config_byte (dev, PCI_CFG_DEV_INT_PIN, &intPin);
+
+		/*assign the appropriate irq line */
+		if (intPin > PCI_IRQ_LINES) {
+			devices[nDevices].error = TRUE;
+		} else if (intPin != 0) {
+			/*This device uses an interrupt line */
+			/*devices[nDevices].irq = ixp425PciIntTranslate[dev][intPin-1]; */
+			devices[nDevices].irq = intPin;
+		}
+#ifdef CONFIG_PCI_SCAN_SHOW
+		printf ("%06d    %03d %03d %04d  %08d      %08x\n", nDevices,
+			devices[nDevices].vendor_id);
+#endif
+		nDevices++;
+
+	}
+
+	calc_bars (memBars, nMBars, IXP425_PCI_BAR_MEM_BASE);
+	sys_pci_device_bars_write ();
+
+	REG_WRITE (PCI_CSR_BASE, PCI_ISR_OFFSET, PCI_ISR_PSE
+		   | PCI_ISR_PFE | PCI_ISR_PPE | PCI_ISR_AHBE);
+}
+
+void sys_pci_bar_info_get (unsigned int devnum,
+			   unsigned int bus,
+			   unsigned int dev, unsigned int func)
+{
+	unsigned int data32;
+	unsigned int tmp;
+	unsigned int size;
+
+	pci_write_config_dword (devnum,
+				PCI_CFG_BASE_ADDRESS_0, IXP425_PCI_BAR_QUERY);
+	pci_read_config_dword (devnum, PCI_CFG_BASE_ADDRESS_0, &data32);
+
+	devices[devnum].bar[0].address = (data32 & 1);
+
+	if (data32 & 1) {
+		/* IO space */
+		tmp = data32 & ~0x3;
+		size = ~(tmp - 1);
+		devices[devnum].bar[0].size = size;
+
+		if (nIOBars < IXP425_PCI_MAX_BAR) {
+			ioBars[nIOBars++] = &devices[devnum].bar[0];
+		}
+	} else {
+		/* Mem space */
+		tmp = data32 & ~IXP425_PCI_BOTTOM_NIBBLE_OF_LONG_MASK;
+		size = ~(tmp - 1);
+		devices[devnum].bar[0].size = size;
+
+		if (nMBars < IXP425_PCI_MAX_BAR) {
+			memBars[nMBars++] = &devices[devnum].bar[0];
+		} else {
+			devices[devnum].error = TRUE;
+		}
+
+	}
+
+	devices[devnum].bar[1].size = 0;
+}
+
+void sortBars (PciBar * Bars[], unsigned int nBars)
+{
+	unsigned int i, j;
+	PciBar *tmp;
+
+	if (nBars == 0) {
+		return;
+	}
+
+	/* Sort biggest to smallest */
+	for (i = 0; i < nBars - 1; i++) {
+		for (j = i + 1; j < nBars; j++) {
+			if (Bars[j]->size > Bars[i]->size) {
+				/* swap them */
+				tmp = Bars[i];
+				Bars[i] = Bars[j];
+				Bars[j] = tmp;
+			}
+		}
+	}
+}
+
+void calc_bars (PciBar * Bars[], unsigned int nBars, unsigned int startAddr)
+{
+	unsigned int i;
+
+	if (nBars == 0) {
+		return;
+	}
+
+	for (i = 0; i < nBars; i++) {
+		Bars[i]->address |= startAddr;
+		startAddr += Bars[i]->size;
+	}
+}
+
+void sys_pci_device_bars_write (void)
+{
+	unsigned int i;
+	int addr;
+
+	for (i = 1; i < nDevices; i++) {
+		if (devices[i].error) {
+			continue;
+		}
+
+		pci_write_config_dword (devices[i].device,
+					PCI_CFG_BASE_ADDRESS_0,
+					devices[i].bar[0].address);
+		addr = BIT (31 - devices[i].device) |
+			(0 << PCI_NP_AD_FUNCSL) |
+			(PCI_CFG_BASE_ADDRESS_0 & ~3);
+		pci_write_config_dword (devices[i].device,
+					PCI_CFG_DEV_INT_LINE, devices[i].irq);
+
+		pci_write_config_word (devices[i].device,
+				       PCI_CFG_COMMAND, INITIAL_PCI_CMD);
+
+	}
+}
+
+
+int pci_device_exists (unsigned int deviceNo)
+{
+	unsigned int vendorId;
+	unsigned int regval;
+
+	pci_read_config_dword (deviceNo, PCI_CFG_VENDOR_ID, &vendorId);
+
+	/* There are two ways to find out an empty device.
+	 *   1. check Master Abort bit after the access.
+	 *   2. check whether the vendor id read back is 0x0.
+	 */
+	REG_READ (PCI_CSR_BASE, PCI_ISR_OFFSET, regval);
+	if ((vendorId != 0x0) && ((regval & PCI_ISR_PFE) == 0)) {
+		return TRUE;
+	}
+	/*no device present, make sure that the master abort bit is reset */
+
+	REG_WRITE (PCI_CSR_BASE, PCI_ISR_OFFSET, PCI_ISR_PFE);
+	return FALSE;
+}
+
+pci_dev_t pci_find_devices (struct pci_device_id * ids, int devNo)
+{
+	unsigned int i;
+	unsigned int devdidvid;
+	unsigned int didvid;
+	unsigned int vendorId, deviceId;
+
+	vendorId = ids->vendor;
+	deviceId = ids->device;
+	didvid = ((deviceId << 16) & IXP425_PCI_TOP_WORD_OF_LONG_MASK) |
+		(vendorId & IXP425_PCI_BOTTOM_WORD_OF_LONG_MASK);
+
+	for (i = devNo + 1; i < nDevices; i++) {
+
+		pci_read_config_dword (devices[i].device, PCI_CFG_VENDOR_ID,
+				       &devdidvid);
+
+		if (devdidvid == didvid) {
+			return devices[i].device;
+		}
+	}
+	return -1;
+}
diff -Naur u-boot-2009.01/drivers/pci/tsi108_pci.c u-boot/drivers/pci/tsi108_pci.c
--- u-boot-2009.01/drivers/pci/tsi108_pci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/pci/tsi108_pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -131,7 +131,7 @@
 	pci_set_region (hose->regions + 0,
 		       CONFIG_SYS_PCI_MEMORY_BUS,
 		       CONFIG_SYS_PCI_MEMORY_PHYS,
-		       CONFIG_SYS_PCI_MEMORY_SIZE, PCI_REGION_MEM | PCI_REGION_MEMORY);
+		       CONFIG_SYS_PCI_MEMORY_SIZE, PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 
 	/* PCI memory space */
 	pci_set_region (hose->regions + 1,
diff -Naur u-boot-2009.01/drivers/pcmcia/Makefile u-boot/drivers/pcmcia/Makefile
--- u-boot-2009.01/drivers/pcmcia/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/pcmcia/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -26,7 +26,7 @@
 LIB	:= $(obj)libpcmcia.a
 
 COBJS-$(CONFIG_I82365) += i82365.o
-COBJS-y += mpc8xx_pcmcia.o
+COBJS-$(CONFIG_8xx) += mpc8xx_pcmcia.o
 COBJS-$(CONFIG_PXA_PCMCIA) += pxa_pcmcia.o
 COBJS-y += rpx_pcmcia.o
 COBJS-$(CONFIG_IDE_TI_CARDBUS) += ti_pci1410a.o
diff -Naur u-boot-2009.01/drivers/pcmcia/mpc8xx_pcmcia.c u-boot/drivers/pcmcia/mpc8xx_pcmcia.c
--- u-boot-2009.01/drivers/pcmcia/mpc8xx_pcmcia.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/pcmcia/mpc8xx_pcmcia.c	2009-02-26 14:03:58.000000000 +0100
@@ -1,7 +1,5 @@
 #include <common.h>
-#if defined(CONFIG_8xx)
 #include <mpc8xx.h>
-#endif
 #include <pcmcia.h>
 
 #undef	CONFIG_PCMCIA
@@ -14,7 +12,7 @@
 #define	CONFIG_PCMCIA
 #endif
 
-#if defined(CONFIG_8xx)	&& defined(CONFIG_PCMCIA)
+#if defined(CONFIG_PCMCIA)
 
 #if	defined(CONFIG_IDE_8xx_PCCARD)
 extern int check_ide_device (int slot);
@@ -301,4 +299,4 @@
 }
 #endif	/* 0 */
 
-#endif	/* CONFIG_8xx && CONFIG_PCMCIA */
+#endif	/* CONFIG_PCMCIA */
diff -Naur u-boot-2009.01/drivers/qe/qe.c u-boot/drivers/qe/qe.c
--- u-boot-2009.01/drivers/qe/qe.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/qe/qe.c	2009-02-26 14:03:58.000000000 +0100
@@ -425,7 +425,7 @@
 	ulong addr;
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -455,13 +455,13 @@
 		return qe_upload_firmware((const struct qe_firmware *) addr);
 	}
 
-	printf ("Usage:\n%s\n", cmdtp->usage);
+	cmd_usage(cmdtp);
 	return 1;
 }
 
 U_BOOT_CMD(
 	qe, 4, 0, qe_cmd,
-	"qe      - QUICC Engine commands\n",
+	"QUICC Engine commands",
 	"fw <addr> [<length>] - Upload firmware binary at address <addr> to "
 		"the QE,\n\twith optional length <length> verification.\n"
 	);
diff -Naur u-boot-2009.01/drivers/qe/uec_phy.c u-boot/drivers/qe/uec_phy.c
--- u-boot-2009.01/drivers/qe/uec_phy.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/qe/uec_phy.c	2009-02-26 14:03:58.000000000 +0100
@@ -603,6 +603,55 @@
 	return 0;
 }
 
+static int smsc_config_aneg (struct uec_mii_info *mii_info)
+{
+	return 0;
+}
+
+static int smsc_read_status (struct uec_mii_info *mii_info)
+{
+	u16 status;
+	int err;
+
+	/* Update the link, but return if there
+	 * was an error */
+	err = genmii_update_link (mii_info);
+	if (err)
+		return err;
+
+	/* If the link is up, read the speed and duplex */
+	/* If we aren't autonegotiating, assume speeds
+	 * are as set */
+	if (mii_info->autoneg && mii_info->link) {
+		int	val;
+
+		status = phy_read (mii_info, 0x1f);
+		val = (status & 0x1c) >> 2;
+
+		switch (val) {
+			case 1:
+				mii_info->duplex = DUPLEX_HALF;
+				mii_info->speed = SPEED_10;
+				break;
+			case 5:
+				mii_info->duplex = DUPLEX_FULL;
+				mii_info->speed = SPEED_10;
+				break;
+			case 2:
+				mii_info->duplex = DUPLEX_HALF;
+				mii_info->speed = SPEED_100;
+				break;
+			case 6:
+				mii_info->duplex = DUPLEX_FULL;
+				mii_info->speed = SPEED_100;
+				break;
+		}
+		mii_info->pause = 0;
+	}
+
+	return 0;
+}
+
 static struct phy_info phy_info_dm9161 = {
 	.phy_id = 0x0181b880,
 	.phy_id_mask = 0x0ffffff0,
@@ -655,6 +704,15 @@
 	.read_status = fixed_phy_read_status,
 };
 
+static struct phy_info phy_info_smsclan8700 = {
+	.phy_id = 0x0007c0c0,
+	.phy_id_mask = 0xfffffff0,
+	.name = "SMSC LAN8700",
+	.features = MII_BASIC_FEATURES,
+	.config_aneg = smsc_config_aneg,
+	.read_status = smsc_read_status,
+};
+
 static struct phy_info phy_info_genmii = {
 	.phy_id = 0x00000000,
 	.phy_id_mask = 0x00000000,
@@ -669,6 +727,7 @@
 	&phy_info_dm9161a,
 	&phy_info_marvell,
 	&phy_info_bcm5481,
+	&phy_info_smsclan8700,
 	&phy_info_fixedphy,
 	&phy_info_genmii,
 	NULL
diff -Naur u-boot-2009.01/drivers/serial/arm_dcc.c u-boot/drivers/serial/arm_dcc.c
--- u-boot-2009.01/drivers/serial/arm_dcc.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/serial/arm_dcc.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2004-2007 ARM Limited.
+ * Copyright (C) 2008 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * As a special exception, if other files instantiate templates or use macros
+ * or inline functions from this file, or you compile this file and link it
+ * with other works to produce a work based on this file, this file does not
+ * by itself cause the resulting work to be covered by the GNU General Public
+ * License. However the source code for this file must still be made available
+ * in accordance with section (3) of the GNU General Public License.
+
+ * This exception does not invalidate any other reasons why a work based on
+ * this file might be covered by the GNU General Public License.
+ */
+
+#include <common.h>
+#include <devices.h>
+
+#define DCC_ARM9_RBIT	(1 << 0)
+#define DCC_ARM9_WBIT	(1 << 1)
+#define DCC_ARM11_RBIT	(1 << 30)
+#define DCC_ARM11_WBIT	(1 << 29)
+
+#define read_core_id(x)	do {						\
+		__asm__ ("mrc p15, 0, %0, c0, c0, 0\n" : "=r" (x));	\
+		x = (x >> 4) & 0xFFF;					\
+		} while (0);
+
+/*
+ * ARM9
+ */
+#define write_arm9_dcc(x)	\
+		__asm__ volatile ("mcr p14, 0, %0, c1, c0, 0\n" : : "r" (x))
+
+#define read_arm9_dcc(x)	\
+		__asm__ volatile ("mrc p14, 0, %0, c1, c0, 0\n" : "=r" (x))
+
+#define status_arm9_dcc(x)	\
+		__asm__ volatile ("mrc p14, 0, %0, c0, c0, 0\n" : "=r" (x))
+
+#define can_read_arm9_dcc(x)	do {	\
+		status_arm9_dcc(x);	\
+		x &= DCC_ARM9_RBIT;	\
+		} while (0);
+
+#define can_write_arm9_dcc(x)	do {	\
+		status_arm9_dcc(x);	\
+		x &= DCC_ARM9_WBIT;	\
+		x = (x == 0);		\
+		} while (0);
+
+/*
+ * ARM11
+ */
+#define write_arm11_dcc(x)	\
+		__asm__ volatile ("mcr p14, 0, %0, c0, c5, 0\n" : : "r" (x))
+
+#define read_arm11_dcc(x)	\
+		__asm__ volatile ("mrc p14, 0, %0, c0, c5, 0\n" : "=r" (x))
+
+#define status_arm11_dcc(x)	\
+		__asm__ volatile ("mrc p14, 0, %0, c0, c1, 0\n" : "=r" (x))
+
+#define can_read_arm11_dcc(x)	do {	\
+		status_arm11_dcc(x);	\
+		x &= DCC_ARM11_RBIT;	\
+		} while (0);
+
+#define can_write_arm11_dcc(x)	do {	\
+		status_arm11_dcc(x);	\
+		x &= DCC_ARM11_WBIT;	\
+		x = (x == 0);		\
+		} while (0);
+
+#define TIMEOUT_COUNT 0x4000000
+
+static enum {
+	arm9_and_earlier,
+	arm11_and_later
+} arm_type = arm9_and_earlier;
+
+#ifndef CONFIG_ARM_DCC_MULTI
+#define arm_dcc_init serial_init
+void serial_setbrg(void) {}
+#define arm_dcc_getc serial_getc
+#define arm_dcc_putc serial_putc
+#define arm_dcc_puts serial_puts
+#define arm_dcc_tstc serial_tstc
+#endif
+
+int arm_dcc_init(void)
+{
+	register unsigned int id;
+
+	read_core_id(id);
+
+	if (id >= 0xb00)
+		arm_type = arm11_and_later;
+	else
+		arm_type = arm9_and_earlier;
+
+	return 0;
+}
+
+int arm_dcc_getc(void)
+{
+	int ch;
+	register unsigned int reg;
+
+	switch (arm_type) {
+	case arm11_and_later:
+		do {
+			can_read_arm11_dcc(reg);
+		} while (!reg);
+		read_arm11_dcc(ch);
+		break;
+
+	case arm9_and_earlier:
+	default:
+		do {
+			can_read_arm9_dcc(reg);
+		} while (!reg);
+		read_arm9_dcc(ch);
+		break;
+	}
+
+	return ch;
+}
+
+void arm_dcc_putc(char ch)
+{
+	register unsigned int reg;
+	unsigned int timeout_count = TIMEOUT_COUNT;
+
+	switch (arm_type) {
+	case arm11_and_later:
+		while (--timeout_count) {
+			can_write_arm11_dcc(reg);
+			if (reg)
+				break;
+		}
+		if (timeout_count == 0)
+			return;
+		else
+			write_arm11_dcc(ch);
+		break;
+
+	case arm9_and_earlier:
+	default:
+		while (--timeout_count) {
+			can_write_arm9_dcc(reg);
+			if (reg)
+				break;
+		}
+		if (timeout_count == 0)
+			return;
+		else
+			write_arm9_dcc(ch);
+		break;
+	}
+}
+
+void arm_dcc_puts(const char *s)
+{
+	while (*s)
+		arm_dcc_putc(*s++);
+}
+
+int arm_dcc_tstc(void)
+{
+	register unsigned int reg;
+
+	switch (arm_type) {
+	case arm11_and_later:
+		can_read_arm11_dcc(reg);
+		break;
+	case arm9_and_earlier:
+	default:
+		can_read_arm9_dcc(reg);
+		break;
+	}
+
+	return reg;
+}
+
+#ifdef CONFIG_ARM_DCC_MULTI
+static device_t arm_dcc_dev;
+
+int drv_arm_dcc_init(void)
+{
+	int rc;
+
+	/* Device initialization */
+	memset(&arm_dcc_dev, 0, sizeof(arm_dcc_dev));
+
+	strcpy(arm_dcc_dev.name, "dcc");
+	arm_dcc_dev.ext = 0;	/* No extensions */
+	arm_dcc_dev.flags = DEV_FLAGS_INPUT | DEV_FLAGS_OUTPUT;
+	arm_dcc_dev.tstc = arm_dcc_tstc;	/* 'tstc' function */
+	arm_dcc_dev.getc = arm_dcc_getc;	/* 'getc' function */
+	arm_dcc_dev.putc = arm_dcc_putc;	/* 'putc' function */
+	arm_dcc_dev.puts = arm_dcc_puts;	/* 'puts' function */
+
+	rc = device_register(&arm_dcc_dev);
+
+	if (rc == 0) {
+		arm_dcc_init();
+		return 1;
+	}
+
+	return 0;
+}
+#endif
diff -Naur u-boot-2009.01/drivers/serial/Makefile u-boot/drivers/serial/Makefile
--- u-boot-2009.01/drivers/serial/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/serial/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -25,20 +25,22 @@
 
 LIB	:= $(obj)libserial.a
 
+COBJS-$(CONFIG_ARM_DCC) += arm_dcc.o
 COBJS-$(CONFIG_ATMEL_USART) += atmel_usart.o
 COBJS-$(CONFIG_MCFUART) += mcfuart.o
 COBJS-$(CONFIG_NS9750_UART) += ns9750_serial.o
-COBJS-y += ns16550.o
+COBJS-$(CONFIG_SYS_NS16550) += ns16550.o
 COBJS-$(CONFIG_DRIVER_S3C4510_UART) += s3c4510b_uart.o
 COBJS-$(CONFIG_S3C64XX) += s3c64xx.o
-COBJS-y += serial.o
+COBJS-$(CONFIG_SYS_NS16550_SERIAL) += serial.o
+COBJS-$(CONFIG_IXP_SERIAL) += serial_ixp.o
 COBJS-$(CONFIG_MAX3100_SERIAL) += serial_max3100.o
 COBJS-$(CONFIG_PL010_SERIAL) += serial_pl01x.o
 COBJS-$(CONFIG_PL011_SERIAL) += serial_pl01x.o
 COBJS-$(CONFIG_XILINX_UARTLITE) += serial_xuartlite.o
 COBJS-$(CONFIG_SCIF_CONSOLE) += serial_sh.o
 COBJS-$(CONFIG_USB_TTY) += usbtty.o
-COBJS-$(CONFIG_VCTH_SERIAL) += vcth.o
+COBJS-$(CONFIG_VCT_SERIAL) += vct.o
 
 COBJS	:= $(sort $(COBJS-y))
 SRCS	:= $(COBJS:.o=.c)
diff -Naur u-boot-2009.01/drivers/serial/mcfuart.c u-boot/drivers/serial/mcfuart.c
--- u-boot-2009.01/drivers/serial/mcfuart.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/serial/mcfuart.c	2009-02-26 14:03:58.000000000 +0100
@@ -115,8 +115,9 @@
 	volatile uart_t *uart = (volatile uart_t *)(CONFIG_SYS_UART_BASE);
 	u32 counter;
 
-	counter = ((gd->bus_clk / gd->baudrate)) >> 5;
-	counter++;
+	/* Setting up BaudRate */
+	counter = (u32) ((gd->bus_clk / 32) + (gd->baudrate / 2));
+	counter = counter / gd->baudrate;
 
 	/* write to CTUR: divide counter upper byte */
 	uart->ubg1 = ((counter & 0xff00) >> 8);
diff -Naur u-boot-2009.01/drivers/serial/ns16550.c u-boot/drivers/serial/ns16550.c
--- u-boot-2009.01/drivers/serial/ns16550.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/serial/ns16550.c	2009-02-26 14:03:58.000000000 +0100
@@ -5,9 +5,6 @@
  */
 
 #include <config.h>
-
-#ifdef CONFIG_SYS_NS16550
-
 #include <ns16550.h>
 
 #define LCRVAL LCR_8N1					/* 8 data, 1 stop, no parity */
@@ -36,9 +33,10 @@
 #else
 	com_port->mdr1 = 0;	/* /16 is proper to hit 115200 with 48MHz */
 #endif
-#endif
+#endif /* CONFIG_OMAP */
 }
 
+#ifndef CONFIG_NS16550_MIN_FUNCTIONS
 void NS16550_reinit (NS16550_t com_port, int baud_divisor)
 {
 	com_port->ier = 0x00;
@@ -53,6 +51,7 @@
 	com_port->dlm = (baud_divisor >> 8) & 0xff;
 	com_port->lcr = LCRVAL;
 }
+#endif /* CONFIG_NS16550_MIN_FUNCTIONS */
 
 void NS16550_putc (NS16550_t com_port, char c)
 {
@@ -60,6 +59,7 @@
 	com_port->thr = c;
 }
 
+#ifndef CONFIG_NS16550_MIN_FUNCTIONS
 char NS16550_getc (NS16550_t com_port)
 {
 	while ((com_port->lsr & LSR_DR) == 0) {
@@ -76,4 +76,4 @@
 	return ((com_port->lsr & LSR_DR) != 0);
 }
 
-#endif
+#endif /* CONFIG_NS16550_MIN_FUNCTIONS */
diff -Naur u-boot-2009.01/drivers/serial/serial.c u-boot/drivers/serial/serial.c
--- u-boot-2009.01/drivers/serial/serial.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/serial/serial.c	2009-02-26 14:03:58.000000000 +0100
@@ -23,8 +23,6 @@
 
 #include <common.h>
 
-#ifdef CONFIG_SYS_NS16550_SERIAL
-
 #include <ns16550.h>
 #ifdef CONFIG_NS87308
 #include <ns87308.h>
@@ -328,5 +326,3 @@
 struct serial_device eserial4_device =
 	INIT_ESERIAL_STRUCTURE(4,"eserial3","EUART4");
 #endif /* CONFIG_SERIAL_MULTI */
-
-#endif
diff -Naur u-boot-2009.01/drivers/serial/serial_ixp.c u-boot/drivers/serial/serial_ixp.c
--- u-boot-2009.01/drivers/serial/serial_ixp.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/serial/serial_ixp.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,125 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <common.h>
+#include <asm/arch/ixp425.h>
+
+/*
+ *               14.7456 MHz
+ * Baud Rate = --------------
+ *              16 x Divisor
+ */
+#define SERIAL_CLOCK 921600
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void serial_setbrg (void)
+{
+	unsigned int quot = 0;
+	int uart = CONFIG_SYS_IXP425_CONSOLE;
+
+	if ((gd->baudrate <= SERIAL_CLOCK) && (SERIAL_CLOCK % gd->baudrate == 0))
+		quot = SERIAL_CLOCK / gd->baudrate;
+	else
+		hang ();
+
+	IER(uart) = 0;					/* Disable for now */
+	FCR(uart) = 0;					/* No fifos enabled */
+
+	/* set baud rate */
+	LCR(uart) = LCR_WLS0 | LCR_WLS1 | LCR_DLAB;
+	DLL(uart) = quot & 0xff;
+	DLH(uart) = quot >> 8;
+	LCR(uart) = LCR_WLS0 | LCR_WLS1;
+#ifdef CONFIG_SERIAL_RTS_ACTIVE
+	MCR(uart) = MCR_RTS;				/* set RTS active */
+#else
+	MCR(uart) = 0;					/* set RTS inactive */
+#endif
+	IER(uart) = IER_UUE;
+}
+
+/*
+ * Initialise the serial port with the given baudrate. The settings
+ * are always 8 data bits, no parity, 1 stop bit, no start bits.
+ *
+ */
+int serial_init (void)
+{
+	serial_setbrg ();
+
+	return (0);
+}
+
+
+/*
+ * Output a single byte to the serial port.
+ */
+void serial_putc (const char c)
+{
+	/* wait for room in the tx FIFO on UART */
+	while ((LSR(CONFIG_SYS_IXP425_CONSOLE) & LSR_TEMT) == 0);
+
+	THR(CONFIG_SYS_IXP425_CONSOLE) = c;
+
+	/* If \n, also do \r */
+	if (c == '\n')
+		serial_putc ('\r');
+}
+
+/*
+ * Read a single byte from the serial port. Returns 1 on success, 0
+ * otherwise. When the function is succesfull, the character read is
+ * written into its argument c.
+ */
+int serial_tstc (void)
+{
+	return LSR(CONFIG_SYS_IXP425_CONSOLE) & LSR_DR;
+}
+
+/*
+ * Read a single byte from the serial port. Returns 1 on success, 0
+ * otherwise. When the function is succesfull, the character read is
+ * written into its argument c.
+ */
+int serial_getc (void)
+{
+	while (!(LSR(CONFIG_SYS_IXP425_CONSOLE) & LSR_DR));
+
+	return (char) RBR(CONFIG_SYS_IXP425_CONSOLE) & 0xff;
+}
+
+void
+serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
diff -Naur u-boot-2009.01/drivers/serial/usbtty.c u-boot/drivers/serial/usbtty.c
--- u-boot-2009.01/drivers/serial/usbtty.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/serial/usbtty.c	2009-02-26 14:03:58.000000000 +0100
@@ -150,8 +150,7 @@
 
 	/* Slave Interface */
 	struct usb_interface_descriptor data_class_interface;
-	struct usb_endpoint_descriptor
-		data_endpoints[NUM_ENDPOINTS-1] __attribute__((packed));
+	struct usb_endpoint_descriptor data_endpoints[NUM_ENDPOINTS-1];
 } __attribute__((packed));
 
 static struct acm_config_desc acm_configuration_descriptors[NUM_CONFIGS] = {
@@ -280,10 +279,8 @@
 struct gserial_config_desc {
 
 	struct usb_configuration_descriptor configuration_desc;
-	struct usb_interface_descriptor
-		interface_desc[NUM_GSERIAL_INTERFACES] __attribute__((packed));
-	struct usb_endpoint_descriptor
-		data_endpoints[NUM_ENDPOINTS] __attribute__((packed));
+	struct usb_interface_descriptor	interface_desc[NUM_GSERIAL_INTERFACES];
+	struct usb_endpoint_descriptor data_endpoints[NUM_ENDPOINTS];
 
 } __attribute__((packed));
 
@@ -433,6 +430,9 @@
  */
 void usbtty_putc (const char c)
 {
+	if (!usbtty_configured ())
+		return;
+
 	buf_push (&usbtty_output, &c, 1);
 	/* If \n, also do \r */
 	if (c == '\n')
@@ -486,8 +486,12 @@
 void usbtty_puts (const char *str)
 {
 	int n;
-	int len = strlen (str);
+	int len;
+
+	if (!usbtty_configured ())
+		return;
 
+	len = strlen (str);
 	/* add '\r' for each '\n' */
 	while (len > 0) {
 		n = next_nl_pos (str);
diff -Naur u-boot-2009.01/drivers/serial/vct.c u-boot/drivers/serial/vct.c
--- u-boot-2009.01/drivers/serial/vct.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/serial/vct.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,125 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_VCT_PLATINUMAVC
+#define UART_1_BASE		0xBDC30000
+#else
+#define UART_1_BASE		0xBF89C000
+#endif
+
+#define	UART_RBR_OFF		0x00	/* receiver buffer reg		*/
+#define	UART_THR_OFF		0x00	/* transmit holding  reg	*/
+#define	UART_DLL_OFF		0x00	/* divisor latch low reg	*/
+#define	UART_IER_OFF		0x04	/* interrupt enable reg		*/
+#define	UART_DLH_OFF		0x04	/* receiver buffer reg		*/
+#define	UART_FCR_OFF		0x08	/* fifo control register	*/
+#define	UART_LCR_OFF		0x0c	/* line control register	*/
+#define	UART_MCR_OFF		0x10	/* modem control register	*/
+#define	UART_LSR_OFF		0x14	/* line status register		*/
+#define	UART_MSR_OFF		0x18	/* modem status register	*/
+#define	UART_SCR_OFF		0x1c	/* scratch pad register		*/
+
+#define UART_RCV_DATA_RDY	0x01	/* Data Received		*/
+#define UART_XMT_HOLD_EMPTY	0x20
+#define UART_TRANSMIT_EMPTY	0x40
+
+/* 7 bit on line control reg. enalbing rw to dll and dlh */
+#define UART_LCR_DLAB		0x0080
+
+#define UART___9600_BDR		0x84
+#define UART__19200_BDR		0x42
+#define UART_115200_BDR		0x08
+
+#define UART_DIS_ALL_INTER	0x00	/* disable all interrupts	*/
+
+#define UART_5DATA_BITS		0x0000	/*   5 [bits]  1.5 bits   2	*/
+#define UART_6DATA_BITS		0x0001	/*   6 [bits]  1   bits   2	*/
+#define UART_7DATA_BITS		0x0002	/*   7 [bits]  1   bits   2	*/
+#define UART_8DATA_BITS		0x0003	/*   8 [bits]  1   bits   2	*/
+
+static void vct_uart_set_baud_rate(u32 address, u32 dh, u32 dl)
+{
+	u32 val = __raw_readl(UART_1_BASE + UART_LCR_OFF);
+
+	/* set 7 bit on 1 */
+	val |= UART_LCR_DLAB;
+	__raw_writel(val, UART_1_BASE + UART_LCR_OFF);
+
+	__raw_writel(dl, UART_1_BASE + UART_DLL_OFF);
+	__raw_writel(dh, UART_1_BASE + UART_DLH_OFF);
+
+	/* set 7 bit on 0 */
+	val &= ~UART_LCR_DLAB;
+	__raw_writel(val, UART_1_BASE + UART_LCR_OFF);
+
+	return;
+}
+
+int serial_init(void)
+{
+	__raw_writel(UART_DIS_ALL_INTER, UART_1_BASE + UART_IER_OFF);
+	vct_uart_set_baud_rate(UART_1_BASE, 0, UART_115200_BDR);
+	__raw_writel(UART_8DATA_BITS, UART_1_BASE + UART_LCR_OFF);
+
+	return 0;
+}
+
+void serial_setbrg(void)
+{
+	/*
+	 * Baudrate change not supported currently, fixed to 115200 baud
+	 */
+}
+
+void serial_putc(const char c)
+{
+	if (c == '\n')
+		serial_putc('\r');
+
+	while (!(UART_XMT_HOLD_EMPTY & __raw_readl(UART_1_BASE + UART_LSR_OFF)))
+		;
+
+	__raw_writel(c, UART_1_BASE + UART_THR_OFF);
+}
+
+void serial_puts(const char *s)
+{
+	while (*s)
+		serial_putc(*s++);
+}
+
+int serial_getc(void)
+{
+	while (!(UART_RCV_DATA_RDY & __raw_readl(UART_1_BASE + UART_LSR_OFF)))
+		;
+
+	return __raw_readl(UART_1_BASE + UART_RBR_OFF) & 0xff;
+}
+
+int serial_tstc(void)
+{
+	if (!(UART_RCV_DATA_RDY & __raw_readl(UART_1_BASE + UART_LSR_OFF)))
+		return 0;
+
+	return 1;
+}
diff -Naur u-boot-2009.01/drivers/serial/vcth.c u-boot/drivers/serial/vcth.c
--- u-boot-2009.01/drivers/serial/vcth.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/serial/vcth.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,121 +0,0 @@
-/*
- * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-#include <asm/io.h>
-
-#define UART_1_BASE		0xBF89C000
-
-#define	UART_RBR_OFF		0x00	/* receiver buffer reg		*/
-#define	UART_THR_OFF		0x00	/* transmit holding  reg	*/
-#define	UART_DLL_OFF		0x00	/* divisor latch low reg	*/
-#define	UART_IER_OFF		0x04	/* interrupt enable reg		*/
-#define	UART_DLH_OFF		0x04	/* receiver buffer reg		*/
-#define	UART_FCR_OFF		0x08	/* fifo control register	*/
-#define	UART_LCR_OFF		0x0c	/* line control register	*/
-#define	UART_MCR_OFF		0x10	/* modem control register	*/
-#define	UART_LSR_OFF		0x14	/* line status register		*/
-#define	UART_MSR_OFF		0x18	/* modem status register	*/
-#define	UART_SCR_OFF		0x1c	/* scratch pad register		*/
-
-#define UART_RCV_DATA_RDY	0x01	/* Data Received		*/
-#define UART_XMT_HOLD_EMPTY	0x20
-#define UART_TRANSMIT_EMPTY	0x40
-
-/* 7 bit on line control reg. enalbing rw to dll and dlh */
-#define UART_LCR_DLAB		0x0080
-
-#define UART___9600_BDR		0x84
-#define UART__19200_BDR		0x42
-#define UART_115200_BDR		0x08
-
-#define UART_DIS_ALL_INTER	0x00	/* disable all interrupts	*/
-
-#define UART_5DATA_BITS		0x0000	/*   5 [bits]  1.5 bits   2	*/
-#define UART_6DATA_BITS		0x0001	/*   6 [bits]  1   bits   2	*/
-#define UART_7DATA_BITS		0x0002	/*   7 [bits]  1   bits   2	*/
-#define UART_8DATA_BITS		0x0003	/*   8 [bits]  1   bits   2	*/
-
-static void vcth_uart_set_baud_rate(u32 address, u32 dh, u32 dl)
-{
-	u32 val = __raw_readl(UART_1_BASE + UART_LCR_OFF);
-
-	/* set 7 bit on 1 */
-	val |= UART_LCR_DLAB;
-	__raw_writel(val, UART_1_BASE + UART_LCR_OFF);
-
-	__raw_writel(dl, UART_1_BASE + UART_DLL_OFF);
-	__raw_writel(dh, UART_1_BASE + UART_DLH_OFF);
-
-	/* set 7 bit on 0 */
-	val &= ~UART_LCR_DLAB;
-	__raw_writel(val, UART_1_BASE + UART_LCR_OFF);
-
-	return;
-}
-
-int serial_init(void)
-{
-	__raw_writel(UART_DIS_ALL_INTER, UART_1_BASE + UART_IER_OFF);
-	vcth_uart_set_baud_rate(UART_1_BASE, 0, UART_115200_BDR);
-	__raw_writel(UART_8DATA_BITS, UART_1_BASE + UART_LCR_OFF);
-
-	return 0;
-}
-
-void serial_setbrg(void)
-{
-	/*
-	 * Baudrate change not supported currently, fixed to 115200 baud
-	 */
-}
-
-void serial_putc(const char c)
-{
-	if (c == '\n')
-		serial_putc('\r');
-
-	while (!(UART_XMT_HOLD_EMPTY & __raw_readl(UART_1_BASE + UART_LSR_OFF)))
-		;
-
-	__raw_writel(c, UART_1_BASE + UART_THR_OFF);
-}
-
-void serial_puts(const char *s)
-{
-	while (*s)
-		serial_putc(*s++);
-}
-
-int serial_getc(void)
-{
-	while (!(UART_RCV_DATA_RDY & __raw_readl(UART_1_BASE + UART_LSR_OFF)))
-		;
-
-	return __raw_readl(UART_1_BASE + UART_RBR_OFF) & 0xff;
-}
-
-int serial_tstc(void)
-{
-	if (!(UART_RCV_DATA_RDY & __raw_readl(UART_1_BASE + UART_LSR_OFF)))
-		return 0;
-
-	return 1;
-}
diff -Naur u-boot-2009.01/drivers/spi/bfin_spi.c u-boot/drivers/spi/bfin_spi.c
--- u-boot-2009.01/drivers/spi/bfin_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/spi/bfin_spi.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,343 @@
+/*
+ * Driver for Blackfin On-Chip SPI device
+ *
+ * Copyright (c) 2005-2008 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+/*#define DEBUG*/
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+
+#include <asm/blackfin.h>
+#include <asm/mach-common/bits/spi.h>
+
+struct bfin_spi_slave {
+	struct spi_slave slave;
+	void *mmr_base;
+	u16 ctl, baud, flg;
+};
+
+#define MAKE_SPI_FUNC(mmr, off) \
+static inline void write_##mmr(struct bfin_spi_slave *bss, u16 val) { bfin_write16(bss->mmr_base + off, val); } \
+static inline u16 read_##mmr(struct bfin_spi_slave *bss) { return bfin_read16(bss->mmr_base + off); }
+MAKE_SPI_FUNC(SPI_CTL,  0x00)
+MAKE_SPI_FUNC(SPI_FLG,  0x04)
+MAKE_SPI_FUNC(SPI_STAT, 0x08)
+MAKE_SPI_FUNC(SPI_TDBR, 0x0c)
+MAKE_SPI_FUNC(SPI_RDBR, 0x10)
+MAKE_SPI_FUNC(SPI_BAUD, 0x14)
+
+#define to_bfin_spi_slave(s) container_of(s, struct bfin_spi_slave, slave)
+
+__attribute__((weak))
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return (cs >= 1 && cs <= 7);
+}
+
+__attribute__((weak))
+void spi_cs_activate(struct spi_slave *slave)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+	write_SPI_FLG(bss,
+		(read_SPI_FLG(bss) &
+		~((!bss->flg << 8) << slave->cs)) |
+		(1 << slave->cs));
+	debug("%s: SPI_FLG:%x\n", __func__, read_SPI_FLG(bss));
+}
+
+__attribute__((weak))
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+	write_SPI_FLG(bss, read_SPI_FLG(bss) & ~(1 << slave->cs));
+	debug("%s: SPI_FLG:%x\n", __func__, read_SPI_FLG(bss));
+}
+
+void spi_init()
+{
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct bfin_spi_slave *bss;
+	u32 mmr_base;
+	u32 baud;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	switch (bus) {
+#ifdef SPI_CTL
+# define SPI0_CTL SPI_CTL
+#endif
+		case 0: mmr_base = SPI0_CTL; break;
+#ifdef SPI1_CTL
+		case 1: mmr_base = SPI1_CTL; break;
+#endif
+#ifdef SPI2_CTL
+		case 2: mmr_base = SPI2_CTL; break;
+#endif
+		default: return NULL;
+	}
+
+	baud = get_sclk() / (2 * max_hz);
+	if (baud < 2)
+		baud = 2;
+	else if (baud > (u16)-1)
+		baud = -1;
+
+	bss = malloc(sizeof(*bss));
+	if (!bss)
+		return NULL;
+
+	bss->slave.bus = bus;
+	bss->slave.cs = cs;
+	bss->mmr_base = (void *)mmr_base;
+	bss->ctl = SPE | MSTR | TDBR_CORE;
+	if (mode & SPI_CPHA) bss->ctl |= CPHA;
+	if (mode & SPI_CPOL) bss->ctl |= CPOL;
+	if (mode & SPI_LSB_FIRST) bss->ctl |= LSBF;
+	bss->baud = baud;
+	bss->flg = mode & SPI_CS_HIGH ? 1 : 0;
+
+	debug("%s: bus:%i cs:%i mmr:%x ctl:%x baud:%i flg:%i\n", __func__,
+		bus, cs, mmr_base, bss->ctl, baud, bss->flg);
+
+	return &bss->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+	free(bss);
+}
+
+static void spi_portmux(struct spi_slave *slave)
+{
+#if defined(__ADSPBF51x__)
+#define SET_MUX(port, mux, func) port##_mux = ((port##_mux & ~PORT_x_MUX_##mux##_MASK) | PORT_x_MUX_##mux##_FUNC_##func)
+	u16 f_mux = bfin_read_PORTF_MUX();
+	u16 f_fer = bfin_read_PORTF_FER();
+	u16 g_mux = bfin_read_PORTG_MUX();
+	u16 g_fer = bfin_read_PORTG_FER();
+	u16 h_mux = bfin_read_PORTH_MUX();
+	u16 h_fer = bfin_read_PORTH_FER();
+	switch (slave->bus) {
+	case 0:
+		/* set SCK/MISO/MOSI */
+		SET_MUX(g, 7, 1);
+		g_fer |= PG12 | PG13 | PG14;
+		switch (slave->cs) {
+			case 1: SET_MUX(f, 2, 1); f_fer |= PF7;  break;
+			case 2: /* see G above */ g_fer |= PG15; break;
+			case 3: SET_MUX(h, 1, 3); f_fer |= PH4;  break;
+			case 4: /* no muxing */                  break;
+			case 5: SET_MUX(g, 1, 3); h_fer |= PG3;  break;
+			case 6: /* no muxing */                  break;
+			case 7: /* no muxing */                  break;
+		}
+	case 1:
+		/* set SCK/MISO/MOSI */
+		SET_MUX(h, 0, 2);
+		h_fer |= PH1 | PH2 | PH3;
+		switch (slave->cs) {
+			case 1: SET_MUX(h, 2, 3); h_fer |= PH6;  break;
+			case 2: SET_MUX(f, 0, 3); f_fer |= PF0;  break;
+			case 3: SET_MUX(g, 0, 3); g_fer |= PG0;  break;
+			case 4: SET_MUX(f, 3, 3); f_fer |= PF8;  break;
+			case 5: SET_MUX(g, 6, 3); h_fer |= PG11; break;
+			case 6: /* no muxing */                  break;
+			case 7: /* no muxing */                  break;
+		}
+	}
+	bfin_write_PORTF_MUX(f_mux);
+	bfin_write_PORTF_FER(f_fer);
+	bfin_write_PORTG_MUX(g_mux);
+	bfin_write_PORTG_FER(g_fer);
+	bfin_write_PORTH_MUX(h_mux);
+	bfin_write_PORTH_FER(h_fer);
+#elif defined(__ADSPBF52x__)
+#define SET_MUX(port, mux, func) port##_mux = ((port##_mux & ~PORT_x_MUX_##mux##_MASK) | PORT_x_MUX_##mux##_FUNC_##func)
+	u16 f_mux = bfin_read_PORTF_MUX();
+	u16 f_fer = bfin_read_PORTF_FER();
+	u16 g_mux = bfin_read_PORTG_MUX();
+	u16 g_fer = bfin_read_PORTG_FER();
+	u16 h_mux = bfin_read_PORTH_MUX();
+	u16 h_fer = bfin_read_PORTH_FER();
+	/* set SCK/MISO/MOSI */
+	SET_MUX(g, 0, 3);
+	g_fer |= PG2 | PG3 | PG4;
+	switch (slave->cs) {
+		case 1: /* see G above */ g_fer |= PG1;  break;
+		case 2: SET_MUX(f, 4, 3); f_fer |= PF12; break;
+		case 3: SET_MUX(f, 4, 3); f_fer |= PF13; break;
+		case 4: SET_MUX(h, 1, 1); h_fer |= PH8;  break;
+		case 5: SET_MUX(h, 2, 1); h_fer |= PH9;  break;
+		case 6: SET_MUX(f, 1, 3); f_fer |= PF9;  break;
+		case 7: SET_MUX(f, 2, 3); f_fer |= PF10; break;
+	}
+	bfin_write_PORTF_MUX(f_mux);
+	bfin_write_PORTF_FER(f_fer);
+	bfin_write_PORTG_MUX(g_mux);
+	bfin_write_PORTG_FER(g_fer);
+	bfin_write_PORTH_MUX(h_mux);
+	bfin_write_PORTH_FER(h_fer);
+#elif defined(__ADSPBF534__) || defined(__ADSPBF536__) || defined(__ADSPBF537__)
+	u16 mux = bfin_read_PORT_MUX();
+	u16 f_fer = bfin_read_PORTF_FER();
+	u16 j_fer = bfin_read_PORTJ_FER();
+	/* set SCK/MISO/MOSI */
+	f_fer |= PF11 | PF12 | PF13;
+	switch (slave->cs) {
+		case 1: f_fer |= PF10; break;
+		case 2: mux |= PJSE; j_fer |= PJ11; break;
+		case 3: mux |= PJSE; j_fer |= PJ10; break;
+		case 4: mux |= PFS4E; f_fer |= PF6; break;
+		case 5: mux |= PFS5E; f_fer |= PF5; break;
+		case 6: mux |= PFS6E; f_fer |= PF4; break;
+		case 7: mux |= PJCE_SPI; j_fer |= PJ5; break;
+	}
+	bfin_write_PORT_MUX(mux);
+	bfin_write_PORTF_FER(f_fer);
+	bfin_write_PORTJ_FER(j_fer);
+#elif defined(__ADSPBF54x__)
+#define DO_MUX(port, pin) \
+	mux = ((mux & ~PORT_x_MUX_##pin##_MASK) | PORT_x_MUX_##pin##_FUNC_1); \
+	fer |= P##port##pin;
+	u32 mux;
+	u16 fer;
+	switch (slave->bus) {
+	case 0:
+		mux = bfin_read_PORTE_MUX();
+		fer = bfin_read_PORTE_FER();
+		/* set SCK/MISO/MOSI */
+		DO_MUX(E, 0);
+		DO_MUX(E, 1);
+		DO_MUX(E, 2);
+		switch (slave->cs) {
+			case 1: DO_MUX(E, 4); break;
+			case 2: DO_MUX(E, 5); break;
+			case 3: DO_MUX(E, 6); break;
+		}
+		bfin_write_PORTE_MUX(mux);
+		bfin_write_PORTE_FER(fer);
+		break;
+	case 1:
+		mux = bfin_read_PORTG_MUX();
+		fer = bfin_read_PORTG_FER();
+		/* set SCK/MISO/MOSI */
+		DO_MUX(G, 8);
+		DO_MUX(G, 9);
+		DO_MUX(G, 10);
+		switch (slave->cs) {
+			case 1: DO_MUX(G, 5); break;
+			case 2: DO_MUX(G, 6); break;
+			case 3: DO_MUX(G, 7); break;
+		}
+		bfin_write_PORTG_MUX(mux);
+		bfin_write_PORTG_FER(fer);
+		break;
+	case 2:
+		mux = bfin_read_PORTB_MUX();
+		fer = bfin_read_PORTB_FER();
+		/* set SCK/MISO/MOSI */
+		DO_MUX(B, 12);
+		DO_MUX(B, 13);
+		DO_MUX(B, 14);
+		switch (slave->cs) {
+			case 1: DO_MUX(B, 9);  break;
+			case 2: DO_MUX(B, 10); break;
+			case 3: DO_MUX(B, 11); break;
+		}
+		bfin_write_PORTB_MUX(mux);
+		bfin_write_PORTB_FER(fer);
+		break;
+	}
+#endif
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+
+	debug("%s: bus:%i cs:%i\n", __func__, slave->bus, slave->cs);
+
+	spi_portmux(slave);
+	write_SPI_CTL(bss, bss->ctl);
+	write_SPI_BAUD(bss, bss->baud);
+	SSYNC();
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+	debug("%s: bus:%i cs:%i\n", __func__, slave->bus, slave->cs);
+	write_SPI_CTL(bss, 0);
+	SSYNC();
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+		void *din, unsigned long flags)
+{
+	struct bfin_spi_slave *bss = to_bfin_spi_slave(slave);
+	const u8 *tx = dout;
+	u8 *rx = din;
+	uint bytes = bitlen / 8;
+	int ret = 0;
+
+	debug("%s: bus:%i cs:%i bitlen:%i bytes:%i flags:%lx\n", __func__,
+		slave->bus, slave->cs, bitlen, bytes, flags);
+
+	if (bitlen == 0)
+		goto done;
+
+	/* we can only do 8 bit transfers */
+	if (bitlen % 8) {
+		flags |= SPI_XFER_END;
+		goto done;
+	}
+
+	if (flags & SPI_XFER_BEGIN)
+		spi_cs_activate(slave);
+
+	/* todo: take advantage of hardware fifos and setup RX dma */
+	while (bytes--) {
+		u8 value = (tx ? *tx++ : 0);
+		debug("%s: tx:%x ", __func__, value);
+		write_SPI_TDBR(bss, value);
+		SSYNC();
+		while ((read_SPI_STAT(bss) & TXS))
+			if (ctrlc()) {
+				ret = -1;
+				goto done;
+			}
+		while (!(read_SPI_STAT(bss) & SPIF))
+			if (ctrlc()) {
+				ret = -1;
+				goto done;
+			}
+		while (!(read_SPI_STAT(bss) & RXS))
+			if (ctrlc()) {
+				ret = -1;
+				goto done;
+			}
+		value = read_SPI_RDBR(bss);
+		if (rx)
+			*rx++ = value;
+		debug("rx:%x\n", value);
+	}
+
+ done:
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	return ret;
+}
diff -Naur u-boot-2009.01/drivers/spi/Makefile u-boot/drivers/spi/Makefile
--- u-boot-2009.01/drivers/spi/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/spi/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -26,6 +26,7 @@
 LIB	:= $(obj)libspi.a
 
 COBJS-$(CONFIG_ATMEL_SPI) += atmel_spi.o
+COBJS-$(CONFIG_BFIN_SPI) += bfin_spi.o
 COBJS-$(CONFIG_MPC8XXX_SPI) += mpc8xxx_spi.o
 COBJS-$(CONFIG_MXC_SPI) += mxc_spi.o
 COBJS-$(CONFIG_SOFT_SPI) += soft_spi.o
diff -Naur u-boot-2009.01/drivers/usb/davinci_usb.c u-boot/drivers/usb/davinci_usb.c
--- u-boot-2009.01/drivers/usb/davinci_usb.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/davinci_usb.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,106 @@
+/*
+ * TI's Davinci platform specific USB wrapper functions.
+ *
+ * Copyright (c) 2008 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Author: Thomas Abraham t-abraham@ti.com, Texas Instruments
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include "davinci_usb.h"
+
+/* MUSB platform configuration */
+struct musb_config musb_cfg = {
+	(struct	musb_regs *)MENTOR_USB0_BASE,
+	DAVINCI_USB_TIMEOUT,
+	0
+};
+
+/* MUSB module register overlay */
+struct davinci_usb_regs *dregs;
+
+/*
+ * Enable the USB phy
+ */
+static u8 phy_on(void)
+{
+	u32 timeout;
+
+	/* Wait until the USB phy is turned on */
+	writel(USBPHY_SESNDEN | USBPHY_VBDTCTEN, USBPHY_CTL_PADDR);
+	timeout = musb_cfg.timeout;
+	while (timeout--)
+		if (readl(USBPHY_CTL_PADDR) & USBPHY_PHYCLKGD)
+			return 1;
+
+	/* USB phy was not turned on */
+	return 0;
+}
+
+/*
+ * Disable the USB phy
+ */
+static void phy_off(void)
+{
+	/* powerdown the on-chip PHY and its oscillator */
+	writel(USBPHY_OSCPDWN | USBPHY_PHYPDWN, USBPHY_CTL_PADDR);
+}
+
+/*
+ * This function performs Davinci platform specific initialization for usb0.
+ */
+int musb_platform_init(void)
+{
+	u32  revision;
+
+	/* enable USB VBUS */
+	enable_vbus();
+
+	/* start the on-chip USB phy and its pll */
+	if (!phy_on())
+		return -1;
+
+	/* reset the controller */
+	dregs = (struct davinci_usb_regs *)DAVINCI_USB0_BASE;
+	writel(1, &dregs->ctrlr);
+	udelay(5000);
+
+	/* Returns zero if e.g. not clocked */
+	revision = readl(&dregs->version);
+	if (!revision)
+		return -1;
+
+	/* Disable all interrupts */
+	writel(DAVINCI_USB_USBINT_MASK | DAVINCI_USB_RXINT_MASK |
+			DAVINCI_USB_TXINT_MASK , &dregs->intmsksetr);
+	return 0;
+}
+
+/*
+ * This function performs Davinci platform specific deinitialization for usb0.
+ */
+void musb_platform_deinit(void)
+{
+	/* Turn of the phy */
+	phy_off();
+
+	/* flush any interrupts */
+	writel(DAVINCI_USB_USBINT_MASK | DAVINCI_USB_TXINT_MASK |
+			DAVINCI_USB_RXINT_MASK , &dregs->intclrr);
+}
diff -Naur u-boot-2009.01/drivers/usb/davinci_usb.h u-boot/drivers/usb/davinci_usb.h
--- u-boot-2009.01/drivers/usb/davinci_usb.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/davinci_usb.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,86 @@
+/*
+ * TI's Davinci platform specific USB wrapper functions.
+ *
+ * Copyright (c) 2008 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Author: Thomas Abraham t-abraham@ti.com, Texas Instruments
+ */
+
+#ifndef __DAVINCI_USB_H__
+#define __DAVINCI_USB_H__
+
+#include <asm/arch/hardware.h>
+#include "musb_core.h"
+
+/* Base address of DAVINCI usb0 wrapper */
+#define DAVINCI_USB0_BASE 0x01C64000
+
+/* Base address of DAVINCI musb core */
+#define MENTOR_USB0_BASE (DAVINCI_USB0_BASE+0x400)
+
+/*
+ * Davinci platform USB wrapper register overlay. Note: Only the required
+ * registers are included in this structure. It can be expanded as required.
+ */
+struct davinci_usb_regs {
+	u32	version;
+	u32	ctrlr;
+	u32	reserved[0x20];
+	u32	intclrr;
+	u32 	intmskr;
+	u32 	intmsksetr;
+};
+
+#define DAVINCI_USB_TX_ENDPTS_MASK	0x1f /* ep0 + 4 tx */
+#define DAVINCI_USB_RX_ENDPTS_MASK	0x1e /* 4 rx */
+#define DAVINCI_USB_USBINT_SHIFT	16
+#define DAVINCI_USB_TXINT_SHIFT 	0
+#define DAVINCI_USB_RXINT_SHIFT 	8
+#define DAVINCI_INTR_DRVVBUS		0x0100
+
+#define DAVINCI_USB_USBINT_MASK 	0x01ff0000	/* 8 Mentor, DRVVBUS */
+#define DAVINCI_USB_TXINT_MASK \
+		(DAVINCI_USB_TX_ENDPTS_MASK << DAVINCI_USB_TXINT_SHIFT)
+#define DAVINCI_USB_RXINT_MASK \
+		(DAVINCI_USB_RX_ENDPTS_MASK << DAVINCI_USB_RXINT_SHIFT)
+#define MGC_BUSCTL_OFFSET(_bEnd, _bOffset) \
+		(0x80 + (8*(_bEnd)) + (_bOffset))
+
+/* Integrated highspeed/otg PHY */
+#define USBPHY_CTL_PADDR	(DAVINCI_SYSTEM_MODULE_BASE + 0x34)
+#define USBPHY_PHYCLKGD 	(1 << 8)
+#define USBPHY_SESNDEN		(1 << 7)	/* v(sess_end) comparator */
+#define USBPHY_VBDTCTEN 	(1 << 6)	/* v(bus) comparator */
+#define USBPHY_PHYPLLON 	(1 << 4)	/* override pll suspend */
+#define USBPHY_CLKO1SEL 	(1 << 3)
+#define USBPHY_OSCPDWN		(1 << 2)
+#define USBPHY_PHYPDWN		(1 << 0)
+
+/* Timeout for Davinci USB module */
+#define DAVINCI_USB_TIMEOUT 0x3FFFFFF
+
+/* IO Expander I2C address and VBUS enable mask */
+#define IOEXP_I2C_ADDR 0x3A
+#define IOEXP_VBUSEN_MASK 1
+
+/* extern functions */
+extern void lpsc_on(unsigned int id);
+extern int i2c_write(uchar chip, uint addr, int alen, uchar *buffer, int len);
+extern int i2c_read(uchar chip, uint addr, int alen, uchar *buffer, int len);
+extern void enable_vbus(void);
+#endif	/* __DAVINCI_USB_H__ */
diff -Naur u-boot-2009.01/drivers/usb/Makefile u-boot/drivers/usb/Makefile
--- u-boot-2009.01/drivers/usb/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/usb/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -28,11 +28,18 @@
 # core
 COBJS-y += usbdcore.o
 COBJS-$(CONFIG_USB_OHCI_NEW) += usb_ohci.o
+COBJS-$(CONFIG_USB_EHCI) += usb_ehci_core.o
 
 # host
 COBJS-$(CONFIG_USB_ISP116X_HCD) += isp116x-hcd.o
 COBJS-$(CONFIG_USB_R8A66597_HCD) += r8a66597-hcd.o
 COBJS-$(CONFIG_USB_SL811HS) += sl811_usb.o
+COBJS-$(CONFIG_USB_EHCI_FSL) += usb_ehci_fsl.o
+COBJS-$(CONFIG_USB_EHCI_PCI) += usb_ehci_pci.o
+COBJS-$(CONFIG_USB_EHCI_IXP4XX) += usb_ehci_ixp.o
+COBJS-$(CONFIG_MUSB_HCD) += musb_hcd.o musb_core.o
+COBJS-$(CONFIG_USB_DAVINCI) += davinci_usb.o
+COBJS-$(CONFIG_USB_EHCI_VCT) += usb_ehci_vct.o
 
 # device
 ifdef CONFIG_USB_DEVICE
diff -Naur u-boot-2009.01/drivers/usb/musb_core.c u-boot/drivers/usb/musb_core.c
--- u-boot-2009.01/drivers/usb/musb_core.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/musb_core.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,141 @@
+/*
+ * Mentor USB OTG Core functionality common for both Host and Device
+ * functionality.
+ *
+ * Copyright (c) 2008 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Author: Thomas Abraham t-abraham@ti.com, Texas Instruments
+ */
+
+#include <common.h>
+
+#include "musb_core.h"
+struct musb_regs *musbr;
+
+/*
+ * program the mentor core to start (enable interrupts, dma, etc.)
+ */
+void musb_start(void)
+{
+	u8 devctl;
+
+	/* disable all interrupts */
+	writew(0, &musbr->intrtxe);
+	writew(0, &musbr->intrrxe);
+	writeb(0, &musbr->intrusbe);
+	writeb(0, &musbr->testmode);
+
+	/* put into basic highspeed mode and start session */
+	writeb(MUSB_POWER_HSENAB, &musbr->power);
+#if defined(CONFIG_MUSB_HCD)
+	devctl = readb(&musbr->devctl);
+	writeb(devctl | MUSB_DEVCTL_SESSION, &musbr->devctl);
+#endif
+}
+
+/*
+ * This function configures the endpoint configuration. The musb hcd or musb
+ * device implementation can use this function to configure the endpoints
+ * and set the FIFO sizes. Note: The summation of FIFO sizes of all endpoints
+ * should not be more than the available FIFO size.
+ *
+ * epinfo	- Pointer to EP configuration table
+ * cnt		- Number of entries in the EP conf table.
+ */
+void musb_configure_ep(struct musb_epinfo *epinfo, u8 cnt)
+{
+	u16 csr;
+	u16 fifoaddr = 64; /* First 64 bytes of FIFO reserved for EP0 */
+	u32 fifosize;
+	u8  idx;
+
+	while (cnt--) {
+		/* prepare fifosize to write to register */
+		fifosize = epinfo->epsize >> 3;
+		idx = ffs(fifosize) - 1;
+
+		writeb(epinfo->epnum, &musbr->index);
+		if (epinfo->epdir) {
+			/* Configure fifo size and fifo base address */
+			writeb(idx, &musbr->txfifosz);
+			writew(fifoaddr >> 3, &musbr->txfifoadd);
+#if defined(CONFIG_MUSB_HCD)
+			/* clear the data toggle bit */
+			csr = readw(&musbr->txcsr);
+			writew(csr | MUSB_TXCSR_CLRDATATOG, &musbr->txcsr);
+#endif
+			/* Flush fifo if required */
+			if (csr & MUSB_TXCSR_TXPKTRDY)
+				writew(csr | MUSB_TXCSR_FLUSHFIFO,
+					&musbr->txcsr);
+		} else {
+			/* Configure fifo size and fifo base address */
+			writeb(idx, &musbr->rxfifosz);
+			writew(fifoaddr >> 3, &musbr->rxfifoadd);
+#if defined(CONFIG_MUSB_HCD)
+			/* clear the data toggle bit */
+			csr = readw(&musbr->rxcsr);
+			writew(csr | MUSB_RXCSR_CLRDATATOG, &musbr->rxcsr);
+#endif
+			/* Flush fifo if required */
+			if (csr & MUSB_RXCSR_RXPKTRDY)
+				writew(csr | MUSB_RXCSR_FLUSHFIFO,
+					&musbr->rxcsr);
+		}
+		fifoaddr += epinfo->epsize;
+		epinfo++;
+	}
+}
+
+/*
+ * This function writes data to endpoint fifo
+ *
+ * ep		- endpoint number
+ * length	- number of bytes to write to FIFO
+ * fifo_data	- Pointer to data buffer that contains the data to write
+ */
+void write_fifo(u8 ep, u32 length, void *fifo_data)
+{
+	u8  *data = (u8 *)fifo_data;
+
+	/* select the endpoint index */
+	writeb(ep, &musbr->index);
+
+	/* write the data to the fifo */
+	while (length--)
+		writeb(*data++, &musbr->fifox[ep]);
+}
+
+/*
+ * This function reads data from endpoint fifo
+ *
+ * ep           - endpoint number
+ * length       - number of bytes to read from FIFO
+ * fifo_data    - pointer to data buffer into which data is read
+ */
+void read_fifo(u8 ep, u32 length, void *fifo_data)
+{
+	u8  *data = (u8 *)fifo_data;
+
+	/* select the endpoint index */
+	writeb(ep, &musbr->index);
+
+	/* read the data to the fifo */
+	while (length--)
+		*data++ = readb(&musbr->fifox[ep]);
+}
diff -Naur u-boot-2009.01/drivers/usb/musb_core.h u-boot/drivers/usb/musb_core.h
--- u-boot-2009.01/drivers/usb/musb_core.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/musb_core.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,316 @@
+/******************************************************************
+ * Copyright 2008 Mentor Graphics Corporation
+ * Copyright (C) 2008 by Texas Instruments
+ *
+ * This file is part of the Inventra Controller Driver for Linux.
+ *
+ * The Inventra Controller Driver for Linux is free software; you
+ * can redistribute it and/or modify it under the terms of the GNU
+ * General Public License version 2 as published by the Free Software
+ * Foundation.
+ *
+ * The Inventra Controller Driver for Linux is distributed in
+ * the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ * without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with The Inventra Controller Driver for Linux ; if not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place,
+ * Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
+ * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
+ * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
+ * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
+ * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
+ * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
+ * GRAPHICS SUPPORT CUSTOMER.
+ ******************************************************************/
+
+#ifndef __MUSB_HDRC_DEFS_H__
+#define __MUSB_HDRC_DEFS_H__
+
+#include <usb.h>
+#include <usb_defs.h>
+#include <asm/io.h>
+
+#define MUSB_EP0_FIFOSIZE	64	/* This is non-configurable */
+
+/* Mentor USB core register overlay structure */
+struct musb_regs {
+	/* common registers */
+	u8	faddr;
+	u8	power;
+	u16	intrtx;
+	u16	intrrx;
+	u16	intrtxe;
+	u16	intrrxe;
+	u8	intrusb;
+	u8	intrusbe;
+	u16	frame;
+	u8	index;
+	u8	testmode;
+	/* indexed registers */
+	u16	txmaxp;
+	u16	txcsr;
+	u16	rxmaxp;
+	u16	rxcsr;
+	u16	rxcount;
+	u8	txtype;
+	u8	txinterval;
+	u8	rxtype;
+	u8	rxinterval;
+	u8	reserved0;
+	u8	fifosize;
+	/* fifo */
+	u32	fifox[16];
+	/* OTG, dynamic FIFO, version & vendor registers */
+	u8	devctl;
+	u8	reserved1;
+	u8	txfifosz;
+	u8	rxfifosz;
+	u16	txfifoadd;
+	u16	rxfifoadd;
+	u32	vcontrol;
+	u16	hwvers;
+	u16	reserved2[5];
+	u8	epinfo;
+	u8	raminfo;
+	u8	linkinfo;
+	u8	vplen;
+	u8	hseof1;
+	u8	fseof1;
+	u8	lseof1;
+	u8	reserved3;
+	/* target address registers */
+	struct musb_tar_regs {
+		u8	txfuncaddr;
+		u8	reserved0;
+		u8	txhubaddr;
+		u8	txhubport;
+		u8	rxfuncaddr;
+		u8	reserved1;
+		u8	rxhubaddr;
+		u8	rxhubport;
+	} tar[16];
+} __attribute((aligned(32)));
+
+/*
+ * MUSB Register bits
+ */
+
+/* POWER */
+#define MUSB_POWER_ISOUPDATE	0x80
+#define MUSB_POWER_SOFTCONN	0x40
+#define MUSB_POWER_HSENAB	0x20
+#define MUSB_POWER_HSMODE	0x10
+#define MUSB_POWER_RESET	0x08
+#define MUSB_POWER_RESUME	0x04
+#define MUSB_POWER_SUSPENDM	0x02
+#define MUSB_POWER_ENSUSPEND	0x01
+#define MUSB_POWER_HSMODE_SHIFT	4
+
+/* INTRUSB */
+#define MUSB_INTR_SUSPEND	0x01
+#define MUSB_INTR_RESUME	0x02
+#define MUSB_INTR_RESET		0x04
+#define MUSB_INTR_BABBLE	0x04
+#define MUSB_INTR_SOF		0x08
+#define MUSB_INTR_CONNECT	0x10
+#define MUSB_INTR_DISCONNECT	0x20
+#define MUSB_INTR_SESSREQ	0x40
+#define MUSB_INTR_VBUSERROR	0x80	/* For SESSION end */
+
+/* DEVCTL */
+#define MUSB_DEVCTL_BDEVICE	0x80
+#define MUSB_DEVCTL_FSDEV	0x40
+#define MUSB_DEVCTL_LSDEV	0x20
+#define MUSB_DEVCTL_VBUS	0x18
+#define MUSB_DEVCTL_VBUS_SHIFT	3
+#define MUSB_DEVCTL_HM		0x04
+#define MUSB_DEVCTL_HR		0x02
+#define MUSB_DEVCTL_SESSION	0x01
+
+/* TESTMODE */
+#define MUSB_TEST_FORCE_HOST	0x80
+#define MUSB_TEST_FIFO_ACCESS	0x40
+#define MUSB_TEST_FORCE_FS	0x20
+#define MUSB_TEST_FORCE_HS	0x10
+#define MUSB_TEST_PACKET	0x08
+#define MUSB_TEST_K		0x04
+#define MUSB_TEST_J		0x02
+#define MUSB_TEST_SE0_NAK	0x01
+
+/* Allocate for double-packet buffering (effectively doubles assigned _SIZE) */
+#define MUSB_FIFOSZ_DPB		0x10
+/* Allocation size (8, 16, 32, ... 4096) */
+#define MUSB_FIFOSZ_SIZE	0x0f
+
+/* CSR0 */
+#define MUSB_CSR0_FLUSHFIFO	0x0100
+#define MUSB_CSR0_TXPKTRDY	0x0002
+#define MUSB_CSR0_RXPKTRDY	0x0001
+
+/* CSR0 in Peripheral mode */
+#define MUSB_CSR0_P_SVDSETUPEND	0x0080
+#define MUSB_CSR0_P_SVDRXPKTRDY	0x0040
+#define MUSB_CSR0_P_SENDSTALL	0x0020
+#define MUSB_CSR0_P_SETUPEND	0x0010
+#define MUSB_CSR0_P_DATAEND	0x0008
+#define MUSB_CSR0_P_SENTSTALL	0x0004
+
+/* CSR0 in Host mode */
+#define MUSB_CSR0_H_DIS_PING		0x0800
+#define MUSB_CSR0_H_WR_DATATOGGLE	0x0400	/* Set to allow setting: */
+#define MUSB_CSR0_H_DATATOGGLE		0x0200	/* Data toggle control */
+#define MUSB_CSR0_H_NAKTIMEOUT		0x0080
+#define MUSB_CSR0_H_STATUSPKT		0x0040
+#define MUSB_CSR0_H_REQPKT		0x0020
+#define MUSB_CSR0_H_ERROR		0x0010
+#define MUSB_CSR0_H_SETUPPKT		0x0008
+#define MUSB_CSR0_H_RXSTALL		0x0004
+
+/* CSR0 bits to avoid zeroing (write zero clears, write 1 ignored) */
+#define MUSB_CSR0_P_WZC_BITS	\
+	(MUSB_CSR0_P_SENTSTALL)
+#define MUSB_CSR0_H_WZC_BITS	\
+	(MUSB_CSR0_H_NAKTIMEOUT | MUSB_CSR0_H_RXSTALL \
+	| MUSB_CSR0_RXPKTRDY)
+
+/* TxType/RxType */
+#define MUSB_TYPE_SPEED		0xc0
+#define MUSB_TYPE_SPEED_SHIFT	6
+#define MUSB_TYPE_SPEED_HIGH 	1
+#define MUSB_TYPE_SPEED_FULL 	2
+#define MUSB_TYPE_SPEED_LOW	3
+#define MUSB_TYPE_PROTO		0x30	/* Implicitly zero for ep0 */
+#define MUSB_TYPE_PROTO_SHIFT	4
+#define MUSB_TYPE_REMOTE_END	0xf	/* Implicitly zero for ep0 */
+#define MUSB_TYPE_PROTO_BULK 	2
+#define MUSB_TYPE_PROTO_INTR 	3
+
+/* CONFIGDATA */
+#define MUSB_CONFIGDATA_MPRXE		0x80	/* Auto bulk pkt combining */
+#define MUSB_CONFIGDATA_MPTXE		0x40	/* Auto bulk pkt splitting */
+#define MUSB_CONFIGDATA_BIGENDIAN	0x20
+#define MUSB_CONFIGDATA_HBRXE		0x10	/* HB-ISO for RX */
+#define MUSB_CONFIGDATA_HBTXE		0x08	/* HB-ISO for TX */
+#define MUSB_CONFIGDATA_DYNFIFO		0x04	/* Dynamic FIFO sizing */
+#define MUSB_CONFIGDATA_SOFTCONE	0x02	/* SoftConnect */
+#define MUSB_CONFIGDATA_UTMIDW		0x01	/* Data width 0/1 => 8/16bits */
+
+/* TXCSR in Peripheral and Host mode */
+#define MUSB_TXCSR_AUTOSET		0x8000
+#define MUSB_TXCSR_MODE			0x2000
+#define MUSB_TXCSR_DMAENAB		0x1000
+#define MUSB_TXCSR_FRCDATATOG		0x0800
+#define MUSB_TXCSR_DMAMODE		0x0400
+#define MUSB_TXCSR_CLRDATATOG		0x0040
+#define MUSB_TXCSR_FLUSHFIFO		0x0008
+#define MUSB_TXCSR_FIFONOTEMPTY		0x0002
+#define MUSB_TXCSR_TXPKTRDY		0x0001
+
+/* TXCSR in Peripheral mode */
+#define MUSB_TXCSR_P_ISO		0x4000
+#define MUSB_TXCSR_P_INCOMPTX		0x0080
+#define MUSB_TXCSR_P_SENTSTALL		0x0020
+#define MUSB_TXCSR_P_SENDSTALL		0x0010
+#define MUSB_TXCSR_P_UNDERRUN		0x0004
+
+/* TXCSR in Host mode */
+#define MUSB_TXCSR_H_WR_DATATOGGLE	0x0200
+#define MUSB_TXCSR_H_DATATOGGLE		0x0100
+#define MUSB_TXCSR_H_NAKTIMEOUT		0x0080
+#define MUSB_TXCSR_H_RXSTALL		0x0020
+#define MUSB_TXCSR_H_ERROR		0x0004
+#define MUSB_TXCSR_H_DATATOGGLE_SHIFT	8
+
+/* TXCSR bits to avoid zeroing (write zero clears, write 1 ignored) */
+#define MUSB_TXCSR_P_WZC_BITS	\
+	(MUSB_TXCSR_P_INCOMPTX | MUSB_TXCSR_P_SENTSTALL \
+	| MUSB_TXCSR_P_UNDERRUN | MUSB_TXCSR_FIFONOTEMPTY)
+#define MUSB_TXCSR_H_WZC_BITS	\
+	(MUSB_TXCSR_H_NAKTIMEOUT | MUSB_TXCSR_H_RXSTALL \
+	| MUSB_TXCSR_H_ERROR | MUSB_TXCSR_FIFONOTEMPTY)
+
+/* RXCSR in Peripheral and Host mode */
+#define MUSB_RXCSR_AUTOCLEAR		0x8000
+#define MUSB_RXCSR_DMAENAB		0x2000
+#define MUSB_RXCSR_DISNYET		0x1000
+#define MUSB_RXCSR_PID_ERR		0x1000
+#define MUSB_RXCSR_DMAMODE		0x0800
+#define MUSB_RXCSR_INCOMPRX		0x0100
+#define MUSB_RXCSR_CLRDATATOG		0x0080
+#define MUSB_RXCSR_FLUSHFIFO		0x0010
+#define MUSB_RXCSR_DATAERROR		0x0008
+#define MUSB_RXCSR_FIFOFULL		0x0002
+#define MUSB_RXCSR_RXPKTRDY		0x0001
+
+/* RXCSR in Peripheral mode */
+#define MUSB_RXCSR_P_ISO		0x4000
+#define MUSB_RXCSR_P_SENTSTALL		0x0040
+#define MUSB_RXCSR_P_SENDSTALL		0x0020
+#define MUSB_RXCSR_P_OVERRUN		0x0004
+
+/* RXCSR in Host mode */
+#define MUSB_RXCSR_H_AUTOREQ		0x4000
+#define MUSB_RXCSR_H_WR_DATATOGGLE	0x0400
+#define MUSB_RXCSR_H_DATATOGGLE		0x0200
+#define MUSB_RXCSR_H_RXSTALL		0x0040
+#define MUSB_RXCSR_H_REQPKT		0x0020
+#define MUSB_RXCSR_H_ERROR		0x0004
+#define MUSB_S_RXCSR_H_DATATOGGLE	9
+
+/* RXCSR bits to avoid zeroing (write zero clears, write 1 ignored) */
+#define MUSB_RXCSR_P_WZC_BITS	\
+	(MUSB_RXCSR_P_SENTSTALL | MUSB_RXCSR_P_OVERRUN \
+	| MUSB_RXCSR_RXPKTRDY)
+#define MUSB_RXCSR_H_WZC_BITS	\
+	(MUSB_RXCSR_H_RXSTALL | MUSB_RXCSR_H_ERROR \
+	| MUSB_RXCSR_DATAERROR | MUSB_RXCSR_RXPKTRDY)
+
+/* HUBADDR */
+#define MUSB_HUBADDR_MULTI_TT		0x80
+
+/* Endpoint configuration information. Note: The value of endpoint fifo size
+ * element should be either 8,16,32,64,128,256,512,1024,2048 or 4096. Other
+ * values are not supported
+ */
+struct musb_epinfo {
+	u8	epnum;	/* endpoint number 	*/
+	u8	epdir;	/* endpoint direction	*/
+	u16	epsize;	/* endpoint FIFO size	*/
+};
+
+/*
+ * Platform specific MUSB configuration. Any platform using the musb
+ * functionality should create one instance of this structure in the
+ * platform specific file.
+ */
+struct musb_config {
+	struct	musb_regs	*regs;
+	u32			timeout;
+	u8			musb_speed;
+};
+
+/* externally defined data */
+extern struct musb_config	musb_cfg;
+extern struct musb_regs		*musbr;
+
+/* exported functions */
+extern void musb_start(void);
+extern void musb_configure_ep(struct musb_epinfo *epinfo, u8 cnt);
+extern void write_fifo(u8 ep, u32 length, void *fifo_data);
+extern void read_fifo(u8 ep, u32 length, void *fifo_data);
+
+/* extern functions */
+extern inline void musb_writew(u32 offset, u16 value);
+extern inline void musb_writeb(u32 offset, u8 value);
+extern inline u16 musb_readw(u32 offset);
+extern inline u8 musb_readb(u32 offset);
+
+#endif	/* __MUSB_HDRC_DEFS_H__ */
diff -Naur u-boot-2009.01/drivers/usb/musb_hcd.c u-boot/drivers/usb/musb_hcd.c
--- u-boot-2009.01/drivers/usb/musb_hcd.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/musb_hcd.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,792 @@
+/*
+ * Mentor USB OTG Core host controller driver.
+ *
+ * Copyright (c) 2008 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Author: Thomas Abraham t-abraham@ti.com, Texas Instruments
+ */
+
+#include <common.h>
+#include "musb_hcd.h"
+
+/* MSC control transfers */
+#define USB_MSC_BBB_RESET 	0xFF
+#define USB_MSC_BBB_GET_MAX_LUN	0xFE
+
+/* Endpoint configuration information */
+static struct musb_epinfo epinfo[3] = {
+	{MUSB_BULK_EP, 1, 512}, /* EP1 - Bluk Out - 512 Bytes */
+	{MUSB_BULK_EP, 0, 512}, /* EP1 - Bluk In  - 512 Bytes */
+	{MUSB_INTR_EP, 0, 64}   /* EP2 - Interrupt IN - 64 Bytes */
+};
+
+/*
+ * This function writes the data toggle value.
+ */
+static void write_toggle(struct usb_device *dev, u8 ep, u8 dir_out)
+{
+	u16 toggle = usb_gettoggle(dev, ep, dir_out);
+	u16 csr;
+
+	if (dir_out) {
+		if (!toggle)
+			writew(MUSB_TXCSR_CLRDATATOG, &musbr->txcsr);
+		else {
+			csr = readw(&musbr->txcsr);
+			csr |= MUSB_TXCSR_H_WR_DATATOGGLE;
+			writew(csr, &musbr->txcsr);
+			csr |= (toggle << MUSB_TXCSR_H_DATATOGGLE_SHIFT);
+			writew(csr, &musbr->txcsr);
+		}
+	} else {
+		if (!toggle)
+			writew(MUSB_RXCSR_CLRDATATOG, &musbr->rxcsr);
+		else {
+			csr = readw(&musbr->rxcsr);
+			csr |= MUSB_RXCSR_H_WR_DATATOGGLE;
+			writew(csr, &musbr->rxcsr);
+			csr |= (toggle << MUSB_S_RXCSR_H_DATATOGGLE);
+			writew(csr, &musbr->rxcsr);
+		}
+	}
+}
+
+/*
+ * This function checks if RxStall has occured on the endpoint. If a RxStall
+ * has occured, the RxStall is cleared and 1 is returned. If RxStall has
+ * not occured, 0 is returned.
+ */
+static u8 check_stall(u8 ep, u8 dir_out)
+{
+	u16 csr;
+
+	/* For endpoint 0 */
+	if (!ep) {
+		csr = readw(&musbr->txcsr);
+		if (csr & MUSB_CSR0_H_RXSTALL) {
+			csr &= ~MUSB_CSR0_H_RXSTALL;
+			writew(csr, &musbr->txcsr);
+			return 1;
+		}
+	} else { /* For non-ep0 */
+		if (dir_out) { /* is it tx ep */
+			csr = readw(&musbr->txcsr);
+			if (csr & MUSB_TXCSR_H_RXSTALL) {
+				csr &= ~MUSB_TXCSR_H_RXSTALL;
+				writew(csr, &musbr->txcsr);
+				return 1;
+			}
+		} else { /* is it rx ep */
+			csr = readw(&musbr->rxcsr);
+			if (csr & MUSB_RXCSR_H_RXSTALL) {
+				csr &= ~MUSB_RXCSR_H_RXSTALL;
+				writew(csr, &musbr->rxcsr);
+				return 1;
+			}
+		}
+	}
+	return 0;
+}
+
+/*
+ * waits until ep0 is ready. Returns 0 if ep is ready, -1 for timeout
+ * error and -2 for stall.
+ */
+static int wait_until_ep0_ready(struct usb_device *dev, u32 bit_mask)
+{
+	u16 csr;
+	int result = 1;
+
+	while (result > 0) {
+		csr = readw(&musbr->txcsr);
+		if (csr & MUSB_CSR0_H_ERROR) {
+			csr &= ~MUSB_CSR0_H_ERROR;
+			writew(csr, &musbr->txcsr);
+			dev->status = USB_ST_CRC_ERR;
+			result = -1;
+			break;
+		}
+
+		switch (bit_mask) {
+		case MUSB_CSR0_TXPKTRDY:
+			if (!(csr & MUSB_CSR0_TXPKTRDY)) {
+				if (check_stall(MUSB_CONTROL_EP, 0)) {
+					dev->status = USB_ST_STALLED;
+					result = -2;
+				} else
+					result = 0;
+			}
+			break;
+
+		case MUSB_CSR0_RXPKTRDY:
+			if (check_stall(MUSB_CONTROL_EP, 0)) {
+				dev->status = USB_ST_STALLED;
+				result = -2;
+			} else
+				if (csr & MUSB_CSR0_RXPKTRDY)
+					result = 0;
+			break;
+
+		case MUSB_CSR0_H_REQPKT:
+			if (!(csr & MUSB_CSR0_H_REQPKT)) {
+				if (check_stall(MUSB_CONTROL_EP, 0)) {
+					dev->status = USB_ST_STALLED;
+					result = -2;
+				} else
+					result = 0;
+			}
+			break;
+		}
+	}
+	return result;
+}
+
+/*
+ * waits until tx ep is ready. Returns 1 when ep is ready and 0 on error.
+ */
+static u8 wait_until_txep_ready(struct usb_device *dev, u8 ep)
+{
+	u16 csr;
+
+	do {
+		if (check_stall(ep, 1)) {
+			dev->status = USB_ST_STALLED;
+			return 0;
+		}
+
+		csr = readw(&musbr->txcsr);
+		if (csr & MUSB_TXCSR_H_ERROR) {
+			dev->status = USB_ST_CRC_ERR;
+			return 0;
+		}
+	} while (csr & MUSB_TXCSR_TXPKTRDY);
+	return 1;
+}
+
+/*
+ * waits until rx ep is ready. Returns 1 when ep is ready and 0 on error.
+ */
+static u8 wait_until_rxep_ready(struct usb_device *dev, u8 ep)
+{
+	u16 csr;
+
+	do {
+		if (check_stall(ep, 0)) {
+			dev->status = USB_ST_STALLED;
+			return 0;
+		}
+
+		csr = readw(&musbr->rxcsr);
+		if (csr & MUSB_RXCSR_H_ERROR) {
+			dev->status = USB_ST_CRC_ERR;
+			return 0;
+		}
+	} while (!(csr & MUSB_RXCSR_RXPKTRDY));
+	return 1;
+}
+
+/*
+ * This function performs the setup phase of the control transfer
+ */
+static int ctrlreq_setup_phase(struct usb_device *dev, struct devrequest *setup)
+{
+	int result;
+	u16 csr;
+
+	/* write the control request to ep0 fifo */
+	write_fifo(MUSB_CONTROL_EP, sizeof(struct devrequest), (void *)setup);
+
+	/* enable transfer of setup packet */
+	csr = readw(&musbr->txcsr);
+	csr |= (MUSB_CSR0_TXPKTRDY|MUSB_CSR0_H_SETUPPKT);
+	writew(csr, &musbr->txcsr);
+
+	/* wait until the setup packet is transmitted */
+	result = wait_until_ep0_ready(dev, MUSB_CSR0_TXPKTRDY);
+	dev->act_len = 0;
+	return result;
+}
+
+/*
+ * This function handles the control transfer in data phase
+ */
+static int ctrlreq_in_data_phase(struct usb_device *dev, u32 len, void *buffer)
+{
+	u16 csr;
+	u32 rxlen = 0;
+	u32 nextlen = 0;
+	u8  maxpktsize = (1 << dev->maxpacketsize) * 8;
+	u8  *rxbuff = (u8 *)buffer;
+	u8  rxedlength;
+	int result;
+
+	while (rxlen < len) {
+		/* Determine the next read length */
+		nextlen = ((len-rxlen) > maxpktsize) ? maxpktsize : (len-rxlen);
+
+		/* Set the ReqPkt bit */
+		csr = readw(&musbr->txcsr);
+		writew(csr | MUSB_CSR0_H_REQPKT, &musbr->txcsr);
+		result = wait_until_ep0_ready(dev, MUSB_CSR0_RXPKTRDY);
+		if (result < 0)
+			return result;
+
+		/* Actual number of bytes received by usb */
+		rxedlength = readb(&musbr->rxcount);
+
+		/* Read the data from the RxFIFO */
+		read_fifo(MUSB_CONTROL_EP, rxedlength, &rxbuff[rxlen]);
+
+		/* Clear the RxPktRdy Bit */
+		csr = readw(&musbr->txcsr);
+		csr &= ~MUSB_CSR0_RXPKTRDY;
+		writew(csr, &musbr->txcsr);
+
+		/* short packet? */
+		if (rxedlength != nextlen) {
+			dev->act_len += rxedlength;
+			break;
+		}
+		rxlen += nextlen;
+		dev->act_len = rxlen;
+	}
+	return 0;
+}
+
+/*
+ * This function handles the control transfer out data phase
+ */
+static int ctrlreq_out_data_phase(struct usb_device *dev, u32 len, void *buffer)
+{
+	u16 csr;
+	u32 txlen = 0;
+	u32 nextlen = 0;
+	u8  maxpktsize = (1 << dev->maxpacketsize) * 8;
+	u8  *txbuff = (u8 *)buffer;
+	int result = 0;
+
+	while (txlen < len) {
+		/* Determine the next write length */
+		nextlen = ((len-txlen) > maxpktsize) ? maxpktsize : (len-txlen);
+
+		/* Load the data to send in FIFO */
+		write_fifo(MUSB_CONTROL_EP, txlen, &txbuff[txlen]);
+
+		/* Set TXPKTRDY bit */
+		csr = readw(&musbr->txcsr);
+		writew(csr | MUSB_CSR0_H_DIS_PING | MUSB_CSR0_TXPKTRDY,
+					&musbr->txcsr);
+		result = wait_until_ep0_ready(dev, MUSB_CSR0_TXPKTRDY);
+		if (result < 0)
+			break;
+
+		txlen += nextlen;
+		dev->act_len = txlen;
+	}
+	return result;
+}
+
+/*
+ * This function handles the control transfer out status phase
+ */
+static int ctrlreq_out_status_phase(struct usb_device *dev)
+{
+	u16 csr;
+	int result;
+
+	/* Set the StatusPkt bit */
+	csr = readw(&musbr->txcsr);
+	csr |= (MUSB_CSR0_H_DIS_PING | MUSB_CSR0_TXPKTRDY |
+			MUSB_CSR0_H_STATUSPKT);
+	writew(csr, &musbr->txcsr);
+
+	/* Wait until TXPKTRDY bit is cleared */
+	result = wait_until_ep0_ready(dev, MUSB_CSR0_TXPKTRDY);
+	return result;
+}
+
+/*
+ * This function handles the control transfer in status phase
+ */
+static int ctrlreq_in_status_phase(struct usb_device *dev)
+{
+	u16 csr;
+	int result;
+
+	/* Set the StatusPkt bit and ReqPkt bit */
+	csr = MUSB_CSR0_H_DIS_PING | MUSB_CSR0_H_REQPKT | MUSB_CSR0_H_STATUSPKT;
+	writew(csr, &musbr->txcsr);
+	result = wait_until_ep0_ready(dev, MUSB_CSR0_H_REQPKT);
+
+	/* clear StatusPkt bit and RxPktRdy bit */
+	csr = readw(&musbr->txcsr);
+	csr &= ~(MUSB_CSR0_RXPKTRDY | MUSB_CSR0_H_STATUSPKT);
+	writew(csr, &musbr->txcsr);
+	return result;
+}
+
+/*
+ * determines the speed of the device (High/Full/Slow)
+ */
+static u8 get_dev_speed(struct usb_device *dev)
+{
+	return (dev->speed & USB_SPEED_HIGH) ? MUSB_TYPE_SPEED_HIGH :
+		((dev->speed & USB_SPEED_LOW) ? MUSB_TYPE_SPEED_LOW :
+						MUSB_TYPE_SPEED_FULL);
+}
+
+/*
+ * configure the hub address and the port address.
+ */
+static void config_hub_port(struct usb_device *dev, u8 ep)
+{
+	u8 chid;
+	u8 hub;
+
+	/* Find out the nearest parent which is high speed */
+	while (dev->parent->parent != NULL)
+		if (get_dev_speed(dev->parent) !=  MUSB_TYPE_SPEED_HIGH)
+			dev = dev->parent;
+		else
+			break;
+
+	/* determine the port address at that hub */
+	hub = dev->parent->devnum;
+	for (chid = 0; chid < USB_MAXCHILDREN; chid++)
+		if (dev->parent->children[chid] == dev)
+			break;
+
+	/* configure the hub address and the port address */
+	writeb(hub, &musbr->tar[ep].txhubaddr);
+	writeb((chid + 1), &musbr->tar[ep].txhubport);
+	writeb(hub, &musbr->tar[ep].rxhubaddr);
+	writeb((chid + 1), &musbr->tar[ep].rxhubport);
+}
+
+/*
+ * do a control transfer
+ */
+int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+			int len, struct devrequest *setup)
+{
+	int devnum = usb_pipedevice(pipe);
+	u16 csr;
+	u8  devspeed;
+
+	/* select control endpoint */
+	writeb(MUSB_CONTROL_EP, &musbr->index);
+	csr = readw(&musbr->txcsr);
+
+	/* target addr and (for multipoint) hub addr/port */
+	writeb(devnum, &musbr->tar[MUSB_CONTROL_EP].txfuncaddr);
+	writeb(devnum, &musbr->tar[MUSB_CONTROL_EP].rxfuncaddr);
+
+	/* configure the hub address and the port number as required */
+	devspeed = get_dev_speed(dev);
+	if ((musb_ishighspeed()) && (dev->parent != NULL) &&
+		(devspeed != MUSB_TYPE_SPEED_HIGH)) {
+		config_hub_port(dev, MUSB_CONTROL_EP);
+		writeb(devspeed << 6, &musbr->txtype);
+	} else {
+		writeb(musb_cfg.musb_speed << 6, &musbr->txtype);
+		writeb(0, &musbr->tar[MUSB_CONTROL_EP].txhubaddr);
+		writeb(0, &musbr->tar[MUSB_CONTROL_EP].txhubport);
+		writeb(0, &musbr->tar[MUSB_CONTROL_EP].rxhubaddr);
+		writeb(0, &musbr->tar[MUSB_CONTROL_EP].rxhubport);
+	}
+
+	/* Control transfer setup phase */
+	if (ctrlreq_setup_phase(dev, setup) < 0)
+		return 0;
+
+	switch (setup->request) {
+	case USB_REQ_GET_DESCRIPTOR:
+	case USB_REQ_GET_CONFIGURATION:
+	case USB_REQ_GET_INTERFACE:
+	case USB_REQ_GET_STATUS:
+	case USB_MSC_BBB_GET_MAX_LUN:
+		/* control transfer in-data-phase */
+		if (ctrlreq_in_data_phase(dev, len, buffer) < 0)
+			return 0;
+		/* control transfer out-status-phase */
+		if (ctrlreq_out_status_phase(dev) < 0)
+			return 0;
+		break;
+
+	case USB_REQ_SET_ADDRESS:
+	case USB_REQ_SET_CONFIGURATION:
+	case USB_REQ_SET_FEATURE:
+	case USB_REQ_SET_INTERFACE:
+	case USB_REQ_CLEAR_FEATURE:
+	case USB_MSC_BBB_RESET:
+		/* control transfer in status phase */
+		if (ctrlreq_in_status_phase(dev) < 0)
+			return 0;
+		break;
+
+	case USB_REQ_SET_DESCRIPTOR:
+		/* control transfer out data phase */
+		if (ctrlreq_out_data_phase(dev, len, buffer) < 0)
+			return 0;
+		/* control transfer in status phase */
+		if (ctrlreq_in_status_phase(dev) < 0)
+			return 0;
+		break;
+
+	default:
+		/* unhandled control transfer */
+		return -1;
+	}
+
+	dev->status = 0;
+	dev->act_len = len;
+	return len;
+}
+
+/*
+ * do a bulk transfer
+ */
+int submit_bulk_msg(struct usb_device *dev, unsigned long pipe,
+					void *buffer, int len)
+{
+	int dir_out = usb_pipeout(pipe);
+	int ep = usb_pipeendpoint(pipe);
+	int devnum = usb_pipedevice(pipe);
+	u8  type;
+	u16 csr;
+	u32 txlen = 0;
+	u32 nextlen = 0;
+	u8  devspeed;
+
+	/* select bulk endpoint */
+	writeb(MUSB_BULK_EP, &musbr->index);
+
+	/* write the address of the device */
+	if (dir_out)
+		writeb(devnum, &musbr->tar[MUSB_BULK_EP].txfuncaddr);
+	else
+		writeb(devnum, &musbr->tar[MUSB_BULK_EP].rxfuncaddr);
+
+	/* configure the hub address and the port number as required */
+	devspeed = get_dev_speed(dev);
+	if ((musb_ishighspeed()) && (dev->parent != NULL) &&
+		(devspeed != MUSB_TYPE_SPEED_HIGH)) {
+		/*
+		 * MUSB is in high speed and the destination device is full
+		 * speed device. So configure the hub address and port
+		 * address registers.
+		 */
+		config_hub_port(dev, MUSB_BULK_EP);
+	} else {
+		if (dir_out) {
+			writeb(0, &musbr->tar[MUSB_BULK_EP].txhubaddr);
+			writeb(0, &musbr->tar[MUSB_BULK_EP].txhubport);
+		} else {
+			writeb(0, &musbr->tar[MUSB_BULK_EP].rxhubaddr);
+			writeb(0, &musbr->tar[MUSB_BULK_EP].rxhubport);
+		}
+		devspeed = musb_cfg.musb_speed;
+	}
+
+	/* Write the saved toggle bit value */
+	write_toggle(dev, ep, dir_out);
+
+	if (dir_out) { /* bulk-out transfer */
+		/* Program the TxType register */
+		type = (devspeed << MUSB_TYPE_SPEED_SHIFT) |
+			   (MUSB_TYPE_PROTO_BULK << MUSB_TYPE_PROTO_SHIFT) |
+			   (ep & MUSB_TYPE_REMOTE_END);
+		writeb(type, &musbr->txtype);
+
+		/* Write maximum packet size to the TxMaxp register */
+		writew(dev->epmaxpacketout[ep], &musbr->txmaxp);
+		while (txlen < len) {
+			nextlen = ((len-txlen) < dev->epmaxpacketout[ep]) ?
+					(len-txlen) : dev->epmaxpacketout[ep];
+
+			/* Write the data to the FIFO */
+			write_fifo(MUSB_BULK_EP, nextlen,
+					(void *)(((u8 *)buffer) + txlen));
+
+			/* Set the TxPktRdy bit */
+			csr = readw(&musbr->txcsr);
+			writew(csr | MUSB_TXCSR_TXPKTRDY, &musbr->txcsr);
+
+			/* Wait until the TxPktRdy bit is cleared */
+			if (!wait_until_txep_ready(dev, MUSB_BULK_EP)) {
+				readw(&musbr->txcsr);
+				usb_settoggle(dev, ep, dir_out,
+				(csr >> MUSB_TXCSR_H_DATATOGGLE_SHIFT) & 1);
+				dev->act_len = txlen;
+				return 0;
+			}
+			txlen += nextlen;
+		}
+
+		/* Keep a copy of the data toggle bit */
+		csr = readw(&musbr->txcsr);
+		usb_settoggle(dev, ep, dir_out,
+				(csr >> MUSB_TXCSR_H_DATATOGGLE_SHIFT) & 1);
+	} else { /* bulk-in transfer */
+		/* Write the saved toggle bit value */
+		write_toggle(dev, ep, dir_out);
+
+		/* Program the RxType register */
+		type = (devspeed << MUSB_TYPE_SPEED_SHIFT) |
+			   (MUSB_TYPE_PROTO_BULK << MUSB_TYPE_PROTO_SHIFT) |
+			   (ep & MUSB_TYPE_REMOTE_END);
+		writeb(type, &musbr->rxtype);
+
+		/* Write the maximum packet size to the RxMaxp register */
+		writew(dev->epmaxpacketin[ep], &musbr->rxmaxp);
+		while (txlen < len) {
+			nextlen = ((len-txlen) < dev->epmaxpacketin[ep]) ?
+					(len-txlen) : dev->epmaxpacketin[ep];
+
+			/* Set the ReqPkt bit */
+			writew(MUSB_RXCSR_H_REQPKT, &musbr->rxcsr);
+
+			/* Wait until the RxPktRdy bit is set */
+			if (!wait_until_rxep_ready(dev, MUSB_BULK_EP)) {
+				csr = readw(&musbr->rxcsr);
+				usb_settoggle(dev, ep, dir_out,
+				(csr >> MUSB_S_RXCSR_H_DATATOGGLE) & 1);
+				csr &= ~MUSB_RXCSR_RXPKTRDY;
+				writew(csr, &musbr->rxcsr);
+				dev->act_len = txlen;
+				return 0;
+			}
+
+			/* Read the data from the FIFO */
+			read_fifo(MUSB_BULK_EP, nextlen,
+					(void *)(((u8 *)buffer) + txlen));
+
+			/* Clear the RxPktRdy bit */
+			csr =  readw(&musbr->rxcsr);
+			csr &= ~MUSB_RXCSR_RXPKTRDY;
+			writew(csr, &musbr->rxcsr);
+			txlen += nextlen;
+		}
+
+		/* Keep a copy of the data toggle bit */
+		csr = readw(&musbr->rxcsr);
+		usb_settoggle(dev, ep, dir_out,
+				(csr >> MUSB_S_RXCSR_H_DATATOGGLE) & 1);
+	}
+
+	/* bulk transfer is complete */
+	dev->status = 0;
+	dev->act_len = len;
+	return 0;
+}
+
+/*
+ * This function initializes the usb controller module.
+ */
+int usb_lowlevel_init(void)
+{
+	u8  power;
+	u32 timeout;
+
+	if (musb_platform_init() == -1)
+		return -1;
+
+	/* Configure all the endpoint FIFO's and start usb controller */
+	musbr = musb_cfg.regs;
+	musb_configure_ep(&epinfo[0],
+			sizeof(epinfo) / sizeof(struct musb_epinfo));
+	musb_start();
+
+	/*
+	 * Wait until musb is enabled in host mode with a timeout. There
+	 * should be a usb device connected.
+	 */
+	timeout = musb_cfg.timeout;
+	while (timeout--)
+		if (readb(&musbr->devctl) & MUSB_DEVCTL_HM)
+			break;
+
+	/* if musb core is not in host mode, then return */
+	if (!timeout)
+		return -1;
+
+	/* start usb bus reset */
+	power = readb(&musbr->power);
+	writeb(power | MUSB_POWER_RESET, &musbr->power);
+
+	/* After initiating a usb reset, wait for about 20ms to 30ms */
+	udelay(30000);
+
+	/* stop usb bus reset */
+	power = readb(&musbr->power);
+	power &= ~MUSB_POWER_RESET;
+	writeb(power, &musbr->power);
+
+	/* Determine if the connected device is a high/full/low speed device */
+	musb_cfg.musb_speed = (readb(&musbr->power) & MUSB_POWER_HSMODE) ?
+			MUSB_TYPE_SPEED_HIGH :
+			((readb(&musbr->devctl) & MUSB_DEVCTL_FSDEV) ?
+			MUSB_TYPE_SPEED_FULL : MUSB_TYPE_SPEED_LOW);
+	return 0;
+}
+
+/*
+ * This function stops the operation of the davinci usb module.
+ */
+int usb_lowlevel_stop(void)
+{
+	/* Reset the USB module */
+	musb_platform_deinit();
+	writeb(0, &musbr->devctl);
+	return 0;
+}
+
+/*
+ * This function supports usb interrupt transfers. Currently, usb interrupt
+ * transfers are not supported.
+ */
+int submit_int_msg(struct usb_device *dev, unsigned long pipe,
+				void *buffer, int len, int interval)
+{
+	int dir_out = usb_pipeout(pipe);
+	int ep = usb_pipeendpoint(pipe);
+	int devnum = usb_pipedevice(pipe);
+	u8  type;
+	u16 csr;
+	u32 txlen = 0;
+	u32 nextlen = 0;
+	u8  devspeed;
+
+	/* select interrupt endpoint */
+	writeb(MUSB_INTR_EP, &musbr->index);
+
+	/* write the address of the device */
+	if (dir_out)
+		writeb(devnum, &musbr->tar[MUSB_INTR_EP].txfuncaddr);
+	else
+		writeb(devnum, &musbr->tar[MUSB_INTR_EP].rxfuncaddr);
+
+	/* configure the hub address and the port number as required */
+	devspeed = get_dev_speed(dev);
+	if ((musb_ishighspeed()) && (dev->parent != NULL) &&
+		(devspeed != MUSB_TYPE_SPEED_HIGH)) {
+		/*
+		 * MUSB is in high speed and the destination device is full
+		 * speed device. So configure the hub address and port
+		 * address registers.
+		 */
+		config_hub_port(dev, MUSB_INTR_EP);
+	} else {
+		if (dir_out) {
+			writeb(0, &musbr->tar[MUSB_INTR_EP].txhubaddr);
+			writeb(0, &musbr->tar[MUSB_INTR_EP].txhubport);
+		} else {
+			writeb(0, &musbr->tar[MUSB_INTR_EP].rxhubaddr);
+			writeb(0, &musbr->tar[MUSB_INTR_EP].rxhubport);
+		}
+		devspeed = musb_cfg.musb_speed;
+	}
+
+	/* Write the saved toggle bit value */
+	write_toggle(dev, ep, dir_out);
+
+	if (!dir_out) { /* intrrupt-in transfer */
+		/* Write the saved toggle bit value */
+		write_toggle(dev, ep, dir_out);
+		writeb(interval, &musbr->rxinterval);
+
+		/* Program the RxType register */
+		type = (devspeed << MUSB_TYPE_SPEED_SHIFT) |
+			   (MUSB_TYPE_PROTO_INTR << MUSB_TYPE_PROTO_SHIFT) |
+			   (ep & MUSB_TYPE_REMOTE_END);
+		writeb(type, &musbr->rxtype);
+
+		/* Write the maximum packet size to the RxMaxp register */
+		writew(dev->epmaxpacketin[ep], &musbr->rxmaxp);
+
+		while (txlen < len) {
+			nextlen = ((len-txlen) < dev->epmaxpacketin[ep]) ?
+					(len-txlen) : dev->epmaxpacketin[ep];
+
+			/* Set the ReqPkt bit */
+			writew(MUSB_RXCSR_H_REQPKT, &musbr->rxcsr);
+
+			/* Wait until the RxPktRdy bit is set */
+			if (!wait_until_rxep_ready(dev, MUSB_INTR_EP)) {
+				csr = readw(&musbr->rxcsr);
+				usb_settoggle(dev, ep, dir_out,
+				(csr >> MUSB_S_RXCSR_H_DATATOGGLE) & 1);
+				csr &= ~MUSB_RXCSR_RXPKTRDY;
+				writew(csr, &musbr->rxcsr);
+				dev->act_len = txlen;
+				return 0;
+			}
+
+			/* Read the data from the FIFO */
+			read_fifo(MUSB_INTR_EP, nextlen,
+					(void *)(((u8 *)buffer) + txlen));
+
+			/* Clear the RxPktRdy bit */
+			csr =  readw(&musbr->rxcsr);
+			csr &= ~MUSB_RXCSR_RXPKTRDY;
+			writew(csr, &musbr->rxcsr);
+			txlen += nextlen;
+		}
+
+		/* Keep a copy of the data toggle bit */
+		csr = readw(&musbr->rxcsr);
+		usb_settoggle(dev, ep, dir_out,
+				(csr >> MUSB_S_RXCSR_H_DATATOGGLE) & 1);
+	}
+
+	/* interrupt transfer is complete */
+	dev->irq_status = 0;
+	dev->irq_act_len = len;
+	dev->irq_handle(dev);
+	dev->status = 0;
+	dev->act_len = len;
+	return 0;
+}
+
+
+#ifdef CONFIG_SYS_USB_EVENT_POLL
+/*
+ * This function polls for USB keyboard data.
+ */
+void usb_event_poll()
+{
+	device_t *dev;
+	struct usb_device *usb_kbd_dev;
+	struct usb_interface_descriptor *iface;
+	struct usb_endpoint_descriptor *ep;
+	int pipe;
+	int maxp;
+
+	/* Get the pointer to USB Keyboard device pointer */
+	dev = device_get_by_name("usbkbd");
+	usb_kbd_dev = (struct usb_device *)dev->priv;
+	iface = &usb_kbd_dev->config.if_desc[0];
+	ep = &iface->ep_desc[0];
+	pipe = usb_rcvintpipe(usb_kbd_dev, ep->bEndpointAddress);
+
+	/* Submit a interrupt transfer request */
+	maxp = usb_maxpacket(usb_kbd_dev, pipe);
+	usb_submit_int_msg(usb_kbd_dev, pipe, &new[0],
+			maxp > 8 ? 8 : maxp, ep->bInterval);
+}
+#endif /* CONFIG_SYS_USB_EVENT_POLL */
diff -Naur u-boot-2009.01/drivers/usb/musb_hcd.h u-boot/drivers/usb/musb_hcd.h
--- u-boot-2009.01/drivers/usb/musb_hcd.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/musb_hcd.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,51 @@
+/*
+ * Mentor USB OTG Core host controller driver.
+ *
+ * Copyright (c) 2008 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Author: Thomas Abraham t-abraham@ti.com, Texas Instruments
+ */
+
+#ifndef __MUSB_HCD_H__
+#define __MUSB_HCD_H__
+
+#include "musb_core.h"
+#ifdef CONFIG_USB_KEYBOARD
+#include <devices.h>
+extern unsigned char new[];
+#endif
+
+/* This defines the endpoint number used for control transfers */
+#define MUSB_CONTROL_EP 0
+
+/* This defines the endpoint number used for bulk transfer */
+#define MUSB_BULK_EP 1
+
+/* This defines the endpoint number used for interrupt transfer */
+#define MUSB_INTR_EP 2
+
+/* Determine the operating speed of MUSB core */
+#define musb_ishighspeed() \
+	((readb(&musbr->power) & MUSB_POWER_HSMODE) \
+		>> MUSB_POWER_HSMODE_SHIFT)
+
+/* extern functions */
+extern int musb_platform_init(void);
+extern void musb_platform_deinit(void);
+
+#endif	/* __MUSB_HCD_H__ */
diff -Naur u-boot-2009.01/drivers/usb/r8a66597-hcd.c u-boot/drivers/usb/r8a66597-hcd.c
--- u-boot-2009.01/drivers/usb/r8a66597-hcd.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/usb/r8a66597-hcd.c	2009-02-26 14:03:58.000000000 +0100
@@ -36,12 +36,37 @@
 static unsigned short endian = CONFIG_R8A66597_ENDIAN;
 static struct r8a66597 gr8a66597;
 
-static void set_devadd_reg(struct r8a66597 *r8a66597, u8 r8a66597_address,
-			   u16 usbspd, u8 upphub, u8 hubport, int port)
+static void get_hub_data(struct usb_device *dev, u16 *hub_devnum, u16 *hubport)
 {
-	u16 val;
+	int i;
+
+	*hub_devnum = 0;
+	*hubport = 0;
+
+	/* check a device connected to root_hub */
+	if ((dev->parent && dev->parent->devnum == 1) ||
+	    (dev->devnum == 1))
+		return;
+
+	for (i = 0; i < USB_MAXCHILDREN; i++) {
+		if (dev->parent->children[i] == dev) {
+			*hub_devnum = (u8)dev->parent->devnum;
+			*hubport = i;
+			return;
+		}
+	}
+
+	printf("get_hub_data error.\n");
+}
+
+static void set_devadd(struct r8a66597 *r8a66597, u8 r8a66597_address,
+			struct usb_device *dev, int port)
+{
+	u16 val, usbspd, upphub, hubport;
 	unsigned long devadd_reg = get_devadd_addr(r8a66597_address);
 
+	get_hub_data(dev, &upphub, &hubport);
+	usbspd = r8a66597->speed;
 	val = (upphub << 11) | (hubport << 8) | (usbspd << 6) | (port & 0x0001);
 	r8a66597_write(r8a66597, val, devadd_reg);
 }
@@ -818,7 +843,7 @@
 	R8A66597_DPRINT("pipe = %08x, buffer = %p, len = %d, devnum = %d\n",
 			pipe, buffer, transfer_len, dev->devnum);
 
-	set_devadd_reg(r8a66597, dev->devnum, r8a66597->speed, 0, 0, 0);
+	set_devadd(r8a66597, dev->devnum, dev, 0);
 
 	pipe_buffer_setting(r8a66597, dev, pipe);
 
@@ -854,13 +879,14 @@
 						setup);
 
 	R8A66597_DPRINT("%s: setup\n", __func__);
-	set_devadd_reg(r8a66597, r8a66597_address, r8a66597->speed, 0, 0, 0);
+	set_devadd(r8a66597, r8a66597_address, dev, 0);
 
 	if (send_setup_packet(r8a66597, dev, setup) < 0) {
 		printf("setup packet send error\n");
 		return -1;
 	}
 
+	dev->act_len = 0;
 	if (usb_pipein(pipe))
 		if (receive_control_packet(r8a66597, dev, buffer,
 						transfer_len) < 0)
diff -Naur u-boot-2009.01/drivers/usb/usb_ehci_core.c u-boot/drivers/usb/usb_ehci_core.c
--- u-boot-2009.01/drivers/usb/usb_ehci_core.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/usb_ehci_core.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,882 @@
+/*-
+ * Copyright (c) 2007-2008, Juniper Networks, Inc.
+ * Copyright (c) 2008, Excito Elektronik i Skne AB
+ * Copyright (c) 2008, Michael Trimarchi <trimarchimichael@yahoo.it>
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/byteorder.h>
+#include <usb.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include "usb_ehci.h"
+
+int rootdev;
+struct ehci_hccr *hccr;	/* R/O registers, not need for volatile */
+volatile struct ehci_hcor *hcor;
+
+static uint16_t portreset;
+static struct QH qh_list __attribute__((aligned(32)));
+
+static struct descriptor {
+	struct usb_hub_descriptor hub;
+	struct usb_device_descriptor device;
+	struct usb_linux_config_descriptor config;
+	struct usb_linux_interface_descriptor interface;
+	struct usb_endpoint_descriptor endpoint;
+}  __attribute__ ((packed)) descriptor = {
+	{
+		0x8,		/* bDescLength */
+		0x29,		/* bDescriptorType: hub descriptor */
+		2,		/* bNrPorts -- runtime modified */
+		0,		/* wHubCharacteristics */
+		0xff,		/* bPwrOn2PwrGood */
+		0,		/* bHubCntrCurrent */
+		{},		/* Device removable */
+		{}		/* at most 7 ports! XXX */
+	},
+	{
+		0x12,		/* bLength */
+		1,		/* bDescriptorType: UDESC_DEVICE */
+		0x0002,		/* bcdUSB: v2.0 */
+		9,		/* bDeviceClass: UDCLASS_HUB */
+		0,		/* bDeviceSubClass: UDSUBCLASS_HUB */
+		1,		/* bDeviceProtocol: UDPROTO_HSHUBSTT */
+		64,		/* bMaxPacketSize: 64 bytes */
+		0x0000,		/* idVendor */
+		0x0000,		/* idProduct */
+		0x0001,		/* bcdDevice */
+		1,		/* iManufacturer */
+		2,		/* iProduct */
+		0,		/* iSerialNumber */
+		1		/* bNumConfigurations: 1 */
+	},
+	{
+		0x9,
+		2,		/* bDescriptorType: UDESC_CONFIG */
+		cpu_to_le16(0x19),
+		1,		/* bNumInterface */
+		1,		/* bConfigurationValue */
+		0,		/* iConfiguration */
+		0x40,		/* bmAttributes: UC_SELF_POWER */
+		0		/* bMaxPower */
+	},
+	{
+		0x9,		/* bLength */
+		4,		/* bDescriptorType: UDESC_INTERFACE */
+		0,		/* bInterfaceNumber */
+		0,		/* bAlternateSetting */
+		1,		/* bNumEndpoints */
+		9,		/* bInterfaceClass: UICLASS_HUB */
+		0,		/* bInterfaceSubClass: UISUBCLASS_HUB */
+		0,		/* bInterfaceProtocol: UIPROTO_HSHUBSTT */
+		0		/* iInterface */
+	},
+	{
+		0x7,		/* bLength */
+		5,		/* bDescriptorType: UDESC_ENDPOINT */
+		0x81,		/* bEndpointAddress:
+				 * UE_DIR_IN | EHCI_INTR_ENDPT
+				 */
+		3,		/* bmAttributes: UE_INTERRUPT */
+		8, 0,		/* wMaxPacketSize */
+		255		/* bInterval */
+	},
+};
+
+#if defined(CONFIG_EHCI_IS_TDI)
+#define ehci_is_TDI()	(1)
+#else
+#define ehci_is_TDI()	(0)
+#endif
+
+#if defined(CONFIG_EHCI_DCACHE)
+/*
+ * Routines to handle (flush/invalidate) the dcache for the QH and qTD
+ * structures and data buffers. This is needed on platforms using this
+ * EHCI support with dcache enabled.
+ */
+static void flush_invalidate(u32 addr, int size, int flush)
+{
+	if (flush)
+		flush_dcache_range(addr, addr + size);
+	else
+		invalidate_dcache_range(addr, addr + size);
+}
+
+static void cache_qtd(struct qTD *qtd, int flush)
+{
+	u32 *ptr = (u32 *)qtd->qt_buffer[0];
+	int len = (qtd->qt_token & 0x7fff0000) >> 16;
+
+	flush_invalidate((u32)qtd, sizeof(struct qTD), flush);
+	if (ptr && len)
+		flush_invalidate((u32)ptr, len, flush);
+}
+
+
+static inline struct QH *qh_addr(struct QH *qh)
+{
+	return (struct QH *)((u32)qh & 0xffffffe0);
+}
+
+static void cache_qh(struct QH *qh, int flush)
+{
+	struct qTD *qtd;
+	struct qTD *next;
+	static struct qTD *first_qtd;
+
+	/*
+	 * Walk the QH list and flush/invalidate all entries
+	 */
+	while (1) {
+		flush_invalidate((u32)qh_addr(qh), sizeof(struct QH), flush);
+		if ((u32)qh & QH_LINK_TYPE_QH)
+			break;
+		qh = qh_addr(qh);
+		qh = (struct QH *)qh->qh_link;
+	}
+	qh = qh_addr(qh);
+
+	/*
+	 * Save first qTD pointer, needed for invalidating pass on this QH
+	 */
+	if (flush)
+		first_qtd = qtd = (struct qTD *)(*(u32 *)&qh->qh_overlay &
+						 0xffffffe0);
+	else
+		qtd = first_qtd;
+
+	/*
+	 * Walk the qTD list and flush/invalidate all entries
+	 */
+	while (1) {
+		if (qtd == NULL)
+			break;
+		cache_qtd(qtd, flush);
+		next = (struct qTD *)((u32)qtd->qt_next & 0xffffffe0);
+		if (next == qtd)
+			break;
+		qtd = next;
+	}
+}
+
+static inline void ehci_flush_dcache(struct QH *qh)
+{
+	cache_qh(qh, 1);
+}
+
+static inline void ehci_invalidate_dcache(struct QH *qh)
+{
+	cache_qh(qh, 0);
+}
+#else /* CONFIG_EHCI_DCACHE */
+/*
+ *
+ */
+static inline void ehci_flush_dcache(struct QH *qh)
+{
+}
+
+static inline void ehci_invalidate_dcache(struct QH *qh)
+{
+}
+#endif /* CONFIG_EHCI_DCACHE */
+
+static int handshake(uint32_t *ptr, uint32_t mask, uint32_t done, int usec)
+{
+	uint32_t result;
+	do {
+		result = ehci_readl(ptr);
+		if (result == ~(uint32_t)0)
+			return -1;
+		result &= mask;
+		if (result == done)
+			return 0;
+		udelay(1);
+		usec--;
+	} while (usec > 0);
+	return -1;
+}
+
+static void ehci_free(void *p, size_t sz)
+{
+
+}
+
+static int ehci_reset(void)
+{
+	uint32_t cmd;
+	uint32_t tmp;
+	uint32_t *reg_ptr;
+	int ret = 0;
+
+	cmd = ehci_readl(&hcor->or_usbcmd);
+	cmd |= CMD_RESET;
+	ehci_writel(&hcor->or_usbcmd, cmd);
+	ret = handshake((uint32_t *)&hcor->or_usbcmd, CMD_RESET, 0, 250 * 1000);
+	if (ret < 0) {
+		printf("EHCI fail to reset\n");
+		goto out;
+	}
+
+	if (ehci_is_TDI()) {
+		reg_ptr = (uint32_t *)((u8 *)hcor + USBMODE);
+		tmp = ehci_readl(reg_ptr);
+		tmp |= USBMODE_CM_HC;
+#if defined(CONFIG_EHCI_MMIO_BIG_ENDIAN)
+		tmp |= USBMODE_BE;
+#endif
+		ehci_writel(reg_ptr, tmp);
+	}
+out:
+	return ret;
+}
+
+static void *ehci_alloc(size_t sz, size_t align)
+{
+	static struct QH qh __attribute__((aligned(32)));
+	static struct qTD td[3] __attribute__((aligned (32)));
+	static int ntds;
+	void *p;
+
+	switch (sz) {
+	case sizeof(struct QH):
+		p = &qh;
+		ntds = 0;
+		break;
+	case sizeof(struct qTD):
+		if (ntds == 3) {
+			debug("out of TDs\n");
+			return NULL;
+		}
+		p = &td[ntds];
+		ntds++;
+		break;
+	default:
+		debug("unknown allocation size\n");
+		return NULL;
+	}
+
+	memset(p, sz, 0);
+	return p;
+}
+
+static int ehci_td_buffer(struct qTD *td, void *buf, size_t sz)
+{
+	uint32_t addr, delta, next;
+	int idx;
+
+	addr = (uint32_t) buf;
+	idx = 0;
+	while (idx < 5) {
+		td->qt_buffer[idx] = cpu_to_hc32(addr);
+		next = (addr + 4096) & ~4095;
+		delta = next - addr;
+		if (delta >= sz)
+			break;
+		sz -= delta;
+		addr = next;
+		idx++;
+	}
+
+	if (idx == 5) {
+		debug("out of buffer pointers (%u bytes left)\n", sz);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+ehci_submit_async(struct usb_device *dev, unsigned long pipe, void *buffer,
+		   int length, struct devrequest *req)
+{
+	struct QH *qh;
+	struct qTD *td;
+	volatile struct qTD *vtd;
+	unsigned long ts;
+	uint32_t *tdp;
+	uint32_t endpt, token, usbsts;
+	uint32_t c, toggle;
+	uint32_t cmd;
+	int ret = 0;
+
+	debug("dev=%p, pipe=%lx, buffer=%p, length=%d, req=%p\n", dev, pipe,
+	      buffer, length, req);
+	if (req != NULL)
+		debug("req=%u (%#x), type=%u (%#x), value=%u (%#x), index=%u\n",
+		      req->request, req->request,
+		      req->requesttype, req->requesttype,
+		      le16_to_cpu(req->value), le16_to_cpu(req->value),
+		      le16_to_cpu(req->index));
+
+	qh = ehci_alloc(sizeof(struct QH), 32);
+	if (qh == NULL) {
+		debug("unable to allocate QH\n");
+		return -1;
+	}
+	qh->qh_link = cpu_to_hc32((uint32_t)&qh_list | QH_LINK_TYPE_QH);
+	c = (usb_pipespeed(pipe) != USB_SPEED_HIGH &&
+	     usb_pipeendpoint(pipe) == 0) ? 1 : 0;
+	endpt = (8 << 28) |
+	    (c << 27) |
+	    (usb_maxpacket(dev, pipe) << 16) |
+	    (0 << 15) |
+	    (1 << 14) |
+	    (usb_pipespeed(pipe) << 12) |
+	    (usb_pipeendpoint(pipe) << 8) |
+	    (0 << 7) | (usb_pipedevice(pipe) << 0);
+	qh->qh_endpt1 = cpu_to_hc32(endpt);
+	endpt = (1 << 30) |
+	    (dev->portnr << 23) |
+	    (dev->parent->devnum << 16) | (0 << 8) | (0 << 0);
+	qh->qh_endpt2 = cpu_to_hc32(endpt);
+	qh->qh_overlay.qt_next = cpu_to_hc32(QT_NEXT_TERMINATE);
+	qh->qh_overlay.qt_altnext = cpu_to_hc32(QT_NEXT_TERMINATE);
+
+	td = NULL;
+	tdp = &qh->qh_overlay.qt_next;
+
+	toggle =
+	    usb_gettoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe));
+
+	if (req != NULL) {
+		td = ehci_alloc(sizeof(struct qTD), 32);
+		if (td == NULL) {
+			debug("unable to allocate SETUP td\n");
+			goto fail;
+		}
+		td->qt_next = cpu_to_hc32(QT_NEXT_TERMINATE);
+		td->qt_altnext = cpu_to_hc32(QT_NEXT_TERMINATE);
+		token = (0 << 31) |
+		    (sizeof(*req) << 16) |
+		    (0 << 15) | (0 << 12) | (3 << 10) | (2 << 8) | (0x80 << 0);
+		td->qt_token = cpu_to_hc32(token);
+		if (ehci_td_buffer(td, req, sizeof(*req)) != 0) {
+			debug("unable construct SETUP td\n");
+			ehci_free(td, sizeof(*td));
+			goto fail;
+		}
+		*tdp = cpu_to_hc32((uint32_t) td);
+		tdp = &td->qt_next;
+		toggle = 1;
+	}
+
+	if (length > 0 || req == NULL) {
+		td = ehci_alloc(sizeof(struct qTD), 32);
+		if (td == NULL) {
+			debug("unable to allocate DATA td\n");
+			goto fail;
+		}
+		td->qt_next = cpu_to_hc32(QT_NEXT_TERMINATE);
+		td->qt_altnext = cpu_to_hc32(QT_NEXT_TERMINATE);
+		token = (toggle << 31) |
+		    (length << 16) |
+		    ((req == NULL ? 1 : 0) << 15) |
+		    (0 << 12) |
+		    (3 << 10) |
+		    ((usb_pipein(pipe) ? 1 : 0) << 8) | (0x80 << 0);
+		td->qt_token = cpu_to_hc32(token);
+		if (ehci_td_buffer(td, buffer, length) != 0) {
+			debug("unable construct DATA td\n");
+			ehci_free(td, sizeof(*td));
+			goto fail;
+		}
+		*tdp = cpu_to_hc32((uint32_t) td);
+		tdp = &td->qt_next;
+	}
+
+	if (req != NULL) {
+		td = ehci_alloc(sizeof(struct qTD), 32);
+		if (td == NULL) {
+			debug("unable to allocate ACK td\n");
+			goto fail;
+		}
+		td->qt_next = cpu_to_hc32(QT_NEXT_TERMINATE);
+		td->qt_altnext = cpu_to_hc32(QT_NEXT_TERMINATE);
+		token = (toggle << 31) |
+		    (0 << 16) |
+		    (1 << 15) |
+		    (0 << 12) |
+		    (3 << 10) |
+		    ((usb_pipein(pipe) ? 0 : 1) << 8) | (0x80 << 0);
+		td->qt_token = cpu_to_hc32(token);
+		*tdp = cpu_to_hc32((uint32_t) td);
+		tdp = &td->qt_next;
+	}
+
+	qh_list.qh_link = cpu_to_hc32((uint32_t) qh | QH_LINK_TYPE_QH);
+
+	/* Flush dcache */
+	ehci_flush_dcache(&qh_list);
+
+	usbsts = ehci_readl(&hcor->or_usbsts);
+	ehci_writel(&hcor->or_usbsts, (usbsts & 0x3f));
+
+	/* Enable async. schedule. */
+	cmd = ehci_readl(&hcor->or_usbcmd);
+	cmd |= CMD_ASE;
+	ehci_writel(&hcor->or_usbcmd, cmd);
+
+	ret = handshake((uint32_t *)&hcor->or_usbsts, STD_ASS, STD_ASS,
+			100 * 1000);
+	if (ret < 0) {
+		printf("EHCI fail timeout STD_ASS set\n");
+		goto fail;
+	}
+
+	/* Wait for TDs to be processed. */
+	ts = get_timer(0);
+	vtd = td;
+	do {
+		/* Invalidate dcache */
+		ehci_invalidate_dcache(&qh_list);
+		token = hc32_to_cpu(vtd->qt_token);
+		if (!(token & 0x80))
+			break;
+	} while (get_timer(ts) < CONFIG_SYS_HZ);
+
+	/* Disable async schedule. */
+	cmd = ehci_readl(&hcor->or_usbcmd);
+	cmd &= ~CMD_ASE;
+	ehci_writel(&hcor->or_usbcmd, cmd);
+
+	ret = handshake((uint32_t *)&hcor->or_usbsts, STD_ASS, 0,
+			100 * 1000);
+	if (ret < 0) {
+		printf("EHCI fail timeout STD_ASS reset\n");
+		goto fail;
+	}
+
+	qh_list.qh_link = cpu_to_hc32((uint32_t)&qh_list | QH_LINK_TYPE_QH);
+
+	token = hc32_to_cpu(qh->qh_overlay.qt_token);
+	if (!(token & 0x80)) {
+		debug("TOKEN=%#x\n", token);
+		switch (token & 0xfc) {
+		case 0:
+			toggle = token >> 31;
+			usb_settoggle(dev, usb_pipeendpoint(pipe),
+				       usb_pipeout(pipe), toggle);
+			dev->status = 0;
+			break;
+		case 0x40:
+			dev->status = USB_ST_STALLED;
+			break;
+		case 0xa0:
+		case 0x20:
+			dev->status = USB_ST_BUF_ERR;
+			break;
+		case 0x50:
+		case 0x10:
+			dev->status = USB_ST_BABBLE_DET;
+			break;
+		default:
+			dev->status = USB_ST_CRC_ERR;
+			break;
+		}
+		dev->act_len = length - ((token >> 16) & 0x7fff);
+	} else {
+		dev->act_len = 0;
+		debug("dev=%u, usbsts=%#x, p[1]=%#x, p[2]=%#x\n",
+		      dev->devnum, ehci_readl(&hcor->or_usbsts),
+		      ehci_readl(&hcor->or_portsc[0]),
+		      ehci_readl(&hcor->or_portsc[1]));
+	}
+
+	return (dev->status != USB_ST_NOT_PROC) ? 0 : -1;
+
+fail:
+	td = (void *)hc32_to_cpu(qh->qh_overlay.qt_next);
+	while (td != (void *)QT_NEXT_TERMINATE) {
+		qh->qh_overlay.qt_next = td->qt_next;
+		ehci_free(td, sizeof(*td));
+		td = (void *)hc32_to_cpu(qh->qh_overlay.qt_next);
+	}
+	ehci_free(qh, sizeof(*qh));
+	return -1;
+}
+
+static inline int min3(int a, int b, int c)
+{
+
+	if (b < a)
+		a = b;
+	if (c < a)
+		a = c;
+	return a;
+}
+
+int
+ehci_submit_root(struct usb_device *dev, unsigned long pipe, void *buffer,
+		 int length, struct devrequest *req)
+{
+	uint8_t tmpbuf[4];
+	u16 typeReq;
+	void *srcptr = NULL;
+	int len, srclen;
+	uint32_t reg;
+	uint32_t *status_reg;
+
+	if (le16_to_cpu(req->index) >= CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS) {
+		printf("The request port(%d) is not configured\n",
+			le16_to_cpu(req->index) - 1);
+		return -1;
+	}
+	status_reg = (uint32_t *)&hcor->or_portsc[
+						le16_to_cpu(req->index) - 1];
+	srclen = 0;
+
+	debug("req=%u (%#x), type=%u (%#x), value=%u, index=%u\n",
+	      req->request, req->request,
+	      req->requesttype, req->requesttype,
+	      le16_to_cpu(req->value), le16_to_cpu(req->index));
+
+	typeReq = req->request << 8 | req->requesttype;
+
+	switch (le16_to_cpu(typeReq)) {
+	case DeviceRequest | USB_REQ_GET_DESCRIPTOR:
+		switch (le16_to_cpu(req->value) >> 8) {
+		case USB_DT_DEVICE:
+			debug("USB_DT_DEVICE request\n");
+			srcptr = &descriptor.device;
+			srclen = 0x12;
+			break;
+		case USB_DT_CONFIG:
+			debug("USB_DT_CONFIG config\n");
+			srcptr = &descriptor.config;
+			srclen = 0x19;
+			break;
+		case USB_DT_STRING:
+			debug("USB_DT_STRING config\n");
+			switch (le16_to_cpu(req->value) & 0xff) {
+			case 0:	/* Language */
+				srcptr = "\4\3\1\0";
+				srclen = 4;
+				break;
+			case 1:	/* Vendor */
+				srcptr = "\16\3u\0-\0b\0o\0o\0t\0";
+				srclen = 14;
+				break;
+			case 2:	/* Product */
+				srcptr = "\52\3E\0H\0C\0I\0 "
+					 "\0H\0o\0s\0t\0 "
+					 "\0C\0o\0n\0t\0r\0o\0l\0l\0e\0r\0";
+				srclen = 42;
+				break;
+			default:
+				debug("unknown value DT_STRING %x\n",
+					le16_to_cpu(req->value));
+				goto unknown;
+			}
+			break;
+		default:
+			debug("unknown value %x\n", le16_to_cpu(req->value));
+			goto unknown;
+		}
+		break;
+	case USB_REQ_GET_DESCRIPTOR | ((USB_DIR_IN | USB_RT_HUB) << 8):
+		switch (le16_to_cpu(req->value) >> 8) {
+		case USB_DT_HUB:
+			debug("USB_DT_HUB config\n");
+			srcptr = &descriptor.hub;
+			srclen = 0x8;
+			break;
+		default:
+			debug("unknown value %x\n", le16_to_cpu(req->value));
+			goto unknown;
+		}
+		break;
+	case USB_REQ_SET_ADDRESS | (USB_RECIP_DEVICE << 8):
+		debug("USB_REQ_SET_ADDRESS\n");
+		rootdev = le16_to_cpu(req->value);
+		break;
+	case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:
+		debug("USB_REQ_SET_CONFIGURATION\n");
+		/* Nothing to do */
+		break;
+	case USB_REQ_GET_STATUS | ((USB_DIR_IN | USB_RT_HUB) << 8):
+		tmpbuf[0] = 1;	/* USB_STATUS_SELFPOWERED */
+		tmpbuf[1] = 0;
+		srcptr = tmpbuf;
+		srclen = 2;
+		break;
+	case USB_REQ_GET_STATUS | ((USB_RT_PORT | USB_DIR_IN) << 8):
+		memset(tmpbuf, 0, 4);
+		reg = ehci_readl(status_reg);
+		if (reg & EHCI_PS_CS)
+			tmpbuf[0] |= USB_PORT_STAT_CONNECTION;
+		if (reg & EHCI_PS_PE)
+			tmpbuf[0] |= USB_PORT_STAT_ENABLE;
+		if (reg & EHCI_PS_SUSP)
+			tmpbuf[0] |= USB_PORT_STAT_SUSPEND;
+		if (reg & EHCI_PS_OCA)
+			tmpbuf[0] |= USB_PORT_STAT_OVERCURRENT;
+		if (reg & EHCI_PS_PR &&
+		    (portreset & (1 << le16_to_cpu(req->index)))) {
+			int ret;
+			/* force reset to complete */
+			reg = reg & ~(EHCI_PS_PR | EHCI_PS_CLEAR);
+			ehci_writel(status_reg, reg);
+			ret = handshake(status_reg, EHCI_PS_PR, 0, 2 * 1000);
+			if (!ret)
+				tmpbuf[0] |= USB_PORT_STAT_RESET;
+			else
+				printf("port(%d) reset error\n",
+					le16_to_cpu(req->index) - 1);
+		}
+		if (reg & EHCI_PS_PP)
+			tmpbuf[1] |= USB_PORT_STAT_POWER >> 8;
+
+		if (ehci_is_TDI()) {
+			switch ((reg >> 26) & 3) {
+			case 0:
+				break;
+			case 1:
+				tmpbuf[1] |= USB_PORT_STAT_LOW_SPEED >> 8;
+				break;
+			case 2:
+			default:
+				tmpbuf[1] |= USB_PORT_STAT_HIGH_SPEED >> 8;
+				break;
+			}
+		} else {
+			tmpbuf[1] |= USB_PORT_STAT_HIGH_SPEED >> 8;
+		}
+
+		if (reg & EHCI_PS_CSC)
+			tmpbuf[2] |= USB_PORT_STAT_C_CONNECTION;
+		if (reg & EHCI_PS_PEC)
+			tmpbuf[2] |= USB_PORT_STAT_C_ENABLE;
+		if (reg & EHCI_PS_OCC)
+			tmpbuf[2] |= USB_PORT_STAT_C_OVERCURRENT;
+		if (portreset & (1 << le16_to_cpu(req->index)))
+			tmpbuf[2] |= USB_PORT_STAT_C_RESET;
+
+		srcptr = tmpbuf;
+		srclen = 4;
+		break;
+	case USB_REQ_SET_FEATURE | ((USB_DIR_OUT | USB_RT_PORT) << 8):
+		reg = ehci_readl(status_reg);
+		reg &= ~EHCI_PS_CLEAR;
+		switch (le16_to_cpu(req->value)) {
+		case USB_PORT_FEAT_ENABLE:
+			reg |= EHCI_PS_PE;
+			ehci_writel(status_reg, reg);
+			break;
+		case USB_PORT_FEAT_POWER:
+			if (HCS_PPC(ehci_readl(&hccr->cr_hcsparams))) {
+				reg |= EHCI_PS_PP;
+				ehci_writel(status_reg, reg);
+			}
+			break;
+		case USB_PORT_FEAT_RESET:
+			if ((reg & (EHCI_PS_PE | EHCI_PS_CS)) == EHCI_PS_CS &&
+			    !ehci_is_TDI() &&
+			    EHCI_PS_IS_LOWSPEED(reg)) {
+				/* Low speed device, give up ownership. */
+				debug("port %d low speed --> companion\n",
+				      req->index - 1);
+				reg |= EHCI_PS_PO;
+				ehci_writel(status_reg, reg);
+				break;
+			} else {
+				reg |= EHCI_PS_PR;
+				reg &= ~EHCI_PS_PE;
+				ehci_writel(status_reg, reg);
+				/*
+				 * caller must wait, then call GetPortStatus
+				 * usb 2.0 specification say 50 ms resets on
+				 * root
+				 */
+				wait_ms(50);
+				portreset |= 1 << le16_to_cpu(req->index);
+			}
+			break;
+		default:
+			debug("unknown feature %x\n", le16_to_cpu(req->value));
+			goto unknown;
+		}
+		/* unblock posted writes */
+		ehci_readl(&hcor->or_usbcmd);
+		break;
+	case USB_REQ_CLEAR_FEATURE | ((USB_DIR_OUT | USB_RT_PORT) << 8):
+		reg = ehci_readl(status_reg);
+		switch (le16_to_cpu(req->value)) {
+		case USB_PORT_FEAT_ENABLE:
+			reg &= ~EHCI_PS_PE;
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			reg = (reg & ~EHCI_PS_CLEAR) | EHCI_PS_PE;
+			break;
+		case USB_PORT_FEAT_POWER:
+			if (HCS_PPC(ehci_readl(&hccr->cr_hcsparams)))
+				reg = reg & ~(EHCI_PS_CLEAR | EHCI_PS_PP);
+		case USB_PORT_FEAT_C_CONNECTION:
+			reg = (reg & ~EHCI_PS_CLEAR) | EHCI_PS_CSC;
+			break;
+		case USB_PORT_FEAT_OVER_CURRENT:
+			reg = (reg & ~EHCI_PS_CLEAR) | EHCI_PS_OCC;
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			portreset &= ~(1 << le16_to_cpu(req->index));
+			break;
+		default:
+			debug("unknown feature %x\n", le16_to_cpu(req->value));
+			goto unknown;
+		}
+		ehci_writel(status_reg, reg);
+		/* unblock posted write */
+		ehci_readl(&hcor->or_usbcmd);
+		break;
+	default:
+		debug("Unknown request\n");
+		goto unknown;
+	}
+
+	wait_ms(1);
+	len = min3(srclen, le16_to_cpu(req->length), length);
+	if (srcptr != NULL && len > 0)
+		memcpy(buffer, srcptr, len);
+	else
+		debug("Len is 0\n");
+
+	dev->act_len = len;
+	dev->status = 0;
+	return 0;
+
+unknown:
+	debug("requesttype=%x, request=%x, value=%x, index=%x, length=%x\n",
+	      req->requesttype, req->request, le16_to_cpu(req->value),
+	      le16_to_cpu(req->index), le16_to_cpu(req->length));
+
+	dev->act_len = 0;
+	dev->status = USB_ST_STALLED;
+	return -1;
+}
+
+int usb_lowlevel_stop(void)
+{
+	return ehci_hcd_stop();
+}
+
+int usb_lowlevel_init(void)
+{
+	uint32_t reg;
+	uint32_t cmd;
+
+	if (ehci_hcd_init() != 0)
+		return -1;
+
+	/* EHCI spec section 4.1 */
+	if (ehci_reset() != 0)
+		return -1;
+
+#if defined(CONFIG_EHCI_HCD_INIT_AFTER_RESET)
+	if (ehci_hcd_init() != 0)
+		return -1;
+#endif
+
+	/* Set head of reclaim list */
+	memset(&qh_list, 0, sizeof(qh_list));
+	qh_list.qh_link = cpu_to_hc32((uint32_t)&qh_list | QH_LINK_TYPE_QH);
+	qh_list.qh_endpt1 = cpu_to_hc32((1 << 15) | (USB_SPEED_HIGH << 12));
+	qh_list.qh_curtd = cpu_to_hc32(QT_NEXT_TERMINATE);
+	qh_list.qh_overlay.qt_next = cpu_to_hc32(QT_NEXT_TERMINATE);
+	qh_list.qh_overlay.qt_altnext = cpu_to_hc32(QT_NEXT_TERMINATE);
+	qh_list.qh_overlay.qt_token = cpu_to_hc32(0x40);
+
+	/* Set async. queue head pointer. */
+	ehci_writel(&hcor->or_asynclistaddr, (uint32_t)&qh_list);
+
+	reg = ehci_readl(&hccr->cr_hcsparams);
+	descriptor.hub.bNbrPorts = HCS_N_PORTS(reg);
+	printf("Register %x NbrPorts %d\n", reg, descriptor.hub.bNbrPorts);
+	/* Port Indicators */
+	if (HCS_INDICATOR(reg))
+		descriptor.hub.wHubCharacteristics |= 0x80;
+	/* Port Power Control */
+	if (HCS_PPC(reg))
+		descriptor.hub.wHubCharacteristics |= 0x01;
+
+	/* Start the host controller. */
+	cmd = ehci_readl(&hcor->or_usbcmd);
+	/*
+	 * Philips, Intel, and maybe others need CMD_RUN before the
+	 * root hub will detect new devices (why?); NEC doesn't
+	 */
+	cmd &= ~(CMD_LRESET|CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);
+	cmd |= CMD_RUN;
+	ehci_writel(&hcor->or_usbcmd, cmd);
+
+	/* take control over the ports */
+	cmd = ehci_readl(&hcor->or_configflag);
+	cmd |= FLAG_CF;
+	ehci_writel(&hcor->or_configflag, cmd);
+	/* unblock posted write */
+	cmd = ehci_readl(&hcor->or_usbcmd);
+	wait_ms(5);
+	reg = HC_VERSION(ehci_readl(&hccr->cr_capbase));
+	printf("USB EHCI %x.%02x\n", reg >> 8, reg & 0xff);
+
+	rootdev = 0;
+
+	return 0;
+}
+
+int
+submit_bulk_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		int length)
+{
+
+	if (usb_pipetype(pipe) != PIPE_BULK) {
+		debug("non-bulk pipe (type=%lu)", usb_pipetype(pipe));
+		return -1;
+	}
+	return ehci_submit_async(dev, pipe, buffer, length, NULL);
+}
+
+int
+submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+		   int length, struct devrequest *setup)
+{
+
+	if (usb_pipetype(pipe) != PIPE_CONTROL) {
+		debug("non-control pipe (type=%lu)", usb_pipetype(pipe));
+		return -1;
+	}
+
+	if (usb_pipedevice(pipe) == rootdev) {
+		if (rootdev == 0)
+			dev->speed = USB_SPEED_HIGH;
+		return ehci_submit_root(dev, pipe, buffer, length, setup);
+	}
+	return ehci_submit_async(dev, pipe, buffer, length, setup);
+}
+
+int
+submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+	       int length, int interval)
+{
+
+	debug("dev=%p, pipe=%lu, buffer=%p, length=%d, interval=%d",
+	      dev, pipe, buffer, length, interval);
+	return -1;
+}
diff -Naur u-boot-2009.01/drivers/usb/usb_ehci_core.h u-boot/drivers/usb/usb_ehci_core.h
--- u-boot-2009.01/drivers/usb/usb_ehci_core.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/usb_ehci_core.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,29 @@
+/*-
+ * Copyright (c) 2007-2008, Juniper Networks, Inc.
+ * Copyright (c) 2008, Excito Elektronik i Skne AB
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef USB_EHCI_CORE_H
+#define USB_EHCI_CORE_H
+
+extern int rootdev;
+extern struct ehci_hccr *hccr;
+extern volatile struct ehci_hcor *hcor;
+
+#endif
diff -Naur u-boot-2009.01/drivers/usb/usb_ehci_fsl.c u-boot/drivers/usb/usb_ehci_fsl.c
--- u-boot-2009.01/drivers/usb/usb_ehci_fsl.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/usb_ehci_fsl.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,100 @@
+/*
+ * (C) Copyright 2008, Excito Elektronik i Sk=E5ne AB
+ *
+ * Author: Tor Krill tor@excito.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <usb.h>
+#include <mpc83xx.h>
+#include <asm/io.h>
+#include <asm/bitops.h>
+
+#include "usb_ehci.h"
+#include "usb_ehci_fsl.h"
+#include "usb_ehci_core.h"
+
+/*
+ * Create the appropriate control structures to manage
+ * a new EHCI host controller.
+ *
+ * Excerpts from linux ehci fsl driver.
+ */
+int ehci_hcd_init(void)
+{
+	volatile immap_t *im = (immap_t *)CONFIG_SYS_IMMR;
+	uint32_t addr, temp;
+
+	addr = (uint32_t)&(im->usb[0]);
+	hccr = (struct ehci_hccr *)(addr + FSL_SKIP_PCI);
+	hcor = (struct ehci_hcor *)((uint32_t) hccr +
+			HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+
+	/* Configure clock */
+	clrsetbits_be32(&(im->clk.sccr), MPC83XX_SCCR_USB_MASK,
+			MPC83XX_SCCR_USB_DRCM_11);
+
+	/* Confgure interface. */
+	temp = in_be32((void *)(addr + FSL_SOC_USB_CTRL));
+	out_be32((void *)(addr + FSL_SOC_USB_CTRL), temp
+		 | REFSEL_16MHZ | UTMI_PHY_EN);
+
+	/* Wait for clock to stabilize */
+	do {
+		temp = in_be32((void *)(addr + FSL_SOC_USB_CTRL));
+		udelay(1000);
+	} while (!(temp & PHY_CLK_VALID));
+
+	/* Set to Host mode */
+	temp = in_le32((void *)(addr + FSL_SOC_USB_USBMODE));
+	out_le32((void *)(addr + FSL_SOC_USB_USBMODE), temp | CM_HOST);
+
+	out_be32((void *)(addr + FSL_SOC_USB_SNOOP1), SNOOP_SIZE_2GB);
+	out_be32((void *)(addr + FSL_SOC_USB_SNOOP2),
+		 0x80000000 | SNOOP_SIZE_2GB);
+
+	/* Init phy */
+	/* TODO: handle different phys? */
+	out_le32(&(hcor->or_portsc[0]), PORT_PTS_UTMI);
+
+	/* Enable interface. */
+	temp = in_be32((void *)(addr + FSL_SOC_USB_CTRL));
+	out_be32((void *)(addr + FSL_SOC_USB_CTRL), temp | USB_EN);
+
+	out_be32((void *)(addr + FSL_SOC_USB_PRICTRL), 0x0000000c);
+	out_be32((void *)(addr + FSL_SOC_USB_AGECNTTHRSH), 0x00000040);
+	out_be32((void *)(addr + FSL_SOC_USB_SICTRL), 0x00000001);
+
+	/* Enable interface. */
+	temp = in_be32((void *)(addr + FSL_SOC_USB_CTRL));
+	out_be32((void *)(addr + FSL_SOC_USB_CTRL), temp | USB_EN);
+
+	temp = in_le32((void *)(addr + FSL_SOC_USB_USBMODE));
+
+	return 0;
+}
+
+/*
+ * Destroy the appropriate control structures corresponding
+ * the the EHCI host controller.
+ */
+int ehci_hcd_stop(void)
+{
+	return 0;
+}
diff -Naur u-boot-2009.01/drivers/usb/usb_ehci_fsl.h u-boot/drivers/usb/usb_ehci_fsl.h
--- u-boot-2009.01/drivers/usb/usb_ehci_fsl.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/usb_ehci_fsl.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2005 freescale semiconductor
+ * Copyright (c) 2005 MontaVista Software
+ * Copyright (c) 2008 Excito Elektronik i Sk=E5ne AB
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _EHCI_FSL_H
+#define _EHCI_FSL_H
+
+/* Global offsets */
+#define FSL_SKIP_PCI		0x100
+
+/* offsets for the non-ehci registers in the FSL SOC USB controller */
+#define FSL_SOC_USB_ULPIVP	0x170
+#define FSL_SOC_USB_PORTSC1	0x184
+#define PORT_PTS_MSK		(3 << 30)
+#define PORT_PTS_UTMI		(0 << 30)
+#define PORT_PTS_ULPI		(2 << 30)
+#define PORT_PTS_SERIAL		(3 << 30)
+#define PORT_PTS_PTW		(1 << 28)
+
+/* USBMODE Register bits */
+#define CM_IDLE			(0 << 0)
+#define CM_RESERVED		(1 << 0)
+#define CM_DEVICE		(2 << 0)
+#define CM_HOST			(3 << 0)
+#define USBMODE_RESERVED_2	(0 << 2)
+#define SLOM			(1 << 3)
+#define SDIS			(1 << 4)
+
+/* CONTROL Register bits */
+#define ULPI_INT_EN		(1 << 0)
+#define WU_INT_EN		(1 << 1)
+#define USB_EN			(1 << 2)
+#define LSF_EN			(1 << 3)
+#define KEEP_OTG_ON		(1 << 4)
+#define OTG_PORT		(1 << 5)
+#define REFSEL_12MHZ		(0 << 6)
+#define REFSEL_16MHZ		(1 << 6)
+#define REFSEL_48MHZ		(2 << 6)
+#define PLL_RESET		(1 << 8)
+#define UTMI_PHY_EN		(1 << 9)
+#define PHY_CLK_SEL_UTMI	(0 << 10)
+#define PHY_CLK_SEL_ULPI	(1 << 10)
+#define CLKIN_SEL_USB_CLK	(0 << 11)
+#define CLKIN_SEL_USB_CLK2	(1 << 11)
+#define CLKIN_SEL_SYS_CLK	(2 << 11)
+#define CLKIN_SEL_SYS_CLK2	(3 << 11)
+#define RESERVED_18		(0 << 13)
+#define RESERVED_17		(0 << 14)
+#define RESERVED_16		(0 << 15)
+#define WU_INT			(1 << 16)
+#define PHY_CLK_VALID		(1 << 17)
+
+#define FSL_SOC_USB_PORTSC2	0x188
+#define FSL_SOC_USB_USBMODE	0x1a8
+#define FSL_SOC_USB_SNOOP1	0x400	/* NOTE: big-endian */
+#define FSL_SOC_USB_SNOOP2	0x404	/* NOTE: big-endian */
+#define FSL_SOC_USB_AGECNTTHRSH	0x408	/* NOTE: big-endian */
+#define FSL_SOC_USB_PRICTRL	0x40c	/* NOTE: big-endian */
+#define FSL_SOC_USB_SICTRL	0x410	/* NOTE: big-endian */
+#define FSL_SOC_USB_CTRL	0x500	/* NOTE: big-endian */
+#define SNOOP_SIZE_2GB		0x1e
+
+/* System Clock Control Register */
+#define MPC83XX_SCCR_USB_MASK		0x00f00000
+#define MPC83XX_SCCR_USB_DRCM_11	0x00300000
+#define MPC83XX_SCCR_USB_DRCM_01	0x00100000
+#define MPC83XX_SCCR_USB_DRCM_10	0x00200000
+
+#endif /* _EHCI_FSL_H */
diff -Naur u-boot-2009.01/drivers/usb/usb_ehci.h u-boot/drivers/usb/usb_ehci.h
--- u-boot-2009.01/drivers/usb/usb_ehci.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/usb_ehci.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,194 @@
+/*-
+ * Copyright (c) 2007-2008, Juniper Networks, Inc.
+ * Copyright (c) 2008, Michael Trimarchi <trimarchimichael@yahoo.it>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef USB_EHCI_H
+#define USB_EHCI_H
+
+#if !defined(CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS)
+#define CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS	2
+#endif
+
+/* (shifted) direction/type/recipient from the USB 2.0 spec, table 9.2 */
+#define DeviceRequest \
+	((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE) << 8)
+
+#define DeviceOutRequest \
+	((USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE) << 8)
+
+#define InterfaceRequest \
+	((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8)
+
+#define EndpointRequest \
+	((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8)
+
+#define EndpointOutRequest \
+	((USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8)
+
+/*
+ * Register Space.
+ */
+struct ehci_hccr {
+	uint32_t cr_capbase;
+#define HC_LENGTH(p)		(((p) >> 0) & 0x00ff)
+#define HC_VERSION(p)		(((p) >> 16) & 0xffff)
+	uint32_t cr_hcsparams;
+#define HCS_PPC(p)		((p) & (1 << 4))
+#define HCS_INDICATOR(p)	((p) & (1 << 16)) /* Port indicators */
+#define HCS_N_PORTS(p)		(((p) >> 0) & 0xf)
+	uint32_t cr_hccparams;
+	uint8_t cr_hcsp_portrt[8];
+} __attribute__ ((packed));
+
+struct ehci_hcor {
+	uint32_t or_usbcmd;
+#define CMD_PARK	(1 << 11)		/* enable "park" */
+#define CMD_PARK_CNT(c)	(((c) >> 8) & 3)	/* how many transfers to park */
+#define CMD_ASE		(1 << 5)		/* async schedule enable */
+#define CMD_LRESET	(1 << 7)		/* partial reset */
+#define CMD_IAAD	(1 << 5)		/* "doorbell" interrupt */
+#define CMD_PSE		(1 << 4)		/* periodic schedule enable */
+#define CMD_RESET	(1 << 1)		/* reset HC not bus */
+#define CMD_RUN		(1 << 0)		/* start/stop HC */
+	uint32_t or_usbsts;
+#define	STD_ASS		(1 << 15)
+#define STS_HALT	(1 << 12)
+	uint32_t or_usbintr;
+	uint32_t or_frindex;
+	uint32_t or_ctrldssegment;
+	uint32_t or_periodiclistbase;
+	uint32_t or_asynclistaddr;
+	uint32_t _reserved_[9];
+	uint32_t or_configflag;
+#define FLAG_CF		(1 << 0)	/* true:  we'll support "high speed" */
+	uint32_t or_portsc[CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS];
+	uint32_t or_systune;
+} __attribute__ ((packed));
+
+#define USBMODE		0x68		/* USB Device mode */
+#define USBMODE_SDIS	(1 << 3)	/* Stream disable */
+#define USBMODE_BE	(1 << 2)	/* BE/LE endiannes select */
+#define USBMODE_CM_HC	(3 << 0)	/* host controller mode */
+#define USBMODE_CM_IDLE	(0 << 0)	/* idle state */
+
+/* Interface descriptor */
+struct usb_linux_interface_descriptor {
+	unsigned char	bLength;
+	unsigned char	bDescriptorType;
+	unsigned char	bInterfaceNumber;
+	unsigned char	bAlternateSetting;
+	unsigned char	bNumEndpoints;
+	unsigned char	bInterfaceClass;
+	unsigned char	bInterfaceSubClass;
+	unsigned char	bInterfaceProtocol;
+	unsigned char	iInterface;
+} __attribute__ ((packed));
+
+/* Configuration descriptor information.. */
+struct usb_linux_config_descriptor {
+	unsigned char	bLength;
+	unsigned char	bDescriptorType;
+	unsigned short	wTotalLength;
+	unsigned char	bNumInterfaces;
+	unsigned char	bConfigurationValue;
+	unsigned char	iConfiguration;
+	unsigned char	bmAttributes;
+	unsigned char	MaxPower;
+} __attribute__ ((packed));
+
+#if defined CONFIG_EHCI_DESC_BIG_ENDIAN
+#define	ehci_readl(x)		(*((volatile u32 *)(x)))
+#define ehci_writel(a, b)	(*((volatile u32 *)(a)) = ((volatile u32)b))
+#else
+#define ehci_readl(x)		cpu_to_le32((*((volatile u32 *)(x))))
+#define ehci_writel(a, b)	(*((volatile u32 *)(a)) = \
+					cpu_to_le32(((volatile u32)b)))
+#endif
+
+#if defined CONFIG_EHCI_MMIO_BIG_ENDIAN
+#define hc32_to_cpu(x)		be32_to_cpu((x))
+#define cpu_to_hc32(x)		cpu_to_be32((x))
+#else
+#define hc32_to_cpu(x)		le32_to_cpu((x))
+#define cpu_to_hc32(x)		cpu_to_le32((x))
+#endif
+
+#define EHCI_PS_WKOC_E		(1 << 22)	/* RW wake on over current */
+#define EHCI_PS_WKDSCNNT_E	(1 << 21)	/* RW wake on disconnect */
+#define EHCI_PS_WKCNNT_E	(1 << 20)	/* RW wake on connect */
+#define EHCI_PS_PO		(1 << 13)	/* RW port owner */
+#define EHCI_PS_PP		(1 << 12)	/* RW,RO port power */
+#define EHCI_PS_LS		(3 << 10)	/* RO line status */
+#define EHCI_PS_PR		(1 << 8)	/* RW port reset */
+#define EHCI_PS_SUSP		(1 << 7)	/* RW suspend */
+#define EHCI_PS_FPR		(1 << 6)	/* RW force port resume */
+#define EHCI_PS_OCC		(1 << 5)	/* RWC over current change */
+#define EHCI_PS_OCA		(1 << 4)	/* RO over current active */
+#define EHCI_PS_PEC		(1 << 3)	/* RWC port enable change */
+#define EHCI_PS_PE		(1 << 2)	/* RW port enable */
+#define EHCI_PS_CSC		(1 << 1)	/* RWC connect status change */
+#define EHCI_PS_CS		(1 << 0)	/* RO connect status */
+#define EHCI_PS_CLEAR		(EHCI_PS_OCC | EHCI_PS_PEC | EHCI_PS_CSC)
+
+#define EHCI_PS_IS_LOWSPEED(x)	(((x) & EHCI_PS_LS) == (1 << 10))
+
+/*
+ * Schedule Interface Space.
+ *
+ * IMPORTANT: Software must ensure that no interface data structure
+ * reachable by the EHCI host controller spans a 4K page boundary!
+ *
+ * Periodic transfers (i.e. isochronous and interrupt transfers) are
+ * not supported.
+ */
+
+/* Queue Element Transfer Descriptor (qTD). */
+struct qTD {
+	uint32_t qt_next;
+#define	QT_NEXT_TERMINATE	1
+	uint32_t qt_altnext;
+	uint32_t qt_token;
+	uint32_t qt_buffer[5];
+};
+
+/* Queue Head (QH). */
+struct QH {
+	uint32_t qh_link;
+#define	QH_LINK_TERMINATE	1
+#define	QH_LINK_TYPE_ITD	0
+#define	QH_LINK_TYPE_QH		2
+#define	QH_LINK_TYPE_SITD	4
+#define	QH_LINK_TYPE_FSTN	6
+	uint32_t qh_endpt1;
+	uint32_t qh_endpt2;
+	uint32_t qh_curtd;
+	struct qTD qh_overlay;
+	/*
+	 * Add dummy fill value to make the size of this struct
+	 * aligned to 32 bytes
+	 */
+	uint8_t fill[16];
+};
+
+/* Low level init functions */
+int ehci_hcd_init(void);
+int ehci_hcd_stop(void);
+
+#endif /* USB_EHCI_H */
diff -Naur u-boot-2009.01/drivers/usb/usb_ehci_ixp.c u-boot/drivers/usb/usb_ehci_ixp.c
--- u-boot-2009.01/drivers/usb/usb_ehci_ixp.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/usb_ehci_ixp.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,49 @@
+/*
+ * (C) Copyright 2008, Michael Trimarchi <trimarchimichael@yahoo.it>
+ *
+ * Author: Michael Trimarchi <trimarchimichael@yahoo.it>
+ * This code is based on ehci freescale driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <usb.h>
+#include "usb_ehci.h"
+#include "usb_ehci_core.h"
+/*
+ * Create the appropriate control structures to manage
+ * a new EHCI host controller.
+ */
+int ehci_hcd_init(void)
+{
+	hccr = (struct ehci_hccr *)(0xcd000100);
+	hcor = (struct ehci_hcor *)((uint32_t) hccr
+			+ HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+
+	printf("IXP4XX init hccr %x and hcor %x hc_length %d\n",
+		(uint32_t)hccr, (uint32_t)hcor,
+		(uint32_t)HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+	return 0;
+}
+
+/*
+ * Destroy the appropriate control structures corresponding
+ * the the EHCI host controller.
+ */
+int ehci_hcd_stop(void)
+{
+	return 0;
+}
diff -Naur u-boot-2009.01/drivers/usb/usb_ehci_pci.c u-boot/drivers/usb/usb_ehci_pci.c
--- u-boot-2009.01/drivers/usb/usb_ehci_pci.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/usb_ehci_pci.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,64 @@
+/*-
+ * Copyright (c) 2007-2008, Juniper Networks, Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <usb.h>
+#include "usb_ehci.h"
+#include "usb_ehci_core.h"
+
+#ifdef CONFIG_PCI_EHCI_DEVICE
+static struct pci_device_id ehci_pci_ids[] = {
+	/* Please add supported PCI EHCI controller ids here */
+	{0, 0}
+};
+#endif
+
+/*
+ * Create the appropriate control structures to manage
+ * a new EHCI host controller.
+ */
+int ehci_hcd_init(void)
+{
+	pci_dev_t pdev;
+	uint32_t addr;
+
+	pdev = pci_find_devices(ehci_pci_ids, CONFIG_PCI_EHCI_DEVICE);
+	if (pdev == -1) {
+		printf("EHCI host controller not found\n");
+		return -1;
+	}
+
+	pci_read_config_dword(pdev, PCI_BASE_ADDRESS_0, &addr);
+	hccr = (struct ehci_hccr *)addr;
+	hcor = (struct ehci_hcor *)((uint32_t) hccr +
+			HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+
+	return 0;
+}
+
+/*
+ * Destroy the appropriate control structures corresponding
+ * the the EHCI host controller.
+ */
+int ehci_hcd_stop(void)
+{
+	return 0;
+}
diff -Naur u-boot-2009.01/drivers/usb/usb_ehci_vct.c u-boot/drivers/usb/usb_ehci_vct.c
--- u-boot-2009.01/drivers/usb/usb_ehci_vct.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/drivers/usb/usb_ehci_vct.c	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2009 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <usb.h>
+
+#include "usb_ehci.h"
+#include "usb_ehci_core.h"
+
+int vct_ehci_hcd_init(u32 *hccr, u32 *hcor);
+
+/*
+ * Create the appropriate control structures to manage
+ * a new EHCI host controller.
+ */
+int ehci_hcd_init(void)
+{
+	int ret;
+	u32 vct_hccr;
+	u32 vct_hcor;
+
+	/*
+	 * Init VCT specific stuff
+	 */
+	ret = vct_ehci_hcd_init(&vct_hccr, &vct_hcor);
+	if (ret)
+		return ret;
+
+	hccr = (struct ehci_hccr *)vct_hccr;
+	hcor = (struct ehci_hcor *)vct_hcor;
+
+	return 0;
+}
+
+/*
+ * Destroy the appropriate control structures corresponding
+ * the the EHCI host controller.
+ */
+int ehci_hcd_stop(void)
+{
+	return 0;
+}
diff -Naur u-boot-2009.01/drivers/usb/usb_ohci.c u-boot/drivers/usb/usb_ohci.c
--- u-boot-2009.01/drivers/usb/usb_ohci.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/usb/usb_ohci.c	2009-02-26 14:03:58.000000000 +0100
@@ -27,7 +27,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
diff -Naur u-boot-2009.01/drivers/video/mb862xx.c u-boot/drivers/video/mb862xx.c
--- u-boot-2009.01/drivers/video/mb862xx.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/video/mb862xx.c	2009-02-26 14:03:58.000000000 +0100
@@ -12,7 +12,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
diff -Naur u-boot-2009.01/drivers/video/smiLynxEM.c u-boot/drivers/video/smiLynxEM.c
--- u-boot-2009.01/drivers/video/smiLynxEM.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/drivers/video/smiLynxEM.c	2009-02-26 14:03:58.000000000 +0100
@@ -12,7 +12,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
diff -Naur u-boot-2009.01/examples/Makefile u-boot/examples/Makefile
--- u-boot-2009.01/examples/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/examples/Makefile	2009-02-26 14:03:58.000000000 +0100
@@ -33,9 +33,13 @@
 ifeq ($(BOARD),omap2420h4)
 LOAD_ADDR = 0x80300000
 else
+ifeq ($(CPU),omap3)
+LOAD_ADDR = 0x80300000
+else
 LOAD_ADDR = 0xc100000
 endif
 endif
+endif
 
 ifeq ($(ARCH),mips)
 LOAD_ADDR = 0x80200000 -T mips.lds
diff -Naur u-boot-2009.01/fs/fat/fat.c u-boot/fs/fat/fat.c
--- u-boot-2009.01/fs/fat/fat.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/fs/fat/fat.c	2009-02-26 14:03:58.000000000 +0100
@@ -434,7 +434,8 @@
  * into 'retdent'
  * Return 0 on success, -1 otherwise.
  */
-__u8	 get_vfatname_block[MAX_CLUSTSIZE];
+__attribute__ ((__aligned__(__alignof__(dir_entry))))
+__u8 get_vfatname_block[MAX_CLUSTSIZE];
 static int
 get_vfatname(fsdata *mydata, int curclust, __u8 *cluster,
 	     dir_entry *retdent, char *l_name)
@@ -520,6 +521,7 @@
  * Get the directory entry associated with 'filename' from the directory
  * starting at 'startsect'
  */
+__attribute__ ((__aligned__(__alignof__(dir_entry))))
 __u8 get_dentfromdir_block[MAX_CLUSTSIZE];
 static dir_entry *get_dentfromdir (fsdata * mydata, int startsect,
 				   char *filename, dir_entry * retdent,
@@ -670,6 +672,7 @@
 {
 	__u8 block[FS_BLOCK_SIZE];
 	volume_info *vistart;
+	char *fstype;
 
 	if (disk_read(0, 1, block) < 0) {
 		FAT_DPRINT("Error: reading block\n");
@@ -702,9 +705,12 @@
 	}
 	memcpy(volinfo, vistart, sizeof(volume_info));
 
-	/* Terminate fs_type string. Writing past the end of vistart
-	   is ok - it's just the buffer. */
-	vistart->fs_type[8] = '\0';
+	/*
+	 * Terminate fs_type string. Writing past the end of vistart
+	 * is ok - it's just the buffer.
+	 */
+	fstype = vistart->fs_type;
+	fstype[8] = '\0';
 
 	if (*fatsize == 32) {
 		if (compare_sign(FAT32_SIGN, vistart->fs_type) == 0) {
@@ -725,8 +731,8 @@
 	return -1;
 }
 
-
-__u8 do_fat_read_block[MAX_CLUSTSIZE];  /* Block buffer */
+__attribute__ ((__aligned__(__alignof__(dir_entry))))
+__u8 do_fat_read_block[MAX_CLUSTSIZE];
 long
 do_fat_read (const char *filename, void *buffer, unsigned long maxsize,
 	     int dols)
diff -Naur u-boot-2009.01/fs/jffs2/jffs2_1pass.c u-boot/fs/jffs2/jffs2_1pass.c
--- u-boot-2009.01/fs/jffs2/jffs2_1pass.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/fs/jffs2/jffs2_1pass.c	2009-03-06 12:33:08.000000000 +0100
@@ -167,8 +167,10 @@
 		size_t * retlen, u_char * buf, int nanddev);
 #endif
 
+#ifndef NAND_PAGE_SIZE
 #define NAND_PAGE_SIZE 512
-#define NAND_PAGE_SHIFT 9
+#endif
+//#define NAND_PAGE_SHIFT 9
 #define NAND_PAGE_MASK (~(NAND_PAGE_SIZE-1))
 
 #ifndef NAND_CACHE_PAGES
@@ -214,8 +216,8 @@
 			if (nand_read(&nand_info[id->num], nand_cache_off,
 						&retlen, nand_cache) != 0 ||
 					retlen != NAND_CACHE_SIZE) {
-				printf("read_nand_cached: error reading nand off %#x size %d bytes\n",
-						nand_cache_off, NAND_CACHE_SIZE);
+				printf("read_nand_cached: error reading nand off %#x size %d of %d bytes\n",
+						nand_cache_off, retlen, NAND_CACHE_SIZE);
 				return -1;
 			}
 #endif
diff -Naur u-boot-2009.01/.gitignore u-boot/.gitignore
--- u-boot-2009.01/.gitignore	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/.gitignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-#
-# NOTE! Don't add files that are generated in specific
-# subdirectories here. Add them in the ".gitignore" file
-# in that subdirectory instead.
-#
-# Normal rules
-#
-
-*.rej
-*.orig
-*.a
-*.o
-*~
-*.swp
-*.patch
-
-#
-# Top-level generic files
-#
-
-/System.map
-/u-boot
-/u-boot.hex
-/u-boot.map
-/u-boot.bin
-/u-boot.srec
-/u-boot.ldr
-/u-boot.ldr.hex
-/u-boot.ldr.srec
-/u-boot-onenand.bin
-/u-boot-flexonenand.bin
-
-#
-# Generated files
-#
-
-*.depend
-/LOG
-/errlog
-/reloc_off
-
-# stgit generated dirs
-patches-*
-.stgit-edit.txt
-
-# quilt's files
-patches
-series
-
-# gdb files
-.gdb_history
-
-# cscope files
-cscope.*
-
-# tags files
-/ctags
-/etags
-
-# OneNAND IPL files
-/onenand_ipl/onenand-ipl*
-/onenand_ipl/board/*/onenand*
-/onenand_ipl/board/*/*.S
diff -Naur u-boot-2009.01/include/74xx_7xx.h u-boot/include/74xx_7xx.h
--- u-boot-2009.01/include/74xx_7xx.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/74xx_7xx.h	2009-02-26 14:03:58.000000000 +0100
@@ -66,43 +66,6 @@
 #define L2CR_L2OH_INV    0x00020000 /* bits 14-15 - output hold time = long */
 #define L2CR_L2IP        0x00000001 /* global invalidate in progress */
 
-/*----------------------------------------------------------------
- * BAT settings.  Look in config_<BOARD>.h for the actual setup
- */
-
-#define BATU_BL_128K            0x00000000
-#define BATU_BL_256K            0x00000004
-#define BATU_BL_512K            0x0000000c
-#define BATU_BL_1M              0x0000001c
-#define BATU_BL_2M              0x0000003c
-#define BATU_BL_4M              0x0000007c
-#define BATU_BL_8M              0x000000fc
-#define BATU_BL_16M             0x000001fc
-#define BATU_BL_32M             0x000003fc
-#define BATU_BL_64M             0x000007fc
-#define BATU_BL_128M            0x00000ffc
-#define BATU_BL_256M            0x00001ffc
-
-#define BATU_VS                 0x00000002
-#define BATU_VP                 0x00000001
-#define BATU_INVALID            0x00000000
-
-#define BATL_WRITETHROUGH       0x00000040
-#define BATL_CACHEINHIBIT       0x00000020
-#define BATL_MEMCOHERENCE	0x00000010
-#define BATL_GUARDEDSTORAGE     0x00000008
-#define BATL_NO_ACCESS		0x00000000
-
-#define BATL_PP_MSK		0x00000003
-#define BATL_PP_00		0x00000000 /* No access */
-#define BATL_PP_01		0x00000001 /* Read-only */
-#define BATL_PP_10		0x00000002 /* Read-write */
-#define BATL_PP_11		0x00000003
-
-#define BATL_PP_NO_ACCESS	BATL_PP_00
-#define BATL_PP_RO		BATL_PP_01
-#define BATL_PP_RW		BATL_PP_10
-
 #ifndef __ASSEMBLY__
 /* cpu ids we detect */
 typedef enum __cpu_t {
diff -Naur u-boot-2009.01/include/api_public.h u-boot/include/api_public.h
--- u-boot-2009.01/include/api_public.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/api_public.h	2009-02-26 14:03:58.000000000 +0100
@@ -57,6 +57,7 @@
 #define API_ENOMEM		3	/* no memory		*/
 #define API_EBUSY		4	/* busy, occupied etc.	*/
 #define API_EIO			5	/* I/O error		*/
+#define API_ESYSC		6	/* syscall error	*/
 
 typedef	int (*scp_t)(int, int *, ...);
 
diff -Naur u-boot-2009.01/include/asm-arm/arch-lpc2292/mmc.h u-boot/include/asm-arm/arch-lpc2292/mmc.h
--- u-boot-2009.01/include/asm-arm/arch-lpc2292/mmc.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-arm/arch-lpc2292/mmc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,22 +0,0 @@
-/*
- * A dummy header file for use with the LPC2292 port to keep the
- * compiler happy.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#ifndef _MMC_ARM_TDM_H_
-#define _MMC_ARM_TDM_H_
-#endif /* _MMC_ARM_TDM_H_ */
diff -Naur u-boot-2009.01/include/asm-arm/arch-mx31/mx31-regs.h u-boot/include/asm-arm/arch-mx31/mx31-regs.h
--- u-boot-2009.01/include/asm-arm/arch-mx31/mx31-regs.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-arm/arch-mx31/mx31-regs.h	2009-02-26 14:03:58.000000000 +0100
@@ -34,7 +34,7 @@
 #define CCM_PDR1	(CCM_BASE + 0x08)
 #define CCM_RCSR	(CCM_BASE + 0x0c)
 #define CCM_MPCTL	(CCM_BASE + 0x10)
-#define CCM_UPCTL	(CCM_BASE + 0x10)
+#define CCM_UPCTL	(CCM_BASE + 0x14)
 #define CCM_SPCTL	(CCM_BASE + 0x18)
 #define CCM_COSR	(CCM_BASE + 0x1C)
 #define CCM_CGR0	(CCM_BASE + 0x20)
@@ -87,6 +87,16 @@
 #define WDOG_BASE		0x53FDC000
 
 /*
+ * GPIO
+ */
+#define GPIO1_BASE	0x53FCC000
+#define GPIO2_BASE	0x53FD0000
+#define GPIO3_BASE	0x53FA4000
+#define GPIO_DR		0x00000000	/* data register */
+#define GPIO_GDIR	0x00000004	/* direction register */
+#define GPIO_PSR	0x00000008	/* pad status register */
+
+/*
  * Signal Multiplexing (IOMUX)
  */
 
diff -Naur u-boot-2009.01/include/asm-arm/arch-omap3/clocks.h u-boot/include/asm-arm/arch-omap3/clocks.h
--- u-boot-2009.01/include/asm-arm/arch-omap3/clocks.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/arch-omap3/clocks.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _CLOCKS_H_
+#define _CLOCKS_H_
+
+#define LDELAY		12000000
+
+#define S12M		12000000
+#define S13M		13000000
+#define S19_2M		19200000
+#define S24M		24000000
+#define S26M		26000000
+#define S38_4M		38400000
+
+#define FCK_IVA2_ON	0x00000001
+#define FCK_CORE1_ON	0x03fffe29
+#define ICK_CORE1_ON	0x3ffffffb
+#define ICK_CORE2_ON	0x0000001f
+#define FCK_WKUP_ON	0x000000e9
+#define ICK_WKUP_ON	0x0000003f
+#define FCK_DSS_ON	0x00000005
+#define ICK_DSS_ON	0x00000001
+#define FCK_CAM_ON	0x00000001
+#define ICK_CAM_ON	0x00000001
+#define FCK_PER_ON	0x0003ffff
+#define ICK_PER_ON	0x0003ffff
+
+/* Used to index into DPLL parameter tables */
+typedef struct {
+	unsigned int m;
+	unsigned int n;
+	unsigned int fsel;
+	unsigned int m2;
+} dpll_param;
+
+/* Following functions are exported from lowlevel_init.S */
+extern dpll_param *get_mpu_dpll_param(void);
+extern dpll_param *get_iva_dpll_param(void);
+extern dpll_param *get_core_dpll_param(void);
+extern dpll_param *get_per_dpll_param(void);
+
+extern void *_end_vect, *_start;
+
+#endif
diff -Naur u-boot-2009.01/include/asm-arm/arch-omap3/clocks_omap3.h u-boot/include/asm-arm/arch-omap3/clocks_omap3.h
--- u-boot-2009.01/include/asm-arm/arch-omap3/clocks_omap3.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/arch-omap3/clocks_omap3.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,285 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _CLOCKS_OMAP3_H_
+#define _CLOCKS_OMAP3_H_
+
+#define PLL_STOP		1	/* PER & IVA */
+#define PLL_LOW_POWER_BYPASS	5	/* MPU, IVA & CORE */
+#define PLL_FAST_RELOCK_BYPASS	6	/* CORE */
+#define PLL_LOCK		7	/* MPU, IVA, CORE & PER */
+
+/*
+ * The following configurations are OPP and SysClk value independant
+ * and hence are defined here. All the other DPLL related values are
+ * tabulated in lowlevel_init.S.
+ */
+
+/* CORE DPLL */
+#define CORE_M3X2	2	/* 332MHz : CM_CLKSEL1_EMU */
+#define CORE_SSI_DIV	3	/* 221MHz : CM_CLKSEL_CORE */
+#define CORE_FUSB_DIV	2	/* 41.5MHz: */
+#define CORE_L4_DIV	2	/* 83MHz  : L4 */
+#define CORE_L3_DIV	2	/* 166MHz : L3 {DDR} */
+#define GFX_DIV		2	/* 83MHz  : CM_CLKSEL_GFX */
+#define WKUP_RSM	2	/* 41.5MHz: CM_CLKSEL_WKUP */
+
+/* PER DPLL */
+#define PER_M6X2	3	/* 288MHz: CM_CLKSEL1_EMU */
+#define PER_M5X2	4	/* 216MHz: CM_CLKSEL_CAM */
+#define PER_M4X2	2	/* 432MHz: CM_CLKSEL_DSS-dss1 */
+#define PER_M3X2	16	/* 54MHz : CM_CLKSEL_DSS-tv */
+
+#define CLSEL1_EMU_VAL ((CORE_M3X2 << 16) | (PER_M6X2 << 24) | (0x0A50))
+
+/* MPU DPLL */
+
+#define MPU_M_12_ES1		0x0FE
+#define MPU_N_12_ES1		0x07
+#define MPU_FSEL_12_ES1		0x05
+#define MPU_M2_12_ES1		0x01
+
+#define MPU_M_12_ES2		0x0FA
+#define MPU_N_12_ES2		0x05
+#define MPU_FSEL_12_ES2		0x07
+#define MPU_M2_ES2		0x01
+
+#define MPU_M_12		0x085
+#define MPU_N_12		0x05
+#define MPU_FSEL_12		0x07
+#define MPU_M2_12		0x01
+
+#define MPU_M_13_ES1		0x17D
+#define MPU_N_13_ES1		0x0C
+#define MPU_FSEL_13_ES1		0x03
+#define MPU_M2_13_ES1		0x01
+
+#define MPU_M_13_ES2		0x1F4
+#define MPU_N_13_ES2		0x0C
+#define MPU_FSEL_13_ES2		0x03
+#define MPU_M2_13_ES2		0x01
+
+#define MPU_M_13		0x10A
+#define MPU_N_13		0x0C
+#define MPU_FSEL_13		0x03
+#define MPU_M2_13		0x01
+
+#define MPU_M_19P2_ES1		0x179
+#define MPU_N_19P2_ES1		0x12
+#define MPU_FSEL_19P2_ES1	0x04
+#define MPU_M2_19P2_ES1		0x01
+
+#define MPU_M_19P2_ES2		0x271
+#define MPU_N_19P2_ES2		0x17
+#define MPU_FSEL_19P2_ES2	0x03
+#define MPU_M2_19P2_ES2		0x01
+
+#define MPU_M_19P2		0x14C
+#define MPU_N_19P2		0x17
+#define MPU_FSEL_19P2		0x03
+#define MPU_M2_19P2		0x01
+
+#define MPU_M_26_ES1		0x17D
+#define MPU_N_26_ES1		0x19
+#define MPU_FSEL_26_ES1		0x03
+#define MPU_M2_26_ES1		0x01
+
+#define MPU_M_26_ES2		0x0FA
+#define MPU_N_26_ES2		0x0C
+#define MPU_FSEL_26_ES2		0x07
+#define MPU_M2_26_ES2		0x01
+
+#define MPU_M_26		0x085
+#define MPU_N_26		0x0C
+#define MPU_FSEL_26		0x07
+#define MPU_M2_26		0x01
+
+#define MPU_M_38P4_ES1		0x1FA
+#define MPU_N_38P4_ES1		0x32
+#define MPU_FSEL_38P4_ES1	0x03
+#define MPU_M2_38P4_ES1		0x01
+
+#define MPU_M_38P4_ES2		0x271
+#define MPU_N_38P4_ES2		0x2F
+#define MPU_FSEL_38P4_ES2	0x03
+#define MPU_M2_38P4_ES2		0x01
+
+#define MPU_M_38P4		0x14C
+#define MPU_N_38P4		0x2F
+#define MPU_FSEL_38P4		0x03
+#define MPU_M2_38P4		0x01
+
+/* IVA DPLL */
+
+#define IVA_M_12_ES1		0x07D
+#define IVA_N_12_ES1		0x05
+#define IVA_FSEL_12_ES1		0x07
+#define IVA_M2_12_ES1		0x01
+
+#define IVA_M_12_ES2		0x0B4
+#define IVA_N_12_ES2		0x05
+#define IVA_FSEL_12_ES2		0x07
+#define IVA_M2_12_ES2		0x01
+
+#define IVA_M_12		0x085
+#define IVA_N_12		0x05
+#define IVA_FSEL_12		0x07
+#define IVA_M2_12		0x01
+
+#define IVA_M_13_ES1		0x0FA
+#define IVA_N_13_ES1		0x0C
+#define IVA_FSEL_13_ES1		0x03
+#define IVA_M2_13_ES1		0x01
+
+#define IVA_M_13_ES2		0x168
+#define IVA_N_13_ES2		0x0C
+#define IVA_FSEL_13_ES2		0x03
+#define IVA_M2_13_ES2		0x01
+
+#define IVA_M_13		0x10A
+#define IVA_N_13		0x0C
+#define IVA_FSEL_13		0x03
+#define IVA_M2_13		0x01
+
+#define IVA_M_19P2_ES1		0x082
+#define IVA_N_19P2_ES1		0x09
+#define IVA_FSEL_19P2_ES1	0x07
+#define IVA_M2_19P2_ES1		0x01
+
+#define IVA_M_19P2_ES2		0x0E1
+#define IVA_N_19P2_ES2		0x0B
+#define IVA_FSEL_19P2_ES2	0x06
+#define IVA_M2_19P2_ES2		0x01
+
+#define IVA_M_19P2		0x14C
+#define IVA_N_19P2		0x17
+#define IVA_FSEL_19P2		0x03
+#define IVA_M2_19P2		0x01
+
+#define IVA_M_26_ES1		0x07D
+#define IVA_N_26_ES1		0x0C
+#define IVA_FSEL_26_ES1		0x07
+#define IVA_M2_26_ES1		0x01
+
+#define IVA_M_26_ES2		0x0B4
+#define IVA_N_26_ES2		0x0C
+#define IVA_FSEL_26_ES2		0x07
+#define IVA_M2_26_ES2		0x01
+
+#define IVA_M_26		0x085
+#define IVA_N_26		0x0C
+#define IVA_FSEL_26		0x07
+#define IVA_M2_26		0x01
+
+#define IVA_M_38P4_ES1		0x13F
+#define IVA_N_38P4_ES1		0x30
+#define IVA_FSEL_38P4_ES1	0x03
+#define IVA_M2_38P4_ES1		0x01
+
+#define IVA_M_38P4_ES2		0x0E1
+#define IVA_N_38P4_ES2		0x17
+#define IVA_FSEL_38P4_ES2	0x06
+#define IVA_M2_38P4_ES2		0x01
+
+#define IVA_M_38P4		0x14C
+#define IVA_N_38P4		0x2F
+#define IVA_FSEL_38P4		0x03
+#define IVA_M2_38P4		0x01
+
+/* CORE DPLL */
+
+#define CORE_M_12		0xA6
+#define CORE_N_12		0x05
+#define CORE_FSEL_12		0x07
+#define CORE_M2_12		0x01	/* M3 of 2 */
+
+#define CORE_M_12_ES1		0x19F
+#define CORE_N_12_ES1		0x0E
+#define CORE_FSL_12_ES1		0x03
+#define CORE_M2_12_ES1		0x1	/* M3 of 2 */
+
+#define CORE_M_13		0x14C
+#define CORE_N_13		0x0C
+#define CORE_FSEL_13		0x03
+#define CORE_M2_13		0x01	/* M3 of 2 */
+
+#define CORE_M_13_ES1		0x1B2
+#define CORE_N_13_ES1		0x10
+#define CORE_FSL_13_ES1		0x03
+#define CORE_M2_13_ES1		0x01	/* M3 of 2 */
+
+#define CORE_M_19P2		0x19F
+#define CORE_N_19P2		0x17
+#define CORE_FSEL_19P2		0x03
+#define CORE_M2_19P2		0x01	/* M3 of 2 */
+
+#define CORE_M_19P2_ES1		0x19F
+#define CORE_N_19P2_ES1		0x17
+#define CORE_FSL_19P2_ES1	0x03
+#define CORE_M2_19P2_ES1	0x01	/* M3 of 2 */
+
+#define CORE_M_26		0xA6
+#define CORE_N_26		0x0C
+#define CORE_FSEL_26		0x07
+#define CORE_M2_26		0x01	/* M3 of 2 */
+
+#define CORE_M_26_ES1		0x1B2
+#define CORE_N_26_ES1		0x21
+#define CORE_FSL_26_ES1		0x03
+#define CORE_M2_26_ES1		0x01	/* M3 of 2 */
+
+#define CORE_M_38P4		0x19F
+#define CORE_N_38P4		0x2F
+#define CORE_FSEL_38P4		0x03
+#define CORE_M2_38P4		0x01	/* M3 of 2 */
+
+#define CORE_M_38P4_ES1		0x19F
+#define CORE_N_38P4_ES1		0x2F
+#define CORE_FSL_38P4_ES1	0x03
+#define CORE_M2_38P4_ES1	0x01	/* M3 of 2 */
+
+/* PER DPLL */
+
+#define PER_M_12		0xD8
+#define PER_N_12		0x05
+#define PER_FSEL_12		0x07
+#define PER_M2_12		0x09
+
+#define PER_M_13		0x1B0
+#define PER_N_13		0x0C
+#define PER_FSEL_13		0x03
+#define PER_M2_13		0x09
+
+#define PER_M_19P2		0xE1
+#define PER_N_19P2		0x09
+#define PER_FSEL_19P2		0x07
+#define PER_M2_19P2		0x09
+
+#define PER_M_26		0xD8
+#define PER_N_26		0x0C
+#define PER_FSEL_26		0x07
+#define PER_M2_26		0x09
+
+#define PER_M_38P4		0xE1
+#define PER_N_38P4		0x13
+#define PER_FSEL_38P4		0x07
+#define PER_M2_38P4		0x09
+
+#endif	/* endif _CLOCKS_OMAP3_H_ */
diff -Naur u-boot-2009.01/include/asm-arm/arch-omap3/cpu.h u-boot/include/asm-arm/arch-omap3/cpu.h
--- u-boot-2009.01/include/asm-arm/arch-omap3/cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/arch-omap3/cpu.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,422 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _CPU_H
+#define _CPU_H
+
+/* Register offsets of common modules */
+/* Control */
+#ifndef __ASSEMBLY__
+typedef struct ctrl {
+	unsigned char res1[0xC0];
+	unsigned short gpmc_nadv_ale;	/* 0xC0 */
+	unsigned short gpmc_noe;	/* 0xC2 */
+	unsigned short gpmc_nwe;	/* 0xC4 */
+	unsigned char res2[0x22A];
+	unsigned int status;		/* 0x2F0 */
+	unsigned int gpstatus;		/* 0x2F4 */
+	unsigned char res3[0x08];
+	unsigned int rpubkey_0;		/* 0x300 */
+	unsigned int rpubkey_1;		/* 0x304 */
+	unsigned int rpubkey_2;		/* 0x308 */
+	unsigned int rpubkey_3;		/* 0x30C */
+	unsigned int rpubkey_4;		/* 0x310 */
+	unsigned char res4[0x04];
+	unsigned int randkey_0;		/* 0x318 */
+	unsigned int randkey_1;		/* 0x31C */
+	unsigned int randkey_2;		/* 0x320 */
+	unsigned int randkey_3;		/* 0x324 */
+	unsigned char res5[0x124];
+	unsigned int ctrl_omap_stat;	/* 0x44C */
+} ctrl_t;
+#else /* __ASSEMBLY__ */
+#define CONTROL_STATUS		0x2F0
+#endif /* __ASSEMBLY__ */
+
+/* cpu type */
+#define OMAP3503		0x5c00
+#define OMAP3515		0x1c00
+#define OMAP3525		0x4c00
+#define OMAP3530		0x0c00
+
+/* device type */
+#define DEVICE_MASK		(0x7 << 8)
+#define SYSBOOT_MASK		0x1F
+#define TST_DEVICE		0x0
+#define EMU_DEVICE		0x1
+#define HS_DEVICE		0x2
+#define GP_DEVICE		0x3
+
+/* GPMC CS3/cs4/cs6 not avaliable */
+#define GPMC_BASE		(OMAP34XX_GPMC_BASE)
+#define GPMC_CONFIG_CS0		0x60
+#define GPMC_CONFIG_CS6		0x150
+#define GPMC_CONFIG_CS0_BASE	(GPMC_BASE + GPMC_CONFIG_CS0)
+#define GPMC_CONFIG_CS6_BASE	(GPMC_BASE + GPMC_CONFIG_CS6)
+#define GPMC_CONFIG_WP		0x10
+
+#define GPMC_CONFIG_WIDTH	0x30
+
+#ifndef __ASSEMBLY__
+typedef struct gpmc {
+	unsigned char res1[0x10];
+	unsigned int sysconfig;		/* 0x10 */
+	unsigned char res2[0x4];
+	unsigned int irqstatus;		/* 0x18 */
+	unsigned int irqenable; 	/* 0x1C */
+	unsigned char res3[0x20];
+	unsigned int timeout_control; 	/* 0x40 */
+	unsigned char res4[0xC];
+	unsigned int config;		/* 0x50 */
+	unsigned int status;		/* 0x54 */
+	unsigned char res5[0x19C];
+	unsigned int ecc_config;	/* 0x1F4 */
+	unsigned int ecc_control;	/* 0x1F8 */
+	unsigned int ecc_size_config;	/* 0x1FC */
+	unsigned int ecc1_result;	/* 0x200 */
+	unsigned int ecc2_result;	/* 0x204 */
+	unsigned int ecc3_result;	/* 0x208 */
+	unsigned int ecc4_result;	/* 0x20C */
+	unsigned int ecc5_result;	/* 0x210 */
+	unsigned int ecc6_result;	/* 0x214 */
+	unsigned int ecc7_result;	/* 0x218 */
+	unsigned int ecc8_result;	/* 0x21C */
+	unsigned int ecc9_result;	/* 0x220 */
+} gpmc_t;
+
+typedef struct gpmc_csx {
+	unsigned int config1;		/* 0x00 */
+	unsigned int config2;		/* 0x04 */
+	unsigned int config3;		/* 0x08 */
+	unsigned int config4;		/* 0x0C */
+	unsigned int config5;		/* 0x10 */
+	unsigned int config6;		/* 0x14 */
+	unsigned int config7;		/* 0x18 */
+	unsigned int nand_cmd;		/* 0x1C */
+	unsigned int nand_adr;		/* 0x20 */
+	unsigned int nand_dat;		/* 0x24 */
+} gpmc_csx_t;
+#else /* __ASSEMBLY__ */
+#define GPMC_CONFIG1		0x00
+#define GPMC_CONFIG2		0x04
+#define GPMC_CONFIG3		0x08
+#define GPMC_CONFIG4		0x0C
+#define GPMC_CONFIG5		0x10
+#define GPMC_CONFIG6		0x14
+#define GPMC_CONFIG7		0x18
+#endif /* __ASSEMBLY__ */
+
+/* GPMC Mapping */
+#define FLASH_BASE		0x10000000	/* NOR flash, */
+						/* aligned to 256 Meg */
+#define FLASH_BASE_SDPV1	0x04000000	/* NOR flash, */
+						/* aligned to 64 Meg */
+#define FLASH_BASE_SDPV2	0x10000000	/* NOR flash, */
+						/* aligned to 256 Meg */
+#define DEBUG_BASE		0x08000000	/* debug board */
+#define NAND_BASE		0x30000000	/* NAND addr */
+						/* (actual size small port) */
+#define PISMO2_BASE		0x18000000	/* PISMO2 CS1/2 */
+#define ONENAND_MAP		0x20000000	/* OneNand addr */
+						/* (actual size small port) */
+/* SMS */
+#ifndef __ASSEMBLY__
+typedef struct sms {
+	unsigned char res1[0x10];
+	unsigned int sysconfig;		/* 0x10 */
+	unsigned char res2[0x34];
+	unsigned int rg_att0;		/* 0x48 */
+	unsigned char res3[0x84];
+	unsigned int class_arb0;	/* 0xD0 */
+} sms_t;
+#endif /* __ASSEMBLY__ */
+
+#define BURSTCOMPLETE_GROUP7	(0x1 << 31)
+
+/* SDRC */
+#ifndef __ASSEMBLY__
+typedef struct sdrc_cs {
+	unsigned int mcfg;		/* 0x80 || 0xB0 */
+	unsigned int mr;		/* 0x84 || 0xB4 */
+	unsigned char res1[0x4];
+	unsigned int emr2;		/* 0x8C || 0xBC */
+	unsigned char res2[0x14];
+	unsigned int rfr_ctrl;		/* 0x84 || 0xD4 */
+	unsigned int manual;		/* 0xA8 || 0xD8 */
+	unsigned char res3[0x4];
+} sdrc_cs_t;
+
+typedef struct sdrc_actim {
+	unsigned int ctrla;		/* 0x9C || 0xC4 */
+	unsigned int ctrlb;		/* 0xA0 || 0xC8 */
+} sdrc_actim_t;
+
+typedef struct sdrc {
+	unsigned char res1[0x10];
+	unsigned int sysconfig;		/* 0x10 */
+	unsigned int status;		/* 0x14 */
+	unsigned char res2[0x28];
+	unsigned int cs_cfg;		/* 0x40 */
+	unsigned int sharing;		/* 0x44 */
+	unsigned char res3[0x18];
+	unsigned int dlla_ctrl;		/* 0x60 */
+	unsigned int dlla_status;	/* 0x64 */
+	unsigned int dllb_ctrl;		/* 0x68 */
+	unsigned int dllb_status;	/* 0x6C */
+	unsigned int power;		/* 0x70 */
+	unsigned char res4[0xC];
+	sdrc_cs_t cs[2];		/* 0x80 || 0xB0 */
+} sdrc_t;
+#endif /* __ASSEMBLY__ */
+
+#define DLLPHASE_90		(0x1 << 1)
+#define LOADDLL			(0x1 << 2)
+#define ENADLL			(0x1 << 3)
+#define DLL_DELAY_MASK		0xFF00
+#define DLL_NO_FILTER_MASK	((0x1 << 9) | (0x1 << 8))
+
+#define PAGEPOLICY_HIGH		(0x1 << 0)
+#define SRFRONRESET		(0x1 << 7)
+#define WAKEUPPROC		(0x1 << 26)
+
+#define DDR_SDRAM		(0x1 << 0)
+#define DEEPPD			(0x1 << 3)
+#define B32NOT16		(0x1 << 4)
+#define BANKALLOCATION		(0x2 << 6)
+#define RAMSIZE_128		(0x40 << 8) /* RAM size in 2MB chunks */
+#define ADDRMUXLEGACY		(0x1 << 19)
+#define CASWIDTH_10BITS		(0x5 << 20)
+#define RASWIDTH_13BITS		(0x2 << 24)
+#define BURSTLENGTH4		(0x2 << 0)
+#define CASL3			(0x3 << 4)
+#define SDRC_ACTIM_CTRL0_BASE	(OMAP34XX_SDRC_BASE + 0x9C)
+#define SDRC_ACTIM_CTRL1_BASE	(OMAP34XX_SDRC_BASE + 0xC4)
+#define ARE_ARCV_1		(0x1 << 0)
+#define ARCV			(0x4e2 << 8) /* Autorefresh count */
+#define OMAP34XX_SDRC_CS0	0x80000000
+#define OMAP34XX_SDRC_CS1	0xA0000000
+#define CMD_NOP			0x0
+#define CMD_PRECHARGE		0x1
+#define CMD_AUTOREFRESH		0x2
+#define CMD_ENTR_PWRDOWN	0x3
+#define CMD_EXIT_PWRDOWN	0x4
+#define CMD_ENTR_SRFRSH		0x5
+#define CMD_CKE_HIGH		0x6
+#define CMD_CKE_LOW		0x7
+#define SOFTRESET		(0x1 << 1)
+#define SMART_IDLE		(0x2 << 3)
+#define REF_ON_IDLE		(0x1 << 6)
+
+/* timer regs offsets (32 bit regs) */
+
+#ifndef __ASSEMBLY__
+typedef struct gptimer {
+	unsigned int tidr;	/* 0x00 r */
+	unsigned char res[0xc];
+	unsigned int tiocp_cfg;	/* 0x10 rw */
+	unsigned int tistat;	/* 0x14 r */
+	unsigned int tisr;	/* 0x18 rw */
+	unsigned int tier;	/* 0x1c rw */
+	unsigned int twer;	/* 0x20 rw */
+	unsigned int tclr;	/* 0x24 rw */
+	unsigned int tcrr;	/* 0x28 rw */
+	unsigned int tldr;	/* 0x2c rw */
+	unsigned int ttgr;	/* 0x30 rw */
+	unsigned int twpc;	/* 0x34 r*/
+	unsigned int tmar;	/* 0x38 rw*/
+	unsigned int tcar1;	/* 0x3c r */
+	unsigned int tcicr;	/* 0x40 rw */
+	unsigned int tcar2;	/* 0x44 r */
+} gptimer_t;
+#endif /* __ASSEMBLY__ */
+
+/* enable sys_clk NO-prescale /1 */
+#define GPT_EN			((0x0 << 2) | (0x1 << 1) | (0x1 << 0))
+
+/* Watchdog */
+#ifndef __ASSEMBLY__
+typedef struct watchdog {
+	unsigned char res1[0x34];
+	unsigned int wwps;	/* 0x34 r */
+	unsigned char res2[0x10];
+	unsigned int wspr;	/* 0x48 rw */
+} watchdog_t;
+#endif /* __ASSEMBLY__ */
+
+#define WD_UNLOCK1		0xAAAA
+#define WD_UNLOCK2		0x5555
+
+/* PRCM */
+#define PRCM_BASE		0x48004000
+
+#ifndef __ASSEMBLY__
+typedef struct prcm {
+	unsigned int fclken_iva2;	/* 0x00 */
+	unsigned int clken_pll_iva2;	/* 0x04 */
+	unsigned char res1[0x1c];
+	unsigned int idlest_pll_iva2;	/* 0x24 */
+	unsigned char res2[0x18];
+	unsigned int clksel1_pll_iva2 ;	/* 0x40 */
+	unsigned int clksel2_pll_iva2;	/* 0x44 */
+	unsigned char res3[0x8bc];
+	unsigned int clken_pll_mpu;	/* 0x904 */
+	unsigned char res4[0x1c];
+	unsigned int idlest_pll_mpu;	/* 0x924 */
+	unsigned char res5[0x18];
+	unsigned int clksel1_pll_mpu;	/* 0x940 */
+	unsigned int clksel2_pll_mpu;	/* 0x944 */
+	unsigned char res6[0xb8];
+	unsigned int fclken1_core;	/* 0xa00 */
+	unsigned char res7[0xc];
+	unsigned int iclken1_core;	/* 0xa10 */
+	unsigned int iclken2_core;	/* 0xa14 */
+	unsigned char res8[0x28];
+	unsigned int clksel_core;	/* 0xa40 */
+	unsigned char res9[0xbc];
+	unsigned int fclken_gfx;	/* 0xb00 */
+	unsigned char res10[0xc];
+	unsigned int iclken_gfx;	/* 0xb10 */
+	unsigned char res11[0x2c];
+	unsigned int clksel_gfx;	/* 0xb40 */
+	unsigned char res12[0xbc];
+	unsigned int fclken_wkup;	/* 0xc00 */
+	unsigned char res13[0xc];
+	unsigned int iclken_wkup;	/* 0xc10 */
+	unsigned char res14[0xc];
+	unsigned int idlest_wkup;	/* 0xc20 */
+	unsigned char res15[0x1c];
+	unsigned int clksel_wkup;	/* 0xc40 */
+	unsigned char res16[0xbc];
+	unsigned int clken_pll;		/* 0xd00 */
+	unsigned char res17[0x1c];
+	unsigned int idlest_ckgen;	/* 0xd20 */
+	unsigned char res18[0x1c];
+	unsigned int clksel1_pll;	/* 0xd40 */
+	unsigned int clksel2_pll;	/* 0xd44 */
+	unsigned int clksel3_pll;	/* 0xd48 */
+	unsigned char res19[0xb4];
+	unsigned int fclken_dss;	/* 0xe00 */
+	unsigned char res20[0xc];
+	unsigned int iclken_dss;	/* 0xe10 */
+	unsigned char res21[0x2c];
+	unsigned int clksel_dss;	/* 0xe40 */
+	unsigned char res22[0xbc];
+	unsigned int fclken_cam;	/* 0xf00 */
+	unsigned char res23[0xc];
+	unsigned int iclken_cam;	/* 0xf10 */
+	unsigned char res24[0x2c];
+	unsigned int clksel_cam;	/* 0xf40 */
+	unsigned char res25[0xbc];
+	unsigned int fclken_per;	/* 0x1000 */
+	unsigned char res26[0xc];
+	unsigned int iclken_per;	/* 0x1010 */
+	unsigned char res27[0x2c];
+	unsigned int clksel_per;	/* 0x1040 */
+	unsigned char res28[0xfc];
+	unsigned int clksel1_emu;	/* 0x1140 */
+} prcm_t;
+#else /* __ASSEMBLY__ */
+#define CM_CLKSEL_CORE		0x48004a40
+#define CM_CLKSEL_GFX		0x48004b40
+#define CM_CLKSEL_WKUP		0x48004c40
+#define CM_CLKEN_PLL		0x48004d00
+#define CM_CLKSEL1_PLL		0x48004d40
+#define CM_CLKSEL1_EMU		0x48005140
+#endif /* __ASSEMBLY__ */
+
+#define PRM_BASE		0x48306000
+
+#ifndef __ASSEMBLY__
+typedef struct prm {
+	unsigned char res1[0xd40];
+	unsigned int clksel;		/* 0xd40 */
+	unsigned char res2[0x50c];
+	unsigned int rstctrl;		/* 0x1250 */
+	unsigned char res3[0x1c];
+	unsigned int clksrc_ctrl;	/* 0x1270 */
+} prm_t;
+#else /* __ASSEMBLY__ */
+#define PRM_RSTCTRL		0x48307250
+#endif /* __ASSEMBLY__ */
+
+#define SYSCLKDIV_1		(0x1 << 6)
+#define SYSCLKDIV_2		(0x1 << 7)
+
+#define CLKSEL_GPT1		(0x1 << 0)
+
+#define EN_GPT1			(0x1 << 0)
+#define EN_32KSYNC		(0x1 << 2)
+
+#define ST_WDT2			(0x1 << 5)
+
+#define ST_MPU_CLK		(0x1 << 0)
+
+#define ST_CORE_CLK		(0x1 << 0)
+
+#define ST_PERIPH_CLK		(0x1 << 1)
+
+#define ST_IVA2_CLK		(0x1 << 0)
+
+#define RESETDONE		(0x1 << 0)
+
+#define TCLR_ST			(0x1 << 0)
+#define TCLR_AR			(0x1 << 1)
+#define TCLR_PRE		(0x1 << 5)
+
+/* SMX-APE */
+#define PM_RT_APE_BASE_ADDR_ARM		(SMX_APE_BASE + 0x10000)
+#define PM_GPMC_BASE_ADDR_ARM		(SMX_APE_BASE + 0x12400)
+#define PM_OCM_RAM_BASE_ADDR_ARM	(SMX_APE_BASE + 0x12800)
+#define PM_IVA2_BASE_ADDR_ARM		(SMX_APE_BASE + 0x14000)
+
+#ifndef __ASSEMBLY__
+typedef struct pm {
+	unsigned char res1[0x48];
+	unsigned int req_info_permission_0;	/* 0x48 */
+	unsigned char res2[0x4];
+	unsigned int read_permission_0;		/* 0x50 */
+	unsigned char res3[0x4];
+	unsigned int wirte_permission_0;	/* 0x58 */
+	unsigned char res4[0x4];
+	unsigned int addr_match_1;		/* 0x58 */
+	unsigned char res5[0x4];
+	unsigned int req_info_permission_1;	/* 0x68 */
+	unsigned char res6[0x14];
+	unsigned int addr_match_2;		/* 0x80 */
+} pm_t;
+#endif /*__ASSEMBLY__ */
+
+/* Permission values for registers -Full fledged permissions to all */
+#define UNLOCK_1			0xFFFFFFFF
+#define UNLOCK_2			0x00000000
+#define UNLOCK_3			0x0000FFFF
+
+#define NOT_EARLY			0
+
+/* I2C base */
+#define I2C_BASE1		(OMAP34XX_CORE_L4_IO_BASE + 0x70000)
+#define I2C_BASE2		(OMAP34XX_CORE_L4_IO_BASE + 0x72000)
+#define I2C_BASE3		(OMAP34XX_CORE_L4_IO_BASE + 0x60000)
+
+#endif /* _CPU_H */
diff -Naur u-boot-2009.01/include/asm-arm/arch-omap3/i2c.h u-boot/include/asm-arm/arch-omap3/i2c.h
--- u-boot-2009.01/include/asm-arm/arch-omap3/i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/arch-omap3/i2c.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,128 @@
+/*
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _I2C_H_
+#define _I2C_H_
+
+#define I2C_DEFAULT_BASE	I2C_BASE1
+
+#define I2C_REV		(I2C_DEFAULT_BASE + 0x00)
+#define I2C_IE 		(I2C_DEFAULT_BASE + 0x04)
+#define I2C_STAT	(I2C_DEFAULT_BASE + 0x08)
+#define I2C_IV 		(I2C_DEFAULT_BASE + 0x0c)
+#define I2C_BUF		(I2C_DEFAULT_BASE + 0x14)
+#define I2C_CNT		(I2C_DEFAULT_BASE + 0x18)
+#define I2C_DATA	(I2C_DEFAULT_BASE + 0x1c)
+#define I2C_SYSC	(I2C_DEFAULT_BASE + 0x20)
+#define I2C_CON		(I2C_DEFAULT_BASE + 0x24)
+#define I2C_OA 		(I2C_DEFAULT_BASE + 0x28)
+#define I2C_SA 		(I2C_DEFAULT_BASE + 0x2c)
+#define I2C_PSC		(I2C_DEFAULT_BASE + 0x30)
+#define I2C_SCLL	(I2C_DEFAULT_BASE + 0x34)
+#define I2C_SCLH	(I2C_DEFAULT_BASE + 0x38)
+#define I2C_SYSTEST	(I2C_DEFAULT_BASE + 0x3c)
+
+/* I2C masks */
+
+/* I2C Interrupt Enable Register (I2C_IE): */
+#define I2C_IE_GC_IE	(1 << 5)
+#define I2C_IE_XRDY_IE	(1 << 4) /* Transmit data ready interrupt enable */
+#define I2C_IE_RRDY_IE	(1 << 3) /* Receive data ready interrupt enable */
+#define I2C_IE_ARDY_IE	(1 << 2) /* Register access ready interrupt enable */
+#define I2C_IE_NACK_IE	(1 << 1) /* No acknowledgment interrupt enable */
+#define I2C_IE_AL_IE	(1 << 0) /* Arbitration lost interrupt enable */
+
+/* I2C Status Register (I2C_STAT): */
+
+#define I2C_STAT_SBD	(1 << 15) /* Single byte data */
+#define I2C_STAT_BB	(1 << 12) /* Bus busy */
+#define I2C_STAT_ROVR	(1 << 11) /* Receive overrun */
+#define I2C_STAT_XUDF	(1 << 10) /* Transmit underflow */
+#define I2C_STAT_AAS	(1 << 9)  /* Address as slave */
+#define I2C_STAT_GC	(1 << 5)
+#define I2C_STAT_XRDY	(1 << 4)  /* Transmit data ready */
+#define I2C_STAT_RRDY	(1 << 3)  /* Receive data ready */
+#define I2C_STAT_ARDY	(1 << 2)  /* Register access ready */
+#define I2C_STAT_NACK	(1 << 1)  /* No acknowledgment interrupt enable */
+#define I2C_STAT_AL	(1 << 0)  /* Arbitration lost interrupt enable */
+
+/* I2C Interrupt Code Register (I2C_INTCODE): */
+
+#define I2C_INTCODE_MASK	7
+#define I2C_INTCODE_NONE	0
+#define I2C_INTCODE_AL		1	/* Arbitration lost */
+#define I2C_INTCODE_NAK		2	/* No acknowledgement/general call */
+#define I2C_INTCODE_ARDY	3	/* Register access ready */
+#define I2C_INTCODE_RRDY	4	/* Rcv data ready */
+#define I2C_INTCODE_XRDY	5	/* Xmit data ready */
+
+/* I2C Buffer Configuration Register (I2C_BUF): */
+
+#define I2C_BUF_RDMA_EN		(1 << 15) /* Receive DMA channel enable */
+#define I2C_BUF_XDMA_EN		(1 << 7)  /* Transmit DMA channel enable */
+
+/* I2C Configuration Register (I2C_CON): */
+
+#define I2C_CON_EN	(1 << 15)  /* I2C module enable */
+#define I2C_CON_BE	(1 << 14)  /* Big endian mode */
+#define I2C_CON_STB	(1 << 11)  /* Start byte mode (master mode only) */
+#define I2C_CON_MST	(1 << 10)  /* Master/slave mode */
+#define I2C_CON_TRX	(1 << 9)   /* Transmitter/receiver mode */
+				   /* (master mode only) */
+#define I2C_CON_XA	(1 << 8)   /* Expand address */
+#define I2C_CON_STP	(1 << 1)   /* Stop condition (master mode only) */
+#define I2C_CON_STT	(1 << 0)   /* Start condition (master mode only) */
+
+/* I2C System Test Register (I2C_SYSTEST): */
+
+#define I2C_SYSTEST_ST_EN	(1 << 15) /* System test enable */
+#define I2C_SYSTEST_FREE	(1 << 14) /* Free running mode, on brkpoint) */
+#define I2C_SYSTEST_TMODE_MASK	(3 << 12) /* Test mode select */
+#define I2C_SYSTEST_TMODE_SHIFT	(12)	  /* Test mode select */
+#define I2C_SYSTEST_SCL_I	(1 << 3)  /* SCL line sense input value */
+#define I2C_SYSTEST_SCL_O	(1 << 2)  /* SCL line drive output value */
+#define I2C_SYSTEST_SDA_I	(1 << 1)  /* SDA line sense input value */
+#define I2C_SYSTEST_SDA_O	(1 << 0)  /* SDA line drive output value */
+
+#define I2C_SCLL_SCLL		0
+#define I2C_SCLL_SCLL_M		0xFF
+#define I2C_SCLL_HSSCLL		8
+#define I2C_SCLH_HSSCLL_M	0xFF
+#define I2C_SCLH_SCLH		0
+#define I2C_SCLH_SCLH_M		0xFF
+#define I2C_SCLH_HSSCLH		8
+#define I2C_SCLH_HSSCLH_M	0xFF
+
+#define OMAP_I2C_STANDARD	100
+#define OMAP_I2C_FAST_MODE	400
+#define OMAP_I2C_HIGH_SPEED	3400
+
+#define SYSTEM_CLOCK_12		12000
+#define SYSTEM_CLOCK_13		13000
+#define SYSTEM_CLOCK_192	19200
+#define SYSTEM_CLOCK_96		96000
+
+#define I2C_IP_CLK		SYSTEM_CLOCK_96
+#define I2C_PSC_MAX		0x0f
+#define I2C_PSC_MIN		0x00
+
+#endif /* _I2C_H_ */
diff -Naur u-boot-2009.01/include/asm-arm/arch-omap3/mem.h u-boot/include/asm-arm/arch-omap3/mem.h
--- u-boot-2009.01/include/asm-arm/arch-omap3/mem.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/arch-omap3/mem.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,227 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _MEM_H_
+#define _MEM_H_
+
+#define CS0		0x0
+#define CS1		0x1 /* mirror CS1 regs appear offset 0x30 from CS0 */
+
+#ifndef __ASSEMBLY__
+typedef enum {
+	STACKED = 0,
+	IP_DDR = 1,
+	COMBO_DDR = 2,
+	IP_SDR = 3,
+} mem_t;
+#endif /* __ASSEMBLY__ */
+
+#define EARLY_INIT	1
+
+/* Slower full frequency range default timings for x32 operation*/
+#define SDP_SDRC_SHARING	0x00000100
+#define SDP_SDRC_MR_0_SDR	0x00000031
+
+/* optimized timings good for current shipping parts */
+#define SDP_3430_SDRC_RFR_CTRL_165MHz	0x0004e201 /* 7.8us/6ns - 50=0x4e2 */
+
+#define DLL_OFFSET		0
+#define DLL_WRITEDDRCLKX2DIS	1
+#define DLL_ENADLL		1
+#define DLL_LOCKDLL		0
+#define DLL_DLLPHASE_72		0
+#define DLL_DLLPHASE_90		1
+
+/* rkw - need to find of 90/72 degree recommendation for speed like before */
+#define SDP_SDRC_DLLAB_CTRL	((DLL_ENADLL << 3) | \
+				(DLL_LOCKDLL << 2) | (DLL_DLLPHASE_90 << 1))
+
+/* Infineon part of 3430SDP (165MHz optimized) 6.06ns
+ *   ACTIMA
+ *	TDAL = Twr/Tck + Trp/tck = 15/6 + 18/6 = 2.5 + 3 = 5.5 -> 6
+ *	TDPL (Twr) = 15/6	= 2.5 -> 3
+ *	TRRD = 12/6	= 2
+ *	TRCD = 18/6	= 3
+ *	TRP = 18/6	= 3
+ *	TRAS = 42/6	= 7
+ *	TRC = 60/6	= 10
+ *	TRFC = 72/6	= 12
+ *   ACTIMB
+ *	TCKE = 2
+ *	XSR = 120/6 = 20
+ */
+#define TDAL_165	6
+#define TDPL_165	3
+#define TRRD_165	2
+#define TRCD_165	3
+#define TRP_165		3
+#define TRAS_165	7
+#define TRC_165		10
+#define TRFC_165	21
+#define V_ACTIMA_165	((TRFC_165 << 27) | (TRC_165 << 22) | \
+			(TRAS_165 << 18) | (TRP_165 << 15) |  \
+			(TRCD_165 << 12) | (TRRD_165 << 9) |  \
+			(TDPL_165 << 6) | (TDAL_165))
+
+#define TWTR_165	1
+#define TCKE_165	1
+#define TXP_165		5
+#define XSR_165		23
+#define V_ACTIMB_165	(((TCKE_165 << 12) | (XSR_165 << 0)) |	\
+			(TXP_165 << 8) | (TWTR_165 << 16))
+
+#define SDP_SDRC_ACTIM_CTRLA_0	V_ACTIMA_165
+#define SDP_SDRC_ACTIM_CTRLB_0	V_ACTIMB_165
+#define SDP_SDRC_RFR_CTRL	SDP_3430_SDRC_RFR_CTRL_165MHz
+
+/*
+ * GPMC settings -
+ * Definitions is as per the following format
+ * #define <PART>_GPMC_CONFIG<x> <value>
+ * Where:
+ * PART is the part name e.g. STNOR - Intel Strata Flash
+ * x is GPMC config registers from 1 to 6 (there will be 6 macros)
+ * Value is corresponding value
+ *
+ * For every valid PRCM configuration there should be only one definition of
+ * the same. if values are independent of the board, this definition will be
+ * present in this file if values are dependent on the board, then this should
+ * go into corresponding mem-boardName.h file
+ *
+ * Currently valid part Names are (PART):
+ * STNOR - Intel Strata Flash
+ * SMNAND - Samsung NAND
+ * MPDB - H4 MPDB board
+ * SBNOR - Sibley NOR
+ * MNAND - Micron Large page x16 NAND
+ * ONNAND - Samsung One NAND
+ *
+ * include/configs/file.h contains the defn - for all CS we are interested
+ * #define OMAP34XX_GPMC_CSx PART
+ * #define OMAP34XX_GPMC_CSx_SIZE Size
+ * #define OMAP34XX_GPMC_CSx_MAP Map
+ * Where:
+ * x - CS number
+ * PART - Part Name as defined above
+ * SIZE - how big is the mapping to be
+ *   GPMC_SIZE_128M - 0x8
+ *   GPMC_SIZE_64M  - 0xC
+ *   GPMC_SIZE_32M  - 0xE
+ *   GPMC_SIZE_16M  - 0xF
+ * MAP  - Map this CS to which address(GPMC address space)- Absolute address
+ *   >>24 before being used.
+ */
+#define GPMC_SIZE_128M	0x8
+#define GPMC_SIZE_64M	0xC
+#define GPMC_SIZE_32M	0xE
+#define GPMC_SIZE_16M	0xF
+
+#define SMNAND_GPMC_CONFIG1	0x00000800
+#define SMNAND_GPMC_CONFIG2	0x00141400
+#define SMNAND_GPMC_CONFIG3	0x00141400
+#define SMNAND_GPMC_CONFIG4	0x0F010F01
+#define SMNAND_GPMC_CONFIG5	0x010C1414
+#define SMNAND_GPMC_CONFIG6	0x1F0F0A80
+#define SMNAND_GPMC_CONFIG7	0x00000C44
+
+#define M_NAND_GPMC_CONFIG1	0x00001800
+#define M_NAND_GPMC_CONFIG2	0x00141400
+#define M_NAND_GPMC_CONFIG3	0x00141400
+#define M_NAND_GPMC_CONFIG4	0x0F010F01
+#define M_NAND_GPMC_CONFIG5	0x010C1414
+#define M_NAND_GPMC_CONFIG6	0x1f0f0A80
+#define M_NAND_GPMC_CONFIG7	0x00000C44
+
+#define STNOR_GPMC_CONFIG1	0x3
+#define STNOR_GPMC_CONFIG2	0x00151501
+#define STNOR_GPMC_CONFIG3	0x00060602
+#define STNOR_GPMC_CONFIG4	0x11091109
+#define STNOR_GPMC_CONFIG5	0x01141F1F
+#define STNOR_GPMC_CONFIG6	0x000004c4
+
+#define SIBNOR_GPMC_CONFIG1	0x1200
+#define SIBNOR_GPMC_CONFIG2	0x001f1f00
+#define SIBNOR_GPMC_CONFIG3	0x00080802
+#define SIBNOR_GPMC_CONFIG4	0x1C091C09
+#define SIBNOR_GPMC_CONFIG5	0x01131F1F
+#define SIBNOR_GPMC_CONFIG6	0x1F0F03C2
+
+#define SDPV2_MPDB_GPMC_CONFIG1	0x00611200
+#define SDPV2_MPDB_GPMC_CONFIG2	0x001F1F01
+#define SDPV2_MPDB_GPMC_CONFIG3	0x00080803
+#define SDPV2_MPDB_GPMC_CONFIG4	0x1D091D09
+#define SDPV2_MPDB_GPMC_CONFIG5	0x041D1F1F
+#define SDPV2_MPDB_GPMC_CONFIG6	0x1D0904C4
+
+#define MPDB_GPMC_CONFIG1	0x00011000
+#define MPDB_GPMC_CONFIG2	0x001f1f01
+#define MPDB_GPMC_CONFIG3	0x00080803
+#define MPDB_GPMC_CONFIG4	0x1c0b1c0a
+#define MPDB_GPMC_CONFIG5	0x041f1F1F
+#define MPDB_GPMC_CONFIG6	0x1F0F04C4
+
+#define P2_GPMC_CONFIG1	0x0
+#define P2_GPMC_CONFIG2	0x0
+#define P2_GPMC_CONFIG3	0x0
+#define P2_GPMC_CONFIG4	0x0
+#define P2_GPMC_CONFIG5	0x0
+#define P2_GPMC_CONFIG6	0x0
+
+#define ONENAND_GPMC_CONFIG1	0x00001200
+#define ONENAND_GPMC_CONFIG2	0x000F0F01
+#define ONENAND_GPMC_CONFIG3	0x00030301
+#define ONENAND_GPMC_CONFIG4	0x0F040F04
+#define ONENAND_GPMC_CONFIG5	0x010F1010
+#define ONENAND_GPMC_CONFIG6	0x1F060000
+
+#define NET_GPMC_CONFIG1	0x00001000
+#define NET_GPMC_CONFIG2	0x001e1e01
+#define NET_GPMC_CONFIG3	0x00080300
+#define NET_GPMC_CONFIG4	0x1c091c09
+#define NET_GPMC_CONFIG5	0x04181f1f
+#define NET_GPMC_CONFIG6	0x00000FCF
+#define NET_GPMC_CONFIG7	0x00000f6c
+
+/* max number of GPMC Chip Selects */
+#define GPMC_MAX_CS	8
+/* max number of GPMC regs */
+#define GPMC_MAX_REG	7
+
+#define PISMO1_NOR	1
+#define PISMO1_NAND	2
+#define PISMO2_CS0	3
+#define PISMO2_CS1	4
+#define PISMO1_ONENAND	5
+#define DBG_MPDB	6
+#define PISMO2_NAND_CS0 7
+#define PISMO2_NAND_CS1 8
+
+/* make it readable for the gpmc_init */
+#define PISMO1_NOR_BASE		FLASH_BASE
+#define PISMO1_NAND_BASE	NAND_BASE
+#define PISMO2_CS0_BASE		PISMO2_MAP1
+#define PISMO1_ONEN_BASE	ONENAND_MAP
+#define DBG_MPDB_BASE		DEBUG_BASE
+
+#endif /* endif _MEM_H_ */
diff -Naur u-boot-2009.01/include/asm-arm/arch-omap3/mmc.h u-boot/include/asm-arm/arch-omap3/mmc.h
--- u-boot-2009.01/include/asm-arm/arch-omap3/mmc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/arch-omap3/mmc.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,235 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation's version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef MMC_H
+#define MMC_H
+
+#include "mmc_host_def.h"
+
+/* Responses */
+#define RSP_TYPE_NONE	(RSP_TYPE_NORSP   | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R1	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R1B	(RSP_TYPE_LGHT48B | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R2	(RSP_TYPE_LGHT136 | CCCE_CHECK   | CICE_NOCHECK)
+#define RSP_TYPE_R3	(RSP_TYPE_LGHT48  | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R4	(RSP_TYPE_LGHT48  | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R5	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R6	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R7	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+
+/* All supported commands */
+#define MMC_CMD0	(INDEX(0)  | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD1	(INDEX(1)  | RSP_TYPE_R3   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD2	(INDEX(2)  | RSP_TYPE_R2   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD3	(INDEX(3)  | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_SDCMD3	(INDEX(3)  | RSP_TYPE_R6   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD4	(INDEX(4)  | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD6	(INDEX(6)  | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD7_SELECT	(INDEX(7)  | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD7_DESELECT (INDEX(7)| RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD8	(INDEX(8)  | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
+#define MMC_SDCMD8	(INDEX(8)  | RSP_TYPE_R7   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD9	(INDEX(9)  | RSP_TYPE_R2   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD12	(INDEX(12) | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD13	(INDEX(13) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD15	(INDEX(15) | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD16	(INDEX(16) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD17	(INDEX(17) | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
+#define MMC_CMD24	(INDEX(24) | RSP_TYPE_R1   | DP_DATA    | DDIR_WRITE)
+#define MMC_ACMD6	(INDEX(6)  | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_ACMD41	(INDEX(41) | RSP_TYPE_R3   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_ACMD51	(INDEX(51) | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
+#define MMC_CMD55	(INDEX(55) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+
+#define MMC_AC_CMD_RCA_MASK	(unsigned int)(0xFFFF << 16)
+#define MMC_BC_CMD_DSR_MASK	(unsigned int)(0xFFFF << 16)
+#define MMC_DSR_DEFAULT		0x0404
+#define SD_CMD8_CHECK_PATTERN	0xAA
+#define SD_CMD8_2_7_3_6_V_RANGE	(0x01 << 8)
+
+/* Clock Configurations and Macros */
+
+#define MMC_CLOCK_REFERENCE		96
+#define MMC_RELATIVE_CARD_ADDRESS	0x1234
+#define MMC_INIT_SEQ_CLK		(MMC_CLOCK_REFERENCE * 1000 / 80)
+#define MMC_400kHz_CLK			(MMC_CLOCK_REFERENCE * 1000 / 400)
+#define CLKDR(r, f, u)			((((r)*100) / ((f)*(u))) + 1)
+#define CLKD(f, u)			(CLKDR(MMC_CLOCK_REFERENCE, f, u))
+
+#define MMC_OCR_REG_ACCESS_MODE_MASK	(0x3 << 29)
+#define MMC_OCR_REG_ACCESS_MODE_BYTE 	(0x0 << 29)
+#define MMC_OCR_REG_ACCESS_MODE_SECTOR	(0x2 << 29)
+
+#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK		(0x1 << 30)
+#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_BYTE		(0x0 << 30)
+#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR	(0x1 << 30)
+
+#define MMC_SD2_CSD_C_SIZE_LSB_MASK	0xFFFF
+#define MMC_SD2_CSD_C_SIZE_MSB_MASK	0x003F
+#define MMC_SD2_CSD_C_SIZE_MSB_OFFSET	16
+#define MMC_CSD_C_SIZE_LSB_MASK		0x0003
+#define MMC_CSD_C_SIZE_MSB_MASK		0x03FF
+#define MMC_CSD_C_SIZE_MSB_OFFSET	2
+
+#define MMC_CSD_TRAN_SPEED_UNIT_MASK	(0x07 << 0)
+#define MMC_CSD_TRAN_SPEED_FACTOR_MASK	(0x0F << 3)
+#define MMC_CSD_TRAN_SPEED_UNIT_100MHZ	(0x3 << 0)
+#define MMC_CSD_TRAN_SPEED_FACTOR_1_0	(0x01 << 3)
+#define MMC_CSD_TRAN_SPEED_FACTOR_8_0	(0x0F << 3)
+
+typedef struct {
+	unsigned not_used:1;
+	unsigned crc:7;
+	unsigned ecc:2;
+	unsigned file_format:2;
+	unsigned tmp_write_protect:1;
+	unsigned perm_write_protect:1;
+	unsigned copy:1;
+	unsigned file_format_grp:1;
+	unsigned content_prot_app:1;
+	unsigned reserved_1:4;
+	unsigned write_bl_partial:1;
+	unsigned write_bl_len:4;
+	unsigned r2w_factor:3;
+	unsigned default_ecc:2;
+	unsigned wp_grp_enable:1;
+	unsigned wp_grp_size:5;
+	unsigned erase_grp_mult:5;
+	unsigned erase_grp_size:5;
+	unsigned c_size_mult:3;
+	unsigned vdd_w_curr_max:3;
+	unsigned vdd_w_curr_min:3;
+	unsigned vdd_r_curr_max:3;
+	unsigned vdd_r_curr_min:3;
+	unsigned c_size_lsb:2;
+	unsigned c_size_msb:10;
+	unsigned reserved_2:2;
+	unsigned dsr_imp:1;
+	unsigned read_blk_misalign:1;
+	unsigned write_blk_misalign:1;
+	unsigned read_bl_partial:1;
+	unsigned read_bl_len:4;
+	unsigned ccc:12;
+	unsigned tran_speed:8;
+	unsigned nsac:8;
+	unsigned taac:8;
+	unsigned reserved_3:2;
+	unsigned spec_vers:4;
+	unsigned csd_structure:2;
+} mmc_csd_reg_t;
+
+/* csd for sd2.0 */
+typedef struct {
+	unsigned not_used:1;
+	unsigned crc:7;
+	unsigned reserved_1:2;
+	unsigned file_format:2;
+	unsigned tmp_write_protect:1;
+	unsigned perm_write_protect:1;
+	unsigned copy:1;
+	unsigned file_format_grp:1;
+	unsigned reserved_2:5;
+	unsigned write_bl_partial:1;
+	unsigned write_bl_len:4;
+	unsigned r2w_factor:3;
+	unsigned reserved_3:2;
+	unsigned wp_grp_enable:1;
+	unsigned wp_grp_size:7;
+	unsigned sector_size:7;
+	unsigned erase_blk_len:1;
+	unsigned reserved_4:1;
+	unsigned c_size_lsb:16;
+	unsigned c_size_msb:6;
+	unsigned reserved_5:6;
+	unsigned dsr_imp:1;
+	unsigned read_blk_misalign:1;
+	unsigned write_blk_misalign:1;
+	unsigned read_bl_partial:1;
+	unsigned read_bl_len:4;
+	unsigned ccc:12;
+	unsigned tran_speed:8;
+	unsigned nsac:8;
+	unsigned taac:8;
+	unsigned reserved_6:6;
+	unsigned csd_structure:2;
+} mmc_sd2_csd_reg_t;
+
+/* extended csd - 512 bytes long */
+typedef struct {
+	unsigned char reserved_1[181];
+	unsigned char erasedmemorycontent;
+	unsigned char reserved_2;
+	unsigned char buswidthmode;
+	unsigned char reserved_3;
+	unsigned char highspeedinterfacetiming;
+	unsigned char reserved_4;
+	unsigned char powerclass;
+	unsigned char reserved_5;
+	unsigned char commandsetrevision;
+	unsigned char reserved_6;
+	unsigned char commandset;
+	unsigned char extendedcsdrevision;
+	unsigned char reserved_7;
+	unsigned char csdstructureversion;
+	unsigned char reserved_8;
+	unsigned char cardtype;
+	unsigned char reserved_9[3];
+	unsigned char powerclass_52mhz_1_95v;
+	unsigned char powerclass_26mhz_1_95v;
+	unsigned char powerclass_52mhz_3_6v;
+	unsigned char powerclass_26mhz_3_6v;
+	unsigned char reserved_10;
+	unsigned char minreadperf_4b_26mhz;
+	unsigned char minwriteperf_4b_26mhz;
+	unsigned char minreadperf_8b_26mhz_4b_52mhz;
+	unsigned char minwriteperf_8b_26mhz_4b_52mhz;
+	unsigned char minreadperf_8b_52mhz;
+	unsigned char minwriteperf_8b_52mhz;
+	unsigned char reserved_11;
+	unsigned int sectorcount;
+	unsigned char reserved_12[288];
+	unsigned char supportedcommandsets;
+	unsigned char reserved_13[7];
+} mmc_extended_csd_reg_t;
+
+/* mmc sd responce */
+typedef struct {
+	unsigned int ocr;
+} mmc_resp_r3;
+
+typedef struct {
+	unsigned short cardstatus;
+	unsigned short newpublishedrca;
+} mmc_resp_r6;
+
+extern mmc_card_data mmc_dev;
+
+unsigned char mmc_lowlevel_init(void);
+unsigned char mmc_send_command(unsigned int cmd, unsigned int arg,
+			       unsigned int *response);
+unsigned char mmc_setup_clock(unsigned int iclk, unsigned short clkd);
+unsigned char mmc_set_opendrain(unsigned char state);
+unsigned char mmc_read_data(unsigned int *output_buf);
+
+#endif /* MMC_H */
diff -Naur u-boot-2009.01/include/asm-arm/arch-omap3/mmc_host_def.h u-boot/include/asm-arm/arch-omap3/mmc_host_def.h
--- u-boot-2009.01/include/asm-arm/arch-omap3/mmc_host_def.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/arch-omap3/mmc_host_def.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,184 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation's version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef MMC_HOST_DEF_H
+#define MMC_HOST_DEF_H
+
+/* T2 Register definitions */
+#define T2_BASE			0x48002000
+
+typedef struct t2 {
+	unsigned char res1[0x274];
+	unsigned int devconf0;		/* 0x274 */
+	unsigned char res2[0x2A8];
+	unsigned int pbias_lite;	/* 0x520 */
+} t2_t;
+
+#define MMCSDIO1ADPCLKISEL		(1 << 24)
+
+#define PBIASLITEPWRDNZ0		(1 << 1)
+#define PBIASSPEEDCTRL0			(1 << 2)
+#define PBIASLITEPWRDNZ1		(1 << 9)
+
+/*
+ * OMAP HSMMC register definitions
+ */
+#define OMAP_HSMMC_BASE		0x4809C000
+
+typedef struct hsmmc {
+	unsigned char res1[0x10];
+	unsigned int sysconfig;		/* 0x10 */
+	unsigned int sysstatus;		/* 0x14 */
+	unsigned char res2[0x14];
+	unsigned int con;		/* 0x2C */
+	unsigned char res3[0xD4];
+	unsigned int blk;		/* 0x104 */
+	unsigned int arg;		/* 0x108 */
+	unsigned int cmd;		/* 0x10C */
+	unsigned int rsp10;		/* 0x110 */
+	unsigned int rsp32;		/* 0x114 */
+	unsigned int rsp54;		/* 0x118 */
+	unsigned int rsp76;		/* 0x11C */
+	unsigned int data;		/* 0x120 */
+	unsigned int pstate;		/* 0x124 */
+	unsigned int hctl;		/* 0x128 */
+	unsigned int sysctl;		/* 0x12C */
+	unsigned int stat;		/* 0x130 */
+	unsigned int ie;		/* 0x134 */
+	unsigned char res4[0x8];
+	unsigned int capa;		/* 0x140 */
+} hsmmc_t;
+
+/*
+ * OMAP HS MMC Bit definitions
+ */
+#define MMC_SOFTRESET			(0x1 << 1)
+#define RESETDONE			(0x1 << 0)
+#define NOOPENDRAIN			(0x0 << 0)
+#define OPENDRAIN			(0x1 << 0)
+#define OD				(0x1 << 0)
+#define INIT_NOINIT			(0x0 << 1)
+#define INIT_INITSTREAM			(0x1 << 1)
+#define HR_NOHOSTRESP			(0x0 << 2)
+#define STR_BLOCK 			(0x0 << 3)
+#define MODE_FUNC			(0x0 << 4)
+#define DW8_1_4BITMODE 			(0x0 << 5)
+#define MIT_CTO				(0x0 << 6)
+#define CDP_ACTIVEHIGH			(0x0 << 7)
+#define WPP_ACTIVEHIGH 			(0x0 << 8)
+#define RESERVED_MASK			(0x3 << 9)
+#define CTPL_MMC_SD 			(0x0 << 11)
+#define BLEN_512BYTESLEN		(0x200 << 0)
+#define NBLK_STPCNT			(0x0 << 16)
+#define DE_DISABLE			(0x0 << 0)
+#define BCE_DISABLE			(0x0 << 1)
+#define ACEN_DISABLE			(0x0 << 2)
+#define DDIR_OFFSET			(4)
+#define DDIR_MASK			(0x1 << 4)
+#define DDIR_WRITE			(0x0 << 4)
+#define DDIR_READ			(0x1 << 4)
+#define MSBS_SGLEBLK			(0x0 << 5)
+#define RSP_TYPE_OFFSET			(16)
+#define RSP_TYPE_MASK			(0x3 << 16)
+#define RSP_TYPE_NORSP			(0x0 << 16)
+#define RSP_TYPE_LGHT136		(0x1 << 16)
+#define RSP_TYPE_LGHT48			(0x2 << 16)
+#define RSP_TYPE_LGHT48B		(0x3 << 16)
+#define CCCE_NOCHECK			(0x0 << 19)
+#define CCCE_CHECK			(0x1 << 19)
+#define CICE_NOCHECK			(0x0 << 20)
+#define CICE_CHECK			(0x1 << 20)
+#define DP_OFFSET			(21)
+#define DP_MASK				(0x1 << 21)
+#define DP_NO_DATA			(0x0 << 21)
+#define DP_DATA				(0x1 << 21)
+#define CMD_TYPE_NORMAL			(0x0 << 22)
+#define INDEX_OFFSET			(24)
+#define INDEX_MASK			(0x3f << 24)
+#define INDEX(i)			(i << 24)
+#define DATI_MASK			(0x1 << 1)
+#define DATI_CMDDIS			(0x1 << 1)
+#define DTW_1_BITMODE			(0x0 << 1)
+#define DTW_4_BITMODE			(0x1 << 1)
+#define SDBP_PWROFF			(0x0 << 8)
+#define SDBP_PWRON			(0x1 << 8)
+#define SDVS_1V8			(0x5 << 9)
+#define SDVS_3V0			(0x6 << 9)
+#define ICE_MASK			(0x1 << 0)
+#define ICE_STOP			(0x0 << 0)
+#define ICS_MASK			(0x1 << 1)
+#define ICS_NOTREADY			(0x0 << 1)
+#define ICE_OSCILLATE			(0x1 << 0)
+#define CEN_MASK			(0x1 << 2)
+#define CEN_DISABLE			(0x0 << 2)
+#define CEN_ENABLE			(0x1 << 2)
+#define CLKD_OFFSET			(6)
+#define CLKD_MASK			(0x3FF << 6)
+#define DTO_MASK			(0xF << 16)
+#define DTO_15THDTO			(0xE << 16)
+#define SOFTRESETALL			(0x1 << 24)
+#define CC_MASK				(0x1 << 0)
+#define TC_MASK				(0x1 << 1)
+#define BWR_MASK			(0x1 << 4)
+#define BRR_MASK			(0x1 << 5)
+#define ERRI_MASK			(0x1 << 15)
+#define IE_CC				(0x01 << 0)
+#define IE_TC				(0x01 << 1)
+#define IE_BWR				(0x01 << 4)
+#define IE_BRR				(0x01 << 5)
+#define IE_CTO				(0x01 << 16)
+#define IE_CCRC				(0x01 << 17)
+#define IE_CEB				(0x01 << 18)
+#define IE_CIE				(0x01 << 19)
+#define IE_DTO				(0x01 << 20)
+#define IE_DCRC				(0x01 << 21)
+#define IE_DEB				(0x01 << 22)
+#define IE_CERR				(0x01 << 28)
+#define IE_BADA				(0x01 << 29)
+
+#define VS30_3V0SUP			(1 << 25)
+#define VS18_1V8SUP			(1 << 26)
+
+/* Driver definitions */
+#define MMCSD_SECTOR_SIZE		512
+#define MMC_CARD			0
+#define SD_CARD				1
+#define BYTE_MODE			0
+#define SECTOR_MODE			1
+#define CLK_INITSEQ			0
+#define CLK_400KHZ			1
+#define CLK_MISC			2
+
+typedef struct {
+	unsigned int card_type;
+	unsigned int version;
+	unsigned int mode;
+	unsigned int size;
+	unsigned int RCA;
+} mmc_card_data;
+
+#define mmc_reg_out(addr, mask, val)\
+	writel((readl(addr) & (~(mask))) | ((val) & (mask)), (addr))
+
+#endif /* MMC_HOST_DEF_H */
diff -Naur u-boot-2009.01/include/asm-arm/arch-omap3/mux.h u-boot/include/asm-arm/arch-omap3/mux.h
--- u-boot-2009.01/include/asm-arm/arch-omap3/mux.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/arch-omap3/mux.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,412 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <x0khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _MUX_H_
+#define _MUX_H_
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ */
+
+#define IEN	(1 << 8)
+
+#define IDIS	(0 << 8)
+#define PTU	(1 << 4)
+#define PTD	(0 << 4)
+#define EN	(1 << 3)
+#define DIS	(0 << 3)
+
+#define M0	0
+#define M1	1
+#define M2	2
+#define M3	3
+#define M4	4
+#define M5	5
+#define M6	6
+#define M7	7
+
+/*
+ * To get the actual address the offset has to added
+ * with OMAP34XX_CTRL_BASE to get the actual address
+ */
+
+/*SDRC*/
+#define CONTROL_PADCONF_SDRC_D0		0x0030
+#define CONTROL_PADCONF_SDRC_D1		0x0032
+#define CONTROL_PADCONF_SDRC_D2		0x0034
+#define CONTROL_PADCONF_SDRC_D3		0x0036
+#define CONTROL_PADCONF_SDRC_D4		0x0038
+#define CONTROL_PADCONF_SDRC_D5		0x003A
+#define CONTROL_PADCONF_SDRC_D6		0x003C
+#define CONTROL_PADCONF_SDRC_D7		0x003E
+#define CONTROL_PADCONF_SDRC_D8		0x0040
+#define CONTROL_PADCONF_SDRC_D9		0x0042
+#define CONTROL_PADCONF_SDRC_D10	0x0044
+#define CONTROL_PADCONF_SDRC_D11	0x0046
+#define CONTROL_PADCONF_SDRC_D12	0x0048
+#define CONTROL_PADCONF_SDRC_D13	0x004A
+#define CONTROL_PADCONF_SDRC_D14	0x004C
+#define CONTROL_PADCONF_SDRC_D15	0x004E
+#define CONTROL_PADCONF_SDRC_D16	0x0050
+#define CONTROL_PADCONF_SDRC_D17	0x0052
+#define CONTROL_PADCONF_SDRC_D18	0x0054
+#define CONTROL_PADCONF_SDRC_D19	0x0056
+#define CONTROL_PADCONF_SDRC_D20	0x0058
+#define CONTROL_PADCONF_SDRC_D21	0x005A
+#define CONTROL_PADCONF_SDRC_D22	0x005C
+#define CONTROL_PADCONF_SDRC_D23	0x005E
+#define CONTROL_PADCONF_SDRC_D24	0x0060
+#define CONTROL_PADCONF_SDRC_D25	0x0062
+#define CONTROL_PADCONF_SDRC_D26	0x0064
+#define CONTROL_PADCONF_SDRC_D27	0x0066
+#define CONTROL_PADCONF_SDRC_D28	0x0068
+#define CONTROL_PADCONF_SDRC_D29	0x006A
+#define CONTROL_PADCONF_SDRC_D30	0x006C
+#define CONTROL_PADCONF_SDRC_D31	0x006E
+#define CONTROL_PADCONF_SDRC_CLK	0x0070
+#define CONTROL_PADCONF_SDRC_DQS0	0x0072
+#define CONTROL_PADCONF_SDRC_DQS1	0x0074
+#define CONTROL_PADCONF_SDRC_DQS2	0x0076
+#define CONTROL_PADCONF_SDRC_DQS3	0x0078
+/*GPMC*/
+#define CONTROL_PADCONF_GPMC_A1		0x007A
+#define CONTROL_PADCONF_GPMC_A2		0x007C
+#define CONTROL_PADCONF_GPMC_A3		0x007E
+#define CONTROL_PADCONF_GPMC_A4		0x0080
+#define CONTROL_PADCONF_GPMC_A5		0x0082
+#define CONTROL_PADCONF_GPMC_A6		0x0084
+#define CONTROL_PADCONF_GPMC_A7		0x0086
+#define CONTROL_PADCONF_GPMC_A8		0x0088
+#define CONTROL_PADCONF_GPMC_A9		0x008A
+#define CONTROL_PADCONF_GPMC_A10	0x008C
+#define CONTROL_PADCONF_GPMC_D0		0x008E
+#define CONTROL_PADCONF_GPMC_D1		0x0090
+#define CONTROL_PADCONF_GPMC_D2		0x0092
+#define CONTROL_PADCONF_GPMC_D3		0x0094
+#define CONTROL_PADCONF_GPMC_D4		0x0096
+#define CONTROL_PADCONF_GPMC_D5		0x0098
+#define CONTROL_PADCONF_GPMC_D6		0x009A
+#define CONTROL_PADCONF_GPMC_D7		0x009C
+#define CONTROL_PADCONF_GPMC_D8		0x009E
+#define CONTROL_PADCONF_GPMC_D9		0x00A0
+#define CONTROL_PADCONF_GPMC_D10	0x00A2
+#define CONTROL_PADCONF_GPMC_D11	0x00A4
+#define CONTROL_PADCONF_GPMC_D12	0x00A6
+#define CONTROL_PADCONF_GPMC_D13	0x00A8
+#define CONTROL_PADCONF_GPMC_D14	0x00AA
+#define CONTROL_PADCONF_GPMC_D15	0x00AC
+#define CONTROL_PADCONF_GPMC_NCS0	0x00AE
+#define CONTROL_PADCONF_GPMC_NCS1	0x00B0
+#define CONTROL_PADCONF_GPMC_NCS2	0x00B2
+#define CONTROL_PADCONF_GPMC_NCS3	0x00B4
+#define CONTROL_PADCONF_GPMC_NCS4	0x00B6
+#define CONTROL_PADCONF_GPMC_NCS5	0x00B8
+#define CONTROL_PADCONF_GPMC_NCS6	0x00BA
+#define CONTROL_PADCONF_GPMC_NCS7	0x00BC
+#define CONTROL_PADCONF_GPMC_CLK	0x00BE
+#define CONTROL_PADCONF_GPMC_NADV_ALE	0x00C0
+#define CONTROL_PADCONF_GPMC_NOE	0x00C2
+#define CONTROL_PADCONF_GPMC_NWE	0x00C4
+#define CONTROL_PADCONF_GPMC_NBE0_CLE	0x00C6
+#define CONTROL_PADCONF_GPMC_NBE1	0x00C8
+#define CONTROL_PADCONF_GPMC_NWP	0x00CA
+#define CONTROL_PADCONF_GPMC_WAIT0	0x00CC
+#define CONTROL_PADCONF_GPMC_WAIT1	0x00CE
+#define CONTROL_PADCONF_GPMC_WAIT2	0x00D0
+#define CONTROL_PADCONF_GPMC_WAIT3	0x00D2
+/*DSS*/
+#define CONTROL_PADCONF_DSS_PCLK	0x00D4
+#define CONTROL_PADCONF_DSS_HSYNC	0x00D6
+#define CONTROL_PADCONF_DSS_VSYNC	0x00D8
+#define CONTROL_PADCONF_DSS_ACBIAS	0x00DA
+#define CONTROL_PADCONF_DSS_DATA0	0x00DC
+#define CONTROL_PADCONF_DSS_DATA1	0x00DE
+#define CONTROL_PADCONF_DSS_DATA2	0x00E0
+#define CONTROL_PADCONF_DSS_DATA3	0x00E2
+#define CONTROL_PADCONF_DSS_DATA4	0x00E4
+#define CONTROL_PADCONF_DSS_DATA5	0x00E6
+#define CONTROL_PADCONF_DSS_DATA6	0x00E8
+#define CONTROL_PADCONF_DSS_DATA7	0x00EA
+#define CONTROL_PADCONF_DSS_DATA8	0x00EC
+#define CONTROL_PADCONF_DSS_DATA9	0x00EE
+#define CONTROL_PADCONF_DSS_DATA10	0x00F0
+#define CONTROL_PADCONF_DSS_DATA11	0x00F2
+#define CONTROL_PADCONF_DSS_DATA12	0x00F4
+#define CONTROL_PADCONF_DSS_DATA13	0x00F6
+#define CONTROL_PADCONF_DSS_DATA14	0x00F8
+#define CONTROL_PADCONF_DSS_DATA15	0x00FA
+#define CONTROL_PADCONF_DSS_DATA16	0x00FC
+#define CONTROL_PADCONF_DSS_DATA17	0x00FE
+#define CONTROL_PADCONF_DSS_DATA18	0x0100
+#define CONTROL_PADCONF_DSS_DATA19	0x0102
+#define CONTROL_PADCONF_DSS_DATA20	0x0104
+#define CONTROL_PADCONF_DSS_DATA21	0x0106
+#define CONTROL_PADCONF_DSS_DATA22	0x0108
+#define CONTROL_PADCONF_DSS_DATA23	0x010A
+/*CAMERA*/
+#define CONTROL_PADCONF_CAM_HS		0x010C
+#define CONTROL_PADCONF_CAM_VS		0x010E
+#define CONTROL_PADCONF_CAM_XCLKA	0x0110
+#define CONTROL_PADCONF_CAM_PCLK	0x0112
+#define CONTROL_PADCONF_CAM_FLD		0x0114
+#define CONTROL_PADCONF_CAM_D0		0x0116
+#define CONTROL_PADCONF_CAM_D1		0x0118
+#define CONTROL_PADCONF_CAM_D2		0x011A
+#define CONTROL_PADCONF_CAM_D3		0x011C
+#define CONTROL_PADCONF_CAM_D4		0x011E
+#define CONTROL_PADCONF_CAM_D5		0x0120
+#define CONTROL_PADCONF_CAM_D6		0x0122
+#define CONTROL_PADCONF_CAM_D7		0x0124
+#define CONTROL_PADCONF_CAM_D8		0x0126
+#define CONTROL_PADCONF_CAM_D9		0x0128
+#define CONTROL_PADCONF_CAM_D10		0x012A
+#define CONTROL_PADCONF_CAM_D11		0x012C
+#define CONTROL_PADCONF_CAM_XCLKB	0x012E
+#define CONTROL_PADCONF_CAM_WEN		0x0130
+#define CONTROL_PADCONF_CAM_STROBE	0x0132
+#define CONTROL_PADCONF_CSI2_DX0	0x0134
+#define CONTROL_PADCONF_CSI2_DY0	0x0136
+#define CONTROL_PADCONF_CSI2_DX1	0x0138
+#define CONTROL_PADCONF_CSI2_DY1	0x013A
+/*Audio Interface */
+#define CONTROL_PADCONF_MCBSP2_FSX	0x013C
+#define CONTROL_PADCONF_MCBSP2_CLKX	0x013E
+#define CONTROL_PADCONF_MCBSP2_DR	0x0140
+#define CONTROL_PADCONF_MCBSP2_DX	0x0142
+#define CONTROL_PADCONF_MMC1_CLK	0x0144
+#define CONTROL_PADCONF_MMC1_CMD	0x0146
+#define CONTROL_PADCONF_MMC1_DAT0	0x0148
+#define CONTROL_PADCONF_MMC1_DAT1	0x014A
+#define CONTROL_PADCONF_MMC1_DAT2	0x014C
+#define CONTROL_PADCONF_MMC1_DAT3	0x014E
+#define CONTROL_PADCONF_MMC1_DAT4	0x0150
+#define CONTROL_PADCONF_MMC1_DAT5	0x0152
+#define CONTROL_PADCONF_MMC1_DAT6	0x0154
+#define CONTROL_PADCONF_MMC1_DAT7	0x0156
+/*Wireless LAN */
+#define CONTROL_PADCONF_MMC2_CLK	0x0158
+#define CONTROL_PADCONF_MMC2_CMD	0x015A
+#define CONTROL_PADCONF_MMC2_DAT0	0x015C
+#define CONTROL_PADCONF_MMC2_DAT1	0x015E
+#define CONTROL_PADCONF_MMC2_DAT2	0x0160
+#define CONTROL_PADCONF_MMC2_DAT3	0x0162
+#define CONTROL_PADCONF_MMC2_DAT4	0x0164
+#define CONTROL_PADCONF_MMC2_DAT5	0x0166
+#define CONTROL_PADCONF_MMC2_DAT6	0x0168
+#define CONTROL_PADCONF_MMC2_DAT7	0x016A
+/*Bluetooth*/
+#define CONTROL_PADCONF_MCBSP3_DX	0x016C
+#define CONTROL_PADCONF_MCBSP3_DR	0x016E
+#define CONTROL_PADCONF_MCBSP3_CLKX	0x0170
+#define CONTROL_PADCONF_MCBSP3_FSX	0x0172
+#define CONTROL_PADCONF_UART2_CTS	0x0174
+#define CONTROL_PADCONF_UART2_RTS	0x0176
+#define CONTROL_PADCONF_UART2_TX	0x0178
+#define CONTROL_PADCONF_UART2_RX	0x017A
+/*Modem Interface */
+#define CONTROL_PADCONF_UART1_TX	0x017C
+#define CONTROL_PADCONF_UART1_RTS	0x017E
+#define CONTROL_PADCONF_UART1_CTS	0x0180
+#define CONTROL_PADCONF_UART1_RX	0x0182
+#define CONTROL_PADCONF_MCBSP4_CLKX	0x0184
+#define CONTROL_PADCONF_MCBSP4_DR	0x0186
+#define CONTROL_PADCONF_MCBSP4_DX	0x0188
+#define CONTROL_PADCONF_MCBSP4_FSX	0x018A
+#define CONTROL_PADCONF_MCBSP1_CLKR	0x018C
+#define CONTROL_PADCONF_MCBSP1_FSR	0x018E
+#define CONTROL_PADCONF_MCBSP1_DX	0x0190
+#define CONTROL_PADCONF_MCBSP1_DR	0x0192
+#define CONTROL_PADCONF_MCBSP_CLKS	0x0194
+#define CONTROL_PADCONF_MCBSP1_FSX	0x0196
+#define CONTROL_PADCONF_MCBSP1_CLKX	0x0198
+/*Serial Interface*/
+#define CONTROL_PADCONF_UART3_CTS_RCTX	0x019A
+#define CONTROL_PADCONF_UART3_RTS_SD	0x019C
+#define CONTROL_PADCONF_UART3_RX_IRRX	0x019E
+#define CONTROL_PADCONF_UART3_TX_IRTX	0x01A0
+#define CONTROL_PADCONF_HSUSB0_CLK	0x01A2
+#define CONTROL_PADCONF_HSUSB0_STP	0x01A4
+#define CONTROL_PADCONF_HSUSB0_DIR	0x01A6
+#define CONTROL_PADCONF_HSUSB0_NXT	0x01A8
+#define CONTROL_PADCONF_HSUSB0_DATA0	0x01AA
+#define CONTROL_PADCONF_HSUSB0_DATA1	0x01AC
+#define CONTROL_PADCONF_HSUSB0_DATA2	0x01AE
+#define CONTROL_PADCONF_HSUSB0_DATA3	0x01B0
+#define CONTROL_PADCONF_HSUSB0_DATA4	0x01B2
+#define CONTROL_PADCONF_HSUSB0_DATA5	0x01B4
+#define CONTROL_PADCONF_HSUSB0_DATA6	0x01B6
+#define CONTROL_PADCONF_HSUSB0_DATA7	0x01B8
+#define CONTROL_PADCONF_I2C1_SCL	0x01BA
+#define CONTROL_PADCONF_I2C1_SDA	0x01BC
+#define CONTROL_PADCONF_I2C2_SCL	0x01BE
+#define CONTROL_PADCONF_I2C2_SDA	0x01C0
+#define CONTROL_PADCONF_I2C3_SCL	0x01C2
+#define CONTROL_PADCONF_I2C3_SDA	0x01C4
+#define CONTROL_PADCONF_I2C4_SCL	0x0A00
+#define CONTROL_PADCONF_I2C4_SDA	0x0A02
+#define CONTROL_PADCONF_HDQ_SIO		0x01C6
+#define CONTROL_PADCONF_MCSPI1_CLK	0x01C8
+#define CONTROL_PADCONF_MCSPI1_SIMO	0x01CA
+#define CONTROL_PADCONF_MCSPI1_SOMI	0x01CC
+#define CONTROL_PADCONF_MCSPI1_CS0	0x01CE
+#define CONTROL_PADCONF_MCSPI1_CS1	0x01D0
+#define CONTROL_PADCONF_MCSPI1_CS2	0x01D2
+#define CONTROL_PADCONF_MCSPI1_CS3	0x01D4
+#define CONTROL_PADCONF_MCSPI2_CLK	0x01D6
+#define CONTROL_PADCONF_MCSPI2_SIMO	0x01D8
+#define CONTROL_PADCONF_MCSPI2_SOMI	0x01DA
+#define CONTROL_PADCONF_MCSPI2_CS0	0x01DC
+#define CONTROL_PADCONF_MCSPI2_CS1	0x01DE
+/*Control and debug */
+#define CONTROL_PADCONF_SYS_32K		0x0A04
+#define CONTROL_PADCONF_SYS_CLKREQ	0x0A06
+#define CONTROL_PADCONF_SYS_NIRQ	0x01E0
+#define CONTROL_PADCONF_SYS_BOOT0	0x0A0A
+#define CONTROL_PADCONF_SYS_BOOT1	0x0A0C
+#define CONTROL_PADCONF_SYS_BOOT2	0x0A0E
+#define CONTROL_PADCONF_SYS_BOOT3	0x0A10
+#define CONTROL_PADCONF_SYS_BOOT4	0x0A12
+#define CONTROL_PADCONF_SYS_BOOT5	0x0A14
+#define CONTROL_PADCONF_SYS_BOOT6	0x0A16
+#define CONTROL_PADCONF_SYS_OFF_MODE	0x0A18
+#define CONTROL_PADCONF_SYS_CLKOUT1	0x0A1A
+#define CONTROL_PADCONF_SYS_CLKOUT2	0x01E2
+#define CONTROL_PADCONF_JTAG_nTRST	0x0A1C
+#define CONTROL_PADCONF_JTAG_TCK	0x0A1E
+#define CONTROL_PADCONF_JTAG_TMS	0x0A20
+#define CONTROL_PADCONF_JTAG_TDI	0x0A22
+#define CONTROL_PADCONF_JTAG_EMU0	0x0A24
+#define CONTROL_PADCONF_JTAG_EMU1	0x0A26
+#define CONTROL_PADCONF_ETK_CLK		0x0A28
+#define CONTROL_PADCONF_ETK_CTL		0x0A2A
+#define CONTROL_PADCONF_ETK_D0		0x0A2C
+#define CONTROL_PADCONF_ETK_D1		0x0A2E
+#define CONTROL_PADCONF_ETK_D2		0x0A30
+#define CONTROL_PADCONF_ETK_D3		0x0A32
+#define CONTROL_PADCONF_ETK_D4		0x0A34
+#define CONTROL_PADCONF_ETK_D5		0x0A36
+#define CONTROL_PADCONF_ETK_D6		0x0A38
+#define CONTROL_PADCONF_ETK_D7		0x0A3A
+#define CONTROL_PADCONF_ETK_D8		0x0A3C
+#define CONTROL_PADCONF_ETK_D9		0x0A3E
+#define CONTROL_PADCONF_ETK_D10		0x0A40
+#define CONTROL_PADCONF_ETK_D11		0x0A42
+#define CONTROL_PADCONF_ETK_D12		0x0A44
+#define CONTROL_PADCONF_ETK_D13		0x0A46
+#define CONTROL_PADCONF_ETK_D14		0x0A48
+#define CONTROL_PADCONF_ETK_D15		0x0A4A
+#define CONTROL_PADCONF_ETK_CLK_ES2	0x05D8
+#define CONTROL_PADCONF_ETK_CTL_ES2	0x05DA
+#define CONTROL_PADCONF_ETK_D0_ES2	0x05DC
+#define CONTROL_PADCONF_ETK_D1_ES2	0x05DE
+#define CONTROL_PADCONF_ETK_D2_ES2	0x05E0
+#define CONTROL_PADCONF_ETK_D3_ES2	0x05E2
+#define CONTROL_PADCONF_ETK_D4_ES2	0x05E4
+#define CONTROL_PADCONF_ETK_D5_ES2	0x05E6
+#define CONTROL_PADCONF_ETK_D6_ES2	0x05E8
+#define CONTROL_PADCONF_ETK_D7_ES2	0x05EA
+#define CONTROL_PADCONF_ETK_D8_ES2	0x05EC
+#define CONTROL_PADCONF_ETK_D9_ES2	0x05EE
+#define CONTROL_PADCONF_ETK_D10_ES2	0x05F0
+#define CONTROL_PADCONF_ETK_D11_ES2	0x05F2
+#define CONTROL_PADCONF_ETK_D12_ES2	0x05F4
+#define CONTROL_PADCONF_ETK_D13_ES2	0x05F6
+#define CONTROL_PADCONF_ETK_D14_ES2	0x05F8
+#define CONTROL_PADCONF_ETK_D15_ES2	0x05FA
+/*Die to Die */
+#define CONTROL_PADCONF_D2D_MCAD0	0x01E4
+#define CONTROL_PADCONF_D2D_MCAD1	0x01E6
+#define CONTROL_PADCONF_D2D_MCAD2	0x01E8
+#define CONTROL_PADCONF_D2D_MCAD3	0x01EA
+#define CONTROL_PADCONF_D2D_MCAD4	0x01EC
+#define CONTROL_PADCONF_D2D_MCAD5	0x01EE
+#define CONTROL_PADCONF_D2D_MCAD6	0x01F0
+#define CONTROL_PADCONF_D2D_MCAD7	0x01F2
+#define CONTROL_PADCONF_D2D_MCAD8	0x01F4
+#define CONTROL_PADCONF_D2D_MCAD9	0x01F6
+#define CONTROL_PADCONF_D2D_MCAD10	0x01F8
+#define CONTROL_PADCONF_D2D_MCAD11	0x01FA
+#define CONTROL_PADCONF_D2D_MCAD12	0x01FC
+#define CONTROL_PADCONF_D2D_MCAD13	0x01FE
+#define CONTROL_PADCONF_D2D_MCAD14	0x0200
+#define CONTROL_PADCONF_D2D_MCAD15	0x0202
+#define CONTROL_PADCONF_D2D_MCAD16	0x0204
+#define CONTROL_PADCONF_D2D_MCAD17	0x0206
+#define CONTROL_PADCONF_D2D_MCAD18	0x0208
+#define CONTROL_PADCONF_D2D_MCAD19	0x020A
+#define CONTROL_PADCONF_D2D_MCAD20	0x020C
+#define CONTROL_PADCONF_D2D_MCAD21	0x020E
+#define CONTROL_PADCONF_D2D_MCAD22	0x0210
+#define CONTROL_PADCONF_D2D_MCAD23	0x0212
+#define CONTROL_PADCONF_D2D_MCAD24	0x0214
+#define CONTROL_PADCONF_D2D_MCAD25	0x0216
+#define CONTROL_PADCONF_D2D_MCAD26	0x0218
+#define CONTROL_PADCONF_D2D_MCAD27	0x021A
+#define CONTROL_PADCONF_D2D_MCAD28	0x021C
+#define CONTROL_PADCONF_D2D_MCAD29	0x021E
+#define CONTROL_PADCONF_D2D_MCAD30	0x0220
+#define CONTROL_PADCONF_D2D_MCAD31	0x0222
+#define CONTROL_PADCONF_D2D_MCAD32	0x0224
+#define CONTROL_PADCONF_D2D_MCAD33	0x0226
+#define CONTROL_PADCONF_D2D_MCAD34	0x0228
+#define CONTROL_PADCONF_D2D_MCAD35	0x022A
+#define CONTROL_PADCONF_D2D_MCAD36	0x022C
+#define CONTROL_PADCONF_D2D_CLK26MI	0x022E
+#define CONTROL_PADCONF_D2D_NRESPWRON	0x0230
+#define CONTROL_PADCONF_D2D_NRESWARM	0x0232
+#define CONTROL_PADCONF_D2D_ARM9NIRQ	0x0234
+#define CONTROL_PADCONF_D2D_UMA2P6FIQ	0x0236
+#define CONTROL_PADCONF_D2D_SPINT	0x0238
+#define CONTROL_PADCONF_D2D_FRINT	0x023A
+#define CONTROL_PADCONF_D2D_DMAREQ0	0x023C
+#define CONTROL_PADCONF_D2D_DMAREQ1	0x023E
+#define CONTROL_PADCONF_D2D_DMAREQ2	0x0240
+#define CONTROL_PADCONF_D2D_DMAREQ3	0x0242
+#define CONTROL_PADCONF_D2D_N3GTRST	0x0244
+#define CONTROL_PADCONF_D2D_N3GTDI	0x0246
+#define CONTROL_PADCONF_D2D_N3GTDO	0x0248
+#define CONTROL_PADCONF_D2D_N3GTMS	0x024A
+#define CONTROL_PADCONF_D2D_N3GTCK	0x024C
+#define CONTROL_PADCONF_D2D_N3GRTCK	0x024E
+#define CONTROL_PADCONF_D2D_MSTDBY	0x0250
+#define CONTROL_PADCONF_D2D_SWAKEUP	0x0A4C
+#define CONTROL_PADCONF_D2D_IDLEREQ	0x0252
+#define CONTROL_PADCONF_D2D_IDLEACK	0x0254
+#define CONTROL_PADCONF_D2D_MWRITE	0x0256
+#define CONTROL_PADCONF_D2D_SWRITE	0x0258
+#define CONTROL_PADCONF_D2D_MREAD	0x025A
+#define CONTROL_PADCONF_D2D_SREAD	0x025C
+#define CONTROL_PADCONF_D2D_MBUSFLAG	0x025E
+#define CONTROL_PADCONF_D2D_SBUSFLAG	0x0260
+#define CONTROL_PADCONF_SDRC_CKE0	0x0262
+#define CONTROL_PADCONF_SDRC_CKE1	0x0264
+
+#define MUX_VAL(OFFSET,VALUE)\
+	writew((VALUE), OMAP34XX_CTRL_BASE + (OFFSET));
+
+#define	CP(x)	(CONTROL_PADCONF_##x)
+
+#endif
diff -Naur u-boot-2009.01/include/asm-arm/arch-omap3/omap3.h u-boot/include/asm-arm/arch-omap3/omap3.h
--- u-boot-2009.01/include/asm-arm/arch-omap3/omap3.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/arch-omap3/omap3.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,222 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Mohammed Khasim <x0khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _OMAP3_H_
+#define _OMAP3_H_
+
+/* Stuff on L3 Interconnect */
+#define SMX_APE_BASE			0x68000000
+
+/* GPMC */
+#define OMAP34XX_GPMC_BASE		0x6E000000
+
+/* SMS */
+#define OMAP34XX_SMS_BASE		0x6C000000
+
+/* SDRC */
+#define OMAP34XX_SDRC_BASE		0x6D000000
+
+/*
+ * L4 Peripherals - L4 Wakeup and L4 Core now
+ */
+#define OMAP34XX_CORE_L4_IO_BASE	0x48000000
+#define OMAP34XX_WAKEUP_L4_IO_BASE	0x48300000
+#define OMAP34XX_L4_PER			0x49000000
+#define OMAP34XX_L4_IO_BASE		OMAP34XX_CORE_L4_IO_BASE
+
+/* CONTROL */
+#define OMAP34XX_CTRL_BASE		(OMAP34XX_L4_IO_BASE + 0x2000)
+
+/* UART */
+#define OMAP34XX_UART1			(OMAP34XX_L4_IO_BASE + 0x6a000)
+#define OMAP34XX_UART2			(OMAP34XX_L4_IO_BASE + 0x6c000)
+#define OMAP34XX_UART3			(OMAP34XX_L4_PER + 0x20000)
+
+/* General Purpose Timers */
+#define OMAP34XX_GPT1			0x48318000
+#define OMAP34XX_GPT2			0x49032000
+#define OMAP34XX_GPT3			0x49034000
+#define OMAP34XX_GPT4			0x49036000
+#define OMAP34XX_GPT5			0x49038000
+#define OMAP34XX_GPT6			0x4903A000
+#define OMAP34XX_GPT7			0x4903C000
+#define OMAP34XX_GPT8			0x4903E000
+#define OMAP34XX_GPT9			0x49040000
+#define OMAP34XX_GPT10			0x48086000
+#define OMAP34XX_GPT11			0x48088000
+#define OMAP34XX_GPT12			0x48304000
+
+/* WatchDog Timers (1 secure, 3 GP) */
+#define WD1_BASE			0x4830C000
+#define WD2_BASE			0x48314000
+#define WD3_BASE			0x49030000
+
+/* 32KTIMER */
+#define SYNC_32KTIMER_BASE		0x48320000
+
+#ifndef __ASSEMBLY__
+
+typedef struct s32ktimer {
+	unsigned char res[0x10];
+	unsigned int s32k_cr;		/* 0x10 */
+} s32ktimer_t;
+
+#endif /* __ASSEMBLY__ */
+
+/* OMAP3 GPIO registers */
+#define OMAP34XX_GPIO1_BASE		0x48310000
+#define OMAP34XX_GPIO2_BASE		0x49050000
+#define OMAP34XX_GPIO3_BASE		0x49052000
+#define OMAP34XX_GPIO4_BASE		0x49054000
+#define OMAP34XX_GPIO5_BASE		0x49056000
+#define OMAP34XX_GPIO6_BASE		0x49058000
+
+#ifndef __ASSEMBLY__
+typedef struct gpio {
+	unsigned char res1[0x34];
+	unsigned int oe;		/* 0x34 */
+	unsigned int datain;		/* 0x38 */
+	unsigned char res2[0x54];
+	unsigned int cleardataout;	/* 0x90 */
+	unsigned int setdataout;	/* 0x94 */
+} gpio_t;
+#endif /* __ASSEMBLY__ */
+
+#define GPIO0				(0x1 << 0)
+#define GPIO1				(0x1 << 1)
+#define GPIO2				(0x1 << 2)
+#define GPIO3				(0x1 << 3)
+#define GPIO4				(0x1 << 4)
+#define GPIO5				(0x1 << 5)
+#define GPIO6				(0x1 << 6)
+#define GPIO7				(0x1 << 7)
+#define GPIO8				(0x1 << 8)
+#define GPIO9				(0x1 << 9)
+#define GPIO10				(0x1 << 10)
+#define GPIO11				(0x1 << 11)
+#define GPIO12				(0x1 << 12)
+#define GPIO13				(0x1 << 13)
+#define GPIO14				(0x1 << 14)
+#define GPIO15				(0x1 << 15)
+#define GPIO16				(0x1 << 16)
+#define GPIO17				(0x1 << 17)
+#define GPIO18				(0x1 << 18)
+#define GPIO19				(0x1 << 19)
+#define GPIO20				(0x1 << 20)
+#define GPIO21				(0x1 << 21)
+#define GPIO22				(0x1 << 22)
+#define GPIO23				(0x1 << 23)
+#define GPIO24				(0x1 << 24)
+#define GPIO25				(0x1 << 25)
+#define GPIO26				(0x1 << 26)
+#define GPIO27				(0x1 << 27)
+#define GPIO28				(0x1 << 28)
+#define GPIO29				(0x1 << 29)
+#define GPIO30				(0x1 << 30)
+#define GPIO31				(0x1 << 31)
+
+/* base address for indirect vectors (internal boot mode) */
+#define SRAM_OFFSET0			0x40000000
+#define SRAM_OFFSET1			0x00200000
+#define SRAM_OFFSET2			0x0000F800
+#define SRAM_VECT_CODE			(SRAM_OFFSET0 | SRAM_OFFSET1 | \
+					 SRAM_OFFSET2)
+
+#define LOW_LEVEL_SRAM_STACK		0x4020FFFC
+
+#define DEBUG_LED1			149	/* gpio */
+#define DEBUG_LED2			150	/* gpio */
+
+#define XDR_POP		5	/* package on package part */
+#define SDR_DISCRETE	4	/* 128M memory SDR module */
+#define DDR_STACKED	3	/* stacked part on 2422 */
+#define DDR_COMBO	2	/* combo part on cpu daughter card */
+#define DDR_DISCRETE	1	/* 2x16 parts on daughter card */
+
+#define DDR_100		100	/* type found on most mem d-boards */
+#define DDR_111		111	/* some combo parts */
+#define DDR_133		133	/* most combo, some mem d-boards */
+#define DDR_165		165	/* future parts */
+
+#define CPU_3430	0x3430
+
+/*
+ * 343x real hardware:
+ *  ES1     = rev 0
+ *
+ * 343x code defines:
+ * ES1     = 0+1 = 1
+ * ES1     = 1+1 = 1
+ */
+#define CPU_3430_ES1		1
+#define CPU_3430_ES2		2
+
+#define WIDTH_8BIT		0x0000
+#define WIDTH_16BIT		0x1000	/* bit pos for 16 bit in gpmc */
+
+/* SDP definitions according to FPGA Rev. Is this OK?? */
+#define SDP_3430_V1		0x1
+#define SDP_3430_V2		0x2
+
+/* EVM definitions */
+#define OMAP3EVM_V1		0x1
+#define OMAP3EVM_V2		0x2
+
+/* I2C power management companion definitions */
+#define PWRMGT_ADDR_ID1		0x48
+#define PWRMGT_ADDR_ID2		0x49
+#define PWRMGT_ADDR_ID3		0x4A
+#define PWRMGT_ADDR_ID4		0x4B
+
+/* I2C ID3 (slave3) register */
+#define LEDEN			0xEE
+
+#define LEDAON			(0x1 << 0)
+#define LEDBON			(0x1 << 1)
+#define LEDAPWM			(0x1 << 4)
+#define LEDBPWM			(0x1 << 5)
+
+/* I2C ID4 (slave4) register */
+#define VAUX2_DEV_GRP		0x76
+#define VAUX2_DEDICATED		0x79
+#define VAUX3_DEV_GRP		0x7A
+#define VAUX3_DEDICATED		0x7D
+#define VMMC1_DEV_GRP		0x82
+#define VMMC1_DEDICATED		0x85
+#define VPLL2_DEV_GRP		0x8E
+#define VPLL2_DEDICATED		0x91
+#define VDAC_DEV_GRP		0x96
+#define VDAC_DEDICATED		0x99
+
+#define DEV_GRP_P1		0x20
+#define DEV_GRP_ALL		0xE0
+
+#define VAUX2_VSEL_28		0x09
+#define VAUX3_VSEL_28		0x03
+#define VPLL2_VSEL_18		0x05
+#define VDAC_VSEL_18		0x03
+#define VMMC1_VSEL_30		0x02
+
+#endif
diff -Naur u-boot-2009.01/include/asm-arm/arch-omap3/omap_gpmc.h u-boot/include/asm-arm/arch-omap3/omap_gpmc.h
--- u-boot-2009.01/include/asm-arm/arch-omap3/omap_gpmc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/arch-omap3/omap_gpmc.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,83 @@
+/*
+ * (C) Copyright 2004-2008 Texas Instruments, <www.ti.com>
+ * Rohit Choraria <rohitkc@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_ARCH_OMAP_GPMC_H
+#define __ASM_ARCH_OMAP_GPMC_H
+
+#define GPMC_BUF_EMPTY	0
+#define GPMC_BUF_FULL	1
+
+#define ECCCLEAR	(0x1 << 8)
+#define ECCRESULTREG1	(0x1 << 0)
+#define ECCSIZE512BYTE	0xFF
+#define ECCSIZE1	(ECCSIZE512BYTE << 22)
+#define ECCSIZE0	(ECCSIZE512BYTE << 12)
+#define ECCSIZE0SEL	(0x000 << 0)
+
+/* Generic ECC Layouts */
+/* Large Page x8 NAND device Layout */
+#ifdef GPMC_NAND_ECC_LP_x8_LAYOUT
+#define GPMC_NAND_HW_ECC_LAYOUT {\
+	.eccbytes = 12,\
+	.eccpos = {1, 2, 3, 4, 5, 6, 7, 8,\
+		9, 10, 11, 12},\
+	.oobfree = {\
+		{.offset = 13,\
+		 .length = 51 } } \
+}
+#endif
+
+/* Large Page x16 NAND device Layout */
+#ifdef GPMC_NAND_ECC_LP_x16_LAYOUT
+#define GPMC_NAND_HW_ECC_LAYOUT {\
+	.eccbytes = 12,\
+	.eccpos = {2, 3, 4, 5, 6, 7, 8, 9,\
+		10, 11, 12, 13},\
+	.oobfree = {\
+		{.offset = 14,\
+		 .length = 50 } } \
+}
+#endif
+
+/* Small Page x8 NAND device Layout */
+#ifdef GPMC_NAND_ECC_SP_x8_LAYOUT
+#define GPMC_NAND_HW_ECC_LAYOUT {\
+	.eccbytes = 3,\
+	.eccpos = {1, 2, 3},\
+	.oobfree = {\
+		{.offset = 4,\
+		 .length = 12 } } \
+}
+#endif
+
+/* Small Page x16 NAND device Layout */
+#ifdef GPMC_NAND_ECC_SP_x16_LAYOUT
+#define GPMC_NAND_HW_ECC_LAYOUT {\
+	.eccbytes = 3,\
+	.eccpos = {2, 3, 4},\
+	.oobfree = {\
+		{.offset = 5,\
+		 .length = 11 } } \
+}
+#endif
+
+#endif /* __ASM_ARCH_OMAP_GPMC_H */
diff -Naur u-boot-2009.01/include/asm-arm/arch-omap3/sys_proto.h u-boot/include/asm-arm/arch-omap3/sys_proto.h
--- u-boot-2009.01/include/asm-arm/arch-omap3/sys_proto.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/arch-omap3/sys_proto.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,70 @@
+/*
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+  */
+#ifndef _SYS_PROTO_H_
+#define _SYS_PROTO_H_
+
+typedef struct {
+	u32 board_type_v1;
+	u32 board_type_v2;
+	u32 mtype;
+	char *board_string;
+	char *nand_string;
+} omap3_sysinfo;
+
+void prcm_init(void);
+void per_clocks_enable(void);
+
+void memif_init(void);
+void sdrc_init(void);
+void do_sdrc_init(u32, u32);
+void gpmc_init(void);
+
+void watchdog_init(void);
+void set_muxconf_regs(void);
+
+u32 get_cpu_rev(void);
+u32 get_mem_type(void);
+u32 get_sysboot_value(void);
+u32 is_gpmc_muxed(void);
+u32 get_gpmc0_type(void);
+u32 get_gpmc0_width(void);
+u32 get_board_type(void);
+void display_board_info(u32);
+u32 get_sdr_cs_size(u32);
+u32 get_sdr_cs_offset(u32);
+u32 is_running_in_sdram(void);
+u32 is_running_in_sram(void);
+u32 is_running_in_flash(void);
+u32 get_device_type(void);
+void l2cache_enable(void);
+void secureworld_exit(void);
+void setup_auxcr(void);
+void try_unlock_memory(void);
+u32 get_boot_type(void);
+void v7_flush_dcache_all(u32);
+void sr32(void *, u32, u32, u32);
+u32 wait_on_value(u32, u32, void *, u32);
+void sdelay(unsigned long);
+void make_cs1_contiguous(void);
+void omap_nand_switch_ecc(int);
+void power_init_r(void);
+
+#endif
diff -Naur u-boot-2009.01/include/asm-arm/arch-pxa/mmc.h u-boot/include/asm-arm/arch-pxa/mmc.h
--- u-boot-2009.01/include/asm-arm/arch-pxa/mmc.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-arm/arch-pxa/mmc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,189 +0,0 @@
-/*
- *  linux/drivers/mmc/mmc_pxa.h
- *
- *  Author: Vladimir Shebordaev, Igor Oblakov
- *  Copyright:  MontaVista Software Inc.
- *
- *  $Id: mmc_pxa.h,v 0.3.1.6 2002/09/25 19:25:48 ted Exp ted $
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- */
-#ifndef __MMC_PXA_P_H__
-#define __MMC_PXA_P_H__
-
-/* PXA-250 MMC controller registers */
-
-/* MMC_STRPCL */
-#define MMC_STRPCL_STOP_CLK		(0x0001UL)
-#define MMC_STRPCL_START_CLK		(0x0002UL)
-
-/* MMC_STAT */
-#define MMC_STAT_END_CMD_RES		(0x0001UL << 13)
-#define MMC_STAT_PRG_DONE		(0x0001UL << 12)
-#define MMC_STAT_DATA_TRAN_DONE		(0x0001UL << 11)
-#define MMC_STAT_CLK_EN			(0x0001UL << 8)
-#define MMC_STAT_RECV_FIFO_FULL		(0x0001UL << 7)
-#define MMC_STAT_XMIT_FIFO_EMPTY	(0x0001UL << 6)
-#define MMC_STAT_RES_CRC_ERROR		(0x0001UL << 5)
-#define MMC_STAT_SPI_READ_ERROR_TOKEN   (0x0001UL << 4)
-#define MMC_STAT_CRC_READ_ERROR		(0x0001UL << 3)
-#define MMC_STAT_CRC_WRITE_ERROR	(0x0001UL << 2)
-#define MMC_STAT_TIME_OUT_RESPONSE	(0x0001UL << 1)
-#define MMC_STAT_READ_TIME_OUT		(0x0001UL)
-
-#define MMC_STAT_ERRORS (MMC_STAT_RES_CRC_ERROR|MMC_STAT_SPI_READ_ERROR_TOKEN\
-	|MMC_STAT_CRC_READ_ERROR|MMC_STAT_TIME_OUT_RESPONSE\
-	|MMC_STAT_READ_TIME_OUT|MMC_STAT_CRC_WRITE_ERROR)
-
-/* MMC_CLKRT */
-#define MMC_CLKRT_20MHZ			(0x0000UL)
-#define MMC_CLKRT_10MHZ			(0x0001UL)
-#define MMC_CLKRT_5MHZ			(0x0002UL)
-#define MMC_CLKRT_2_5MHZ		(0x0003UL)
-#define MMC_CLKRT_1_25MHZ		(0x0004UL)
-#define MMC_CLKRT_0_625MHZ		(0x0005UL)
-#define MMC_CLKRT_0_3125MHZ		(0x0006UL)
-
-/* MMC_SPI */
-#define MMC_SPI_DISABLE			(0x00UL)
-#define MMC_SPI_EN			(0x01UL)
-#define MMC_SPI_CS_EN			(0x01UL << 2)
-#define MMC_SPI_CS_ADDRESS		(0x01UL << 3)
-#define MMC_SPI_CRC_ON			(0x01UL << 1)
-
-/* MMC_CMDAT */
-#define MMC_CMDAT_SD_4DAT		(0x0001UL << 8)
-#define MMC_CMDAT_MMC_DMA_EN		(0x0001UL << 7)
-#define MMC_CMDAT_INIT			(0x0001UL << 6)
-#define MMC_CMDAT_BUSY			(0x0001UL << 5)
-#define MMC_CMDAT_BCR			(0x0003UL << 5)
-#define MMC_CMDAT_STREAM		(0x0001UL << 4)
-#define MMC_CMDAT_BLOCK			(0x0000UL << 4)
-#define MMC_CMDAT_WRITE			(0x0001UL << 3)
-#define MMC_CMDAT_READ			(0x0000UL << 3)
-#define MMC_CMDAT_DATA_EN		(0x0001UL << 2)
-#define MMC_CMDAT_R0			(0)
-#define MMC_CMDAT_R1			(0x0001UL)
-#define MMC_CMDAT_R2			(0x0002UL)
-#define MMC_CMDAT_R3			(0x0003UL)
-
-/* MMC_RESTO */
-#define MMC_RES_TO_MAX			(0x007fUL) /* [6:0] */
-
-/* MMC_RDTO */
-#define MMC_READ_TO_MAX			(0x0ffffUL) /* [15:0] */
-
-/* MMC_BLKLEN */
-#define MMC_BLK_LEN_MAX			(0x03ffUL) /* [9:0] */
-
-/* MMC_PRTBUF */
-#define MMC_PRTBUF_BUF_PART_FULL	(0x01UL)
-#define MMC_PRTBUF_BUF_FULL		(0x00UL    )
-
-/* MMC_I_MASK */
-#define MMC_I_MASK_TXFIFO_WR_REQ	(0x01UL << 6)
-#define MMC_I_MASK_RXFIFO_RD_REQ	(0x01UL << 5)
-#define MMC_I_MASK_CLK_IS_OFF		(0x01UL << 4)
-#define MMC_I_MASK_STOP_CMD		(0x01UL << 3)
-#define MMC_I_MASK_END_CMD_RES		(0x01UL << 2)
-#define MMC_I_MASK_PRG_DONE		(0x01UL << 1)
-#define MMC_I_MASK_DATA_TRAN_DONE       (0x01UL)
-#define MMC_I_MASK_ALL			(0x07fUL)
-
-
-/* MMC_I_REG */
-#define MMC_I_REG_TXFIFO_WR_REQ		(0x01UL << 6)
-#define MMC_I_REG_RXFIFO_RD_REQ		(0x01UL << 5)
-#define MMC_I_REG_CLK_IS_OFF		(0x01UL << 4)
-#define MMC_I_REG_STOP_CMD		(0x01UL << 3)
-#define MMC_I_REG_END_CMD_RES		(0x01UL << 2)
-#define MMC_I_REG_PRG_DONE		(0x01UL << 1)
-#define MMC_I_REG_DATA_TRAN_DONE	(0x01UL)
-#define MMC_I_REG_ALL			(0x007fUL)
-
-/* MMC_CMD */
-#define MMC_CMD_INDEX_MAX		(0x006fUL)  /* [5:0] */
-#define CMD(x)  (x)
-
-#define MMC_DEFAULT_RCA			1
-
-#define MMC_BLOCK_SIZE			512
-#define MMC_MAX_BLOCK_SIZE		512
-
-#define MMC_R1_IDLE_STATE		0x01
-#define MMC_R1_ERASE_STATE		0x02
-#define MMC_R1_ILLEGAL_CMD		0x04
-#define MMC_R1_COM_CRC_ERR		0x08
-#define MMC_R1_ERASE_SEQ_ERR		0x01
-#define MMC_R1_ADDR_ERR			0x02
-#define MMC_R1_PARAM_ERR		0x04
-
-#define MMC_R1B_WP_ERASE_SKIP		0x0002
-#define MMC_R1B_ERR			0x0004
-#define MMC_R1B_CC_ERR			0x0008
-#define MMC_R1B_CARD_ECC_ERR		0x0010
-#define MMC_R1B_WP_VIOLATION		0x0020
-#define MMC_R1B_ERASE_PARAM		0x0040
-#define MMC_R1B_OOR			0x0080
-#define MMC_R1B_IDLE_STATE		0x0100
-#define MMC_R1B_ERASE_RESET		0x0200
-#define MMC_R1B_ILLEGAL_CMD		0x0400
-#define MMC_R1B_COM_CRC_ERR		0x0800
-#define MMC_R1B_ERASE_SEQ_ERR		0x1000
-#define MMC_R1B_ADDR_ERR		0x2000
-#define MMC_R1B_PARAM_ERR		0x4000
-
-typedef struct mmc_cid
-{
-/* FIXME: BYTE_ORDER */
-   uchar year:4,
-   month:4;
-   uchar sn[3];
-   uchar fwrev:4,
-   hwrev:4;
-   uchar name[6];
-   uchar id[3];
-} mmc_cid_t;
-
-typedef struct mmc_csd
-{
-	uint8_t		csd_structure:2,
-			spec_ver:4,
-			rsvd1:2;
-	uint8_t		taac;
-	uint8_t		nsac;
-	uint8_t		tran_speed;
-	uint16_t	ccc:12,
-			read_bl_len:4;
-	uint64_t	read_bl_partial:1,
-			write_blk_misalign:1,
-			read_blk_misalign:1,
-			dsr_imp:1,
-			rsvd2:2,
-			c_size:12,
-			vdd_r_curr_min:3,
-			vdd_r_curr_max:3,
-			vdd_w_curr_min:3,
-			vdd_w_curr_max:3,
-			c_size_mult:3,
-			erase_blk_en:1,
-			sector_size:7,
-			wp_grp_size:7,
-			wp_grp_enable:1,
-			default_ecc:2,
-			r2w_factor:3,
-			write_bl_len:4,
-			write_bl_partial:1,
-			rsvd3:4,
-			content_prot_app:1;
-	uint8_t		file_format_grp:1,
-			copy:1,
-			perm_write_protect:1,
-			tmp_write_protect:1,
-			file_format:2,
-			ecc:2;
-} mmc_csd_t;
-
-#endif /* __MMC_PXA_P_H__ */
diff -Naur u-boot-2009.01/include/asm-arm/config.h u-boot/include/asm-arm/config.h
--- u-boot-2009.01/include/asm-arm/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-arm/config.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#endif
diff -Naur u-boot-2009.01/include/asm-arm/mach-types.h u-boot/include/asm-arm/mach-types.h
--- u-boot-2009.01/include/asm-arm/mach-types.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-arm/mach-types.h	2009-02-26 14:03:58.000000000 +0100
@@ -1376,7 +1376,7 @@
 #define MACH_TYPE_OLIP8                1378
 #define MACH_TYPE_GHI270HG             1379
 #define MACH_TYPE_DAVINCI_DM6467_EVM   1380
-#define MACH_TYPE_DAVINCI_DM350_EVM    1381
+#define MACH_TYPE_DAVINCI_DM355_EVM    1381
 #define MACH_TYPE_BLACKRIVER           1383
 #define MACH_TYPE_SANDGATEWP           1384
 #define MACH_TYPE_CDOTBWSG             1385
@@ -1806,7 +1806,7 @@
 #define MACH_TYPE_PILZ_PMI5            1820
 #define MACH_TYPE_JADE                 1821
 #define MACH_TYPE_KS8695_SOFTPLC       1822
-#define MACH_TYPE_GPRISC4              1823
+#define MACH_TYPE_GPRISC3              1823
 #define MACH_TYPE_STAMP9260            1824
 #define MACH_TYPE_SMDK6430             1825
 #define MACH_TYPE_SMDKC100             1826
@@ -1857,6 +1857,139 @@
 #define MACH_TYPE_IMX27IPCAM           1871
 #define MACH_TYPE_NEMOC                1872
 #define MACH_TYPE_GENEVA               1873
+#define MACH_TYPE_HTCPHAROS            1874
+#define MACH_TYPE_NEONC                1875
+#define MACH_TYPE_NAS7100              1876
+#define MACH_TYPE_TEUPHONE             1877
+#define MACH_TYPE_ANNAX_ETH2           1878
+#define MACH_TYPE_CSB733               1879
+#define MACH_TYPE_BK3                  1880
+#define MACH_TYPE_OMAP_EM32            1881
+#define MACH_TYPE_ET9261CP             1882
+#define MACH_TYPE_JASPERC              1883
+#define MACH_TYPE_ISSI_ARM9            1884
+#define MACH_TYPE_UED                  1885
+#define MACH_TYPE_ESIBLADE             1886
+#define MACH_TYPE_EYE02                1887
+#define MACH_TYPE_IMX27KBD             1888
+#define MACH_TYPE_SST61VC010_FPGA      1889
+#define MACH_TYPE_KIXVP435             1890
+#define MACH_TYPE_KIXNP435             1891
+#define MACH_TYPE_AFRICA               1892
+#define MACH_TYPE_NH233                1893
+#define MACH_TYPE_RD88F6183AP_GE       1894
+#define MACH_TYPE_BCM4760              1895
+#define MACH_TYPE_EDDY_V2              1896
+#define MACH_TYPE_REALVIEW_PBA8        1897
+#define MACH_TYPE_HID_A7               1898
+#define MACH_TYPE_HERO                 1899
+#define MACH_TYPE_OMAP_POSEIDON        1900
+#define MACH_TYPE_REALVIEW_PBX         1901
+#define MACH_TYPE_MICRO9S              1902
+#define MACH_TYPE_MAKO                 1903
+#define MACH_TYPE_XDAFLAME             1904
+#define MACH_TYPE_PHIDGET_SBC2         1905
+#define MACH_TYPE_LIMESTONE            1906
+#define MACH_TYPE_IPROBE_C32           1907
+#define MACH_TYPE_RUT100               1908
+#define MACH_TYPE_ASUSP535             1909
+#define MACH_TYPE_HTCRAPHAEL           1910
+#define MACH_TYPE_SYGDG1               1911
+#define MACH_TYPE_SYGDG2               1912
+#define MACH_TYPE_SEOUL                1913
+#define MACH_TYPE_SALERNO              1914
+#define MACH_TYPE_UCN_S3C64XX          1915
+#define MACH_TYPE_MSM7201A             1916
+#define MACH_TYPE_LPR1                 1917
+#define MACH_TYPE_ARMADILLO500FX       1918
+#define MACH_TYPE_G3EVM                1919
+#define MACH_TYPE_Z3_DM355             1920
+#define MACH_TYPE_W90P910EVB           1921
+#define MACH_TYPE_W90P920EVB           1922
+#define MACH_TYPE_W90P950EVB           1923
+#define MACH_TYPE_W90N960EVB           1924
+#define MACH_TYPE_CAMHD                1925
+#define MACH_TYPE_MVC100               1926
+#define MACH_TYPE_ELECTRUM_200         1927
+#define MACH_TYPE_HTCJADE              1928
+#define MACH_TYPE_MEMPHIS              1929
+#define MACH_TYPE_IMX27SBC             1930
+#define MACH_TYPE_LEXTAR               1931
+#define MACH_TYPE_MV88F6281GTW_GE      1932
+#define MACH_TYPE_NCP                  1933
+#define MACH_TYPE_Z32AN                1934
+#define MACH_TYPE_TMQ_CAPD             1935
+#define MACH_TYPE_OMAP3_WL             1936
+#define MACH_TYPE_CHUMBY               1937
+#define MACH_TYPE_ATSARM9              1938
+#define MACH_TYPE_DAVINCI_DM365_EVM    1939
+#define MACH_TYPE_BAHAMAS              1940
+#define MACH_TYPE_DAS                  1941
+#define MACH_TYPE_MINIDAS              1942
+#define MACH_TYPE_VK1000               1943
+#define MACH_TYPE_CENTRO               1944
+#define MACH_TYPE_CTERA_2BAY           1945
+#define MACH_TYPE_EDGECONNECT          1946
+#define MACH_TYPE_ND27000              1947
+#define MACH_TYPE_GEMALTO_COBRA        1948
+#define MACH_TYPE_INGELABS_COMET       1949
+#define MACH_TYPE_POLLUX_WIZ           1950
+#define MACH_TYPE_BLACKSTONE           1951
+#define MACH_TYPE_TOPAZ                1952
+#define MACH_TYPE_AIXLE                1953
+#define MACH_TYPE_MW998                1954
+#define MACH_TYPE_NOKIA_RX51           1955
+#define MACH_TYPE_VSC5605EV            1956
+#define MACH_TYPE_NT98700DK            1957
+#define MACH_TYPE_ICONTACT             1958
+#define MACH_TYPE_SWARCO_FRCPU         1959
+#define MACH_TYPE_SWARCO_SCPU          1960
+#define MACH_TYPE_BBOX_P16             1961
+#define MACH_TYPE_BSTD                 1962
+#define MACH_TYPE_SBC2440II            1963
+#define MACH_TYPE_PCM034               1964
+#define MACH_TYPE_NESO                 1965
+#define MACH_TYPE_WLNX_9G20            1966
+#define MACH_TYPE_OMAP_ZOOM2           1967
+#define MACH_TYPE_TOTEMNOVA            1968
+#define MACH_TYPE_C5000                1969
+#define MACH_TYPE_UNIPO_AT91SAM9263    1970
+#define MACH_TYPE_ETHERNUT5            1971
+#define MACH_TYPE_ARM11                1972
+#define MACH_TYPE_CPUAT9260            1973
+#define MACH_TYPE_CPUPXA255            1974
+#define MACH_TYPE_CPUIMX27             1975
+#define MACH_TYPE_CHEFLUX              1976
+#define MACH_TYPE_EB_CPUX9K2           1977
+#define MACH_TYPE_OPCOTEC              1978
+#define MACH_TYPE_YT                   1979
+#define MACH_TYPE_MOTOQ                1980
+#define MACH_TYPE_BSB1                 1981
+#define MACH_TYPE_ACS5K                1982
+#define MACH_TYPE_MILAN                1983
+#define MACH_TYPE_QUARTZV2             1984
+#define MACH_TYPE_RSVP                 1985
+#define MACH_TYPE_RMP200               1986
+#define MACH_TYPE_SNAPPER_9260         1987
+#define MACH_TYPE_DSM320               1988
+#define MACH_TYPE_ADSGCM               1989
+#define MACH_TYPE_ASE2_400             1990
+#define MACH_TYPE_PIZZA                1991
+#define MACH_TYPE_SPOT_NGPL            1992
+#define MACH_TYPE_ARMATA               1993
+#define MACH_TYPE_EXEDA                1994
+#define MACH_TYPE_MX31SF005            1995
+#define MACH_TYPE_F5D8231_4_V2         1996
+#define MACH_TYPE_Q2440                1997
+#define MACH_TYPE_QQ2440               1998
+#define MACH_TYPE_MINI2440             1999
+#define MACH_TYPE_COLIBRI300           2000
+#define MACH_TYPE_JADES                2001
+#define MACH_TYPE_SPARK                2002
+#define MACH_TYPE_BENZINA              2003
+#define MACH_TYPE_BLAZE                2004
+#define MACH_TYPE_LINKSTATION_LS_HGL   2005
+#define MACH_TYPE_HTCVENUS             2006
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
@@ -18226,14 +18359,14 @@
 # define machine_is_davinci_dm6467_evm()	(0)
 #endif
 
-#ifdef CONFIG_MACH_DAVINCI_DM350_EVM
+#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_DAVINCI_DM350_EVM
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM355_EVM
 # endif
-# define machine_is_davinci_dm355_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM350_EVM)
+# define machine_is_davinci_dm355_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM355_EVM)
 #else
 # define machine_is_davinci_dm355_evm()	(0)
 #endif
@@ -22925,9 +23058,9 @@
 # else
 #  define machine_arch_type	MACH_TYPE_AT572D940HFEB
 # endif
-# define machine_is_at572d940hfeb()	(machine_arch_type == MACH_TYPE_AT572D940HFEB)
+# define machine_is_at572d940hfek()	(machine_arch_type == MACH_TYPE_AT572D940HFEB)
 #else
-# define machine_is_at572d940hfeb()	(0)
+# define machine_is_at572d940hfek()	(0)
 #endif
 
 #ifdef CONFIG_MACH_CYBOOK3
@@ -23386,14 +23519,14 @@
 # define machine_is_ks8695_softplc()	(0)
 #endif
 
-#ifdef CONFIG_MACH_GPRISC4
+#ifdef CONFIG_MACH_GPRISC3
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_GPRISC4
+#  define machine_arch_type	MACH_TYPE_GPRISC3
 # endif
-# define machine_is_gprisc3()	(machine_arch_type == MACH_TYPE_GPRISC4)
+# define machine_is_gprisc3()	(machine_arch_type == MACH_TYPE_GPRISC3)
 #else
 # define machine_is_gprisc3()	(0)
 #endif
@@ -23981,9 +24114,9 @@
 # else
 #  define machine_arch_type	MACH_TYPE_NEMOC
 # endif
-# define machine_is_nenoc()	(machine_arch_type == MACH_TYPE_NEMOC)
+# define machine_is_nemoc()	(machine_arch_type == MACH_TYPE_NEMOC)
 #else
-# define machine_is_nenoc()	(0)
+# define machine_is_nemoc()	(0)
 #endif
 
 #ifdef CONFIG_MACH_GENEVA
@@ -23998,6 +24131,1602 @@
 # define machine_is_geneva()	(0)
 #endif
 
+#ifdef CONFIG_MACH_HTCPHAROS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCPHAROS
+# endif
+# define machine_is_htcpharos()	(machine_arch_type == MACH_TYPE_HTCPHAROS)
+#else
+# define machine_is_htcpharos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEONC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEONC
+# endif
+# define machine_is_neonc()	(machine_arch_type == MACH_TYPE_NEONC)
+#else
+# define machine_is_neonc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS7100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS7100
+# endif
+# define machine_is_nas7100()	(machine_arch_type == MACH_TYPE_NAS7100)
+#else
+# define machine_is_nas7100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEUPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEUPHONE
+# endif
+# define machine_is_teuphone()	(machine_arch_type == MACH_TYPE_TEUPHONE)
+#else
+# define machine_is_teuphone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANNAX_ETH2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANNAX_ETH2
+# endif
+# define machine_is_annax_eth2()	(machine_arch_type == MACH_TYPE_ANNAX_ETH2)
+#else
+# define machine_is_annax_eth2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB733
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB733
+# endif
+# define machine_is_csb733()	(machine_arch_type == MACH_TYPE_CSB733)
+#else
+# define machine_is_csb733()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BK3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BK3
+# endif
+# define machine_is_bk3()	(machine_arch_type == MACH_TYPE_BK3)
+#else
+# define machine_is_bk3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_EM32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_EM32
+# endif
+# define machine_is_omap_em32()	(machine_arch_type == MACH_TYPE_OMAP_EM32)
+#else
+# define machine_is_omap_em32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ET9261CP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ET9261CP
+# endif
+# define machine_is_et9261cp()	(machine_arch_type == MACH_TYPE_ET9261CP)
+#else
+# define machine_is_et9261cp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JASPERC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JASPERC
+# endif
+# define machine_is_jasperc()	(machine_arch_type == MACH_TYPE_JASPERC)
+#else
+# define machine_is_jasperc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ISSI_ARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ISSI_ARM9
+# endif
+# define machine_is_issi_arm9()	(machine_arch_type == MACH_TYPE_ISSI_ARM9)
+#else
+# define machine_is_issi_arm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UED
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UED
+# endif
+# define machine_is_ued()	(machine_arch_type == MACH_TYPE_UED)
+#else
+# define machine_is_ued()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESIBLADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESIBLADE
+# endif
+# define machine_is_esiblade()	(machine_arch_type == MACH_TYPE_ESIBLADE)
+#else
+# define machine_is_esiblade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EYE02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EYE02
+# endif
+# define machine_is_eye02()	(machine_arch_type == MACH_TYPE_EYE02)
+#else
+# define machine_is_eye02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27KBD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27KBD
+# endif
+# define machine_is_imx27kbd()	(machine_arch_type == MACH_TYPE_IMX27KBD)
+#else
+# define machine_is_imx27kbd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SST61VC010_FPGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SST61VC010_FPGA
+# endif
+# define machine_is_sst61vc010_fpga()	(machine_arch_type == MACH_TYPE_SST61VC010_FPGA)
+#else
+# define machine_is_sst61vc010_fpga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXVP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXVP435
+# endif
+# define machine_is_kixvp435()	(machine_arch_type == MACH_TYPE_KIXVP435)
+#else
+# define machine_is_kixvp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXNP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXNP435
+# endif
+# define machine_is_kixnp435()	(machine_arch_type == MACH_TYPE_KIXNP435)
+#else
+# define machine_is_kixnp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AFRICA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AFRICA
+# endif
+# define machine_is_africa()	(machine_arch_type == MACH_TYPE_AFRICA)
+#else
+# define machine_is_africa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NH233
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NH233
+# endif
+# define machine_is_nh233()	(machine_arch_type == MACH_TYPE_NH233)
+#else
+# define machine_is_nh233()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6183AP_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6183AP_GE
+# endif
+# define machine_is_rd88f6183ap_ge()	(machine_arch_type == MACH_TYPE_RD88F6183AP_GE)
+#else
+# define machine_is_rd88f6183ap_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM4760
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM4760
+# endif
+# define machine_is_bcm4760()	(machine_arch_type == MACH_TYPE_BCM4760)
+#else
+# define machine_is_bcm4760()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDDY_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDDY_V2
+# endif
+# define machine_is_eddy_v2()	(machine_arch_type == MACH_TYPE_EDDY_V2)
+#else
+# define machine_is_eddy_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBA8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBA8
+# endif
+# define machine_is_realview_pba8()	(machine_arch_type == MACH_TYPE_REALVIEW_PBA8)
+#else
+# define machine_is_realview_pba8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HID_A7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HID_A7
+# endif
+# define machine_is_hid_a7()	(machine_arch_type == MACH_TYPE_HID_A7)
+#else
+# define machine_is_hid_a7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERO
+# endif
+# define machine_is_hero()	(machine_arch_type == MACH_TYPE_HERO)
+#else
+# define machine_is_hero()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_POSEIDON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_POSEIDON
+# endif
+# define machine_is_omap_poseidon()	(machine_arch_type == MACH_TYPE_OMAP_POSEIDON)
+#else
+# define machine_is_omap_poseidon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBX
+# endif
+# define machine_is_realview_pbx()	(machine_arch_type == MACH_TYPE_REALVIEW_PBX)
+#else
+# define machine_is_realview_pbx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9S
+# endif
+# define machine_is_micro9s()	(machine_arch_type == MACH_TYPE_MICRO9S)
+#else
+# define machine_is_micro9s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAKO
+# endif
+# define machine_is_mako()	(machine_arch_type == MACH_TYPE_MAKO)
+#else
+# define machine_is_mako()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XDAFLAME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XDAFLAME
+# endif
+# define machine_is_xdaflame()	(machine_arch_type == MACH_TYPE_XDAFLAME)
+#else
+# define machine_is_xdaflame()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHIDGET_SBC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHIDGET_SBC2
+# endif
+# define machine_is_phidget_sbc2()	(machine_arch_type == MACH_TYPE_PHIDGET_SBC2)
+#else
+# define machine_is_phidget_sbc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIMESTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIMESTONE
+# endif
+# define machine_is_limestone()	(machine_arch_type == MACH_TYPE_LIMESTONE)
+#else
+# define machine_is_limestone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPROBE_C32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPROBE_C32
+# endif
+# define machine_is_iprobe_c32()	(machine_arch_type == MACH_TYPE_IPROBE_C32)
+#else
+# define machine_is_iprobe_c32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUT100
+# endif
+# define machine_is_rut100()	(machine_arch_type == MACH_TYPE_RUT100)
+#else
+# define machine_is_rut100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASUSP535
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASUSP535
+# endif
+# define machine_is_asusp535()	(machine_arch_type == MACH_TYPE_ASUSP535)
+#else
+# define machine_is_asusp535()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCRAPHAEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCRAPHAEL
+# endif
+# define machine_is_htcraphael()	(machine_arch_type == MACH_TYPE_HTCRAPHAEL)
+#else
+# define machine_is_htcraphael()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYGDG1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYGDG1
+# endif
+# define machine_is_sygdg1()	(machine_arch_type == MACH_TYPE_SYGDG1)
+#else
+# define machine_is_sygdg1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYGDG2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYGDG2
+# endif
+# define machine_is_sygdg2()	(machine_arch_type == MACH_TYPE_SYGDG2)
+#else
+# define machine_is_sygdg2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SEOUL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEOUL
+# endif
+# define machine_is_seoul()	(machine_arch_type == MACH_TYPE_SEOUL)
+#else
+# define machine_is_seoul()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SALERNO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SALERNO
+# endif
+# define machine_is_salerno()	(machine_arch_type == MACH_TYPE_SALERNO)
+#else
+# define machine_is_salerno()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UCN_S3C64XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UCN_S3C64XX
+# endif
+# define machine_is_ucn_s3c64xx()	(machine_arch_type == MACH_TYPE_UCN_S3C64XX)
+#else
+# define machine_is_ucn_s3c64xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7201A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7201A
+# endif
+# define machine_is_msm7201a()	(machine_arch_type == MACH_TYPE_MSM7201A)
+#else
+# define machine_is_msm7201a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPR1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPR1
+# endif
+# define machine_is_lpr1()	(machine_arch_type == MACH_TYPE_LPR1)
+#else
+# define machine_is_lpr1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO500FX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO500FX
+# endif
+# define machine_is_armadillo500fx()	(machine_arch_type == MACH_TYPE_ARMADILLO500FX)
+#else
+# define machine_is_armadillo500fx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G3EVM
+# endif
+# define machine_is_g3evm()	(machine_arch_type == MACH_TYPE_G3EVM)
+#else
+# define machine_is_g3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_DM355
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_DM355
+# endif
+# define machine_is_z3_dm355()	(machine_arch_type == MACH_TYPE_Z3_DM355)
+#else
+# define machine_is_z3_dm355()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P910EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P910EVB
+# endif
+# define machine_is_w90p910evb()	(machine_arch_type == MACH_TYPE_W90P910EVB)
+#else
+# define machine_is_w90p910evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P920EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P920EVB
+# endif
+# define machine_is_w90p920evb()	(machine_arch_type == MACH_TYPE_W90P920EVB)
+#else
+# define machine_is_w90p920evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P950EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P950EVB
+# endif
+# define machine_is_w90p950evb()	(machine_arch_type == MACH_TYPE_W90P950EVB)
+#else
+# define machine_is_w90p950evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90N960EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90N960EVB
+# endif
+# define machine_is_w90n960evb()	(machine_arch_type == MACH_TYPE_W90N960EVB)
+#else
+# define machine_is_w90n960evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAMHD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAMHD
+# endif
+# define machine_is_camhd()	(machine_arch_type == MACH_TYPE_CAMHD)
+#else
+# define machine_is_camhd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MVC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MVC100
+# endif
+# define machine_is_mvc100()	(machine_arch_type == MACH_TYPE_MVC100)
+#else
+# define machine_is_mvc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELECTRUM_200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELECTRUM_200
+# endif
+# define machine_is_electrum_200()	(machine_arch_type == MACH_TYPE_ELECTRUM_200)
+#else
+# define machine_is_electrum_200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCJADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCJADE
+# endif
+# define machine_is_htcjade()	(machine_arch_type == MACH_TYPE_HTCJADE)
+#else
+# define machine_is_htcjade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MEMPHIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEMPHIS
+# endif
+# define machine_is_memphis()	(machine_arch_type == MACH_TYPE_MEMPHIS)
+#else
+# define machine_is_memphis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27SBC
+# endif
+# define machine_is_imx27sbc()	(machine_arch_type == MACH_TYPE_IMX27SBC)
+#else
+# define machine_is_imx27sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEXTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEXTAR
+# endif
+# define machine_is_lextar()	(machine_arch_type == MACH_TYPE_LEXTAR)
+#else
+# define machine_is_lextar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88F6281GTW_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88F6281GTW_GE
+# endif
+# define machine_is_mv88f6281gtw_ge()	(machine_arch_type == MACH_TYPE_MV88F6281GTW_GE)
+#else
+# define machine_is_mv88f6281gtw_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NCP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NCP
+# endif
+# define machine_is_ncp()	(machine_arch_type == MACH_TYPE_NCP)
+#else
+# define machine_is_ncp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z32AN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z32AN
+# endif
+# define machine_is_z32an_series()	(machine_arch_type == MACH_TYPE_Z32AN)
+#else
+# define machine_is_z32an_series()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TMQ_CAPD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TMQ_CAPD
+# endif
+# define machine_is_tmq_capd()	(machine_arch_type == MACH_TYPE_TMQ_CAPD)
+#else
+# define machine_is_tmq_capd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_WL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_WL
+# endif
+# define machine_is_omap3_wl()	(machine_arch_type == MACH_TYPE_OMAP3_WL)
+#else
+# define machine_is_omap3_wl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHUMBY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHUMBY
+# endif
+# define machine_is_chumby()	(machine_arch_type == MACH_TYPE_CHUMBY)
+#else
+# define machine_is_chumby()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATSARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATSARM9
+# endif
+# define machine_is_atsarm9()	(machine_arch_type == MACH_TYPE_ATSARM9)
+#else
+# define machine_is_atsarm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM365_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_EVM
+# endif
+# define machine_is_davinci_dm365_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_EVM)
+#else
+# define machine_is_davinci_dm365_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BAHAMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BAHAMAS
+# endif
+# define machine_is_bahamas()	(machine_arch_type == MACH_TYPE_BAHAMAS)
+#else
+# define machine_is_bahamas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAS
+# endif
+# define machine_is_das()	(machine_arch_type == MACH_TYPE_DAS)
+#else
+# define machine_is_das()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINIDAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINIDAS
+# endif
+# define machine_is_minidas()	(machine_arch_type == MACH_TYPE_MINIDAS)
+#else
+# define machine_is_minidas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VK1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VK1000
+# endif
+# define machine_is_vk1000()	(machine_arch_type == MACH_TYPE_VK1000)
+#else
+# define machine_is_vk1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CENTRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CENTRO
+# endif
+# define machine_is_centro()	(machine_arch_type == MACH_TYPE_CENTRO)
+#else
+# define machine_is_centro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_2BAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_2BAY
+# endif
+# define machine_is_ctera_2bay()	(machine_arch_type == MACH_TYPE_CTERA_2BAY)
+#else
+# define machine_is_ctera_2bay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDGECONNECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDGECONNECT
+# endif
+# define machine_is_edgeconnect()	(machine_arch_type == MACH_TYPE_EDGECONNECT)
+#else
+# define machine_is_edgeconnect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ND27000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ND27000
+# endif
+# define machine_is_nd27000()	(machine_arch_type == MACH_TYPE_ND27000)
+#else
+# define machine_is_nd27000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEMALTO_COBRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMALTO_COBRA
+# endif
+# define machine_is_cobra()	(machine_arch_type == MACH_TYPE_GEMALTO_COBRA)
+#else
+# define machine_is_cobra()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INGELABS_COMET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INGELABS_COMET
+# endif
+# define machine_is_ingelabs_comet()	(machine_arch_type == MACH_TYPE_INGELABS_COMET)
+#else
+# define machine_is_ingelabs_comet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POLLUX_WIZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POLLUX_WIZ
+# endif
+# define machine_is_pollux_wiz()	(machine_arch_type == MACH_TYPE_POLLUX_WIZ)
+#else
+# define machine_is_pollux_wiz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLACKSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLACKSTONE
+# endif
+# define machine_is_blackstone()	(machine_arch_type == MACH_TYPE_BLACKSTONE)
+#else
+# define machine_is_blackstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOPAZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOPAZ
+# endif
+# define machine_is_topaz()	(machine_arch_type == MACH_TYPE_TOPAZ)
+#else
+# define machine_is_topaz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AIXLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AIXLE
+# endif
+# define machine_is_aixle()	(machine_arch_type == MACH_TYPE_AIXLE)
+#else
+# define machine_is_aixle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MW998
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MW998
+# endif
+# define machine_is_mw998()	(machine_arch_type == MACH_TYPE_MW998)
+#else
+# define machine_is_mw998()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RX51
+# endif
+# define machine_is_nokia_rx51()	(machine_arch_type == MACH_TYPE_NOKIA_RX51)
+#else
+# define machine_is_nokia_rx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VSC5605EV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VSC5605EV
+# endif
+# define machine_is_vsc5605ev()	(machine_arch_type == MACH_TYPE_VSC5605EV)
+#else
+# define machine_is_vsc5605ev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NT98700DK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NT98700DK
+# endif
+# define machine_is_nt98700dk()	(machine_arch_type == MACH_TYPE_NT98700DK)
+#else
+# define machine_is_nt98700dk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONTACT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONTACT
+# endif
+# define machine_is_icontact()	(machine_arch_type == MACH_TYPE_ICONTACT)
+#else
+# define machine_is_icontact()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCO_FRCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCO_FRCPU
+# endif
+# define machine_is_swarco_frcpu()	(machine_arch_type == MACH_TYPE_SWARCO_FRCPU)
+#else
+# define machine_is_swarco_frcpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCO_SCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCO_SCPU
+# endif
+# define machine_is_swarco_scpu()	(machine_arch_type == MACH_TYPE_SWARCO_SCPU)
+#else
+# define machine_is_swarco_scpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BBOX_P16
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BBOX_P16
+# endif
+# define machine_is_bbox_p16()	(machine_arch_type == MACH_TYPE_BBOX_P16)
+#else
+# define machine_is_bbox_p16()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSTD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSTD
+# endif
+# define machine_is_bstd()	(machine_arch_type == MACH_TYPE_BSTD)
+#else
+# define machine_is_bstd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC2440II
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC2440II
+# endif
+# define machine_is_sbc2440ii()	(machine_arch_type == MACH_TYPE_SBC2440II)
+#else
+# define machine_is_sbc2440ii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM034
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM034
+# endif
+# define machine_is_pcm034()	(machine_arch_type == MACH_TYPE_PCM034)
+#else
+# define machine_is_pcm034()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NESO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NESO
+# endif
+# define machine_is_neso()	(machine_arch_type == MACH_TYPE_NESO)
+#else
+# define machine_is_neso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WLNX_9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WLNX_9G20
+# endif
+# define machine_is_wlnx_9g20()	(machine_arch_type == MACH_TYPE_WLNX_9G20)
+#else
+# define machine_is_wlnx_9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM2
+# endif
+# define machine_is_omap_zoom2()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM2)
+#else
+# define machine_is_omap_zoom2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOTEMNOVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOTEMNOVA
+# endif
+# define machine_is_totemnova()	(machine_arch_type == MACH_TYPE_TOTEMNOVA)
+#else
+# define machine_is_totemnova()	(0)
+#endif
+
+#ifdef CONFIG_MACH_C5000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C5000
+# endif
+# define machine_is_c5000()	(machine_arch_type == MACH_TYPE_C5000)
+#else
+# define machine_is_c5000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIPO_AT91SAM9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIPO_AT91SAM9263
+# endif
+# define machine_is_unipo_at91sam9263()	(machine_arch_type == MACH_TYPE_UNIPO_AT91SAM9263)
+#else
+# define machine_is_unipo_at91sam9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETHERNUT5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETHERNUT5
+# endif
+# define machine_is_ethernut5()	(machine_arch_type == MACH_TYPE_ETHERNUT5)
+#else
+# define machine_is_ethernut5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARM11
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM11
+# endif
+# define machine_is_arm11()	(machine_arch_type == MACH_TYPE_ARM11)
+#else
+# define machine_is_arm11()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9260
+# endif
+# define machine_is_cpuat9260()	(machine_arch_type == MACH_TYPE_CPUAT9260)
+#else
+# define machine_is_cpuat9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUPXA255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUPXA255
+# endif
+# define machine_is_cpupxa255()	(machine_arch_type == MACH_TYPE_CPUPXA255)
+#else
+# define machine_is_cpupxa255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUIMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUIMX27
+# endif
+# define machine_is_cpuimx27()	(machine_arch_type == MACH_TYPE_CPUIMX27)
+#else
+# define machine_is_cpuimx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHEFLUX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHEFLUX
+# endif
+# define machine_is_cheflux()	(machine_arch_type == MACH_TYPE_CHEFLUX)
+#else
+# define machine_is_cheflux()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EB_CPUX9K2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EB_CPUX9K2
+# endif
+# define machine_is_eb_cpux9k2()	(machine_arch_type == MACH_TYPE_EB_CPUX9K2)
+#else
+# define machine_is_eb_cpux9k2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPCOTEC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPCOTEC
+# endif
+# define machine_is_opcotec()	(machine_arch_type == MACH_TYPE_OPCOTEC)
+#else
+# define machine_is_opcotec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YT
+# endif
+# define machine_is_yt()	(machine_arch_type == MACH_TYPE_YT)
+#else
+# define machine_is_yt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOTOQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOTOQ
+# endif
+# define machine_is_motoq()	(machine_arch_type == MACH_TYPE_MOTOQ)
+#else
+# define machine_is_motoq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSB1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSB1
+# endif
+# define machine_is_bsb1()	(machine_arch_type == MACH_TYPE_BSB1)
+#else
+# define machine_is_bsb1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACS5K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACS5K
+# endif
+# define machine_is_acs5k()	(machine_arch_type == MACH_TYPE_ACS5K)
+#else
+# define machine_is_acs5k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MILAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MILAN
+# endif
+# define machine_is_milan()	(machine_arch_type == MACH_TYPE_MILAN)
+#else
+# define machine_is_milan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUARTZV2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUARTZV2
+# endif
+# define machine_is_quartzv2()	(machine_arch_type == MACH_TYPE_QUARTZV2)
+#else
+# define machine_is_quartzv2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSVP
+# endif
+# define machine_is_rsvp()	(machine_arch_type == MACH_TYPE_RSVP)
+#else
+# define machine_is_rsvp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RMP200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RMP200
+# endif
+# define machine_is_rmp200()	(machine_arch_type == MACH_TYPE_RMP200)
+#else
+# define machine_is_rmp200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_9260
+# endif
+# define machine_is_snapper_9260()	(machine_arch_type == MACH_TYPE_SNAPPER_9260)
+#else
+# define machine_is_snapper_9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSM320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSM320
+# endif
+# define machine_is_dsm320()	(machine_arch_type == MACH_TYPE_DSM320)
+#else
+# define machine_is_dsm320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSGCM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSGCM
+# endif
+# define machine_is_adsgcm()	(machine_arch_type == MACH_TYPE_ADSGCM)
+#else
+# define machine_is_adsgcm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASE2_400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASE2_400
+# endif
+# define machine_is_ase2_400()	(machine_arch_type == MACH_TYPE_ASE2_400)
+#else
+# define machine_is_ase2_400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIZZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIZZA
+# endif
+# define machine_is_pizza()	(machine_arch_type == MACH_TYPE_PIZZA)
+#else
+# define machine_is_pizza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPOT_NGPL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPOT_NGPL
+# endif
+# define machine_is_spot_ngpl()	(machine_arch_type == MACH_TYPE_SPOT_NGPL)
+#else
+# define machine_is_spot_ngpl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMATA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMATA
+# endif
+# define machine_is_armata()	(machine_arch_type == MACH_TYPE_ARMATA)
+#else
+# define machine_is_armata()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXEDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXEDA
+# endif
+# define machine_is_exeda()	(machine_arch_type == MACH_TYPE_EXEDA)
+#else
+# define machine_is_exeda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31SF005
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31SF005
+# endif
+# define machine_is_mx31sf005()	(machine_arch_type == MACH_TYPE_MX31SF005)
+#else
+# define machine_is_mx31sf005()	(0)
+#endif
+
+#ifdef CONFIG_MACH_F5D8231_4_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_F5D8231_4_V2
+# endif
+# define machine_is_f5d8231_4_v2()	(machine_arch_type == MACH_TYPE_F5D8231_4_V2)
+#else
+# define machine_is_f5d8231_4_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Q2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Q2440
+# endif
+# define machine_is_q2440()	(machine_arch_type == MACH_TYPE_Q2440)
+#else
+# define machine_is_q2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QQ2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QQ2440
+# endif
+# define machine_is_qq2440()	(machine_arch_type == MACH_TYPE_QQ2440)
+#else
+# define machine_is_qq2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2440
+# endif
+# define machine_is_mini2440()	(machine_arch_type == MACH_TYPE_MINI2440)
+#else
+# define machine_is_mini2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI300
+# endif
+# define machine_is_colibri300()	(machine_arch_type == MACH_TYPE_COLIBRI300)
+#else
+# define machine_is_colibri300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JADES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JADES
+# endif
+# define machine_is_jades()	(machine_arch_type == MACH_TYPE_JADES)
+#else
+# define machine_is_jades()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPARK
+# endif
+# define machine_is_spark()	(machine_arch_type == MACH_TYPE_SPARK)
+#else
+# define machine_is_spark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BENZINA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BENZINA
+# endif
+# define machine_is_benzina()	(machine_arch_type == MACH_TYPE_BENZINA)
+#else
+# define machine_is_benzina()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLAZE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLAZE
+# endif
+# define machine_is_blaze()	(machine_arch_type == MACH_TYPE_BLAZE)
+#else
+# define machine_is_blaze()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_LS_HGL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_LS_HGL
+# endif
+# define machine_is_linkstation_ls_hgl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LS_HGL)
+#else
+# define machine_is_linkstation_ls_hgl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCVENUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCVENUS
+# endif
+# define machine_is_htcvenus()	(machine_arch_type == MACH_TYPE_HTCVENUS)
+#else
+# define machine_is_htcvenus()	(0)
+#endif
+
 /*
  * These have not yet been registered
  */
diff -Naur u-boot-2009.01/include/asm-avr32/arch-at32ap700x/mmc.h u-boot/include/asm-avr32/arch-at32ap700x/mmc.h
--- u-boot-2009.01/include/asm-avr32/arch-at32ap700x/mmc.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-avr32/arch-at32ap700x/mmc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2004-2006 Atmel Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#ifndef __ASM_AVR32_MMC_H
-#define __ASM_AVR32_MMC_H
-
-struct mmc_cid {
-	unsigned long psn;
-	unsigned short oid;
-	unsigned char mid;
-	unsigned char prv;
-	unsigned char mdt;
-	char pnm[7];
-};
-
-struct mmc_csd
-{
-	u8	csd_structure:2,
-		spec_vers:4,
-		rsvd1:2;
-	u8	taac;
-	u8	nsac;
-	u8	tran_speed;
-	u16	ccc:12,
-		read_bl_len:4;
-	u64	read_bl_partial:1,
-		write_blk_misalign:1,
-		read_blk_misalign:1,
-		dsr_imp:1,
-		rsvd2:2,
-		c_size:12,
-		vdd_r_curr_min:3,
-		vdd_r_curr_max:3,
-		vdd_w_curr_min:3,
-		vdd_w_curr_max:3,
-		c_size_mult:3,
-		sector_size:5,
-		erase_grp_size:5,
-		wp_grp_size:5,
-		wp_grp_enable:1,
-		default_ecc:2,
-		r2w_factor:3,
-		write_bl_len:4,
-		write_bl_partial:1,
-		rsvd3:5;
-	u8	file_format_grp:1,
-		copy:1,
-		perm_write_protect:1,
-		tmp_write_protect:1,
-		file_format:2,
-		ecc:2;
-	u8	crc:7;
-	u8	one:1;
-};
-
-#define R1_ILLEGAL_COMMAND		(1 << 22)
-#define R1_APP_CMD			(1 << 5)
-
-#endif /* __ASM_AVR32_MMC_H */
diff -Naur u-boot-2009.01/include/asm-avr32/bitops.h u-boot/include/asm-avr32/bitops.h
--- u-boot-2009.01/include/asm-avr32/bitops.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-avr32/bitops.h	2009-03-04 16:17:21.000000000 +0100
@@ -22,4 +22,6 @@
 #ifndef __ASM_AVR32_BITOPS_H
 #define __ASM_AVR32_BITOPS_H
 
+#define ffs(x) generic_ffs(x)
+
 #endif /* __ASM_AVR32_BITOPS_H */
diff -Naur u-boot-2009.01/include/asm-avr32/config.h u-boot/include/asm-avr32/config.h
--- u-boot-2009.01/include/asm-avr32/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-avr32/config.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#endif
diff -Naur u-boot-2009.01/include/asm-avr32/io.h u-boot/include/asm-avr32/io.h
--- u-boot-2009.01/include/asm-avr32/io.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-avr32/io.h	2009-02-26 14:03:58.000000000 +0100
@@ -76,12 +76,12 @@
 #include <asm/addrspace.h>
 
 /* virt_to_phys will only work when address is in P1 or P2 */
-static __inline__ unsigned long virt_to_phys(volatile void *address)
+static inline phys_addr_t virt_to_phys(volatile void *address)
 {
 	return PHYSADDR(address);
 }
 
-static __inline__ void * phys_to_virt(unsigned long address)
+static inline void *phys_to_virt(phys_addr_t address)
 {
 	return (void *)P1SEGADDR(address);
 }
diff -Naur u-boot-2009.01/include/asm-blackfin/blackfin-config-post.h u-boot/include/asm-blackfin/blackfin-config-post.h
--- u-boot-2009.01/include/asm-blackfin/blackfin-config-post.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/blackfin-config-post.h	2009-02-26 14:03:58.000000000 +0100
@@ -1,7 +1,7 @@
 /*
  * blackfin-config-post.h - setup common defines for Blackfin boards based on config.h
  *
- * Copyright (c) 2007 Analog Devices Inc.
+ * Copyright (c) 2007-2008 Analog Devices Inc.
  *
  * Licensed under the GPL-2 or later.
  */
@@ -9,11 +9,6 @@
 #ifndef __ASM_BLACKFIN_CONFIG_POST_H__
 #define __ASM_BLACKFIN_CONFIG_POST_H__
 
-/* Check to make sure everything fits in external RAM */
-#if ((CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN) > CONFIG_SYS_MAX_RAM_SIZE)
-# error Memory Map does not fit into configuration
-#endif
-
 /* Sanity check CONFIG_BFIN_CPU */
 #ifndef CONFIG_BFIN_CPU
 # error CONFIG_BFIN_CPU: your board config needs to define this
@@ -65,8 +60,86 @@
 #endif
 
 /* Using L1 scratch pad makes sense for everyone by default. */
-#ifndef CMD_LINE_ADDR
-# define CMD_LINE_ADDR L1_SRAM_SCRATCH
+#ifndef CONFIG_LINUX_CMDLINE_ADDR
+# define CONFIG_LINUX_CMDLINE_ADDR L1_SRAM_SCRATCH
+#endif
+#ifndef CONFIG_LINUX_CMDLINE_SIZE
+# define CONFIG_LINUX_CMDLINE_SIZE L1_SRAM_SCRATCH_SIZE
+#endif
+
+/* Set default SPI flash CS to the one we boot from */
+#if defined(CONFIG_ENV_IS_IN_SPI_FLASH) && !defined(CONFIG_ENV_SPI_CS)
+# define CONFIG_ENV_SPI_CS BFIN_BOOT_SPI_SSEL
+#endif
+
+/* Default/common Blackfin memory layout */
+#ifndef CONFIG_SYS_SDRAM_BASE
+# define CONFIG_SYS_SDRAM_BASE 0
+#endif
+#ifndef CONFIG_SYS_MAX_RAM_SIZE
+# define CONFIG_SYS_MAX_RAM_SIZE (CONFIG_MEM_SIZE * 1024 * 1024)
+#endif
+#ifndef CONFIG_SYS_MONITOR_BASE
+# define CONFIG_SYS_MONITOR_BASE (CONFIG_SYS_MAX_RAM_SIZE - CONFIG_SYS_MONITOR_LEN)
+#endif
+#ifndef CONFIG_SYS_MALLOC_BASE
+# define CONFIG_SYS_MALLOC_BASE (CONFIG_SYS_MONITOR_BASE - CONFIG_SYS_MALLOC_LEN)
+#endif
+#ifndef CONFIG_SYS_GBL_DATA_SIZE
+# define CONFIG_SYS_GBL_DATA_SIZE (128)
+#endif
+#ifndef CONFIG_SYS_GBL_DATA_ADDR
+# define CONFIG_SYS_GBL_DATA_ADDR (CONFIG_SYS_MALLOC_BASE - CONFIG_SYS_GBL_DATA_SIZE)
+#endif
+#ifndef CONFIG_STACKBASE
+# define CONFIG_STACKBASE (CONFIG_SYS_GBL_DATA_ADDR - 4)
+#endif
+#ifndef CONFIG_SYS_MEMTEST_START
+# define CONFIG_SYS_MEMTEST_START 0
+#endif
+#ifndef CONFIG_SYS_MEMTEST_END
+# define CONFIG_SYS_MEMTEST_END (CONFIG_STACKBASE - 8192 + 4)
+#endif
+
+/* Check to make sure everything fits in external RAM */
+#if ((CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN) > CONFIG_SYS_MAX_RAM_SIZE)
+# error Memory Map does not fit into configuration
+#endif
+
+/* Default/common Blackfin environment settings */
+#ifndef CONFIG_LOADADDR
+# define CONFIG_LOADADDR 0x1000000
+#endif
+#ifndef CONFIG_SYS_LOAD_ADDR
+# define CONFIG_SYS_LOAD_ADDR CONFIG_LOADADDR
+#endif
+#ifndef CONFIG_SYS_BOOTM_LEN
+# define CONFIG_SYS_BOOTM_LEN 0x4000000
+#endif
+#ifndef CONFIG_SYS_PROMPT
+# define CONFIG_SYS_PROMPT "bfin> "
+#endif
+#ifndef CONFIG_SYS_CBSIZE
+# ifdef CONFIG_CMD_KGDB
+#  define CONFIG_SYS_CBSIZE 1024
+# else
+#  define CONFIG_SYS_CBSIZE 256
+# endif
+#endif
+#ifndef CONFIG_SYS_BARGSIZE
+# define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+#endif
+#ifndef CONFIG_SYS_PBSIZE
+# define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#endif
+#ifndef CONFIG_SYS_MAXARGS
+# define CONFIG_SYS_MAXARGS 16
+#endif
+#ifndef CONFIG_SYS_HZ
+# define CONFIG_SYS_HZ 1000
+#endif
+#ifndef CONFIG_SYS_BAUDRATE_TABLE
+# define CONFIG_SYS_BAUDRATE_TABLE { 9600, 19200, 38400, 57600, 115200 }
 #endif
 
 #endif
diff -Naur u-boot-2009.01/include/asm-blackfin/blackfin-config-pre.h u-boot/include/asm-blackfin/blackfin-config-pre.h
--- u-boot-2009.01/include/asm-blackfin/blackfin-config-pre.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/blackfin-config-pre.h	2009-02-26 14:03:58.000000000 +0100
@@ -38,4 +38,35 @@
 #define BFIN_BOOT_8HOST_DMA   12      /* boot ldr from 8-bit host dma */
 #define BFIN_BOOT_NAND        13      /* boot ldr from nand flash */
 
+#ifndef __ASSEMBLY__
+static inline const char *get_bfin_boot_mode(int bfin_boot)
+{
+	switch (bfin_boot) {
+	case BFIN_BOOT_BYPASS:     return "bypass";
+	case BFIN_BOOT_PARA:       return "parallel flash";
+	case BFIN_BOOT_SPI_MASTER: return "spi flash";
+	case BFIN_BOOT_SPI_SLAVE:  return "spi slave";
+	case BFIN_BOOT_TWI_MASTER: return "i2c flash";
+	case BFIN_BOOT_TWI_SLAVE:  return "i2c slave";
+	case BFIN_BOOT_UART:       return "uart";
+	case BFIN_BOOT_IDLE:       return "idle";
+	case BFIN_BOOT_FIFO:       return "fifo";
+	case BFIN_BOOT_MEM:        return "memory";
+	case BFIN_BOOT_16HOST_DMA: return "16bit dma";
+	case BFIN_BOOT_8HOST_DMA:  return "8bit dma";
+	case BFIN_BOOT_NAND:       return "nand flash";
+	default:                   return "INVALID";
+	}
+}
+#endif
+
+/* Define the default SPI CS used when booting out of SPI */
+#if defined(__ADSPBF531__) || defined(__ADSPBF532__) || defined(__ADSPBF533__) || \
+    defined(__ADSPBF538__) || defined(__ADSPBF539__) || defined(__ADSPBF561__) || \
+    defined(__ADSPBF51x__)
+# define BFIN_BOOT_SPI_SSEL 2
+#else
+# define BFIN_BOOT_SPI_SSEL 1
+#endif
+
 #endif
diff -Naur u-boot-2009.01/include/asm-blackfin/blackfin_local.h u-boot/include/asm-blackfin/blackfin_local.h
--- u-boot-2009.01/include/asm-blackfin/blackfin_local.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/blackfin_local.h	2009-02-26 14:03:58.000000000 +0100
@@ -43,6 +43,9 @@
 #define SCLK_TO_MSEC(sclk) ((MSEC_PER_SEC * ((sclk) / USEC_PER_MSEC)) / (BFIN_SCLK / USEC_PER_MSEC))
 #define MSEC_TO_SCLK(msec) ((((BFIN_SCLK / USEC_PER_MSEC) * (msec)) / MSEC_PER_SEC) * USEC_PER_MSEC)
 
+#define L1_CACHE_SHIFT 5
+#define L1_CACHE_BYTES (1 << L1_CACHE_SHIFT)
+
 #include <asm/linkage.h>
 
 #ifndef __ASSEMBLY__
@@ -52,25 +55,22 @@
 
 # include <linux/types.h>
 
+extern u_long get_vco(void);
+extern u_long get_cclk(void);
 extern u_long get_sclk(void);
 
 # define bfin_revid() (*pCHIPID >> 28)
 
 extern void blackfin_icache_flush_range(const void *, const void *);
 extern void blackfin_dcache_flush_range(const void *, const void *);
-extern void blackfin_dcache_invalidate_range(const void *, const void *);
+extern void blackfin_icache_dcache_flush_range(const void *, const void *);
+extern void blackfin_dcache_flush_invalidate_range(const void *, const void *);
 
-/* Use DMA to move data from on chip to external memory.  While this is
- * required for only L1 instruction (it is not directly readable by the
- * core via data loads), it isn't a huge performance issue for other
- * regions (it's probably even faster than core load/stores).  However,
- * the DMA engine does not have access to the L1 scratchpad, and we
- * cannot use DMA inside of the MMR space.
+/* Use DMA to move data from on chip to external memory.  The L1 instruction
+ * regions can only be accessed via DMA, so if the address in question is in
+ * that region, make sure we attempt to DMA indirectly.
  */
-# define addr_bfin_on_chip_mem(addr) \
-	(((unsigned long)(addr) >= 0xef000000 && (unsigned long)addr < SYSMMR_BASE) && \
-	 !((unsigned long)(addr) >= L1_SRAM_SCRATCH && \
-	   (unsigned long)(addr) < L1_SRAM_SCRATCH_END))
+# define addr_bfin_on_chip_mem(addr) (((unsigned long)(addr) & 0xFFF00000) == 0xFFA00000)
 
 # include <asm/system.h>
 
diff -Naur u-boot-2009.01/include/asm-blackfin/config.h u-boot/include/asm-blackfin/config.h
--- u-boot-2009.01/include/asm-blackfin/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-blackfin/config.h	2009-02-26 14:03:58.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#endif
diff -Naur u-boot-2009.01/include/asm-blackfin/mach-bf527/anomaly.h u-boot/include/asm-blackfin/mach-bf527/anomaly.h
--- u-boot-2009.01/include/asm-blackfin/mach-bf527/anomaly.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/mach-bf527/anomaly.h	2009-02-26 14:03:58.000000000 +0100
@@ -7,82 +7,154 @@
  */
 
 /* This file shoule be up to date with:
- *  - Revision C, 01/25/2008; ADSP-BF527 Blackfin Processor Anomaly List
+ *  - Revision B, 08/12/2008; ADSP-BF526 Blackfin Processor Anomaly List
+ *  - Revision E, 08/18/2008; ADSP-BF527 Blackfin Processor Anomaly List
  */
 
 #ifndef _MACH_ANOMALY_H_
 #define _MACH_ANOMALY_H_
 
+#if defined(__ADSPBF522__) || defined(__ADSPBF524__) || defined(__ADSPBF526__)
+# define ANOMALY_BF526 1
+#else
+# define ANOMALY_BF526 0
+#endif
+#if defined(__ADSPBF523__) || defined(__ADSPBF525__) || defined(__ADSPBF527__)
+# define ANOMALY_BF527 1
+#else
+# define ANOMALY_BF527 0
+#endif
+
 /* Multi-Issue Instruction with dsp32shiftimm in slot1 and P-reg Store in slot2 Not Supported */
 #define ANOMALY_05000074 (1)
 /* DMA_RUN Bit Is Not Valid after a Peripheral Receive Channel DMA Stops */
-#define ANOMALY_05000119 (1)
+#define ANOMALY_05000119 (1)	/* note: brokenness is noted in documentation, not anomaly sheet */
 /* Rx.H Cannot Be Used to Access 16-bit System MMR Registers */
 #define ANOMALY_05000122 (1)
 /* Spurious Hardware Error from an Access in the Shadow of a Conditional Branch */
 #define ANOMALY_05000245 (1)
 /* Sensitivity To Noise with Slow Input Edge Rates on External SPORT TX and RX Clocks */
 #define ANOMALY_05000265 (1)
-/* Errors when SSYNC, CSYNC, or Loads to LT, LB and LC Registers Are Interrupted */
-#define ANOMALY_05000312 (1)
+/* False Hardware Errors Caused by Fetches at the Boundary of Reserved Memory */
+#define ANOMALY_05000310 (1)
+/* PPI Is Level-Sensitive on First Transfer In Single Frame Sync Modes */
+#define ANOMALY_05000313 (__SILICON_REVISION__ < 2)
 /* Incorrect Access of OTP_STATUS During otp_write() Function */
-#define ANOMALY_05000328 (1)
+#define ANOMALY_05000328 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
 /* Disallowed Configuration Prevents Subsequent Allowed Configuration on Host DMA Port */
-#define ANOMALY_05000337 (1)
+#define ANOMALY_05000337 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
 /* Ethernet MAC MDIO Reads Do Not Meet IEEE Specification */
-#define ANOMALY_05000341 (1)
+#define ANOMALY_05000341 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
 /* TWI May Not Operate Correctly Under Certain Signal Termination Conditions */
-#define ANOMALY_05000342 (1)
+#define ANOMALY_05000342 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
 /* USB Calibration Value Is Not Initialized */
-#define ANOMALY_05000346 (1)
+#define ANOMALY_05000346 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* USB Calibration Value to use */
+#define ANOMALY_05000346_value 0xE510
 /* Preboot Routine Incorrectly Alters Reset Value of USB Register */
-#define ANOMALY_05000347 (1)
+#define ANOMALY_05000347 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
 /* Security Features Are Not Functional */
-#define ANOMALY_05000348 (__SILICON_REVISION__ < 1)
+#define ANOMALY_05000348 (ANOMALY_BF527 && __SILICON_REVISION__ < 1)
+/* bfrom_SysControl() Firmware Function Performs Improper System Reset */
+#define ANOMALY_05000353 (ANOMALY_BF526)
 /* Regulator Programming Blocked when Hibernate Wakeup Source Remains Active */
-#define ANOMALY_05000355 (1)
+#define ANOMALY_05000355 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
 /* Serial Port (SPORT) Multichannel Transmit Failure when Channel 0 Is Disabled */
-#define ANOMALY_05000357 (1)
+#define ANOMALY_05000357 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
 /* Incorrect Revision Number in DSPID Register */
-#define ANOMALY_05000364 (__SILICON_REVISION__ > 0)
+#define ANOMALY_05000364 (ANOMALY_BF527 && __SILICON_REVISION__ == 1)
 /* PPI Underflow Error Goes Undetected in ITU-R 656 Mode */
 #define ANOMALY_05000366 (1)
-/* New Feature: Higher Default CCLK Rate */
-#define ANOMALY_05000368 (1)
+/* Incorrect Default CSEL Value in PLL_DIV */
+#define ANOMALY_05000368 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
 /* Possible RETS Register Corruption when Subroutine Is under 5 Cycles in Duration */
-#define ANOMALY_05000371 (1)
+#define ANOMALY_05000371 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
 /* Authentication Fails To Initiate */
-#define ANOMALY_05000376 (__SILICON_REVISION__ > 0)
+#define ANOMALY_05000376 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
 /* Data Read From L3 Memory by USB DMA May be Corrupted */
-#define ANOMALY_05000380 (1)
-/* USB Full-speed Mode not Fully Tested */
-#define ANOMALY_05000381 (1)
-/* New Feature: Boot from OTP Memory */
-#define ANOMALY_05000385 (1)
-/* New Feature: bfrom_SysControl() Routine */
-#define ANOMALY_05000386 (1)
-/* New Feature: Programmable Preboot Settings */
-#define ANOMALY_05000387 (1)
+#define ANOMALY_05000380 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* 8-Bit NAND Flash Boot Mode Not Functional */
+#define ANOMALY_05000382 (__SILICON_REVISION__ < 2)
+/* Host Must Not Read Back During Host DMA Boot */
+#define ANOMALY_05000384 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* Boot from OTP Memory Not Functional */
+#define ANOMALY_05000385 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* bfrom_SysControl() Firmware Routine Not Functional */
+#define ANOMALY_05000386 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* Programmable Preboot Settings Not Functional */
+#define ANOMALY_05000387 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* CRC32 Checksum Support Not Functional */
+#define ANOMALY_05000388 (__SILICON_REVISION__ < 2)
 /* Reset Vector Must Not Be in SDRAM Memory Space */
-#define ANOMALY_05000389 (1)
-/* New Feature: pTempCurrent Added to ADI_BOOT_DATA Structure */
-#define ANOMALY_05000392 (1)
-/* New Feature: dTempByteCount Value Increased in ADI_BOOT_DATA Structure */
-#define ANOMALY_05000393 (1)
-/* New Feature: Log Buffer Functionality */
-#define ANOMALY_05000394 (1)
-/* New Feature: Hook Routine Functionality */
-#define ANOMALY_05000395 (1)
-/* New Feature: Header Indirect Bit */
-#define ANOMALY_05000396 (1)
-/* New Feature: BK_ONES, BK_ZEROS, and BK_DATECODE Constants */
-#define ANOMALY_05000397 (1)
-/* New Feature: SWRESET, DFRESET and WDRESET Bits Added to SYSCR Register */
-#define ANOMALY_05000398 (1)
-/* New Feature: BCODE_NOBOOT Added to BCODE Field of SYSCR Register */
-#define ANOMALY_05000399 (1)
+#define ANOMALY_05000389 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* pTempCurrent Not Present in ADI_BOOT_DATA Structure */
+#define ANOMALY_05000392 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* Deprecated Value of dTempByteCount in ADI_BOOT_DATA Structure */
+#define ANOMALY_05000393 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* Log Buffer Not Functional */
+#define ANOMALY_05000394 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* Hook Routine Not Functional */
+#define ANOMALY_05000395 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* Header Indirect Bit Not Functional */
+#define ANOMALY_05000396 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* BK_ONES, BK_ZEROS, and BK_DATECODE Constants Not Functional */
+#define ANOMALY_05000397 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* SWRESET, DFRESET and WDRESET Bits in the SYSCR Register Not Functional */
+#define ANOMALY_05000398 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* BCODE_NOBOOT in BCODE Field of SYSCR Register Not Functional */
+#define ANOMALY_05000399 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
 /* PPI Data Signals D0 and D8 do not Tristate After Disabling PPI */
-#define ANOMALY_05000401 (1)
+#define ANOMALY_05000401 (__SILICON_REVISION__ < 2)
+/* Level-Sensitive External GPIO Wakeups May Cause Indefinite Stall */
+#define ANOMALY_05000403 (__SILICON_REVISION__ < 2)
+/* Lockbox SESR Disallows Certain User Interrupts */
+#define ANOMALY_05000404 (__SILICON_REVISION__ < 2)
+/* Lockbox SESR Firmware Does Not Save/Restore Full Context */
+#define ANOMALY_05000405 (1)
+/* Lockbox SESR Firmware Arguments Are Not Retained After First Initialization */
+#define ANOMALY_05000407 (__SILICON_REVISION__ < 2)
+/* Lockbox Firmware Memory Cleanup Routine Does not Clear Registers */
+#define ANOMALY_05000408 (1)
+/* Lockbox firmware leaves MDMA0 channel enabled */
+#define ANOMALY_05000409 (__SILICON_REVISION__ < 2)
+/* Incorrect Default Internal Voltage Regulator Setting */
+#define ANOMALY_05000410 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* bfrom_SysControl() Firmware Function Cannot be Used to Enter Power Saving Modes */
+#define ANOMALY_05000411 (__SILICON_REVISION__ < 2)
+/* OTP_CHECK_FOR_PREV_WRITE Bit is Not Functional in bfrom_OtpWrite() API */
+#define ANOMALY_05000414 (__SILICON_REVISION__ < 2)
+/* DEB2_URGENT Bit Not Functional */
+#define ANOMALY_05000415 (__SILICON_REVISION__ < 2)
+/* Speculative Fetches Can Cause Undesired External FIFO Operations */
+#define ANOMALY_05000416 (1)
+/* SPORT0 Ignores External TSCLK0 on PG14 When TMR6 is an Output */
+#define ANOMALY_05000417 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* tSFSPE and tHFSPE Do Not Meet Data Sheet Specifications */
+#define ANOMALY_05000418 (__SILICON_REVISION__ < 2)
+/* USB PLL_STABLE Bit May Not Accurately Reflect the USB PLL's Status */
+#define ANOMALY_05000420 (__SILICON_REVISION__ < 2)
+/* TWI Fall Time (Tof) May Violate the Minimum I2C Specification */
+#define ANOMALY_05000421 (1)
+/* TWI Input Capacitance (Ci) May Violate the Maximum I2C Specification */
+#define ANOMALY_05000422 (ANOMALY_BF527 && __SILICON_REVISION__ > 1)
+/* Certain Ethernet Frames With Errors are Misclassified in RMII Mode */
+#define ANOMALY_05000423 (__SILICON_REVISION__ < 2)
+/* Internal Voltage Regulator Not Trimmed */
+#define ANOMALY_05000424 (ANOMALY_BF527 && __SILICON_REVISION__ < 2)
+/* Multichannel SPORT Channel Misalignment Under Specific Configuration */
+#define ANOMALY_05000425 (__SILICON_REVISION__ < 2)
+/* Speculative Fetches of Indirect-Pointer Instructions Can Cause Spurious Hardware Errors */
+#define ANOMALY_05000426 (1)
+/* WB_EDGE Bit in NFC_IRQSTAT Incorrectly Reflects Buffer Status Instead of IRQ Status */
+#define ANOMALY_05000429 (__SILICON_REVISION__ < 2)
+/* Software System Reset Corrupts PLL_LOCKCNT Register */
+#define ANOMALY_05000430 (ANOMALY_BF527 && __SILICON_REVISION__ > 1)
+/* bfrom_SysControl() Does Not Clear SIC_IWR1 Before Executing PLL Programming Sequence */
+#define ANOMALY_05000432 (ANOMALY_BF526)
+/* Certain SIC Registers are not Reset After Soft or Core Double Fault Reset */
+#define ANOMALY_05000435 ((ANOMALY_BF526 && __SILICON_REVISION__ < 1) || ANOMALY_BF527)
+/* IFLUSH Instruction at End of Hardware Loop Causes Infinite Stall */
+#define ANOMALY_05000443 (1)
 
 /* Anomalies that don't exist on this proc */
 #define ANOMALY_05000125 (0)
@@ -95,10 +167,12 @@
 #define ANOMALY_05000263 (0)
 #define ANOMALY_05000266 (0)
 #define ANOMALY_05000273 (0)
+#define ANOMALY_05000285 (0)
 #define ANOMALY_05000307 (0)
 #define ANOMALY_05000311 (0)
+#define ANOMALY_05000312 (0)
 #define ANOMALY_05000323 (0)
-#define ANOMALY_05000353 (1)
 #define ANOMALY_05000363 (0)
+#define ANOMALY_05000412 (0)
 
 #endif
diff -Naur u-boot-2009.01/include/asm-blackfin/mach-bf533/anomaly.h u-boot/include/asm-blackfin/mach-bf533/anomaly.h
--- u-boot-2009.01/include/asm-blackfin/mach-bf533/anomaly.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/mach-bf533/anomaly.h	2009-02-26 14:03:58.000000000 +0100
@@ -7,7 +7,7 @@
  */
 
 /* This file shoule be up to date with:
- *  - Revision C, 02/08/2008; ADSP-BF531/BF532/BF533 Blackfin Processor Anomaly List
+ *  - Revision E, 09/18/2008; ADSP-BF531/BF532/BF533 Blackfin Processor Anomaly List
  */
 
 #ifndef _MACH_ANOMALY_H_
@@ -97,11 +97,11 @@
 /* UART STB Bit Incorrectly Affects Receiver Setting */
 #define ANOMALY_05000231 (__SILICON_REVISION__ < 5)
 /* PPI_FS3 Is Not Driven in 2 or 3 Internal Frame Sync Transmit Modes */
-#define ANOMALY_05000233 (__SILICON_REVISION__ < 4)
+#define ANOMALY_05000233 (__SILICON_REVISION__ < 6)
 /* Incorrect Revision Number in DSPID Register */
 #define ANOMALY_05000234 (__SILICON_REVISION__ == 4)
 /* DF Bit in PLL_CTL Register Does Not Respond to Hardware Reset */
-#define ANOMALY_05000242 (__SILICON_REVISION__ < 4)
+#define ANOMALY_05000242 (__SILICON_REVISION__ < 5)
 /* If I-Cache Is On, CSYNC/SSYNC/IDLE Around Change of Control Causes Failures */
 #define ANOMALY_05000244 (__SILICON_REVISION__ < 5)
 /* Spurious Hardware Error from an Access in the Shadow of a Conditional Branch */
@@ -131,7 +131,7 @@
 /* CSYNC/SSYNC/IDLE Causes Infinite Stall in Penultimate Instruction in Hardware Loop */
 #define ANOMALY_05000264 (__SILICON_REVISION__ < 5)
 /* Sensitivity To Noise with Slow Input Edge Rates on External SPORT TX and RX Clocks */
-#define ANOMALY_05000265 (__SILICON_REVISION__ < 5)
+#define ANOMALY_05000265 (1)
 /* High I/O Activity Causes Output Voltage of Internal Voltage Regulator (Vddint) to Increase */
 #define ANOMALY_05000269 (__SILICON_REVISION__ < 5)
 /* High I/O Activity Causes Output Voltage of Internal Voltage Regulator (Vddint) to Decrease */
@@ -141,23 +141,23 @@
 /* Certain Data Cache Writethrough Modes Fail for Vddint <= 0.9V */
 #define ANOMALY_05000272 (1)
 /* Writes to Synchronous SDRAM Memory May Be Lost */
-#define ANOMALY_05000273 (1)
+#define ANOMALY_05000273 (__SILICON_REVISION__ < 6)
 /* Timing Requirements Change for External Frame Sync PPI Modes with Non-Zero PPI_DELAY */
 #define ANOMALY_05000276 (1)
 /* Writes to an I/O Data Register One SCLK Cycle after an Edge Is Detected May Clear Interrupt */
-#define ANOMALY_05000277 (1)
+#define ANOMALY_05000277 (__SILICON_REVISION__ < 6)
 /* Disabling Peripherals with DMA Running May Cause DMA System Instability */
-#define ANOMALY_05000278 (1)
+#define ANOMALY_05000278 (__SILICON_REVISION__ < 6)
 /* False Hardware Error Exception When ISR Context Is Not Restored */
-#define ANOMALY_05000281 (1)
+#define ANOMALY_05000281 (__SILICON_REVISION__ < 6)
 /* Memory DMA Corruption with 32-Bit Data and Traffic Control */
-#define ANOMALY_05000282 (1)
+#define ANOMALY_05000282 (__SILICON_REVISION__ < 6)
 /* System MMR Write Is Stalled Indefinitely When Killed in a Particular Stage */
-#define ANOMALY_05000283 (1)
+#define ANOMALY_05000283 (__SILICON_REVISION__ < 6)
 /* SPORTs May Receive Bad Data If FIFOs Fill Up */
-#define ANOMALY_05000288 (1)
+#define ANOMALY_05000288 (__SILICON_REVISION__ < 6)
 /* Memory-To-Memory DMA Source/Destination Descriptors Must Be in Same Memory Space */
-#define ANOMALY_05000301 (1)
+#define ANOMALY_05000301 (__SILICON_REVISION__ < 6)
 /* SSYNCs After Writes To DMA MMR Registers May Not Be Handled Correctly */
 #define ANOMALY_05000302 (__SILICON_REVISION__ < 5)
 /* New Feature: Additional Hysteresis on SPORT Input Pins (Not Available On Older Silicon) */
@@ -169,30 +169,37 @@
 /* False Hardware Errors Caused by Fetches at the Boundary of Reserved Memory */
 #define ANOMALY_05000310 (1)
 /* Erroneous Flag (GPIO) Pin Operations under Specific Sequences */
-#define ANOMALY_05000311 (1)
+#define ANOMALY_05000311 (__SILICON_REVISION__ < 6)
 /* Errors When SSYNC, CSYNC, or Loads to LT, LB and LC Registers Are Interrupted */
-#define ANOMALY_05000312 (1)
+#define ANOMALY_05000312 (__SILICON_REVISION__ < 6)
 /* PPI Is Level-Sensitive on First Transfer */
-#define ANOMALY_05000313 (1)
+#define ANOMALY_05000313 (__SILICON_REVISION__ < 6)
 /* Killed System MMR Write Completes Erroneously On Next System MMR Access */
-#define ANOMALY_05000315 (1)
+#define ANOMALY_05000315 (__SILICON_REVISION__ < 6)
 /* Internal Voltage Regulator Values of 1.05V, 1.10V and 1.15V Not Allowed for LQFP Packages */
-#define ANOMALY_05000319 (ANOMALY_BF531 || ANOMALY_BF532)
+#define ANOMALY_05000319 ((ANOMALY_BF531 || ANOMALY_BF532) && __SILICON_REVISION__ < 6)
 /* Serial Port (SPORT) Multichannel Transmit Failure when Channel 0 Is Disabled */
-#define ANOMALY_05000357 (1)
+#define ANOMALY_05000357 (__SILICON_REVISION__ < 6)
 /* UART Break Signal Issues */
 #define ANOMALY_05000363 (__SILICON_REVISION__ < 5)
 /* PPI Underflow Error Goes Undetected in ITU-R 656 Mode */
 #define ANOMALY_05000366 (1)
 /* Possible RETS Register Corruption when Subroutine Is under 5 Cycles in Duration */
-#define ANOMALY_05000371 (1)
+#define ANOMALY_05000371 (__SILICON_REVISION__ < 6)
 /* PPI Does Not Start Properly In Specific Mode */
-#define ANOMALY_05000400 (__SILICON_REVISION__ >= 5)
+#define ANOMALY_05000400 (__SILICON_REVISION__ == 5)
 /* SSYNC Stalls Processor when Executed from Non-Cacheable Memory */
-#define ANOMALY_05000402 (__SILICON_REVISION__ >= 5)
+#define ANOMALY_05000402 (__SILICON_REVISION__ == 5)
 /* Level-Sensitive External GPIO Wakeups May Cause Indefinite Stall */
 #define ANOMALY_05000403 (1)
-
+/* Speculative Fetches Can Cause Undesired External FIFO Operations */
+#define ANOMALY_05000416 (1)
+/* Multichannel SPORT Channel Misalignment Under Specific Configuration */
+#define ANOMALY_05000425 (1)
+/* Speculative Fetches of Indirect-Pointer Instructions Can Cause False Hardware Errors */
+#define ANOMALY_05000426 (1)
+/* IFLUSH Instruction at End of Hardware Loop Causes Infinite Stall */
+#define ANOMALY_05000443 (1)
 
 /* These anomalies have been "phased" out of analog.com anomaly sheets and are
  * here to show running on older silicon just isn't feasible.
@@ -271,5 +278,9 @@
 #define ANOMALY_05000266 (0)
 #define ANOMALY_05000323 (0)
 #define ANOMALY_05000353 (1)
+#define ANOMALY_05000386 (1)
+#define ANOMALY_05000412 (0)
+#define ANOMALY_05000432 (0)
+#define ANOMALY_05000435 (0)
 
 #endif
diff -Naur u-boot-2009.01/include/asm-blackfin/mach-bf537/anomaly.h u-boot/include/asm-blackfin/mach-bf537/anomaly.h
--- u-boot-2009.01/include/asm-blackfin/mach-bf537/anomaly.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/mach-bf537/anomaly.h	2009-02-26 14:03:58.000000000 +0100
@@ -7,7 +7,7 @@
  */
 
 /* This file shoule be up to date with:
- *  - Revision C, 02/08/2008; ADSP-BF534/ADSP-BF536/ADSP-BF537 Blackfin Processor Anomaly List
+ *  - Revision D, 09/18/2008; ADSP-BF534/ADSP-BF536/ADSP-BF537 Blackfin Processor Anomaly List
  */
 
 #ifndef _MACH_ANOMALY_H_
@@ -148,6 +148,14 @@
 #define ANOMALY_05000402 (__SILICON_REVISION__ >= 5)
 /* Level-Sensitive External GPIO Wakeups May Cause Indefinite Stall */
 #define ANOMALY_05000403 (1)
+/* Speculative Fetches Can Cause Undesired External FIFO Operations */
+#define ANOMALY_05000416 (1)
+/* Multichannel SPORT Channel Misalignment Under Specific Configuration */
+#define ANOMALY_05000425 (1)
+/* Speculative Fetches of Indirect-Pointer Instructions Can Cause False Hardware Errors */
+#define ANOMALY_05000426 (1)
+/* IFLUSH Instruction at End of Hardware Loop Causes Infinite Stall */
+#define ANOMALY_05000443 (1)
 
 /* Anomalies that don't exist on this proc */
 #define ANOMALY_05000125 (0)
@@ -160,5 +168,9 @@
 #define ANOMALY_05000323 (0)
 #define ANOMALY_05000353 (1)
 #define ANOMALY_05000363 (0)
+#define ANOMALY_05000386 (1)
+#define ANOMALY_05000412 (0)
+#define ANOMALY_05000432 (0)
+#define ANOMALY_05000435 (0)
 
 #endif
diff -Naur u-boot-2009.01/include/asm-blackfin/mach-bf548/anomaly.h u-boot/include/asm-blackfin/mach-bf548/anomaly.h
--- u-boot-2009.01/include/asm-blackfin/mach-bf548/anomaly.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/mach-bf548/anomaly.h	2009-02-26 14:03:59.000000000 +0100
@@ -7,7 +7,7 @@
  */
 
 /* This file shoule be up to date with:
- *  - Revision F, 06/11/2008; ADSP-BF542/BF544/BF547/BF548/BF549 Blackfin Processor Anomaly List
+ *  - Revision G, 08/07/2008; ADSP-BF542/BF544/BF547/BF548/BF549 Blackfin Processor Anomaly List
  */
 
 #ifndef _MACH_ANOMALY_H_
@@ -36,7 +36,7 @@
 /* TWI Slave Boot Mode Is Not Functional */
 #define ANOMALY_05000324 (__SILICON_REVISION__ < 1)
 /* External FIFO Boot Mode Is Not Functional */
-#define ANOMALY_05000325 (__SILICON_REVISION__ < 1)
+#define ANOMALY_05000325 (__SILICON_REVISION__ < 2)
 /* Data Lost When Core and DMA Accesses Are Made to the USB FIFO Simultaneously */
 #define ANOMALY_05000327 (__SILICON_REVISION__ < 1)
 /* Incorrect Access of OTP_STATUS During otp_write() Function */
@@ -61,6 +61,8 @@
 #define ANOMALY_05000344 (__SILICON_REVISION__ < 1)
 /* USB Calibration Value Is Not Intialized */
 #define ANOMALY_05000346 (__SILICON_REVISION__ < 1)
+/* USB Calibration Value to use */
+#define ANOMALY_05000346_value 0x5411
 /* Preboot Routine Incorrectly Alters Reset Value of USB Register */
 #define ANOMALY_05000347 (__SILICON_REVISION__ < 1)
 /* Data Lost when Core Reads SDH Data FIFO */
@@ -68,7 +70,7 @@
 /* PLL Status Register Is Inaccurate */
 #define ANOMALY_05000351 (__SILICON_REVISION__ < 1)
 /* bfrom_SysControl() Firmware Function Performs Improper System Reset */
-#define ANOMALY_05000353 (1)
+#define ANOMALY_05000353 (__SILICON_REVISION__ < 2)
 /* Regulator Programming Blocked when Hibernate Wakeup Source Remains Active */
 #define ANOMALY_05000355 (__SILICON_REVISION__ < 1)
 /* System Stalled During A Core Access To AMC While A Core Access To NFC FIFO Is Required */
@@ -86,13 +88,13 @@
 /* Default PLL MSEL and SSEL Settings Can Cause 400MHz Product To Violate Specifications */
 #define ANOMALY_05000370 (__SILICON_REVISION__ < 1)
 /* Possible RETS Register Corruption when Subroutine Is under 5 Cycles in Duration */
-#define ANOMALY_05000371 (1)
+#define ANOMALY_05000371 (__SILICON_REVISION__ < 2)
 /* USB DP/DM Data Pins May Lose State When Entering Hibernate */
 #define ANOMALY_05000372 (__SILICON_REVISION__ < 1)
 /* Mobile DDR Operation Not Functional */
 #define ANOMALY_05000377 (1)
 /* Security/Authentication Speedpath Causes Authentication To Fail To Initiate */
-#define ANOMALY_05000378 (1)
+#define ANOMALY_05000378 (__SILICON_REVISION__ < 2)
 /* 16-Bit NAND FLASH Boot Mode Is Not Functional */
 #define ANOMALY_05000379 (1)
 /* 8-Bit NAND Flash Boot Mode Not Functional */
@@ -126,25 +128,37 @@
 /* BK_ONES, BK_ZEROS, and BK_DATECODE Constants Not Functional */
 #define ANOMALY_05000397 (__SILICON_REVISION__ < 1)
 /* Lockbox SESR Disallows Certain User Interrupts */
-#define ANOMALY_05000404 (1)
+#define ANOMALY_05000404 (__SILICON_REVISION__ < 2)
 /* Lockbox SESR Firmware Does Not Save/Restore Full Context */
 #define ANOMALY_05000405 (1)
 /* Lockbox SESR Argument Checking Does Not Check L2 Memory Protection Range */
-#define ANOMALY_05000406 (1)
+#define ANOMALY_05000406 (__SILICON_REVISION__ < 2)
 /* Lockbox SESR Firmware Arguments Are Not Retained After First Initialization */
-#define ANOMALY_05000407 (1)
+#define ANOMALY_05000407 (__SILICON_REVISION__ < 2)
 /* Lockbox Firmware Memory Cleanup Routine Does not Clear Registers */
 #define ANOMALY_05000408 (1)
 /* Lockbox firmware leaves MDMA0 channel enabled */
-#define ANOMALY_05000409 (1)
+#define ANOMALY_05000409 (__SILICON_REVISION__ < 2)
 /* bfrom_SysControl() Firmware Function Cannot be Used to Enter Power Saving Modes */
-#define ANOMALY_05000411 (1)
-/* FIFO Boot Mode Is Not Functional */
-#define ANOMALY_05000412 (1)
+#define ANOMALY_05000411 (__SILICON_REVISION__ < 2)
 /* NAND Boot Mode Not Compatible With Some NAND Flash Devices */
-#define ANOMALY_05000413 (1)
+#define ANOMALY_05000413 (__SILICON_REVISION__ < 2)
 /* OTP_CHECK_FOR_PREV_WRITE Bit is Not Functional in bfrom_OtpWrite() API */
-#define ANOMALY_05000414 (1)
+#define ANOMALY_05000414 (__SILICON_REVISION__ < 2)
+/* Speculative Fetches Can Cause Undesired External FIFO Operations */
+#define ANOMALY_05000416 (1)
+/* Multichannel SPORT Channel Misalignment Under Specific Configuration */
+#define ANOMALY_05000425 (1)
+/* Speculative Fetches of Indirect-Pointer Instructions Can Cause Spurious Hardware Errors */
+#define ANOMALY_05000426 (1)
+/* CORE_EPPI_PRIO bit and SYS_EPPI_PRIO bit in the HMDMA1_CONTROL register are not functional */
+#define ANOMALY_05000427 (__SILICON_REVISION__ < 2)
+/* WB_EDGE Bit in NFC_IRQSTAT Incorrectly Behaves as a Buffer Status Bit Instead of an IRQ Status Bit */
+#define ANOMALY_05000429 (__SILICON_REVISION__ < 2)
+/* Software System Reset Corrupts PLL_LOCKCNT Register */
+#define ANOMALY_05000430 (__SILICON_REVISION__ >= 2)
+/* IFLUSH Instruction at End of Hardware Loop Causes Infinite Stall */
+#define ANOMALY_05000443 (1)
 
 /* Anomalies that don't exist on this proc */
 #define ANOMALY_05000125 (0)
@@ -161,5 +175,8 @@
 #define ANOMALY_05000311 (0)
 #define ANOMALY_05000323 (0)
 #define ANOMALY_05000363 (0)
+#define ANOMALY_05000412 (0)
+#define ANOMALY_05000432 (0)
+#define ANOMALY_05000435 (0)
 
 #endif
diff -Naur u-boot-2009.01/include/asm-blackfin/mach-bf548/ports.h u-boot/include/asm-blackfin/mach-bf548/ports.h
--- u-boot-2009.01/include/asm-blackfin/mach-bf548/ports.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/mach-bf548/ports.h	2009-02-26 14:03:59.000000000 +0100
@@ -236,7 +236,25 @@
 #define PH14			0x4000
 #define PH15			0x8000
 
-/* Port J Masks */
+/* Port I Masks */
+#define PI0			0x0001
+#define PI1			0x0002
+#define PI2			0x0004
+#define PI3			0x0008
+#define PI4			0x0010
+#define PI5			0x0020
+#define PI6			0x0040
+#define PI7			0x0080
+#define PI8			0x0100
+#define PI9			0x0200
+#define PI10			0x0400
+#define PI11			0x0800
+#define PI12			0x1000
+#define PI13			0x2000
+#define PI14			0x4000
+#define PI15			0x8000
+
+/* Port I Masks */
 #define PJ0			0x0001
 #define PJ1			0x0002
 #define PJ2			0x0004
diff -Naur u-boot-2009.01/include/asm-blackfin/mach-bf561/anomaly.h u-boot/include/asm-blackfin/mach-bf561/anomaly.h
--- u-boot-2009.01/include/asm-blackfin/mach-bf561/anomaly.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/mach-bf561/anomaly.h	2009-02-26 14:03:59.000000000 +0100
@@ -7,7 +7,7 @@
  */
 
 /* This file shoule be up to date with:
- *  - Revision P, 02/08/2008; ADSP-BF561 Blackfin Processor Anomaly List
+ *  - Revision Q, 11/07/2008; ADSP-BF561 Blackfin Processor Anomaly List
  */
 
 #ifndef _MACH_ANOMALY_H_
@@ -264,6 +264,18 @@
 #define ANOMALY_05000371 (1)
 /* Level-Sensitive External GPIO Wakeups May Cause Indefinite Stall */
 #define ANOMALY_05000403 (1)
+/* TESTSET Instruction Causes Data Corruption with Writeback Data Cache Enabled */
+#define ANOMALY_05000412 (1)
+/* Speculative Fetches Can Cause Undesired External FIFO Operations */
+#define ANOMALY_05000416 (1)
+/* Multichannel SPORT Channel Misalignment Under Specific Configuration */
+#define ANOMALY_05000425 (1)
+/* Speculative Fetches of Indirect-Pointer Instructions Can Cause False Hardware Errors */
+#define ANOMALY_05000426 (1)
+/* Lost/Corrupted L2/L3 Memory Write after Speculative L2 Memory Read by Core B */
+#define ANOMALY_05000428 (__SILICON_REVISION__ > 3)
+/* IFLUSH Instruction at End of Hardware Loop Causes Infinite Stall */
+#define ANOMALY_05000443 (1)
 
 /* Anomalies that don't exist on this proc */
 #define ANOMALY_05000158 (0)
@@ -271,5 +283,8 @@
 #define ANOMALY_05000273 (0)
 #define ANOMALY_05000311 (0)
 #define ANOMALY_05000353 (1)
+#define ANOMALY_05000386 (1)
+#define ANOMALY_05000432 (0)
+#define ANOMALY_05000435 (0)
 
 #endif
diff -Naur u-boot-2009.01/include/asm-blackfin/mach-common/bits/bootrom.h u-boot/include/asm-blackfin/mach-common/bits/bootrom.h
--- u-boot-2009.01/include/asm-blackfin/mach-common/bits/bootrom.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/mach-common/bits/bootrom.h	2009-02-26 14:03:59.000000000 +0100
@@ -88,27 +88,42 @@
 #define _BOOTROM_REV                   0xEF000040
 #define _BOOTROM_SESR                  0xEF001000
 
+#define BOOTROM_FOLLOWS_C_ABI 1
+
 #define BOOTROM_CAPS_ADI_BOOT_STRUCTS 1
 
-/* Not available on initial BF54x or BF52x */
-#if (defined(__ADSPBF54x__) && __SILICON_REVISION__ < 1) || \
-    (defined(__ADSPBF52x__) && __SILICON_REVISION__ < 2)
-#define BOOTROM_CAPS_SYSCONTROL 0
-#else
-#define BOOTROM_CAPS_SYSCONTROL 1
 #endif
 
+#ifndef BOOTROM_FOLLOWS_C_ABI
+#define BOOTROM_FOLLOWS_C_ABI 0
 #endif
-
 #ifndef BOOTROM_CAPS_ADI_BOOT_STRUCTS
 #define BOOTROM_CAPS_ADI_BOOT_STRUCTS 0
 #endif
-#ifndef BOOTROM_CAPS_SYSCONTROL
-#define BOOTROM_CAPS_SYSCONTROL 0
-#endif
+
+/* Possible syscontrol action flags */
+#define SYSCTRL_READ        0x00000000    /* read registers */
+#define SYSCTRL_WRITE       0x00000001    /* write registers */
+#define SYSCTRL_SYSRESET    0x00000002    /* perform system reset */
+#define SYSCTRL_CORERESET   0x00000004    /* perform core reset */
+#define SYSCTRL_SOFTRESET   0x00000006    /* perform core and system reset */
+#define SYSCTRL_VRCTL       0x00000010    /* read/write VR_CTL register */
+#define SYSCTRL_EXTVOLTAGE  0x00000020    /* VDDINT supplied externally */
+#define SYSCTRL_INTVOLTAGE  0x00000000    /* VDDINT generated by on-chip regulator */
+#define SYSCTRL_OTPVOLTAGE  0x00000040    /* For Factory Purposes Only */
+#define SYSCTRL_PLLCTL      0x00000100    /* read/write PLL_CTL register */
+#define SYSCTRL_PLLDIV      0x00000200    /* read/write PLL_DIV register */
+#define SYSCTRL_LOCKCNT     0x00000400    /* read/write PLL_LOCKCNT register */
+#define SYSCTRL_PLLSTAT     0x00000800    /* read/write PLL_STAT register */
 
 #ifndef __ASSEMBLY__
 
+#if BOOTROM_FOLLOWS_C_ABI
+# define BOOTROM_CALLED_FUNC_ATTR
+#else
+# define BOOTROM_CALLED_FUNC_ATTR __attribute__((saveall))
+#endif
+
 /* Structures for the syscontrol() function */
 typedef struct ADI_SYSCTRL_VALUES {
 	uint16_t uwVrCtl;
@@ -121,25 +136,26 @@
 #ifndef _BOOTROM_SYSCONTROL
 #define _BOOTROM_SYSCONTROL 0
 #endif
-static uint32_t (* const syscontrol)(uint32_t action_flags, ADI_SYSCTRL_VALUES *power_settings, void *reserved) = (void *)_BOOTROM_SYSCONTROL;
-
-#endif /* __ASSEMBLY__ */
-
-/* Possible syscontrol action flags */
-#define SYSCTRL_READ        0x00000000    /* read registers */
-#define SYSCTRL_WRITE       0x00000001    /* write registers */
-#define SYSCTRL_SYSRESET    0x00000002    /* perform system reset */
-#define SYSCTRL_SOFTRESET   0x00000004    /* perform core and system reset */
-#define SYSCTRL_VRCTL       0x00000010    /* read/write VR_CTL register */
-#define SYSCTRL_EXTVOLTAGE  0x00000020    /* VDDINT supplied externally */
-#define SYSCTRL_INTVOLTAGE  0x00000000    /* VDDINT generated by on-chip regulator */
-#define SYSCTRL_OTPVOLTAGE  0x00000040    /* For Factory Purposes Only */
-#define SYSCTRL_PLLCTL      0x00000100    /* read/write PLL_CTL register */
-#define SYSCTRL_PLLDIV      0x00000200    /* read/write PLL_DIV register */
-#define SYSCTRL_LOCKCNT     0x00000400    /* read/write PLL_LOCKCNT register */
-#define SYSCTRL_PLLSTAT     0x00000800    /* read/write PLL_STAT register */
+static uint32_t (* const bfrom_SysControl)(uint32_t action_flags, ADI_SYSCTRL_VALUES *power_settings, void *reserved) = (void *)_BOOTROM_SYSCONTROL;
 
-#ifndef __ASSEMBLY__
+/* We need a dedicated function since we need to screw with the stack pointer
+ * when resetting.  The on-chip ROM will save/restore registers on the stack
+ * when doing a system reset, so the stack cannot be outside of the chip.
+ */
+__attribute__((__noreturn__))
+static inline void bfrom_SoftReset(void *new_stack)
+{
+	while (1)
+		__asm__ __volatile__(
+			"sp = %[stack];"
+			"jump (%[bfrom_syscontrol]);"
+			: : [bfrom_syscontrol] "p"(bfrom_SysControl),
+				"q0"(SYSCTRL_SOFTRESET),
+				"q1"(0),
+				"q2"(NULL),
+				[stack] "p"(new_stack)
+		);
+}
 
 /* Structures for working with LDRs and boot rom callbacks */
 typedef struct ADI_BOOT_HEADER {
diff -Naur u-boot-2009.01/include/asm-blackfin/mach-common/bits/ebiu.h u-boot/include/asm-blackfin/mach-common/bits/ebiu.h
--- u-boot-2009.01/include/asm-blackfin/mach-common/bits/ebiu.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/mach-common/bits/ebiu.h	2009-02-26 14:03:59.000000000 +0100
@@ -357,8 +357,8 @@
 #define EBSZ_32		0x0002		/* SDRAM External Bank Size = 32MB */
 #define EBSZ_64		0x0004		/* SDRAM External Bank Size = 64MB */
 #define EBSZ_128	0x0006		/* SDRAM External Bank Size = 128MB */
-#define EBSZ_256	0x0007		/* SDRAM External Bank Size = 256MB */
-#define EBSZ_512	0x0008		/* SDRAM External Bank Size = 512MB */
+#define EBSZ_256	0x0008		/* SDRAM External Bank Size = 256MB */
+#define EBSZ_512	0x000A		/* SDRAM External Bank Size = 512MB */
 #define EBCAW_8		0x0000		/* SDRAM External Bank Column Address Width = 8 Bits */
 #define EBCAW_9		0x0010		/* SDRAM External Bank Column Address Width = 9 Bits */
 #define EBCAW_10	0x0020		/* SDRAM External Bank Column Address Width = 10 Bits */
@@ -410,12 +410,31 @@
 
 /* EBIU_SDSTAT Masks */
 #define SDCI		0x0001		/* SDRAM controller is idle */
-#define SDSRA		0x0002		/* SDRAM SDRAM self refresh is active */
+#define SDSRA		0x0002		/* SDRAM self refresh is active */
 #define SDPUA		0x0004		/* SDRAM power up active */
 #define SDRS		0x0008		/* SDRAM is in reset state */
 #define SDEASE		0x0010		/* SDRAM EAB sticky error status - W1C */
 #define BGSTAT		0x0020		/* Bus granted */
 
+/* Only available on DDR based-parts */
+#else
+
+/* EBIU_ERRMST Masks */
+#define DEB0_ERROR	0x0001		/* DEB0 access on reserved memory */
+#define DEB1_ERROR	0x0002		/* DEB1 access on reserved memory */
+#define DEB2_ERROR	0x0004		/* DEB2 (USB) access on reserved memory */
+#define CORE_ERROR	0x0008		/* Core access on reserved memory */
+#define DEB0_MERROR	0x0010		/* DEB0 access on reserved memory and DEB0_ERROR is set */
+#define DEB1_MERROR	0x0020		/* DEB1 access on reserved memory and DEB1_ERROR is set */
+#define DEB2_MERROR	0x0040		/* DEB2 access on reserved memory and DEB2_ERROR is set */
+#define CORE_MERROR	0x0080		/* Core access on reserved memory and CORE_ERROR is set */
+
+/* EBIU_RSTCTL Masks */
+#define DDR_SRESET	0x0001		/* Reset Control to DDR Controller */
+#define SRREQ		0x0008		/* Self Refresh Request */
+#define SRACK		0x0010		/* Self Refresh Request Acknowledgement */
+#define MDDRENABLE	0x0020		/* Mobile DDR Enable */
+
 #endif /* EBIU_SDGCTL */
 
 #endif
diff -Naur u-boot-2009.01/include/asm-blackfin/mach-common/bits/otp.h u-boot/include/asm-blackfin/mach-common/bits/otp.h
--- u-boot-2009.01/include/asm-blackfin/mach-common/bits/otp.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/mach-common/bits/otp.h	2009-02-26 14:03:59.000000000 +0100
@@ -9,23 +9,22 @@
 
 #include "bootrom.h"
 
-static uint32_t (* const otp_command)(uint32_t command, uint32_t value) = (void *)_BOOTROM_OTP_COMMAND;
-static uint32_t (* const otp_read)(uint32_t page, uint32_t flags, uint64_t *page_content) = (void *)_BOOTROM_OTP_READ;
-static uint32_t (* const otp_write)(uint32_t page, uint32_t flags, uint64_t *page_content) = (void *)_BOOTROM_OTP_WRITE;
+static uint32_t (* const bfrom_OtpCommand)(uint32_t command, uint32_t value) = (void *)_BOOTROM_OTP_COMMAND;
+static uint32_t (* const bfrom_OtpRead)(uint32_t page, uint32_t flags, uint64_t *page_content) = (void *)_BOOTROM_OTP_READ;
+static uint32_t (* const bfrom_OtpWrite)(uint32_t page, uint32_t flags, uint64_t *page_content) = (void *)_BOOTROM_OTP_WRITE;
 
 #endif
 
 /* otp_command(): defines for "command" */
-#define OTP_INIT             0x00000001
-#define OTP_CLOSE            0x00000002
+#define OTP_INIT                 0x00000001
+#define OTP_CLOSE                0x00000002
 
 /* otp_{read,write}(): defines for "flags" */
-#define OTP_LOWER_HALF       0x00000000 /* select upper/lower 64-bit half (bit 0) */
-#define OTP_UPPER_HALF       0x00000001
-#define OTP_NO_ECC           0x00000010 /* do not use ECC */
-#define OTP_LOCK             0x00000020 /* sets page protection bit for page */
-#define OTP_ACCESS_READ      0x00001000
-#define OTP_ACCESS_READWRITE 0x00002000
+#define OTP_LOWER_HALF           0x00000000 /* select upper/lower 64-bit half (bit 0) */
+#define OTP_UPPER_HALF           0x00000001
+#define OTP_NO_ECC               0x00000010 /* do not use ECC */
+#define OTP_LOCK                 0x00000020 /* sets page protection bit for page */
+#define OTP_CHECK_FOR_PREV_WRITE 0x00000080
 
 /* Return values for all functions */
 #define OTP_SUCCESS          0x00000000
diff -Naur u-boot-2009.01/include/asm-blackfin/mach-common/bits/pata.h u-boot/include/asm-blackfin/mach-common/bits/pata.h
--- u-boot-2009.01/include/asm-blackfin/mach-common/bits/pata.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-blackfin/mach-common/bits/pata.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,220 @@
+/*
+ * ATAPI Masks
+ */
+
+#ifndef __BFIN_PERIPHERAL_PATA__
+#define __BFIN_PERIPHERAL_PATA__
+
+/* Bit masks for ATAPI_CONTROL */
+#define                 PIO_START  0x1        /* Start PIO/Reg Op */
+#define               MULTI_START  0x2        /* Start Multi-DMA Op */
+#define               ULTRA_START  0x4        /* Start Ultra-DMA Op */
+#define                  XFER_DIR  0x8        /* Transfer Direction */
+#define                  IORDY_EN  0x10       /* IORDY Enable */
+#define                FIFO_FLUSH  0x20       /* Flush FIFOs */
+#define                  SOFT_RST  0x40       /* Soft Reset */
+#define                   DEV_RST  0x80       /* Device Reset */
+#define                TFRCNT_RST  0x100      /* Trans Count Reset */
+#define               END_ON_TERM  0x200      /* End/Terminate Select */
+#define               PIO_USE_DMA  0x400      /* PIO-DMA Enable */
+#define          UDMAIN_FIFO_THRS  0xf000     /* Ultra DMA-IN FIFO Threshold */
+
+/* Bit masks for ATAPI_STATUS */
+#define               PIO_XFER_ON  0x1        /* PIO transfer in progress */
+#define             MULTI_XFER_ON  0x2        /* Multi-word DMA transfer in progress */
+#define             ULTRA_XFER_ON  0x4        /* Ultra DMA transfer in progress */
+#define               ULTRA_IN_FL  0xf0       /* Ultra DMA Input FIFO Level */
+
+/* Bit masks for ATAPI_DEV_ADDR */
+#define                  DEV_ADDR  0x1f       /* Device Address */
+
+/* Bit masks for ATAPI_INT_MASK */
+#define        ATAPI_DEV_INT_MASK  0x1        /* Device interrupt mask */
+#define             PIO_DONE_MASK  0x2        /* PIO transfer done interrupt mask */
+#define           MULTI_DONE_MASK  0x4        /* Multi-DMA transfer done interrupt mask */
+#define          UDMAIN_DONE_MASK  0x8        /* Ultra-DMA in transfer done interrupt mask */
+#define         UDMAOUT_DONE_MASK  0x10       /* Ultra-DMA out transfer done interrupt mask */
+#define       HOST_TERM_XFER_MASK  0x20       /* Host terminate current transfer interrupt mask */
+#define           MULTI_TERM_MASK  0x40       /* Device terminate Multi-DMA transfer interrupt mask */
+#define          UDMAIN_TERM_MASK  0x80       /* Device terminate Ultra-DMA-in transfer interrupt mask */
+#define         UDMAOUT_TERM_MASK  0x100      /* Device terminate Ultra-DMA-out transfer interrupt mask */
+
+/* Bit masks for ATAPI_INT_STATUS */
+#define             ATAPI_DEV_INT  0x1        /* Device interrupt status */
+#define              PIO_DONE_INT  0x2        /* PIO transfer done interrupt status */
+#define            MULTI_DONE_INT  0x4        /* Multi-DMA transfer done interrupt status */
+#define           UDMAIN_DONE_INT  0x8        /* Ultra-DMA in transfer done interrupt status */
+#define          UDMAOUT_DONE_INT  0x10       /* Ultra-DMA out transfer done interrupt status */
+#define        HOST_TERM_XFER_INT  0x20       /* Host terminate current transfer interrupt status */
+#define            MULTI_TERM_INT  0x40       /* Device terminate Multi-DMA transfer interrupt status */
+#define           UDMAIN_TERM_INT  0x80       /* Device terminate Ultra-DMA-in transfer interrupt status */
+#define          UDMAOUT_TERM_INT  0x100      /* Device terminate Ultra-DMA-out transfer interrupt status */
+
+/* Bit masks for ATAPI_LINE_STATUS */
+#define                ATAPI_INTR  0x1        /* Device interrupt to host line status */
+#define                ATAPI_DASP  0x2        /* Device dasp to host line status */
+#define                ATAPI_CS0N  0x4        /* ATAPI chip select 0 line status */
+#define                ATAPI_CS1N  0x8        /* ATAPI chip select 1 line status */
+#define                ATAPI_ADDR  0x70       /* ATAPI address line status */
+#define              ATAPI_DMAREQ  0x80       /* ATAPI DMA request line status */
+#define             ATAPI_DMAACKN  0x100      /* ATAPI DMA acknowledge line status */
+#define               ATAPI_DIOWN  0x200      /* ATAPI write line status */
+#define               ATAPI_DIORN  0x400      /* ATAPI read line status */
+#define               ATAPI_IORDY  0x800      /* ATAPI IORDY line status */
+
+/* Bit masks for ATAPI_SM_STATE */
+#define                PIO_CSTATE  0xf        /* PIO mode state machine current state */
+#define                DMA_CSTATE  0xf0       /* DMA mode state machine current state */
+#define             UDMAIN_CSTATE  0xf00      /* Ultra DMA-In mode state machine current state */
+#define            UDMAOUT_CSTATE  0xf000     /* ATAPI IORDY line status */
+
+/* Bit masks for ATAPI_TERMINATE */
+#define           ATAPI_HOST_TERM  0x1        /* Host terminationation */
+
+/* Bit masks for ATAPI_REG_TIM_0 */
+#define                    T2_REG  0xff       /* End of cycle time for register access transfers */
+#define                  TEOC_REG  0xff00     /* Selects DIOR/DIOW pulsewidth */
+
+/* Bit masks for ATAPI_PIO_TIM_0 */
+#define                    T1_REG  0xf        /* Time from address valid to DIOR/DIOW */
+#define                T2_REG_PIO  0xff0      /* DIOR/DIOW pulsewidth */
+#define                    T4_REG  0xf000     /* DIOW data hold */
+
+/* Bit masks for ATAPI_PIO_TIM_1 */
+#define              TEOC_REG_PIO  0xff       /* End of cycle time for PIO access transfers. */
+
+/* Bit masks for ATAPI_MULTI_TIM_0 */
+#define                        TD  0xff       /* DIOR/DIOW asserted pulsewidth */
+#define                        TM  0xff00     /* Time from address valid to DIOR/DIOW */
+
+/* Bit masks for ATAPI_MULTI_TIM_1 */
+#define                       TKW  0xff       /* Selects DIOW negated pulsewidth */
+#define                       TKR  0xff00     /* Selects DIOR negated pulsewidth */
+
+/* Bit masks for ATAPI_MULTI_TIM_2 */
+#define                        TH  0xff       /* Selects DIOW data hold */
+#define                      TEOC  0xff00     /* Selects end of cycle for DMA */
+
+/* Bit masks for ATAPI_ULTRA_TIM_0 */
+#define                      TACK  0xff       /* Selects setup and hold times for TACK */
+#define                      TENV  0xff00     /* Selects envelope time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_1 */
+#define                      TDVS  0xff       /* Selects data valid setup time */
+#define                 TCYC_TDVS  0xff00     /* Selects cycle time - TDVS time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_2 */
+#define                       TSS  0xff       /* Selects time from STROBE edge to negation of DMARQ or assertion of STOP */
+#define                      TMLI  0xff00     /* Selects interlock time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_3 */
+#define                      TZAH  0xff       /* Selects minimum delay required for output */
+#define               READY_PAUSE  0xff00     /* Selects ready to pause */
+
+/* Bit masks for ATAPI_CONTROL */
+#define                 PIO_START  0x1        /* Start PIO/Reg Op */
+#define               MULTI_START  0x2        /* Start Multi-DMA Op */
+#define               ULTRA_START  0x4        /* Start Ultra-DMA Op */
+#define                  XFER_DIR  0x8        /* Transfer Direction */
+#define                  IORDY_EN  0x10       /* IORDY Enable */
+#define                FIFO_FLUSH  0x20       /* Flush FIFOs */
+#define                  SOFT_RST  0x40       /* Soft Reset */
+#define                   DEV_RST  0x80       /* Device Reset */
+#define                TFRCNT_RST  0x100      /* Trans Count Reset */
+#define               END_ON_TERM  0x200      /* End/Terminate Select */
+#define               PIO_USE_DMA  0x400      /* PIO-DMA Enable */
+#define          UDMAIN_FIFO_THRS  0xf000     /* Ultra DMA-IN FIFO Threshold */
+
+/* Bit masks for ATAPI_STATUS */
+#define               PIO_XFER_ON  0x1        /* PIO transfer in progress */
+#define             MULTI_XFER_ON  0x2        /* Multi-word DMA transfer in progress */
+#define             ULTRA_XFER_ON  0x4        /* Ultra DMA transfer in progress */
+#define               ULTRA_IN_FL  0xf0       /* Ultra DMA Input FIFO Level */
+
+/* Bit masks for ATAPI_DEV_ADDR */
+#define                  DEV_ADDR  0x1f       /* Device Address */
+
+/* Bit masks for ATAPI_INT_MASK */
+#define        ATAPI_DEV_INT_MASK  0x1        /* Device interrupt mask */
+#define             PIO_DONE_MASK  0x2        /* PIO transfer done interrupt mask */
+#define           MULTI_DONE_MASK  0x4        /* Multi-DMA transfer done interrupt mask */
+#define          UDMAIN_DONE_MASK  0x8        /* Ultra-DMA in transfer done interrupt mask */
+#define         UDMAOUT_DONE_MASK  0x10       /* Ultra-DMA out transfer done interrupt mask */
+#define       HOST_TERM_XFER_MASK  0x20       /* Host terminate current transfer interrupt mask */
+#define           MULTI_TERM_MASK  0x40       /* Device terminate Multi-DMA transfer interrupt mask */
+#define          UDMAIN_TERM_MASK  0x80       /* Device terminate Ultra-DMA-in transfer interrupt mask */
+#define         UDMAOUT_TERM_MASK  0x100      /* Device terminate Ultra-DMA-out transfer interrupt mask */
+
+/* Bit masks for ATAPI_INT_STATUS */
+#define             ATAPI_DEV_INT  0x1        /* Device interrupt status */
+#define              PIO_DONE_INT  0x2        /* PIO transfer done interrupt status */
+#define            MULTI_DONE_INT  0x4        /* Multi-DMA transfer done interrupt status */
+#define           UDMAIN_DONE_INT  0x8        /* Ultra-DMA in transfer done interrupt status */
+#define          UDMAOUT_DONE_INT  0x10       /* Ultra-DMA out transfer done interrupt status */
+#define        HOST_TERM_XFER_INT  0x20       /* Host terminate current transfer interrupt status */
+#define            MULTI_TERM_INT  0x40       /* Device terminate Multi-DMA transfer interrupt status */
+#define           UDMAIN_TERM_INT  0x80       /* Device terminate Ultra-DMA-in transfer interrupt status */
+#define          UDMAOUT_TERM_INT  0x100      /* Device terminate Ultra-DMA-out transfer interrupt status */
+
+/* Bit masks for ATAPI_LINE_STATUS */
+#define                ATAPI_INTR  0x1        /* Device interrupt to host line status */
+#define                ATAPI_DASP  0x2        /* Device dasp to host line status */
+#define                ATAPI_CS0N  0x4        /* ATAPI chip select 0 line status */
+#define                ATAPI_CS1N  0x8        /* ATAPI chip select 1 line status */
+#define                ATAPI_ADDR  0x70       /* ATAPI address line status */
+#define              ATAPI_DMAREQ  0x80       /* ATAPI DMA request line status */
+#define             ATAPI_DMAACKN  0x100      /* ATAPI DMA acknowledge line status */
+#define               ATAPI_DIOWN  0x200      /* ATAPI write line status */
+#define               ATAPI_DIORN  0x400      /* ATAPI read line status */
+#define               ATAPI_IORDY  0x800      /* ATAPI IORDY line status */
+
+/* Bit masks for ATAPI_SM_STATE */
+#define                PIO_CSTATE  0xf        /* PIO mode state machine current state */
+#define                DMA_CSTATE  0xf0       /* DMA mode state machine current state */
+#define             UDMAIN_CSTATE  0xf00      /* Ultra DMA-In mode state machine current state */
+#define            UDMAOUT_CSTATE  0xf000     /* ATAPI IORDY line status */
+
+/* Bit masks for ATAPI_TERMINATE */
+#define           ATAPI_HOST_TERM  0x1        /* Host terminationation */
+
+/* Bit masks for ATAPI_REG_TIM_0 */
+#define                    T2_REG  0xff       /* End of cycle time for register access transfers */
+#define                  TEOC_REG  0xff00     /* Selects DIOR/DIOW pulsewidth */
+
+/* Bit masks for ATAPI_PIO_TIM_0 */
+#define                    T1_REG  0xf        /* Time from address valid to DIOR/DIOW */
+#define                T2_REG_PIO  0xff0      /* DIOR/DIOW pulsewidth */
+#define                    T4_REG  0xf000     /* DIOW data hold */
+
+/* Bit masks for ATAPI_PIO_TIM_1 */
+#define              TEOC_REG_PIO  0xff       /* End of cycle time for PIO access transfers. */
+
+/* Bit masks for ATAPI_MULTI_TIM_0 */
+#define                        TD  0xff       /* DIOR/DIOW asserted pulsewidth */
+#define                        TM  0xff00     /* Time from address valid to DIOR/DIOW */
+
+/* Bit masks for ATAPI_MULTI_TIM_1 */
+#define                       TKW  0xff       /* Selects DIOW negated pulsewidth */
+#define                       TKR  0xff00     /* Selects DIOR negated pulsewidth */
+
+/* Bit masks for ATAPI_MULTI_TIM_2 */
+#define                        TH  0xff       /* Selects DIOW data hold */
+#define                      TEOC  0xff00     /* Selects end of cycle for DMA */
+
+/* Bit masks for ATAPI_ULTRA_TIM_0 */
+#define                      TACK  0xff       /* Selects setup and hold times for TACK */
+#define                      TENV  0xff00     /* Selects envelope time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_1 */
+#define                      TDVS  0xff       /* Selects data valid setup time */
+#define                 TCYC_TDVS  0xff00     /* Selects cycle time - TDVS time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_2 */
+#define                       TSS  0xff       /* Selects time from STROBE edge to negation of DMARQ or assertion of STOP */
+#define                      TMLI  0xff00     /* Selects interlock time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_3 */
+#define                      TZAH  0xff       /* Selects minimum delay required for output */
+#define               READY_PAUSE  0xff00     /* Selects ready to pause */
+
+#endif /* __BFIN_PERIPHERAL_PATA__ */
diff -Naur u-boot-2009.01/include/asm-blackfin/mach-common/bits/sdh.h u-boot/include/asm-blackfin/mach-common/bits/sdh.h
--- u-boot-2009.01/include/asm-blackfin/mach-common/bits/sdh.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-blackfin/mach-common/bits/sdh.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,122 @@
+/*
+ * SDH Masks
+ */
+
+#ifndef __BFIN_PERIPHERAL_SDH__
+#define __BFIN_PERIPHERAL_SDH__
+
+/* Bit masks for SDH_COMMAND */
+#define                   CMD_IDX  0x3f       /* Command Index */
+#define                   CMD_RSP  0x40       /* Response */
+#define                 CMD_L_RSP  0x80       /* Long Response */
+#define                 CMD_INT_E  0x100      /* Command Interrupt */
+#define                CMD_PEND_E  0x200      /* Command Pending */
+#define                     CMD_E  0x400      /* Command Enable */
+
+/* Bit masks for SDH_PWR_CTL */
+#define                    PWR_ON  0x3        /* Power On */
+#define                 SD_CMD_OD  0x40       /* Open Drain Output */
+#define                   ROD_CTL  0x80       /* Rod Control */
+
+/* Bit masks for SDH_CLK_CTL */
+#define                    CLKDIV  0xff       /* MC_CLK Divisor */
+#define                     CLK_E  0x100      /* MC_CLK Bus Clock Enable */
+#define                  PWR_SV_E  0x200      /* Power Save Enable */
+#define             CLKDIV_BYPASS  0x400      /* Bypass Divisor */
+#define                  WIDE_BUS  0x800      /* Wide Bus Mode Enable */
+
+/* Bit masks for SDH_RESP_CMD */
+#define                  RESP_CMD  0x3f       /* Response Command */
+
+/* Bit masks for SDH_DATA_CTL */
+#define                     DTX_E  0x1        /* Data Transfer Enable */
+#define                   DTX_DIR  0x2        /* Data Transfer Direction */
+#define                  DTX_MODE  0x4        /* Data Transfer Mode */
+#define                 DTX_DMA_E  0x8        /* Data Transfer DMA Enable */
+#define              DTX_BLK_LGTH  0xf0       /* Data Transfer Block Length */
+
+/* Bit masks for SDH_STATUS */
+#define              CMD_CRC_FAIL  0x1        /* CMD CRC Fail */
+#define              DAT_CRC_FAIL  0x2        /* Data CRC Fail */
+#define              CMD_TIME_OUT  0x4        /* CMD Time Out */
+#define              DAT_TIME_OUT  0x8        /* Data Time Out */
+#define               TX_UNDERRUN  0x10       /* Transmit Underrun */
+#define                RX_OVERRUN  0x20       /* Receive Overrun */
+#define              CMD_RESP_END  0x40       /* CMD Response End */
+#define                  CMD_SENT  0x80       /* CMD Sent */
+#define                   DAT_END  0x100      /* Data End */
+#define             START_BIT_ERR  0x200      /* Start Bit Error */
+#define               DAT_BLK_END  0x400      /* Data Block End */
+#define                   CMD_ACT  0x800      /* CMD Active */
+#define                    TX_ACT  0x1000     /* Transmit Active */
+#define                    RX_ACT  0x2000     /* Receive Active */
+#define              TX_FIFO_STAT  0x4000     /* Transmit FIFO Status */
+#define              RX_FIFO_STAT  0x8000     /* Receive FIFO Status */
+#define              TX_FIFO_FULL  0x10000    /* Transmit FIFO Full */
+#define              RX_FIFO_FULL  0x20000    /* Receive FIFO Full */
+#define              TX_FIFO_ZERO  0x40000    /* Transmit FIFO Empty */
+#define               RX_DAT_ZERO  0x80000    /* Receive FIFO Empty */
+#define                TX_DAT_RDY  0x100000   /* Transmit Data Available */
+#define               RX_FIFO_RDY  0x200000   /* Receive Data Available */
+
+/* Bit masks for SDH_STATUS_CLR */
+#define         CMD_CRC_FAIL_STAT  0x1        /* CMD CRC Fail Status */
+#define         DAT_CRC_FAIL_STAT  0x2        /* Data CRC Fail Status */
+#define          CMD_TIMEOUT_STAT  0x4        /* CMD Time Out Status */
+#define          DAT_TIMEOUT_STAT  0x8        /* Data Time Out status */
+#define          TX_UNDERRUN_STAT  0x10       /* Transmit Underrun Status */
+#define           RX_OVERRUN_STAT  0x20       /* Receive Overrun Status */
+#define         CMD_RESP_END_STAT  0x40       /* CMD Response End Status */
+#define             CMD_SENT_STAT  0x80       /* CMD Sent Status */
+#define              DAT_END_STAT  0x100      /* Data End Status */
+#define        START_BIT_ERR_STAT  0x200      /* Start Bit Error Status */
+#define          DAT_BLK_END_STAT  0x400      /* Data Block End Status */
+
+/* Bit masks for SDH_MASK0 */
+#define         CMD_CRC_FAIL_MASK  0x1        /* CMD CRC Fail Mask */
+#define         DAT_CRC_FAIL_MASK  0x2        /* Data CRC Fail Mask */
+#define          CMD_TIMEOUT_MASK  0x4        /* CMD Time Out Mask */
+#define          DAT_TIMEOUT_MASK  0x8        /* Data Time Out Mask */
+#define          TX_UNDERRUN_MASK  0x10       /* Transmit Underrun Mask */
+#define           RX_OVERRUN_MASK  0x20       /* Receive Overrun Mask */
+#define         CMD_RESP_END_MASK  0x40       /* CMD Response End Mask */
+#define             CMD_SENT_MASK  0x80       /* CMD Sent Mask */
+#define              DAT_END_MASK  0x100      /* Data End Mask */
+#define        START_BIT_ERR_MASK  0x200      /* Start Bit Error Mask */
+#define          DAT_BLK_END_MASK  0x400      /* Data Block End Mask */
+#define              CMD_ACT_MASK  0x800      /* CMD Active Mask */
+#define               TX_ACT_MASK  0x1000     /* Transmit Active Mask */
+#define               RX_ACT_MASK  0x2000     /* Receive Active Mask */
+#define         TX_FIFO_STAT_MASK  0x4000     /* Transmit FIFO Status Mask */
+#define         RX_FIFO_STAT_MASK  0x8000     /* Receive FIFO Status Mask */
+#define         TX_FIFO_FULL_MASK  0x10000    /* Transmit FIFO Full Mask */
+#define         RX_FIFO_FULL_MASK  0x20000    /* Receive FIFO Full Mask */
+#define         TX_FIFO_ZERO_MASK  0x40000    /* Transmit FIFO Empty Mask */
+#define          RX_DAT_ZERO_MASK  0x80000    /* Receive FIFO Empty Mask */
+#define           TX_DAT_RDY_MASK  0x100000   /* Transmit Data Available Mask */
+#define          RX_FIFO_RDY_MASK  0x200000   /* Receive Data Available Mask */
+
+/* Bit masks for SDH_FIFO_CNT */
+#define                FIFO_COUNT  0x7fff     /* FIFO Count */
+
+/* Bit masks for SDH_E_STATUS */
+#define              SDIO_INT_DET  0x2        /* SDIO Int Detected */
+#define               SD_CARD_DET  0x10       /* SD Card Detect */
+
+/* Bit masks for SDH_E_MASK */
+#define                  SDIO_MSK  0x2        /* Mask SDIO Int Detected */
+#define                   SCD_MSK  0x40       /* Mask Card Detect */
+
+/* Bit masks for SDH_CFG */
+#define                   CLKS_EN  0x1        /* Clocks Enable */
+#define                      SD4E  0x4        /* SDIO 4-Bit Enable */
+#define                       MWE  0x8        /* Moving Window Enable */
+#define                    SD_RST  0x10       /* SDMMC Reset */
+#define                 PUP_SDDAT  0x20       /* Pull-up SD_DAT */
+#define                PUP_SDDAT3  0x40       /* Pull-up SD_DAT3 */
+#define                 PD_SDDAT3  0x80       /* Pull-down SD_DAT3 */
+
+/* Bit masks for SDH_RD_WAIT_EN */
+#define                       RWR  0x1        /* Read Wait Request */
+
+#endif
diff -Naur u-boot-2009.01/include/asm-blackfin/mmc.h u-boot/include/asm-blackfin/mmc.h
--- u-boot-2009.01/include/asm-blackfin/mmc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-blackfin/mmc.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1 @@
+#include <asm-avr32/arch-at32ap700x/mmc.h>
diff -Naur u-boot-2009.01/include/asm-blackfin/posix_types.h u-boot/include/asm-blackfin/posix_types.h
--- u-boot-2009.01/include/asm-blackfin/posix_types.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-blackfin/posix_types.h	2009-02-26 14:03:59.000000000 +0100
@@ -40,15 +40,17 @@
 typedef unsigned short __kernel_nlink_t;
 typedef long __kernel_off_t;
 typedef int __kernel_pid_t;
-typedef unsigned short __kernel_ipc_pid_t;
-typedef unsigned short __kernel_uid_t;
-typedef unsigned short __kernel_gid_t;
-typedef unsigned int __kernel_size_t;
-typedef int __kernel_ssize_t;
+typedef unsigned int __kernel_ipc_pid_t;
+typedef unsigned int __kernel_uid_t;
+typedef unsigned int __kernel_gid_t;
+typedef unsigned long __kernel_size_t;
+typedef long __kernel_ssize_t;
 typedef int __kernel_ptrdiff_t;
 typedef long __kernel_time_t;
 typedef long __kernel_suseconds_t;
 typedef long __kernel_clock_t;
+typedef int __kernel_timer_t;
+typedef int __kernel_clockid_t;
 typedef int __kernel_daddr_t;
 typedef char *__kernel_caddr_t;
 typedef unsigned short __kernel_uid16_t;
@@ -67,14 +69,10 @@
 #endif
 
 typedef struct {
-#if defined(__KERNEL__) || defined(__USE_ALL)
 	int val[2];
-#else				/* !defined(__KERNEL__) && !defined(__USE_ALL) */
-	int __val[2];
-#endif				/* !defined(__KERNEL__) && !defined(__USE_ALL) */
 } __kernel_fsid_t;
 
-#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+#if defined(__KERNEL__)
 
 #undef	__FD_SET
 #define	__FD_SET(d, set)	((set)->fds_bits[__FDELT(d)] |= __FDMASK(d))
@@ -88,6 +86,6 @@
 #undef	__FD_ZERO
 #define __FD_ZERO(fdsetp) (memset (fdsetp, 0, sizeof(*(fd_set *)fdsetp)))
 
-#endif	/* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2) */
+#endif				/* defined(__KERNEL__) */
 
 #endif
diff -Naur u-boot-2009.01/include/asm-i386/config.h u-boot/include/asm-i386/config.h
--- u-boot-2009.01/include/asm-i386/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-i386/config.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#endif
diff -Naur u-boot-2009.01/include/asm-i386/interrupt.h u-boot/include/asm-i386/interrupt.h
--- u-boot-2009.01/include/asm-i386/interrupt.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-i386/interrupt.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * (C) Copyright 2008
+ * Graeme Russ, graeme.russ@gmail.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_INTERRUPT_H_
+#define __ASM_INTERRUPT_H_ 1
+
+void set_vector(int intnum, void *routine);
+
+#endif
diff -Naur u-boot-2009.01/include/asm-m68k/config.h u-boot/include/asm-m68k/config.h
--- u-boot-2009.01/include/asm-m68k/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-m68k/config.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#endif
diff -Naur u-boot-2009.01/include/asm-m68k/m5271.h u-boot/include/asm-m68k/m5271.h
--- u-boot-2009.01/include/asm-m68k/m5271.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-m68k/m5271.h	2009-02-26 14:03:59.000000000 +0100
@@ -37,8 +37,27 @@
 
 #define MCF_FMPLL_SYNCR				0x120000
 #define MCF_FMPLL_SYNSR				0x120004
+
 #define MCF_FMPLL_SYNCR_MFD(x)			((x&0x7)<<24)
+#define MCF_SYNCR_MFD_4X		0x00000000
+#define MCF_SYNCR_MFD_6X		0x01000000
+#define MCF_SYNCR_MFD_8X		0x02000000
+#define MCF_SYNCR_MFD_10X		0x03000000
+#define MCF_SYNCR_MFD_12X		0x04000000
+#define MCF_SYNCR_MFD_14X		0x05000000
+#define MCF_SYNCR_MFD_16X		0x06000000
+#define MCF_SYNCR_MFD_18X		0x07000000
+
 #define MCF_FMPLL_SYNCR_RFD(x)			((x&0x7)<<19)
+#define MCF_SYNCR_RFD_DIV1		0x00000000
+#define MCF_SYNCR_RFD_DIV2		0x00080000
+#define MCF_SYNCR_RFD_DIV4		0x00100000
+#define MCF_SYNCR_RFD_DIV8		0x00180000
+#define MCF_SYNCR_RFD_DIV16		0x00200000
+#define MCF_SYNCR_RFD_DIV32		0x00280000
+#define MCF_SYNCR_RFD_DIV64		0x00300000
+#define MCF_SYNCR_RFD_DIV128		0x00380000
+
 #define MCF_FMPLL_SYNSR_LOCK			0x8
 
 #define MCF_WTM_WCR				0x140000
@@ -50,17 +69,79 @@
 #define MCF_RCM_RCR_FRCRSTOUT			0x40
 #define MCF_RCM_RCR_SOFTRST			0x80
 
+#define MCF_GPIO_PODR_ADDR			0x100000
+#define MCF_GPIO_PODR_DATAH			0x100001
+#define MCF_GPIO_PODR_DATAL			0x100002
+#define MCF_GPIO_PODR_BUSCTL			0x100003
+#define MCF_GPIO_PODR_BS			0x100004
+#define MCF_GPIO_PODR_CS			0x100005
+#define MCF_GPIO_PODR_SDRAM			0x100006
+#define MCF_GPIO_PODR_FECI2C			0x100007
+#define MCF_GPIO_PODR_UARTH			0x100008
+#define MCF_GPIO_PODR_UARTL			0x100009
+#define MCF_GPIO_PODR_QSPI			0x10000A
+#define MCF_GPIO_PODR_TIMER			0x10000B
+
+#define MCF_GPIO_PDDR_ADDR			0x100010
+#define MCF_GPIO_PDDR_DATAH			0x100011
+#define MCF_GPIO_PDDR_DATAL			0x100012
+#define MCF_GPIO_PDDR_BUSCTL			0x100013
+#define MCF_GPIO_PDDR_BS			0x100014
+#define MCF_GPIO_PDDR_CS			0x100015
+#define MCF_GPIO_PDDR_SDRAM			0x100016
+#define MCF_GPIO_PDDR_FECI2C			0x100017
+#define MCF_GPIO_PDDR_UARTH			0x100018
+#define MCF_GPIO_PDDR_UARTL			0x100019
+#define MCF_GPIO_PDDR_QSPI			0x10001A
+#define MCF_GPIO_PDDR_TIMER			0x10001B
+
+#define MCF_GPIO_PPDSDR_ADDR			0x100020
+#define MCF_GPIO_PPDSDR_DATAH			0x100021
+#define MCF_GPIO_PPDSDR_DATAL			0x100022
+#define MCF_GPIO_PPDSDR_BUSCTL			0x100023
+#define MCF_GPIO_PPDSDR_BS			0x100024
+#define MCF_GPIO_PPDSDR_CS			0x100025
+#define MCF_GPIO_PPDSDR_SDRAM			0x100026
+#define MCF_GPIO_PPDSDR_FECI2C			0x100027
+#define MCF_GPIO_PPDSDR_UARTH			0x100028
+#define MCF_GPIO_PPDSDR_UARTL			0x100029
+#define MCF_GPIO_PPDSDR_QSPI			0x10002A
+#define MCF_GPIO_PPDSDR_TIMER			0x10002B
+
+#define MCF_GPIO_PCLRR_ADDR			0x100030
+#define MCF_GPIO_PCLRR_DATAH			0x100031
+#define MCF_GPIO_PCLRR_DATAL			0x100032
+#define MCF_GPIO_PCLRR_BUSCTL			0x100033
+#define MCF_GPIO_PCLRR_BS			0x100034
+#define MCF_GPIO_PCLRR_CS			0x100035
+#define MCF_GPIO_PCLRR_SDRAM			0x100036
+#define MCF_GPIO_PCLRR_FECI2C			0x100037
+#define MCF_GPIO_PCLRR_UARTH			0x100038
+#define MCF_GPIO_PCLRR_UARTL			0x100039
+#define MCF_GPIO_PCLRR_QSPI			0x10003A
+#define MCF_GPIO_PCLRR_TIMER			0x10003B
+
 #define MCF_GPIO_PAR_AD				0x100040
+#define MCF_GPIO_PAR_BUSCTL			0x100042
+#define MCF_GPIO_PAR_BS				0x100044
 #define MCF_GPIO_PAR_CS				0x100045
 #define MCF_GPIO_PAR_SDRAM			0x100046
 #define MCF_GPIO_PAR_FECI2C			0x100047
 #define MCF_GPIO_PAR_UART			0x100048
+#define MCF_GPIO_PAR_QSPI			0x10004A
+#define MCF_GPIO_PAR_TIMER			0x10004C
+
+#define MCF_DSCR_EIM				0x100050
+#define MCF_DCSR_FEC12C 			0x100052
+#define MCF_DCSR_UART				0x100053
+#define MCF_DCSR_QSPI				0x100054
+#define MCF_DCSR_TIMER				0x100055
 
 #define MCF_CCM_CIR				0x11000A
 #define MCF_CCM_CIR_PRN_MASK			0x3F
 #define MCF_CCM_CIR_PIN_LEN			6
-#define MCF_CCM_CIR_PIN_MCF5270			0x2e
-#define MCF_CCM_CIR_PIN_MCF5271			0x80
+#define MCF_CCM_CIR_PIN_MCF5270			0x002e
+#define MCF_CCM_CIR_PIN_MCF5271			0x0032
 
 #define MCF_GPIO_AD_ADDR23			0x80
 #define MCF_GPIO_AD_ADDR22			0x40
diff -Naur u-boot-2009.01/include/asm-microblaze/config.h u-boot/include/asm-microblaze/config.h
--- u-boot-2009.01/include/asm-microblaze/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-microblaze/config.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#endif
diff -Naur u-boot-2009.01/include/asm-mips/config.h u-boot/include/asm-mips/config.h
--- u-boot-2009.01/include/asm-mips/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-mips/config.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#endif
diff -Naur u-boot-2009.01/include/asm-mips/io.h u-boot/include/asm-mips/io.h
--- u-boot-2009.01/include/asm-mips/io.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-mips/io.h	2009-02-26 14:03:59.000000000 +0100
@@ -118,7 +118,7 @@
  * Change virtual addresses to physical addresses and vv.
  * These are trivial on the 1:1 Linux/MIPS mapping
  */
-extern inline phys_addr_t virt_to_phys(void * address)
+extern inline phys_addr_t virt_to_phys(volatile void * address)
 {
 	return CPHYSADDR(address);
 }
diff -Naur u-boot-2009.01/include/asm-nios/config.h u-boot/include/asm-nios/config.h
--- u-boot-2009.01/include/asm-nios/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-nios/config.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#endif
diff -Naur u-boot-2009.01/include/asm-nios2/config.h u-boot/include/asm-nios2/config.h
--- u-boot-2009.01/include/asm-nios2/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-nios2/config.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#endif
diff -Naur u-boot-2009.01/include/asm-ppc/config.h u-boot/include/asm-ppc/config.h
--- u-boot-2009.01/include/asm-ppc/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-ppc/config.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#ifndef CONFIG_MAX_MEM_MAPPED
+#if defined(CONFIG_4xx) || defined(CONFIG_E500)
+#define CONFIG_MAX_MEM_MAPPED	((phys_size_t)2 << 30)
+#else
+#define CONFIG_MAX_MEM_MAPPED	(256 << 20)
+#endif
+#endif
+
+#endif
diff -Naur u-boot-2009.01/include/asm-ppc/cpm_8260.h u-boot/include/asm-ppc/cpm_8260.h
--- u-boot-2009.01/include/asm-ppc/cpm_8260.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/cpm_8260.h	2009-02-26 14:03:59.000000000 +0100
@@ -546,6 +546,34 @@
 
 #define BD_SCC_TX_LAST		((ushort)0x0800)
 
+/*  SCC as HDLC controller - taken from commproc.h
+ */
+typedef struct scc_hdlc {
+	sccp_t  sh_genscc;
+	/*
+	* HDLC specific parameter RAM
+	*/
+	uchar   res[4];         /* reserved */
+	ulong   sh_cmask;       /* CRC constant */
+	ulong   sh_cpres;       /* CRC preset */
+	ushort  sh_disfc;       /* discarded frame counter */
+	ushort  sh_crcec;       /* CRC error counter */
+	ushort  sh_abtsc;       /* abort sequence counter */
+	ushort  sh_nmarc;       /* nonmatching address rx cnt */
+	ushort  sh_retrc;       /* frame retransmission cnt */
+	ushort  sh_mflr;        /* maximum frame length reg */
+	ushort  sh_maxcnt;      /* maximum length counter */
+	ushort  sh_rfthr;       /* received frames threshold */
+	ushort  sh_rfcnt;       /* received frames count */
+	ushort  sh_hmask;       /* user defined frm addr mask */
+	ushort  sh_haddr1;      /* user defined frm address 1 */
+	ushort  sh_haddr2;      /* user defined frm address 2 */
+	ushort  sh_haddr3;      /* user defined frm address 3 */
+	ushort  sh_haddr4;      /* user defined frm address 4 */
+	ushort  tmp;            /* temp */
+	ushort  tmp_mb;         /* temp */
+} scc_hdlc_t;
+
 /* How about some FCCs.....
 */
 #define FCC_GFMR_DIAG_NORM	((uint)0x00000000)
diff -Naur u-boot-2009.01/include/asm-ppc/e300.h u-boot/include/asm-ppc/e300.h
--- u-boot-2009.01/include/asm-ppc/e300.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/e300.h	2009-02-26 14:03:59.000000000 +0100
@@ -88,39 +88,4 @@
 #define HID2_IWLCK_101 0x0000A000 /* way 0 through way 4 locked */
 #define HID2_IWLCK_110 0x0000C000 /* way 0 through way 5 locked */
 
-
-/* BAT (block address translation */
-#define BATU_BEPI_MSK		0xfffe0000
-#define BATU_BL_MSK		0x00001ffc
-
-#define BATU_BL_128K		0x00000000
-#define BATU_BL_256K		0x00000004
-#define BATU_BL_512K		0x0000000c
-#define BATU_BL_1M		0x0000001c
-#define BATU_BL_2M		0x0000003c
-#define BATU_BL_4M		0x0000007c
-#define BATU_BL_8M		0x000000fc
-#define BATU_BL_16M		0x000001fc
-#define BATU_BL_32M		0x000003fc
-#define BATU_BL_64M		0x000007fc
-#define BATU_BL_128M		0x00000ffc
-#define BATU_BL_256M		0x00001ffc
-
-#define BATU_VS			0x00000002
-#define BATU_VP			0x00000001
-
-#define BATL_BRPN_MSK		0xfffe0000
-#define BATL_WIMG_MSK		0x00000078
-
-#define BATL_WRITETHROUGH	0x00000040
-#define BATL_CACHEINHIBIT	0x00000020
-#define BATL_MEMCOHERENCE	0x00000010
-#define BATL_GUARDEDSTORAGE	0x00000008
-
-#define BATL_PP_MSK		0x00000003
-#define BATL_PP_00		0x00000000 /* No access */
-#define BATL_PP_01		0x00000001 /* Read-only */
-#define BATL_PP_10		0x00000002 /* Read-write */
-#define BATL_PP_11		0x00000003
-
 #endif	/* __E300_H__ */
diff -Naur u-boot-2009.01/include/asm-ppc/fsl_ddr_sdram.h u-boot/include/asm-ppc/fsl_ddr_sdram.h
--- u-boot-2009.01/include/asm-ppc/fsl_ddr_sdram.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/fsl_ddr_sdram.h	2009-02-26 14:03:59.000000000 +0100
@@ -34,7 +34,10 @@
 #elif defined(CONFIG_FSL_DDR3)
 #define FSL_DDR_MIN_TCKE_PULSE_WIDTH_DDR	(3)	/* FIXME */
 typedef ddr3_spd_eeprom_t generic_spd_eeprom_t;
+#ifndef CONFIG_FSL_SDRAM_TYPE
+#define CONFIG_FSL_SDRAM_TYPE	SDRAM_TYPE_DDR3
 #endif
+#endif	/* #if defined(CONFIG_FSL_DDR1) */
 
 /* define bank(chip select) interleaving mode */
 #define FSL_DDR_CS0_CS1			0x40
@@ -48,6 +51,23 @@
 #define FSL_DDR_BANK_INTERLEAVING	0x2
 #define FSL_DDR_SUPERBANK_INTERLEAVING	0x3
 
+/* DDR_SDRAM_CFG - DDR SDRAM Control Configuration
+ */
+#define SDRAM_CFG_MEM_EN		0x80000000
+#define SDRAM_CFG_SREN			0x40000000
+#define SDRAM_CFG_ECC_EN		0x20000000
+#define SDRAM_CFG_RD_EN			0x10000000
+#define SDRAM_CFG_SDRAM_TYPE_DDR1	0x02000000
+#define SDRAM_CFG_SDRAM_TYPE_DDR2	0x03000000
+#define SDRAM_CFG_SDRAM_TYPE_MASK	0x07000000
+#define SDRAM_CFG_SDRAM_TYPE_SHIFT	24
+#define SDRAM_CFG_DYN_PWR		0x00200000
+#define SDRAM_CFG_32_BE			0x00080000
+#define SDRAM_CFG_8_BE			0x00040000
+#define SDRAM_CFG_NCAP			0x00020000
+#define SDRAM_CFG_2T_EN			0x00008000
+#define SDRAM_CFG_BI			0x00000001
+
 /* Record of register values computed */
 typedef struct fsl_ddr_cfg_regs_s {
 	struct {
@@ -143,6 +163,10 @@
 	unsigned int bstopre;
 	unsigned int tCKE_clock_pulse_width_ps;	/* tCKE */
 	unsigned int tFAW_window_four_activates_ps;	/* tFAW --  FOUR_ACT */
+
+	/* Automatic self refresh */
+	unsigned int auto_self_refresh_en;
+	unsigned int sr_it;
 } memctl_options_t;
 
 extern phys_size_t fsl_ddr_sdram(void);
diff -Naur u-boot-2009.01/include/asm-ppc/fsl_law.h u-boot/include/asm-ppc/fsl_law.h
--- u-boot-2009.01/include/asm-ppc/fsl_law.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/fsl_law.h	2009-02-26 14:03:59.000000000 +0100
@@ -42,7 +42,7 @@
 #ifndef CONFIG_MPC8641
 	LAW_TRGT_IF_PCIE_1 = 0x02,
 #endif
-#ifndef CONFIG_MPC8572
+#if !defined(CONFIG_MPC8572) && !defined(CONFIG_P2020)
 	LAW_TRGT_IF_PCIE_3 = 0x03,
 #endif
 	LAW_TRGT_IF_LBC = 0x04,
@@ -61,7 +61,7 @@
 #define LAW_TRGT_IF_PCIE_1	LAW_TRGT_IF_PCI
 #endif
 
-#ifdef CONFIG_MPC8572
+#if defined(CONFIG_MPC8572) || defined(CONFIG_P2020)
 #define LAW_TRGT_IF_PCIE_3	LAW_TRGT_IF_PCI
 #endif
 
diff -Naur u-boot-2009.01/include/asm-ppc/fsl_lbc.h u-boot/include/asm-ppc/fsl_lbc.h
--- u-boot-2009.01/include/asm-ppc/fsl_lbc.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/fsl_lbc.h	2009-02-26 14:03:59.000000000 +0100
@@ -28,6 +28,8 @@
 
 #define BR_BA				0xFFFF8000
 #define BR_BA_SHIFT			15
+#define BR_XBA				0x00006000
+#define BR_XBA_SHIFT			13
 #define BR_PS				0x00001800
 #define BR_PS_SHIFT			11
 #define BR_PS_8				0x00000800	/* Port Size 8 bit */
@@ -70,7 +72,7 @@
 #endif
 
 /* Convert an address into the right format for the BR registers */
-#ifdef CONFIG_PHYS_64BIT
+#if defined(CONFIG_PHYS_64BIT) && !defined(CONFIG_FSL_ELBC)
 #define BR_PHYS_ADDR(x)	((unsigned long)((x & 0x0ffff8000ULL) | \
 					 ((x & 0x300000000ULL) >> 19)))
 #else
@@ -90,6 +92,8 @@
 
 #define OR_GPCM_AM			0xFFFF8000
 #define OR_GPCM_AM_SHIFT		15
+#define OR_GPCM_XAM			0x00006000
+#define OR_GPCM_XAM_SHIFT		13
 #define OR_GPCM_BCTLD			0x00001000
 #define OR_GPCM_BCTLD_SHIFT		12
 #define OR_GPCM_CSNT			0x00000800
@@ -132,6 +136,8 @@
 
 #define OR_FCM_AM			0xFFFF8000
 #define OR_FCM_AM_SHIFT				15
+#define OR_FCM_XAM			0x00006000
+#define OR_FCM_XAM_SHIFT		13
 #define OR_FCM_BCTLD			0x00001000
 #define OR_FCM_BCTLD_SHIFT			12
 #define OR_FCM_PGS			0x00000400
diff -Naur u-boot-2009.01/include/asm-ppc/global_data.h u-boot/include/asm-ppc/global_data.h
--- u-boot-2009.01/include/asm-ppc/global_data.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/global_data.h	2009-02-26 14:03:59.000000000 +0100
@@ -75,7 +75,7 @@
 	u32 lbiu_clk;
 	u32 lclk_clk;
 	u32 pci_clk;
-#if defined(CONFIG_MPC837X)
+#if defined(CONFIG_MPC837X) || defined(CONFIG_MPC831X)
 	u32 pciexp1_clk;
 	u32 pciexp2_clk;
 #endif
diff -Naur u-boot-2009.01/include/asm-ppc/immap_512x.h u-boot/include/asm-ppc/immap_512x.h
--- u-boot-2009.01/include/asm-ppc/immap_512x.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/immap_512x.h	2009-02-26 14:03:59.000000000 +0100
@@ -415,7 +415,25 @@
  * IIM
  */
 typedef struct iim512x {
-	u8 fixme[0x1000];
+	u32 stat;		/* IIM status register */
+	u32 statm;		/* IIM status IRQ mask */
+	u32 err;		/* IIM errors register */
+	u32 emask;		/* IIM error IRQ mask  */
+	u32 fctl;		/* IIM fuse control register */
+	u32 ua;			/* IIM upper address register */
+	u32 la;			/* IIM lower address register */
+	u32 sdat;		/* IIM explicit sense data */
+	u8 res0[0x08];
+	u32 prg_p;		/* IIM program protection register */
+	u8 res1[0x10];
+	u32 divide;		/* IIM divide factor register */
+	u8 res2[0x7c0];
+	u32 fbac0;		/* IIM fuse bank 0 prot (for Freescale use) */
+	u32 fb0w0[0x1f];	/* IIM fuse bank 0 data (for Freescale use) */
+	u8 res3[0x380];
+	u32 fbac1;		/* IIM fuse bank 1 protection */
+	u32 fb1w1[0x01f];	/* IIM fuse bank 1 data */
+	u8 res4[0x380];
 } iim512x_t;
 
 /*
@@ -451,7 +469,34 @@
  * PATA
  */
 typedef struct pata512x {
-	u8 fixme[0x100];
+	/* LOCAL Registers */
+	u32 pata_time1;		/* Time register 1: PIO and tx timing parameter */
+	u32 pata_time2;		/* Time register 2: PIO timing parameter */
+	u32 pata_time3;		/* Time register 3: PIO and MDMA timing parameter */
+	u32 pata_time4;		/* Time register 4: MDMA and UDMA timing parameter */
+	u32 pata_time5;		/* Time register 5: UDMA timing parameter */
+	u32 pata_time6;		/* Time register 6: UDMA timing parameter */
+	u32 pata_fifo_data32;   /* 32bit wide dataport to/from FIFO */
+	u32 pata_fifo_data16;   /* 16bit wide dataport to/from FIFO */
+	u32 pata_fifo_fill;	/* FIFO filling in halfwords (READONLY)*/
+	u32 pata_ata_control;   /* ATA Interface control register */
+	u32 pata_irq_pending;   /* Interrupt pending register (READONLY) */
+	u32 pata_irq_enable;	/* Interrupt enable register */
+	u32 pata_irq_clear;	/* Interrupt clear register (WRITEONLY)*/
+	u32 pata_fifo_alarm;	/* fifo alarm threshold */
+	u32 res1[0x1A];
+	/* DRIVE Registers */
+	u32 pata_drive_data;	/* drive data register*/
+	u32 pata_drive_features;/* drive features register */
+	u32 pata_drive_sectcnt; /* drive sector count register */
+	u32 pata_drive_sectnum; /* drive sector number register */
+	u32 pata_drive_cyllow;  /* drive cylinder low register */
+	u32 pata_drive_cylhigh; /* drive cylinder high register */
+	u32 pata_drive_dev_head;/* drive device head register */
+	u32 pata_drive_command; /* write = drive command, read = drive status reg */
+	u32 res2[0x06];
+	u32 pata_drive_alt_stat;/* write = drive control, read = drive alt status reg */
+	u32 res3[0x09];
 } pata512x_t;
 
 /*
diff -Naur u-boot-2009.01/include/asm-ppc/immap_83xx.h u-boot/include/asm-ppc/immap_83xx.h
--- u-boot-2009.01/include/asm-ppc/immap_83xx.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/immap_83xx.h	2009-02-26 14:03:59.000000000 +0100
@@ -52,23 +52,28 @@
 	law83xx_t lblaw[4];	/* LBIU local access window */
 	u8 res2[0x20];
 	law83xx_t pcilaw[2];	/* PCI local access window */
-	u8 res3[0x30];
+	u8 res3[0x10];
+	law83xx_t pcielaw[2];	/* PCI Express local access window */
+	u8 res4[0x10];
 	law83xx_t ddrlaw[2];	/* DDR local access window */
-	u8 res4[0x50];
+	u8 res5[0x50];
 	u32 sgprl;		/* System General Purpose Register Low */
 	u32 sgprh;		/* System General Purpose Register High */
 	u32 spridr;		/* System Part and Revision ID Register */
-	u8 res5[0x04];
+	u8 res6[0x04];
 	u32 spcr;		/* System Priority Configuration Register */
 	u32 sicrl;		/* System I/O Configuration Register Low */
 	u32 sicrh;		/* System I/O Configuration Register High */
-	u8 res6[0x04];
+	u8 res7[0x04];
 	u32 sidcr0;		/* System I/O Delay Configuration Register 0 */
 	u32 sidcr1;		/* System I/O Delay Configuration Register 1 */
 	u32 ddrcdr;		/* DDR Control Driver Register */
 	u32 ddrdsr;		/* DDR Debug Status Register */
 	u32 obir;		/* Output Buffer Impedance Register */
-	u8 res7[0xCC];
+	u8 res8[0xC];
+	u32 pecr1;		/* PCI Express control register 1 */
+	u32 pecr2;		/* PCI Express control register 2 */
+	u8 res9[0xB8];
 } sysconf83xx_t;
 
 /*
@@ -503,8 +508,110 @@
 /*
  *  PCI Express
  */
+struct pex_inbound_window {
+	u32 ar;
+	u32 tar;
+	u32 barl;
+	u32 barh;
+};
+
+struct pex_outbound_window {
+	u32 ar;
+	u32 bar;
+	u32 tarl;
+	u32 tarh;
+};
+
+struct pex_csb_bridge {
+	u32 pex_csb_ver;
+	u32 pex_csb_cab;
+	u32 pex_csb_ctrl;
+	u8 res0[8];
+	u32 pex_dms_dstmr;
+	u8 res1[4];
+	u32 pex_cbs_stat;
+	u8 res2[0x20];
+	u32 pex_csb_obctrl;
+	u32 pex_csb_obstat;
+	u8 res3[0x98];
+	u32 pex_csb_ibctrl;
+	u32 pex_csb_ibstat;
+	u8 res4[0xb8];
+	u32 pex_wdma_ctrl;
+	u32 pex_wdma_addr;
+	u32 pex_wdma_stat;
+	u8 res5[0x94];
+	u32 pex_rdma_ctrl;
+	u32 pex_rdma_addr;
+	u32 pex_rdma_stat;
+	u8 res6[0xd4];
+	u32 pex_ombcr;
+	u32 pex_ombdr;
+	u8 res7[0x38];
+	u32 pex_imbcr;
+	u32 pex_imbdr;
+	u8 res8[0x38];
+	u32 pex_int_enb;
+	u32 pex_int_stat;
+	u32 pex_int_apio_vec1;
+	u32 pex_int_apio_vec2;
+	u8 res9[0x10];
+	u32 pex_int_ppio_vec1;
+	u32 pex_int_ppio_vec2;
+	u32 pex_int_wdma_vec1;
+	u32 pex_int_wdma_vec2;
+	u32 pex_int_rdma_vec1;
+	u32 pex_int_rdma_vec2;
+	u32 pex_int_misc_vec;
+	u8 res10[4];
+	u32 pex_int_axi_pio_enb;
+	u32 pex_int_axi_wdma_enb;
+	u32 pex_int_axi_rdma_enb;
+	u32 pex_int_axi_misc_enb;
+	u32 pex_int_axi_pio_stat;
+	u32 pex_int_axi_wdma_stat;
+	u32 pex_int_axi_rdma_stat;
+	u32 pex_int_axi_misc_stat;
+	u8 res11[0xa0];
+	struct pex_outbound_window pex_outbound_win[4];
+	u8 res12[0x100];
+	u32 pex_epiwtar0;
+	u32 pex_epiwtar1;
+	u32 pex_epiwtar2;
+	u32 pex_epiwtar3;
+	u8 res13[0x70];
+	struct pex_inbound_window pex_inbound_win[4];
+};
+
 typedef struct pex83xx {
-	u8 fixme[0x1000];
+	u8 pex_cfg_header[0x404];
+	u32 pex_ltssm_stat;
+	u8 res0[0x30];
+	u32 pex_ack_replay_timeout;
+	u8 res1[4];
+	u32 pex_gclk_ratio;
+	u8 res2[0xc];
+	u32 pex_pm_timer;
+	u32 pex_pme_timeout;
+	u8 res3[4];
+	u32 pex_aspm_req_timer;
+	u8 res4[0x18];
+	u32 pex_ssvid_update;
+	u8 res5[0x34];
+	u32 pex_cfg_ready;
+	u8 res6[0x24];
+	u32 pex_bar_sizel;
+	u8 res7[4];
+	u32 pex_bar_sel;
+	u8 res8[0x20];
+	u32 pex_bar_pf;
+	u8 res9[0x88];
+	u32 pex_pme_to_ack_tor;
+	u8 res10[0xc];
+	u32 pex_ss_intr_mask;
+	u8 res11[0x25c];
+	struct pex_csb_bridge bridge;
+	u8 res12[0x160];
 } pex83xx_t;
 
 /*
@@ -788,4 +895,6 @@
 } immap_t;
 #endif
 
+#define CONFIG_SYS_MPC83xx_ESDHC_OFFSET	(0x2e000)
+#define CONFIG_SYS_MPC83xx_ESDHC_ADDR	(CONFIG_SYS_IMMR + CONFIG_SYS_MPC83xx_ESDHC_OFFSET)
 #endif				/* __IMMAP_83xx__ */
diff -Naur u-boot-2009.01/include/asm-ppc/immap_85xx.h u-boot/include/asm-ppc/immap_85xx.h
--- u-boot-2009.01/include/asm-ppc/immap_85xx.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/immap_85xx.h	2009-02-26 14:03:59.000000000 +0100
@@ -58,7 +58,23 @@
 	uint	lawbar7;	/* 0xce8 - Local Access Window 7 Base Address Register */
 	char	res19[4];
 	uint	lawar7;		/* 0xcf0 - Local Access Window 7 Attributes Register */
-	char	res20[780];	/* XXX: LAW 8, LAW9 for 8572 */
+	char	res19_8a[20];
+	uint	lawbar8;	/* 0xd08 - Local Access Window 8 Base Address Register */
+	char	res19_8b[4];
+	uint	lawar8;		/* 0xd10 - Local Access Window 8 Attributes Register */
+	char	res19_9a[20];
+	uint	lawbar9;	/* 0xd28 - Local Access Window 9 Base Address Register */
+	char	res19_9b[4];
+	uint	lawar9;		/* 0xd30 - Local Access Window 9 Attributes Register */
+	char	res19_10a[20];
+	uint	lawbar10;	/* 0xd48 - Local Access Window 10 Base Address Register */
+	char	res19_10b[4];
+	uint	lawar10;	/* 0xd50 - Local Access Window 10 Attributes Register */
+	char	res19_11a[20];
+	uint	lawbar11;	/* 0xd68 - Local Access Window 11 Base Address Register */
+	char	res19_11b[4];
+	uint	lawar11;	/* 0xd70 - Local Access Window 11 Attributes Register */
+	char	res20[652];
 	uint	eebacr;		/* 0x1000 - ECM CCB Address Configuration Register */
 	char	res21[12];
 	uint	eebpcr;		/* 0x1010 - ECM CCB Port Configuration Register */
@@ -119,7 +135,12 @@
 	uint	ddr_sr_cntr;		/* 0x217C - DDR self refresh counter */
 	uint	ddr_sdram_rcw_1;	/* 0x2180 - DDR Register Control Words 1 */
 	uint	ddr_sdram_rcw_2;	/* 0x2184 - DDR Register Control Words 2 */
-	char	res8_1b[2672];
+	char	res8_1b[2456];
+	uint	ddr_dsr1;		/* 0x2B20 - DDR Debug Status Register 1	*/
+	uint	ddr_dsr2;		/* 0x2B24 - DDR Debug Status Register 2	*/
+	uint	ddr_cdr1;		/* 0x2B28 - DDR Control Driver Register 1 */
+	uint	ddr_cdr2;		/* 0x2B2C - DDR Control Driver Register 2 */
+	char	res8_1c[200];
 	uint	ip_rev1;		/* 0x2BF8 - DDR IP Block Revision 1 */
 	uint	ip_rev2;		/* 0x2BFC - DDR IP Block Revision 2 */
 	char	res8_2[512];
@@ -1593,6 +1614,9 @@
 	uint	gpindr;		/* 0xe0050 - General-purpose input data register */
 	char	res5[12];
 	uint	pmuxcr;		/* 0xe0060 - Alternate function signal multiplex control */
+#define MPC85xx_PMUXCR_SD_DATA		0x80000000
+#define MPC85xx_PMUXCR_SDHC_CD		0x40000000
+#define MPC85xx_PMUXCR_SDHC_WP		0x20000000
 	char	res6[12];
 	uint	devdisr;	/* 0xe0070 - Device disable control */
 #define MPC85xx_DEVDISR_PCI1		0x80000000
diff -Naur u-boot-2009.01/include/asm-ppc/immap_86xx.h u-boot/include/asm-ppc/immap_86xx.h
--- u-boot-2009.01/include/asm-ppc/immap_86xx.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/immap_86xx.h	2009-02-26 14:03:59.000000000 +0100
@@ -1289,22 +1289,35 @@
 	uint	powmgtcsr;	/* 0xe0080 - Power management status and control register */
 	char	res8[12];
 	uint	mcpsumr;	/* 0xe0090 - Machine check summary register */
-	char	res9[12];
+	uint	rstrscr;	/* 0xe0094 - Reset request status and control register */
+	char	res9[8];
 	uint	pvr;		/* 0xe00a0 - Processor version register */
 	uint	svr;		/* 0xe00a4 - System version register */
-	char	res10a[1880];
+	char	res10a[8];
+	uint	rstcr;		/* 0xe00b0 - Reset control register */
+#define MPC86xx_RSTCR_HRST_REQ	0x00000002
+	char	res10b[1868];
 	uint	clkdvdr;	/* 0xe0800 - Clock Divide register */
-	char	res10b[1532];
+	char	res10c[796];
+	uint	ddr1clkdr;	/* 0xe0b20 - DDRC1 Clock Disable register */
+	char	res10d[4];
+	uint	ddr2clkdr;	/* 0xe0b28 - DDRC2 Clock Disable register */
+	char	res10e[724];
 	uint	clkocr;		/* 0xe0e00 - Clock out select register */
 	char	res11[12];
 	uint	ddrdllcr;	/* 0xe0e10 - DDR DLL control register */
 	char	res12[12];
 	uint	lbcdllcr;	/* 0xe0e20 - LBC DLL control register */
-	int	res13[57];
-	uint    lynxdcr1;        /* 0xe0f08 - Lynx debug control register 1*/
-	int     res14[6];
-	uint    ddrioovcr;      /* 0xe0f24 - DDR IO Overdrive Control register */
-	char	res15[216];
+	char	res13a[224];
+	uint	srds1cr0;	/* 0xe0f04 - SerDes1 control register 0 */
+	char	res13b[4];
+	uint	srds1cr1;	/* 0xe0f08 - SerDes1 control register 1 */
+	char	res14[24];
+	uint	ddrioovcr;	/* 0xe0f24 - DDR IO Overdrive Control register */
+	char	res15a[24];
+	uint	srds2cr0;	/* 0xe0f40 - SerDes2 control register 0 */
+	uint	srds2cr1;	/* 0xe0f44 - SerDes2 control register 1 */
+	char	res16[184];
 } ccsr_gur_t;
 
 /*
diff -Naur u-boot-2009.01/include/asm-ppc/mmu.h u-boot/include/asm-ppc/mmu.h
--- u-boot-2009.01/include/asm-ppc/mmu.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/mmu.h	2009-02-26 14:03:59.000000000 +0100
@@ -138,6 +138,10 @@
 extern void _tlbie(unsigned long va);	/* invalidate a TLB entry */
 extern void _tlbia(void);		/* invalidate all TLB entries */
 
+#ifdef CONFIG_ADDR_MAP
+extern void init_addr_map(void);
+#endif
+
 typedef enum {
 	IBAT0 = 0, IBAT1, IBAT2, IBAT3,
 	DBAT0, DBAT1, DBAT2, DBAT3,
@@ -153,25 +157,64 @@
 
 #endif /* __ASSEMBLY__ */
 
-/* Block size masks */
-#define BL_128K	0x000
-#define BL_256K 0x001
-#define BL_512K 0x003
-#define BL_1M   0x007
-#define BL_2M   0x00F
-#define BL_4M   0x01F
-#define BL_8M   0x03F
-#define BL_16M  0x07F
-#define BL_32M  0x0FF
-#define BL_64M  0x1FF
-#define BL_128M 0x3FF
-#define BL_256M 0x7FF
+#define BATU_VS                 0x00000002
+#define BATU_VP                 0x00000001
+#define BATU_INVALID            0x00000000
+
+#define BATL_WRITETHROUGH       0x00000040
+#define BATL_CACHEINHIBIT       0x00000020
+#define BATL_MEMCOHERENCE	0x00000010
+#define BATL_GUARDEDSTORAGE     0x00000008
+#define BATL_NO_ACCESS		0x00000000
+
+#define BATL_PP_MSK		0x00000003
+#define BATL_PP_00		0x00000000 /* No access */
+#define BATL_PP_01		0x00000001 /* Read-only */
+#define BATL_PP_10		0x00000002 /* Read-write */
+#define BATL_PP_11		0x00000003
+
+#define BATL_PP_NO_ACCESS	BATL_PP_00
+#define BATL_PP_RO		BATL_PP_01
+#define BATL_PP_RW		BATL_PP_10
+
+/* BAT Block size values */
+#define BATU_BL_128K            0x00000000
+#define BATU_BL_256K            0x00000004
+#define BATU_BL_512K            0x0000000c
+#define BATU_BL_1M              0x0000001c
+#define BATU_BL_2M              0x0000003c
+#define BATU_BL_4M              0x0000007c
+#define BATU_BL_8M              0x000000fc
+#define BATU_BL_16M             0x000001fc
+#define BATU_BL_32M             0x000003fc
+#define BATU_BL_64M             0x000007fc
+#define BATU_BL_128M            0x00000ffc
+#define BATU_BL_256M            0x00001ffc
+
+/* Block lengths for processors that support extended block length */
+#ifdef HID0_XBSEN
+#define BATU_BL_512M            0x00003ffc
+#define BATU_BL_1G              0x00007ffc
+#define BATU_BL_2G              0x0000fffc
+#define BATU_BL_4G              0x0001fffc
+#define BATU_BL_MAX		BATU_BL_4G
+#else
+#define BATU_BL_MAX		BATU_BL_256M
+#endif
 
 /* BAT Access Protection */
 #define BPP_XX	0x00		/* No access */
 #define BPP_RX	0x01		/* Read only */
 #define BPP_RW	0x02		/* Read/write */
 
+/* Macros to get values from BATs, once data is in the BAT register format */
+#define BATU_VALID(x) (x & 0x3)
+#define BATU_VADDR(x) (x & 0xfffe0000)
+#define BATL_PADDR(x) ((phys_addr_t)((x & 0xfffe0000)		\
+				     | ((x & 0x0e00ULL) << 24)	\
+				     | ((x & 0x04ULL) << 30)))
+#define BATU_SIZE(x) (1UL << (fls((x & BATU_BL_MAX) >> 2) + 17))
+
 /* Used to set up SDR1 register */
 #define HASH_TABLE_SIZE_64K	0x00010000
 #define HASH_TABLE_SIZE_128K	0x00020000
@@ -431,9 +474,7 @@
 extern void disable_tlb(u8 esel);
 extern void invalidate_tlb(u8 tlb);
 extern void init_tlbs(void);
-#ifdef CONFIG_ADDR_MAP
-extern void init_addr_map(void);
-#endif
+
 extern unsigned int setup_ddr_tlbs(unsigned int memsize_in_meg);
 
 #define SET_TLB_ENTRY(_tlb, _epn, _rpn, _perms, _wimge, _ts, _esel, _sz, _iprot) \
diff -Naur u-boot-2009.01/include/asm-ppc/ppc4xx-sdram.h u-boot/include/asm-ppc/ppc4xx-sdram.h
--- u-boot-2009.01/include/asm-ppc/ppc4xx-sdram.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/ppc4xx-sdram.h	2009-02-26 14:03:59.000000000 +0100
@@ -566,6 +566,8 @@
 #define SDRAM_RDCC_RSAE_MASK		0x00000001
 #define SDRAM_RDCC_RSAE_DISABLE		0x00000001
 #define SDRAM_RDCC_RSAE_ENABLE		0x00000000
+#define SDRAM_RDCC_RDSS_ENCODE(n)	((((u32)(n))&0x03)<<30)
+#define SDRAM_RDCC_RDSS_DECODE(n)	((((u32)(n))>>30)&0x03)
 
 /*
  * SDRAM Read Feedback Delay Control Register
diff -Naur u-boot-2009.01/include/asm-ppc/processor.h u-boot/include/asm-ppc/processor.h
--- u-boot-2009.01/include/asm-ppc/processor.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/asm-ppc/processor.h	2009-02-26 14:03:59.000000000 +0100
@@ -451,6 +451,8 @@
 #define   L2CSR0_L2LO		0x00000020	/* L2 Cache Lock Overflow */
 #define SPRN_L2CSR1	0x3fa	/* L2 Data Cache Control and Status Register 1 */
 
+#define SPRN_TLB0CFG	0x2B0	/* TLB 0 Config Register */
+#define SPRN_TLB1CFG	0x2B1	/* TLB 1 Config Register */
 #define SPRN_MMUCSR0	0x3f4	/* MMU control and status register 0 */
 #define SPRN_MAS0	0x270	/* MMU Assist Register 0 */
 #define SPRN_MAS1	0x271	/* MMU Assist Register 1 */
@@ -777,6 +779,13 @@
 #define PVR_MAJ(pvr)	(((pvr) >>  4) & 0xF)	/* Major revision field */
 #define PVR_MIN(pvr)	(((pvr) >>  0) & 0xF)	/* Minor revision field */
 
+/* e600 core PVR fields */
+
+#define PVR_E600_VER(pvr)	(((pvr) >> 15) & 0xFFFF) /* Version/type */
+#define PVR_E600_TECH(pvr)	(((pvr) >> 12) & 0xF)	 /* Technology */
+#define PVR_E600_MAJ(pvr)	(((pvr) >> 8) & 0xF)	 /* Major revision */
+#define PVR_E600_MIN(pvr)	(((pvr) >> 0) & 0xFF)	 /* Minor revision */
+
 /* Processor Version Numbers */
 
 #define PVR_403GA	0x00200000
@@ -857,7 +866,6 @@
 #define PVR_85xx_REV2	(PVR_85xx | 0x0020)
 
 #define PVR_86xx	0x80040000
-#define PVR_86xx_REV1	(PVR_86xx | 0x0010)
 
 #define PVR_VIRTEX5     0x7ff21912
 
@@ -949,6 +957,8 @@
 #define SVR_8568_E	0x807D00
 #define SVR_8572	0x80E000
 #define SVR_8572_E	0x80E800
+#define SVR_P2020	0x80E200
+#define SVR_P2020_E	0x80EA00
 
 #define SVR_8610	0x80A000
 #define SVR_8641	0x809000
diff -Naur u-boot-2009.01/include/asm-sh/config.h u-boot/include/asm-sh/config.h
--- u-boot-2009.01/include/asm-sh/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-sh/config.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#endif
diff -Naur u-boot-2009.01/include/asm-sparc/config.h u-boot/include/asm-sparc/config.h
--- u-boot-2009.01/include/asm-sparc/config.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/asm-sparc/config.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _ASM_CONFIG_H_
+#define _ASM_CONFIG_H_
+
+#endif
diff -Naur u-boot-2009.01/include/command.h u-boot/include/command.h
--- u-boot-2009.01/include/command.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/command.h	2009-02-26 14:03:59.000000000 +0100
@@ -33,6 +33,11 @@
 #define NULL	0
 #endif
 
+/* Default to a width of 8 characters for help message command width */
+#ifndef CONFIG_SYS_HELP_CMD_WIDTH
+#define CONFIG_SYS_HELP_CMD_WIDTH	8
+#endif
+
 #ifndef	__ASSEMBLY__
 /*
  * Monitor Command Table
@@ -64,6 +69,8 @@
 cmd_tbl_t *find_cmd(const char *cmd);
 cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len);
 
+extern void cmd_usage(cmd_tbl_t *cmdtp);
+
 #ifdef CONFIG_AUTO_COMPLETE
 extern void install_auto_complete(void);
 extern int cmd_auto_complete(const char *const prompt, char *buf, int *np, int *colp);
diff -Naur u-boot-2009.01/include/common.h u-boot/include/common.h
--- u-boot-2009.01/include/common.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/common.h	2009-02-26 14:03:59.000000000 +0100
@@ -597,6 +597,8 @@
 
 /* lib_$(ARCH)/cache.c */
 void	flush_cache   (unsigned long, unsigned long);
+void	flush_dcache_range(unsigned long start, unsigned long stop);
+void	invalidate_dcache_range(unsigned long start, unsigned long stop);
 
 
 /* lib_$(ARCH)/ticks.S */
diff -Naur u-boot-2009.01/include/config_cmd_all.h u-boot/include/config_cmd_all.h
--- u-boot-2009.01/include/config_cmd_all.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/config_cmd_all.h	2009-02-26 14:03:59.000000000 +0100
@@ -33,7 +33,7 @@
 #define CONFIG_CMD_ECHO		/* echo arguments		*/
 #define CONFIG_CMD_EEPROM	/* EEPROM read/write support	*/
 #define CONFIG_CMD_ELF		/* ELF (VxWorks) load/boot cmd	*/
-#define CONFIG_CMD_ENV		/* saveenv			*/
+#define CONFIG_CMD_SAVEENV	/* saveenv			*/
 #define CONFIG_CMD_EXT2		/* EXT2 Support			*/
 #define CONFIG_CMD_FAT		/* FAT support			*/
 #define CONFIG_CMD_FDC		/* Floppy Disk Support		*/
diff -Naur u-boot-2009.01/include/config_cmd_default.h u-boot/include/config_cmd_default.h
--- u-boot-2009.01/include/config_cmd_default.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/config_cmd_default.h	2009-02-26 14:03:59.000000000 +0100
@@ -21,11 +21,13 @@
 #define CONFIG_CMD_BOOTD	/* bootd			*/
 #define CONFIG_CMD_CONSOLE	/* coninfo			*/
 #define CONFIG_CMD_ECHO		/* echo arguments		*/
-#define CONFIG_CMD_ENV		/* saveenv			*/
+#define CONFIG_CMD_SAVEENV	/* saveenv			*/
 #define CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
 #define CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
 #define CONFIG_CMD_IMI		/* iminfo			*/
+#ifndef CONFIG_SYS_NO_FLASH
 #define CONFIG_CMD_IMLS		/* List all found images	*/
+#endif
 #define CONFIG_CMD_ITEST	/* Integer (and string) test	*/
 #define CONFIG_CMD_LOADB	/* loadb			*/
 #define CONFIG_CMD_LOADS	/* loads			*/
diff -Naur u-boot-2009.01/include/configs/acadia.h u-boot/include/configs/acadia.h
--- u-boot-2009.01/include/configs/acadia.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/acadia.h	2009-02-26 14:03:59.000000000 +0100
@@ -262,7 +262,6 @@
  * NAND FLASH
  *----------------------------------------------------------------------*/
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_SYS_NAND_BASE		(CONFIG_SYS_NAND_ADDR + CONFIG_SYS_NAND_CS)
 #define CONFIG_SYS_NAND_SELECT_DEVICE  1	/* nand driver supports mutipl. chips	*/
 
diff -Naur u-boot-2009.01/include/configs/actux1.h u-boot/include/configs/actux1.h
--- u-boot-2009.01/include/configs/actux1.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/actux1.h	2009-02-26 14:03:59.000000000 +0100
@@ -39,6 +39,7 @@
 #define CONFIG_DISPLAY_CPUINFO		1
 #define CONFIG_DISPLAY_BOARDINFO	1
 
+#define CONFIG_IXP_SERIAL
 #define CONFIG_SYS_IXP425_CONSOLE		IXP425_UART2
 #define CONFIG_BAUDRATE			115200
 #define CONFIG_BOOTDELAY		3
@@ -172,8 +173,6 @@
 
 /* include IXP4xx NPE support */
 #define CONFIG_IXP4XX_NPE		1
-/* use separate flash sector with ucode images */
-#define CONFIG_IXP4XX_NPE_EXT_UCODE_BASE	0x50040000
 #define CONFIG_NET_MULTI		1
 /* NPE0 PHY address */
 #define	CONFIG_PHY_ADDR			0
@@ -208,6 +207,7 @@
 #define CONFIG_SYS_USE_PPCENV			1
 
 #define CONFIG_EXTRA_ENV_SETTINGS \
+	"npe_ucode=50040000\0"						\
 	"mtd=IXP4XX-Flash.0:256k(uboot),64k(ucode),1152k(linux),-(root)\0" \
 	"kerneladdr=50050000\0"						\
 	"rootaddr=50170000\0"						\
diff -Naur u-boot-2009.01/include/configs/actux2.h u-boot/include/configs/actux2.h
--- u-boot-2009.01/include/configs/actux2.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/actux2.h	2009-02-26 14:03:59.000000000 +0100
@@ -32,6 +32,7 @@
 #define CONFIG_DISPLAY_CPUINFO		1
 #define CONFIG_DISPLAY_BOARDINFO	1
 
+#define CONFIG_IXP_SERIAL
 #define CONFIG_SYS_IXP425_CONSOLE		IXP425_UART2
 #define CONFIG_BAUDRATE			115200
 #define CONFIG_BOOTDELAY		5
@@ -147,8 +148,6 @@
 
 /* include IXP4xx NPE support */
 #define CONFIG_IXP4XX_NPE		1
-/* use separate flash sector with ucode images */
-#define CONFIG_IXP4XX_NPE_EXT_UCODE_BASE	0x50040000
 #define CONFIG_NET_MULTI		1
 /* NPE0 PHY address */
 #define	CONFIG_PHY_ADDR			0x00
@@ -185,6 +184,7 @@
 #define CONFIG_SYS_USE_PPCENV			1
 
 #define CONFIG_EXTRA_ENV_SETTINGS					\
+	"npe_ucode=50040000\0"						\
 	"mtd=IXP4XX-Flash.0:256k(uboot),64k(ucode),1152k(linux),-(root)\0" \
 	"kerneladdr=50050000\0"						\
 	"rootaddr=50170000\0"						\
diff -Naur u-boot-2009.01/include/configs/actux3.h u-boot/include/configs/actux3.h
--- u-boot-2009.01/include/configs/actux3.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/actux3.h	2009-02-26 14:03:59.000000000 +0100
@@ -32,6 +32,7 @@
 #define CONFIG_DISPLAY_CPUINFO		1
 #define CONFIG_DISPLAY_BOARDINFO	1
 
+#define CONFIG_IXP_SERIAL
 #define CONFIG_SYS_IXP425_CONSOLE		IXP425_UART2
 #define CONFIG_BAUDRATE			115200
 #define CONFIG_BOOTDELAY		3
@@ -146,8 +147,6 @@
 
 /* include IXP4xx NPE support */
 #define CONFIG_IXP4XX_NPE		1
-/* use separate flash sector with ucode images */
-#define CONFIG_IXP4XX_NPE_EXT_UCODE_BASE	0x50040000
 
 #define CONFIG_NET_MULTI		1
 /* NPE0 PHY address */
@@ -185,6 +184,7 @@
 #define CONFIG_SYS_USE_PPCENV			1
 
 #define CONFIG_EXTRA_ENV_SETTINGS					\
+	"npe_ucode=50040000\0"						\
 	"mtd=IXP4XX-Flash.0:256k(uboot),64k(ucode),1152k(linux),-(root)\0" \
 	"kerneladdr=50050000\0"						\
 	"rootaddr=50170000\0"						\
diff -Naur u-boot-2009.01/include/configs/actux4.h u-boot/include/configs/actux4.h
--- u-boot-2009.01/include/configs/actux4.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/actux4.h	2009-02-26 14:03:59.000000000 +0100
@@ -32,6 +32,7 @@
 #define CONFIG_DISPLAY_CPUINFO		1
 #define CONFIG_DISPLAY_BOARDINFO	1
 
+#define CONFIG_IXP_SERIAL
 #define CONFIG_SYS_IXP425_CONSOLE		IXP425_UART1
 #define CONFIG_BAUDRATE			115200
 #define CONFIG_BOOTDELAY		3
@@ -149,8 +150,6 @@
 
 /* include IXP4xx NPE support */
 #define CONFIG_IXP4XX_NPE		1
-/* use separate flash sector with ucode images */
-#define CONFIG_IXP4XX_NPE_EXT_UCODE_BASE	0x51000000
 
 #define CONFIG_NET_MULTI		1
 /* NPE0 PHY address */
@@ -181,6 +180,7 @@
 #define CONFIG_ENV_ADDR			(PHYS_FLASH_1 + 0x3f000)
 
 #define CONFIG_EXTRA_ENV_SETTINGS					\
+	"npe_ucode=51000000\0"						\
 	"mtd=IXP4XX-Flash.0:252k(uboot),4k(uboot_env);"			\
 	"IXP4XX-Flash.1:128k(ucode),1280k(linux),-(root)\0"		\
 	"kerneladdr=51020000\0"						\
diff -Naur u-boot-2009.01/include/configs/ads5121.h u-boot/include/configs/ads5121.h
--- u-boot-2009.01/include/configs/ads5121.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ads5121.h	2009-02-26 14:03:59.000000000 +0100
@@ -47,6 +47,7 @@
 #define CONFIG_E300		1	/* E300 Family */
 #define CONFIG_MPC512X		1	/* MPC512X family */
 #define CONFIG_FSL_DIU_FB	1	/* FSL DIU */
+#undef CONFIG_FSL_DIU_LOGO_BMP		/* Don't include FSL DIU binary bmp */
 
 /* video */
 #undef CONFIG_VIDEO
@@ -294,6 +295,11 @@
 #endif
 
 /*
+ * IIM - IC Identification Module
+ */
+#undef CONFIG_IIM
+
+/*
  * EEPROM configuration
  */
 #define CONFIG_SYS_I2C_EEPROM_ADDR_LEN		2	/* 16-bit EEPROM address */
@@ -348,11 +354,20 @@
 #define CONFIG_CMD_REGINFO
 #define CONFIG_CMD_EEPROM
 #define CONFIG_CMD_DATE
+#undef CONFIG_CMD_FUSE
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_EXT2
 
 #if defined(CONFIG_PCI)
 #define CONFIG_CMD_PCI
 #endif
 
+#if defined(CONFIG_CMD_IDE)
+#define CONFIG_DOS_PARTITION
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ISO_PARTITION
+#endif /* defined(CONFIG_CMD_IDE) */
+
 /*
  * Watchdog timeout = CONFIG_SYS_WATCHDOG_VALUE * 65536 / IPS clock.
  * For example, when IPS is set to 66MHz and CONFIG_SYS_WATCHDOG_VALUE is set
@@ -489,4 +504,48 @@
 #define OF_TBCLK		(bd->bi_busfreq / 4)
 #define OF_STDOUT_PATH		"/soc@80000000/serial@11300"
 
+/*-----------------------------------------------------------------------
+ * IDE/ATA stuff
+ *-----------------------------------------------------------------------
+ */
+
+#undef  CONFIG_IDE_8xx_PCCARD		/* Use IDE with PC Card	Adapter	*/
+#undef	CONFIG_IDE_8xx_DIRECT		/* Direct IDE    not supported	*/
+#undef	CONFIG_IDE_LED			/* LED   for IDE not supported	*/
+
+#define CONFIG_IDE_RESET		/* reset for IDE supported	*/
+#define CONFIG_IDE_PREINIT
+
+#define CONFIG_SYS_IDE_MAXBUS		1	/* max. 1 IDE bus		*/
+#define CONFIG_SYS_IDE_MAXDEVICE	2	/* max. 1 drive per IDE bus	*/
+
+#define CONFIG_SYS_ATA_IDE0_OFFSET	0x0000
+#define CONFIG_SYS_ATA_BASE_ADDR	MPC512X_PATA
+
+/* Offset for data I/O			RefMan MPC5121EE Table 28-10	*/
+#define CONFIG_SYS_ATA_DATA_OFFSET	(0x00A0)
+
+/* Offset for normal register accesses	*/
+#define CONFIG_SYS_ATA_REG_OFFSET	(CONFIG_SYS_ATA_DATA_OFFSET)
+
+/* Offset for alternate registers	RefMan MPC5121EE Table 28-23	*/
+#define CONFIG_SYS_ATA_ALT_OFFSET	(0x00D8)
+
+/* Interval between registers	*/
+#define CONFIG_SYS_ATA_STRIDE		4
+
+#define ATA_BASE_ADDR		MPC512X_PATA
+
+/*
+ * Control register bit definitions
+ */
+#define FSL_ATA_CTRL_FIFO_RST_B		0x80000000
+#define FSL_ATA_CTRL_ATA_RST_B		0x40000000
+#define FSL_ATA_CTRL_FIFO_TX_EN		0x20000000
+#define FSL_ATA_CTRL_FIFO_RCV_EN	0x10000000
+#define FSL_ATA_CTRL_DMA_PENDING	0x08000000
+#define FSL_ATA_CTRL_DMA_ULTRA		0x04000000
+#define FSL_ATA_CTRL_DMA_WRITE		0x02000000
+#define FSL_ATA_CTRL_IORDY_EN		0x01000000
+
 #endif	/* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/afeb9260.h u-boot/include/configs/afeb9260.h
--- u-boot-2009.01/include/configs/afeb9260.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/afeb9260.h	2009-02-26 14:03:59.000000000 +0100
@@ -97,7 +97,6 @@
 #define DATAFLASH_TCHS			(0x1 << 24)
 
 /* NAND flash */
-#define NAND_MAX_CHIPS			1
 #define CONFIG_SYS_MAX_NAND_DEVICE		1
 #define CONFIG_SYS_NAND_BASE			0x40000000
 #define CONFIG_SYS_NAND_DBW_8			1
@@ -115,7 +114,6 @@
 
 /* USB */
 #define CONFIG_USB_OHCI_NEW		1
-#define LITTLEENDIAN			1
 #define CONFIG_DOS_PARTITION		1
 #define CONFIG_SYS_USB_OHCI_CPU_INIT		1
 #define CONFIG_SYS_USB_OHCI_REGS_BASE		0x00500000	/* AT91SAM9260_UHP_BASE */
diff -Naur u-boot-2009.01/include/configs/alpr.h u-boot/include/configs/alpr.h
--- u-boot-2009.01/include/configs/alpr.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/alpr.h	2009-02-26 14:03:59.000000000 +0100
@@ -335,7 +335,6 @@
  * NAND-FLASH stuff
  *-----------------------------------------------------------------------*/
 #define CONFIG_SYS_MAX_NAND_DEVICE	4
-#define NAND_MAX_CHIPS		CONFIG_SYS_MAX_NAND_DEVICE
 #define CONFIG_SYS_NAND_BASE		0xF0000000	/* NAND FLASH Base Address	*/
 #define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE + 0, CONFIG_SYS_NAND_BASE + 2,	\
 				  CONFIG_SYS_NAND_BASE + 4, CONFIG_SYS_NAND_BASE + 6 }
diff -Naur u-boot-2009.01/include/configs/ap325rxa.h u-boot/include/configs/ap325rxa.h
--- u-boot-2009.01/include/configs/ap325rxa.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ap325rxa.h	2009-02-26 14:03:59.000000000 +0100
@@ -40,7 +40,7 @@
 #define CONFIG_CMD_PING
 #define CONFIG_CMD_NFS
 #define CONFIG_CMD_SDRAM
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_EXT2
 #define CONFIG_DOS_PARTITION
diff -Naur u-boot-2009.01/include/configs/ASH405.h u-boot/include/configs/ASH405.h
--- u-boot-2009.01/include/configs/ASH405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ASH405.h	2009-02-26 14:03:59.000000000 +0100
@@ -125,7 +125,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 #undef	CONFIG_UART1_CONSOLE		/* define for uart1 as console	*/
 
@@ -150,7 +149,6 @@
  *-----------------------------------------------------------------------
  */
 #define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#define NAND_MAX_CHIPS          1
 #define CONFIG_SYS_MAX_NAND_DEVICE	1         /* Max number of NAND devices */
 #define NAND_BIG_DELAY_US	25
 
diff -Naur u-boot-2009.01/include/configs/at91cap9adk.h u-boot/include/configs/at91cap9adk.h
--- u-boot-2009.01/include/configs/at91cap9adk.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/at91cap9adk.h	2009-02-26 14:03:59.000000000 +0100
@@ -118,7 +118,6 @@
 #define CONFIG_SYS_MAX_FLASH_BANKS		1
 
 /* NAND flash */
-#define NAND_MAX_CHIPS			1
 #define CONFIG_SYS_MAX_NAND_DEVICE		1
 #define CONFIG_SYS_NAND_BASE			0x40000000
 #define CONFIG_SYS_NAND_DBW_8			1
@@ -132,7 +131,6 @@
 
 /* USB */
 #define CONFIG_USB_OHCI_NEW		1
-#define LITTLEENDIAN			1
 #define CONFIG_DOS_PARTITION		1
 #define CONFIG_SYS_USB_OHCI_CPU_INIT		1
 #define CONFIG_SYS_USB_OHCI_REGS_BASE		0x00700000	/* AT91_BASE_UHP */
diff -Naur u-boot-2009.01/include/configs/at91rm9200dk.h u-boot/include/configs/at91rm9200dk.h
--- u-boot-2009.01/include/configs/at91rm9200dk.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/at91rm9200dk.h	2009-02-26 14:03:59.000000000 +0100
@@ -129,7 +129,6 @@
 
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS 1
-#define NAND_MAX_CHIPS 1
 
 #define AT91_SMART_MEDIA_ALE (1 << 22)	/* our ALE is AD22 */
 #define AT91_SMART_MEDIA_CLE (1 << 21)	/* our CLE is AD21 */
diff -Naur u-boot-2009.01/include/configs/at91sam9260ek.h u-boot/include/configs/at91sam9260ek.h
--- u-boot-2009.01/include/configs/at91sam9260ek.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/at91sam9260ek.h	2009-02-26 14:03:59.000000000 +0100
@@ -100,7 +100,6 @@
 #define DATAFLASH_TCHS			(0x1 << 24)
 
 /* NAND flash */
-#define NAND_MAX_CHIPS			1
 #define CONFIG_SYS_MAX_NAND_DEVICE		1
 #define CONFIG_SYS_NAND_BASE			0x40000000
 #define CONFIG_SYS_NAND_DBW_8			1
@@ -117,7 +116,6 @@
 
 /* USB */
 #define CONFIG_USB_OHCI_NEW		1
-#define LITTLEENDIAN			1
 #define CONFIG_DOS_PARTITION		1
 #define CONFIG_SYS_USB_OHCI_CPU_INIT		1
 #define CONFIG_SYS_USB_OHCI_REGS_BASE		0x00500000	/* AT91SAM9260_UHP_BASE */
diff -Naur u-boot-2009.01/include/configs/at91sam9261ek.h u-boot/include/configs/at91sam9261ek.h
--- u-boot-2009.01/include/configs/at91sam9261ek.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/at91sam9261ek.h	2009-02-26 14:03:59.000000000 +0100
@@ -111,7 +111,6 @@
 #define DATAFLASH_TCHS			(0x1 << 24)
 
 /* NAND flash */
-#define NAND_MAX_CHIPS			1
 #define CONFIG_SYS_MAX_NAND_DEVICE		1
 #define CONFIG_SYS_NAND_BASE			0x40000000
 #define CONFIG_SYS_NAND_DBW_8			1
@@ -130,7 +129,6 @@
 
 /* USB */
 #define CONFIG_USB_OHCI_NEW		1
-#define LITTLEENDIAN			1
 #define CONFIG_DOS_PARTITION		1
 #define CONFIG_SYS_USB_OHCI_CPU_INIT		1
 #define CONFIG_SYS_USB_OHCI_REGS_BASE		0x00500000	/* AT91SAM9261_UHP_BASE */
diff -Naur u-boot-2009.01/include/configs/at91sam9263ek.h u-boot/include/configs/at91sam9263ek.h
--- u-boot-2009.01/include/configs/at91sam9263ek.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/at91sam9263ek.h	2009-02-26 14:03:59.000000000 +0100
@@ -123,7 +123,6 @@
 #endif
 
 /* NAND flash */
-#define NAND_MAX_CHIPS			1
 #define CONFIG_SYS_MAX_NAND_DEVICE		1
 #define CONFIG_SYS_NAND_BASE			0x40000000
 #define CONFIG_SYS_NAND_DBW_8			1
@@ -137,7 +136,6 @@
 
 /* USB */
 #define CONFIG_USB_OHCI_NEW		1
-#define LITTLEENDIAN			1
 #define CONFIG_DOS_PARTITION		1
 #define CONFIG_SYS_USB_OHCI_CPU_INIT		1
 #define CONFIG_SYS_USB_OHCI_REGS_BASE		0x00a00000	/* AT91SAM9263_UHP_BASE */
diff -Naur u-boot-2009.01/include/configs/at91sam9rlek.h u-boot/include/configs/at91sam9rlek.h
--- u-boot-2009.01/include/configs/at91sam9rlek.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/at91sam9rlek.h	2009-02-26 14:03:59.000000000 +0100
@@ -104,7 +104,6 @@
 #define CONFIG_SYS_NO_FLASH			1
 
 /* NAND flash */
-#define NAND_MAX_CHIPS			1
 #define CONFIG_SYS_MAX_NAND_DEVICE		1
 #define CONFIG_SYS_NAND_BASE			0x40000000
 #define CONFIG_SYS_NAND_DBW_8			1
diff -Naur u-boot-2009.01/include/configs/bamboo.h u-boot/include/configs/bamboo.h
--- u-boot-2009.01/include/configs/bamboo.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/bamboo.h	2009-02-26 14:03:59.000000000 +0100
@@ -197,7 +197,6 @@
  * NAND FLASH
  *----------------------------------------------------------------------*/
 #define CONFIG_SYS_MAX_NAND_DEVICE	2
-#define NAND_MAX_CHIPS		CONFIG_SYS_MAX_NAND_DEVICE
 #define CONFIG_SYS_NAND_BASE		(CONFIG_SYS_NAND_ADDR + CONFIG_SYS_NAND_CS)
 #define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_ADDR + 2 }
 #define CONFIG_SYS_NAND_SELECT_DEVICE  1	/* nand driver supports mutipl. chips	*/
diff -Naur u-boot-2009.01/include/configs/BC3450.h u-boot/include/configs/BC3450.h
--- u-boot-2009.01/include/configs/BC3450.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/BC3450.h	2009-02-26 14:03:59.000000000 +0100
@@ -396,10 +396,11 @@
 /*
  * Ethernet configuration
  *
- * Define CONFIG_FEC10MBIT to force FEC at 10MBIT
+ * Define CONFIG_MPC5xxx_MII10 to force FEC at 10MBIT
  */
 #define CONFIG_MPC5xxx_FEC	1
-#undef CONFIG_FEC_10MBIT
+#define CONFIG_MPC5xxx_FEC_MII100
+#undef CONFIG_MPC5xxx_MII10
 #define CONFIG_PHY_ADDR		0x00
 
 /*
diff -Naur u-boot-2009.01/include/configs/bf533-ezkit.h u-boot/include/configs/bf533-ezkit.h
--- u-boot-2009.01/include/configs/bf533-ezkit.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/bf533-ezkit.h	2009-02-26 14:03:59.000000000 +0100
@@ -198,7 +198,7 @@
 #define I2C_DELAY	udelay(5)	/* 1/4 I2C clock duration */
 
 #define CONFIG_SYS_I2C_SPEED		50000
-#define CONFIG_SYS_I2C_SLAVE		0xFE
+#define CONFIG_SYS_I2C_SLAVE		0
 
 #define CONFIG_SYS_BOOTM_LEN		0x4000000	/* Large Image Length, set to 64 Meg */
 
diff -Naur u-boot-2009.01/include/configs/bf533-stamp.h u-boot/include/configs/bf533-stamp.h
--- u-boot-2009.01/include/configs/bf533-stamp.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/bf533-stamp.h	2009-02-26 14:03:59.000000000 +0100
@@ -300,7 +300,7 @@
 #define I2C_DELAY		udelay(5)	/* 1/4 I2C clock duration */
 
 #define CONFIG_SYS_I2C_SPEED		50000
-#define CONFIG_SYS_I2C_SLAVE		0xFE
+#define CONFIG_SYS_I2C_SLAVE		0
 #endif /* CONFIG_SOFT_I2C */
 
 /*
diff -Naur u-boot-2009.01/include/configs/bf537-stamp.h u-boot/include/configs/bf537-stamp.h
--- u-boot-2009.01/include/configs/bf537-stamp.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/bf537-stamp.h	2009-02-26 14:03:59.000000000 +0100
@@ -278,7 +278,6 @@
 #define ADDR_COLUMN_PAGE	3
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS		1
-#define NAND_MAX_CHIPS		1
 #define BFIN_NAND_READY		PF3
 
 #define NAND_WAIT_READY(nand)			\
@@ -306,13 +305,11 @@
 
 /*
  * I2C settings
- * By default PF1 is used as SDA and PF0 as SCL on the Stamp board
  */
-/* #define CONFIG_SOFT_I2C	1*/	/* I2C bit-banged */
-#define CONFIG_HARD_I2C		1	/* I2C TWI */
-#if defined CONFIG_HARD_I2C
-#define CONFIG_TWICLK_KHZ	50
-#endif
+#define CONFIG_HARD_I2C		1
+#define CONFIG_BFIN_TWI_I2C	1
+#define CONFIG_SYS_I2C_SPEED	50000
+#define CONFIG_SYS_I2C_SLAVE	0
 
 #define CONFIG_EBIU_SDRRC_VAL  0x306
 #define CONFIG_EBIU_SDGCTL_VAL 0x91114d
@@ -322,39 +319,6 @@
 #define CONFIG_EBIU_AMBCTL0_VAL		0x7BB07BB0
 #define CONFIG_EBIU_AMBCTL1_VAL		0xFFC27BB0
 
-#if defined CONFIG_SOFT_I2C
-/*
- * Software (bit-bang) I2C driver configuration
- */
-#define PF_SCL			PF0
-#define PF_SDA			PF1
-
-#define I2C_INIT		(*pFIO_DIR |=  PF_SCL); asm("ssync;")
-#define I2C_ACTIVE		(*pFIO_DIR |=  PF_SDA); *pFIO_INEN &= ~PF_SDA; asm("ssync;")
-#define I2C_TRISTATE		(*pFIO_DIR &= ~PF_SDA); *pFIO_INEN |= PF_SDA; asm("ssync;")
-#define I2C_READ		((volatile)(*pFIO_FLAG_D & PF_SDA) != 0); asm("ssync;")
-#define I2C_SDA(bit)		if(bit) { \
-					*pFIO_FLAG_S = PF_SDA; \
-					asm("ssync;"); \
-					} \
-				else    { \
-					*pFIO_FLAG_C = PF_SDA; \
-					asm("ssync;"); \
-					}
-#define I2C_SCL(bit)		if(bit) { \
-					*pFIO_FLAG_S = PF_SCL; \
-					asm("ssync;"); \
-					} \
-				else    { \
-					*pFIO_FLAG_C = PF_SCL; \
-					asm("ssync;"); \
-					}
-#define I2C_DELAY		udelay(5)	/* 1/4 I2C clock duration */
-#endif
-
-#define CONFIG_SYS_I2C_SPEED		50000
-#define CONFIG_SYS_I2C_SLAVE		0xFE
-
 /* 0xFF, 0x7BB07BB0, 0x22547BB0 */
 /* #define AMGCTLVAL		(AMBEN_P0 | AMBEN_P1 | AMBEN_P2 | AMCKEN)
 #define AMBCTL0VAL		(B1WAT_7 | B1RAT_11 | B1HT_2 | B1ST_3 | B1TT_4 | ~B1RDYPOL | \
diff -Naur u-boot-2009.01/include/configs/canmb.h u-boot/include/configs/canmb.h
--- u-boot-2009.01/include/configs/canmb.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/canmb.h	2009-02-26 14:03:59.000000000 +0100
@@ -173,6 +173,7 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 #define	CONFIG_PHY_ADDR		0x0
 /*
  * GPIO configuration:
diff -Naur u-boot-2009.01/include/configs/canyonlands.h u-boot/include/configs/canyonlands.h
--- u-boot-2009.01/include/configs/canyonlands.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/canyonlands.h	2009-02-26 14:03:59.000000000 +0100
@@ -234,7 +234,6 @@
  * NAND-FLASH related
  *----------------------------------------------------------------------*/
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_SYS_NAND_BASE		(CONFIG_SYS_NAND_ADDR + CONFIG_SYS_NAND_CS)
 #define CONFIG_SYS_NAND_SELECT_DEVICE  1	/* nand driver supports mutipl. chips	*/
 
diff -Naur u-boot-2009.01/include/configs/CATcenter.h u-boot/include/configs/CATcenter.h
--- u-boot-2009.01/include/configs/CATcenter.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/CATcenter.h	2009-02-26 14:03:59.000000000 +0100
@@ -184,7 +184,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK		/* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD		691200
 
 /* The following table includes the supported baudrates */
@@ -219,7 +218,6 @@
 
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS 1
-#define NAND_MAX_CHIPS 1
 
 #define CONFIG_SYS_NAND0_CE  (0x80000000 >> 1)	 /* our CE is GPIO1 */
 #define CONFIG_SYS_NAND0_CLE (0x80000000 >> 2)	 /* our CLE is GPIO2 */
diff -Naur u-boot-2009.01/include/configs/cerf250.h u-boot/include/configs/cerf250.h
--- u-boot-2009.01/include/configs/cerf250.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/cerf250.h	2009-02-26 14:03:59.000000000 +0100
@@ -117,7 +117,7 @@
 
 #define CONFIG_SYS_LOAD_ADDR		0xa2000000	/* default load address */
 
-#define CONFIG_SYS_HZ				3686400		/* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 #define CONFIG_SYS_CPUSPEED		0x141		/* set core clock to 400/200/100 MHz */
 
 #define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
diff -Naur u-boot-2009.01/include/configs/cm4008.h u-boot/include/configs/cm4008.h
--- u-boot-2009.01/include/configs/cm4008.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/cm4008.h	2009-02-26 14:03:59.000000000 +0100
@@ -73,7 +73,7 @@
  */
 #include <config_cmd_default.h>
 
-#undef CONFIG_CMD_ENV
+#undef CONFIG_CMD_SAVEENV
 
 
 #define CONFIG_BOOTDELAY	0
diff -Naur u-boot-2009.01/include/configs/cm41xx.h u-boot/include/configs/cm41xx.h
--- u-boot-2009.01/include/configs/cm41xx.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/cm41xx.h	2009-02-26 14:03:59.000000000 +0100
@@ -73,7 +73,7 @@
  */
 #include <config_cmd_default.h>
 
-#undef CONFIG_CMD_ENV
+#undef CONFIG_CMD_SAVEENV
 
 
 #define CONFIG_BOOTDELAY	0
diff -Naur u-boot-2009.01/include/configs/cm5200.h u-boot/include/configs/cm5200.h
--- u-boot-2009.01/include/configs/cm5200.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/cm5200.h	2009-02-26 14:03:59.000000000 +0100
@@ -65,6 +65,7 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 #define CONFIG_PHY_ADDR		0x00
 #define CONFIG_ENV_OVERWRITE	1	/* allow overwriting of ethaddr */
 /* use misc_init_r() to read ethaddr from I2C EEPROM (see CONFIG_SYS_I2C_EEPROM) */
diff -Naur u-boot-2009.01/include/configs/cmi_mpc5xx.h u-boot/include/configs/cmi_mpc5xx.h
--- u-boot-2009.01/include/configs/cmi_mpc5xx.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/cmi_mpc5xx.h	2009-02-26 14:03:59.000000000 +0100
@@ -69,7 +69,7 @@
 #define CONFIG_CMD_ASKENV
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_CONSOLE
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_RUN
 #define CONFIG_CMD_IMI
 
diff -Naur u-boot-2009.01/include/configs/CMS700.h u-boot/include/configs/CMS700.h
--- u-boot-2009.01/include/configs/CMS700.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/CMS700.h	2009-02-26 14:03:59.000000000 +0100
@@ -125,7 +125,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 #define	CONFIG_UART1_CONSOLE		/* define for uart1 as console	*/
 
@@ -157,7 +156,6 @@
  *-----------------------------------------------------------------------
  */
 #define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#define NAND_MAX_CHIPS          1
 #define CONFIG_SYS_MAX_NAND_DEVICE	1         /* Max number of NAND devices */
 #define NAND_BIG_DELAY_US	25
 
diff -Naur u-boot-2009.01/include/configs/CPCI2DP.h u-boot/include/configs/CPCI2DP.h
--- u-boot-2009.01/include/configs/CPCI2DP.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/CPCI2DP.h	2009-02-26 14:03:59.000000000 +0100
@@ -112,7 +112,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 #define CONFIG_UART1_CONSOLE            /* define for uart1 as console  */
 
diff -Naur u-boot-2009.01/include/configs/CPCI4052.h u-boot/include/configs/CPCI4052.h
--- u-boot-2009.01/include/configs/CPCI4052.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/CPCI4052.h	2009-02-26 14:03:59.000000000 +0100
@@ -134,7 +134,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 
 /* The following table includes the supported baudrates */
diff -Naur u-boot-2009.01/include/configs/CPCI405AB.h u-boot/include/configs/CPCI405AB.h
--- u-boot-2009.01/include/configs/CPCI405AB.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/CPCI405AB.h	2009-02-26 14:03:59.000000000 +0100
@@ -133,7 +133,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 
 /* The following table includes the supported baudrates */
diff -Naur u-boot-2009.01/include/configs/CPCI405DT.h u-boot/include/configs/CPCI405DT.h
--- u-boot-2009.01/include/configs/CPCI405DT.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/CPCI405DT.h	2009-02-26 14:03:59.000000000 +0100
@@ -135,7 +135,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 
 /* The following table includes the supported baudrates */
diff -Naur u-boot-2009.01/include/configs/CPCI405.h u-boot/include/configs/CPCI405.h
--- u-boot-2009.01/include/configs/CPCI405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/CPCI405.h	2009-02-26 14:03:59.000000000 +0100
@@ -125,7 +125,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 
 /* The following table includes the supported baudrates */
diff -Naur u-boot-2009.01/include/configs/cpci5200.h u-boot/include/configs/cpci5200.h
--- u-boot-2009.01/include/configs/cpci5200.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/cpci5200.h	2009-02-26 14:03:59.000000000 +0100
@@ -259,6 +259,7 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 /*
  * Define CONFIG_FEC_10MBIT to force FEC at 10Mb
  */
diff -Naur u-boot-2009.01/include/configs/cradle.h u-boot/include/configs/cradle.h
--- u-boot-2009.01/include/configs/cradle.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/cradle.h	2009-02-26 14:03:59.000000000 +0100
@@ -103,7 +103,7 @@
 
 #define CONFIG_SYS_LOAD_ADDR           0xa2000000      /* default load address */
 
-#define CONFIG_SYS_HZ                  3686400         /* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 #define CONFIG_SYS_CPUSPEED            0x141           /* set core clock to 200/200/100 MHz */
 
 						/* valid baudrates */
diff -Naur u-boot-2009.01/include/configs/CRAYL1.h u-boot/include/configs/CRAYL1.h
--- u-boot-2009.01/include/configs/CRAYL1.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/CRAYL1.h	2009-02-26 14:03:59.000000000 +0100
@@ -86,7 +86,7 @@
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_MEMORY
 #define CONFIG_CMD_NET
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_CONSOLE
 #define CONFIG_CMD_ASKENV
 #define CONFIG_CMD_ECHO
diff -Naur u-boot-2009.01/include/configs/csb226.h u-boot/include/configs/csb226.h
--- u-boot-2009.01/include/configs/csb226.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/csb226.h	2009-02-26 14:03:59.000000000 +0100
@@ -78,7 +78,7 @@
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_MEMORY
 #define CONFIG_CMD_NET
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_RUN
 #define CONFIG_CMD_ASKENV
 #define CONFIG_CMD_ECHO
@@ -131,7 +131,7 @@
 						/* RS: is this where U-Boot is  */
 						/* RS: relocated to in RAM?      */
 
-#define CONFIG_SYS_HZ                  3686400         /* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 						/* RS: the oscillator is actually 3680130?? */
 #define CONFIG_SYS_CPUSPEED            0x141           /* set core clock to 200/200/100 MHz */
 						/* 0101000001 */
diff -Naur u-boot-2009.01/include/configs/csb272.h u-boot/include/configs/csb272.h
--- u-boot-2009.01/include/configs/csb272.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/csb272.h	2009-02-26 14:03:59.000000000 +0100
@@ -162,7 +162,6 @@
  *
  */
 #define CONFIG_SYS_EXT_SERIAL_CLOCK	3868400	/* use external serial clock */
-#undef  CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59 */
 #undef  CONFIG_SYS_BASE_BAUD
 #define CONFIG_BAUDRATE		38400	/* Default baud rate */
 #define CONFIG_SYS_BAUDRATE_TABLE      \
diff -Naur u-boot-2009.01/include/configs/csb472.h u-boot/include/configs/csb472.h
--- u-boot-2009.01/include/configs/csb472.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/csb472.h	2009-02-26 14:03:59.000000000 +0100
@@ -161,7 +161,6 @@
  *
  */
 #undef CONFIG_SYS_EXT_SERIAL_CLOCK		/* use internal serial clock */
-#undef  CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59 */
 #define CONFIG_SYS_BASE_BAUD		691200
 #define CONFIG_BAUDRATE		38400	/* Default baud rate */
 #define CONFIG_SYS_BAUDRATE_TABLE      \
diff -Naur u-boot-2009.01/include/configs/csb637.h u-boot/include/configs/csb637.h
--- u-boot-2009.01/include/configs/csb637.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/csb637.h	2009-02-26 14:03:59.000000000 +0100
@@ -131,7 +131,6 @@
 
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS 1
-#define NAND_MAX_CHIPS 1
 
 #define AT91_SMART_MEDIA_ALE (1 << 22)	/* our ALE is AD22 */
 #define AT91_SMART_MEDIA_CLE (1 << 21)	/* our CLE is AD21 */
diff -Naur u-boot-2009.01/include/configs/davinci_dvevm.h u-boot/include/configs/davinci_dvevm.h
--- u-boot-2009.01/include/configs/davinci_dvevm.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/davinci_dvevm.h	2009-02-26 14:03:59.000000000 +0100
@@ -127,7 +127,6 @@
 #define CONFIG_SYS_NAND_BASE		0x02000000
 #define CONFIG_SYS_NAND_HW_ECC
 #define CONFIG_SYS_MAX_NAND_DEVICE	1	/* Max number of NAND devices */
-#define NAND_MAX_CHIPS		1
 #define CONFIG_ENV_OFFSET		0x0	/* Block 0--not used by bootcode */
 #define DEF_BOOTM		""
 #elif defined(CONFIG_SYS_USE_NOR)
@@ -172,6 +171,8 @@
 #define CONFIG_SYS_LONGHELP
 #define CONFIG_CRC32_VERIFY
 #define CONFIG_MX_CYCLIC
+#define CONFIG_MUSB_HCD
+#define CONFIG_USB_DAVINCI
 /*===================*/
 /* Linux Information */
 /*===================*/
@@ -204,6 +205,22 @@
 #else
 #error "Either CONFIG_SYS_USE_NAND or CONFIG_SYS_USE_NOR _MUST_ be defined !!!"
 #endif
+/*==========================*/
+/* USB MSC support (if any) */
+/*==========================*/
+#ifdef CONFIG_USB_DAVINCI
+#define CONFIG_CMD_USB
+#ifdef CONFIG_MUSB_HCD
+#define CONFIG_USB_STORAGE
+#define CONFIG_CMD_STORAGE
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+#ifdef CONFIG_USB_KEYBOARD
+#define CONFIG_SYS_USB_EVENT_POLL
+#define CONFIG_PREBOOT "usb start"
+#endif
+#endif
 /*=======================*/
 /* KGDB support (if any) */
 /*=======================*/
diff -Naur u-boot-2009.01/include/configs/davinci_schmoogie.h u-boot/include/configs/davinci_schmoogie.h
--- u-boot-2009.01/include/configs/davinci_schmoogie.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/davinci_schmoogie.h	2009-02-26 14:03:59.000000000 +0100
@@ -89,7 +89,6 @@
 #define CONFIG_SYS_NAND_BASE		0x02000000
 #define CONFIG_SYS_NAND_HW_ECC
 #define CONFIG_SYS_MAX_NAND_DEVICE	1	/* Max number of NAND devices */
-#define NAND_MAX_CHIPS		1
 #define CONFIG_ENV_OFFSET		0x0	/* Block 0--not used by bootcode */
 /*=====================*/
 /* Board related stuff */
diff -Naur u-boot-2009.01/include/configs/davinci_sffsdr.h u-boot/include/configs/davinci_sffsdr.h
--- u-boot-2009.01/include/configs/davinci_sffsdr.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/davinci_sffsdr.h	2009-02-26 14:03:59.000000000 +0100
@@ -85,7 +85,6 @@
 #define CONFIG_SYS_NAND_BASE		0x02000000
 #define CONFIG_SYS_NAND_HW_ECC
 #define CONFIG_SYS_MAX_NAND_DEVICE	1	/* Max number of NAND devices */
-#define NAND_MAX_CHIPS		1
 #define CONFIG_ENV_OFFSET		0x0	/* Block 0--not used by bootcode */
 /* I2C switch definitions for PCA9543 chip */
 #define CONFIG_SYS_I2C_PCA9543_ADDR		0x70
diff -Naur u-boot-2009.01/include/configs/davinci_sonata.h u-boot/include/configs/davinci_sonata.h
--- u-boot-2009.01/include/configs/davinci_sonata.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/davinci_sonata.h	2009-02-26 14:03:59.000000000 +0100
@@ -122,7 +122,6 @@
 #define CONFIG_SYS_NAND_BASE		0x02000000
 #define CONFIG_SYS_NAND_HW_ECC
 #define CONFIG_SYS_MAX_NAND_DEVICE	1	/* Max number of NAND devices */
-#define NAND_MAX_CHIPS		1
 #define CONFIG_ENV_OFFSET		0x0	/* Block 0--not used by bootcode */
 #define DEF_BOOTM		""
 #elif defined(CONFIG_SYS_USE_NOR)
diff -Naur u-boot-2009.01/include/configs/dbau1x00.h u-boot/include/configs/dbau1x00.h
--- u-boot-2009.01/include/configs/dbau1x00.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/dbau1x00.h	2009-02-26 14:03:59.000000000 +0100
@@ -97,7 +97,7 @@
 #undef CONFIG_CMD_BDI
 #undef CONFIG_CMD_BEDBUG
 #undef CONFIG_CMD_ELF
-#undef CONFIG_CMD_ENV
+#undef CONFIG_CMD_SAVEENV
 #undef CONFIG_CMD_FAT
 #undef CONFIG_CMD_FPGA
 #undef CONFIG_CMD_MII
diff -Naur u-boot-2009.01/include/configs/delta.h u-boot/include/configs/delta.h
--- u-boot-2009.01/include/configs/delta.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/delta.h	2009-02-26 14:03:59.000000000 +0100
@@ -34,7 +34,6 @@
 #ifdef CONFIG_LCD
 #define CONFIG_SHARP_LM8V31
 #endif
-/* #define CONFIG_MMC		1 */
 #define BOARD_LATE_INIT		1
 
 #undef CONFIG_SKIP_RELOCATE_UBOOT
@@ -108,7 +107,7 @@
 
 #else
 
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_NAND
 #define CONFIG_CMD_I2C
 
@@ -131,8 +130,6 @@
 #define CONFIG_SYS_USB_OHCI_SLOT_NAME	"delta"
 #define CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS	3
 
-#define LITTLEENDIAN            1       /* used by usb_ohci.c  */
-
 #define CONFIG_BOOTDELAY	-1
 #define CONFIG_ETHADDR		08:00:3e:26:0a:5b
 #define CONFIG_NETMASK		255.255.0.0
@@ -173,7 +170,7 @@
 
 #define CONFIG_SYS_LOAD_ADDR	(CONFIG_SYS_DRAM_BASE + 0x8000) /* default load address */
 
-#define CONFIG_SYS_HZ			3250000		/* incrementer freq: 3.25 MHz */
+#define CONFIG_SYS_HZ			1000
 
 /* Monahans Core Frequency */
 #define CONFIG_SYS_MONAHANS_RUN_MODE_OSC_RATIO		16 /* valid values: 8, 16, 24, 31 */
@@ -183,7 +180,11 @@
 						/* valid baudrates */
 #define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
 
-/* #define CONFIG_SYS_MMC_BASE		0xF0000000 */
+#ifdef CONFIG_MMC
+#define CONFIG_PXA_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_SYS_MMC_BASE		0xF0000000
+#endif
 
 /*
  * Stack sizes
@@ -258,7 +259,6 @@
 
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS		1
-#define NAND_MAX_CHIPS		1
 
 #define CONFIG_SYS_NO_FLASH		1
 
diff -Naur u-boot-2009.01/include/configs/DP405.h u-boot/include/configs/DP405.h
--- u-boot-2009.01/include/configs/DP405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/DP405.h	2009-02-26 14:03:59.000000000 +0100
@@ -117,7 +117,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 #undef	CONFIG_UART1_CONSOLE		/* define for uart1 as console	*/
 
diff -Naur u-boot-2009.01/include/configs/DU440.h u-boot/include/configs/DU440.h
--- u-boot-2009.01/include/configs/DU440.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/DU440.h	2009-02-26 14:03:59.000000000 +0100
@@ -411,7 +411,6 @@
  * NAND FLASH
  */
 #define CONFIG_SYS_MAX_NAND_DEVICE	2
-#define NAND_MAX_CHIPS		CONFIG_SYS_MAX_NAND_DEVICE
 #define CONFIG_SYS_NAND_SELECT_DEVICE  1	/* nand driver supports mutipl. chips */
 #define CONFIG_SYS_NAND_BASE_LIST	{CONFIG_SYS_NAND0_ADDR + CONFIG_SYS_NAND0_CS, \
 				 CONFIG_SYS_NAND1_ADDR + CONFIG_SYS_NAND1_CS}
diff -Naur u-boot-2009.01/include/configs/eNET.h u-boot/include/configs/eNET.h
--- u-boot-2009.01/include/configs/eNET.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/eNET.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,248 @@
+/*
+ * (C) Copyright 2008
+ * Graeme Russ, graeme.russ@gmail.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * board/config.h - configuration options, board specific
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * Stuff still to be dealt with -
+ */
+#define CONFIG_RTC_MC146818
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define DEBUG_PARSER
+
+#define CONFIG_X86			1	/* Intel X86 CPU */
+#define CONFIG_SC520			1	/* AMD SC520 */
+#define CONFIG_SC520_SSI
+#define CONFIG_SHOW_BOOT_PROGRESS	1
+#define CONFIG_LAST_STAGE_INIT		1
+
+/*
+ * If CONFIG_HW_WATCHDOG is not defined, the watchdog jumper on the
+ * bottom (processor) board MUST be removed!
+ */
+#undef CONFIG_WATCHDOG
+#undef CONFIG_HW_WATCHDOG
+
+ /*-----------------------------------------------------------------------
+  * Video Configuration
+  */
+#undef CONFIG_VIDEO			/* No Video Hardware */
+#undef CONFIG_CFB_CONSOLE
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_MALLOC_SIZE	(CONFIG_SYS_ENV_SIZE + 128*1024)
+
+#define CONFIG_BAUDRATE		9600
+
+/*-----------------------------------------------------------------------
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_AUTOSCRIPT	/* Autoscript Support		*/
+#define CONFIG_CMD_BDI		/* bdinfo			*/
+#define CONFIG_CMD_BOOTD	/* bootd			*/
+#define CONFIG_CMD_CONSOLE	/* coninfo			*/
+#define CONFIG_CMD_ECHO		/* echo arguments		*/
+#define CONFIG_CMD_SAVEENV	/* saveenv			*/
+#define CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+#define CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#define CONFIG_CMD_IMI		/* iminfo			*/
+#define CONFIG_CMD_IMLS		/* List all found images	*/
+#define CONFIG_CMD_ITEST	/* Integer (and string) test	*/
+#define CONFIG_CMD_LOADB	/* loadb			*/
+#define CONFIG_CMD_LOADS	/* loads			*/
+#define CONFIG_CMD_MEMORY	/* md mm nm mw cp cmp crc base loop mtest */
+#define CONFIG_CMD_MISC		/* Misc functions like sleep etc*/
+#undef CONFIG_CMD_NET		/* bootp, tftpboot, rarpboot	*/
+#undef CONFIG_CMD_NFS		/* NFS support			*/
+#define CONFIG_CMD_RUN		/* run command in env variable	*/
+#define CONFIG_CMD_SETGETDCR	/* DCR support on 4xx		*/
+#define CONFIG_CMD_XIMG		/* Load part of Multi Image	*/
+#undef CONFIG_CMD_IRQ		/* IRQ Information		*/
+
+#define CONFIG_BOOTDELAY		15
+#define CONFIG_BOOTARGS			"root=/dev/mtdblock0 console=ttyS0,9600"
+/* #define CONFIG_BOOTCOMMAND		"bootm 38000000" */
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE		115200		/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX		2		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+#define	CONFIG_SYS_PROMPT		"boot > "	/* Monitor Command Prompt	*/
+#define	CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					 sizeof(CONFIG_SYS_PROMPT) + \
+					 16)		/* Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x00100000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x01000000	/* 1 ... 16 MB in DRAM	*/
+
+#undef  CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CONFIG_SYS_LOAD_ADDR		0x100000	/* default load address	*/
+
+#define	CONFIG_SYS_HZ			1024		/* incrementer freq: 1kHz */
+
+						/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * SDRAM Configuration
+ */
+#define CONFIG_SYS_SDRAM_DRCTMCTL	0x18
+#define CONFIG_NR_DRAM_BANKS		4
+
+/* CONFIG_SYS_SDRAM_DRCTMCTL Overrides the following*/
+#undef CONFIG_SYS_SDRAM_PRECHARGE_DELAY
+#undef CONFIG_SYS_SDRAM_REFRESH_RATE
+#undef CONFIG_SYS_SDRAM_RAS_CAS_DELAY
+#undef CONFIG_SYS_SDRAM_CAS_LATENCY_2T
+#undef CONFIG_SYS_SDRAM_CAS_LATENCY_3T
+
+/*-----------------------------------------------------------------------
+ * CPU Features
+ */
+#define CONFIG_SYS_SC520_HIGH_SPEED	0	/* 100 or 133MHz */
+#undef  CONFIG_SYS_RESET_SC520			/* use SC520 MMCR's to reset cpu */
+#define CONFIG_SYS_TIMER_SC520			/* use SC520 swtimers */
+#undef  CONFIG_SYS_TIMER_GENERIC		/* use the i8254 PIT timers */
+#undef  CONFIG_SYS_TIMER_TSC			/* use the Pentium TSC timers */
+#define CONFIG_SYS_USE_SIO_UART		0       /* prefer the uarts on the SIO to those
+					 * in the SC520 on the CDP */
+
+/*-----------------------------------------------------------------------
+ * Memory organization
+ */
+#define CONFIG_SYS_STACK_SIZE		0x8000  	/* Size of bootloader stack */
+#define CONFIG_SYS_BL_START_FLASH	0x38040000	/* Address of relocated code */
+#define CONFIG_SYS_BL_START_RAM		0x03fd0000	/* Address of relocated code */
+#define CONFIG_SYS_MONITOR_BASE		TEXT_BASE
+#define CONFIG_SYS_MONITOR_LEN		(256 * 1024)    /* Reserve 256 kB for Mon	*/
+#define CONFIG_SYS_FLASH_BASE		0x38000000	/* Boot Flash */
+#define CONFIG_SYS_FLASH_BASE_1		0x10000000	/* StrataFlash 1 */
+#define CONFIG_SYS_FLASH_BASE_2		0x11000000	/* StrataFlash 2 */
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2*CONFIG_SYS_HZ) /* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(2*CONFIG_SYS_HZ) /* Timeout for Flash Write */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+ /*-----------------------------------------------------------------------
+  * FLASH configuration
+  */
+#define CONFIG_FLASH_CFI_DRIVER				/* Use the common driver */
+#define CONFIG_FLASH_CFI_LEGACY
+#define CONFIG_SYS_FLASH_CFI				/* Flash is CFI conformant */
+#define CONFIG_SYS_MAX_FLASH_BANKS	3	/* max number of memory banks */
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE,   \
+					 CONFIG_SYS_FLASH_BASE_1, \
+					 CONFIG_SYS_FLASH_BASE_2}
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_SYS_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_8BIT
+#define CONFIG_SYS_FLASH_LEGACY_512Kx8
+
+ /*-----------------------------------------------------------------------
+  * Environment configuration
+  */
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x20000 /*   Offset   of Environment Sector */
+#define CONFIG_ENV_SIZE			0x08000 /* Total Size of Environment Sector */
+#define CONFIG_ENV_SECT_SIZE		0x20000 /* Total Size of Environment Sector */
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE_1 + \
+					 CONFIG_ENV_OFFSET)
+#define CONFIG_ENV_OFFSET_REDUND	(CONFIG_ENV_OFFSET + \
+					 CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE_REDUND		(CONFIG_ENV_SIZE)
+
+
+ /*-----------------------------------------------------------------------
+  * PCI configuration
+  */
+#undef CONFIG_PCI                                /* include pci support */
+#undef CONFIG_PCI_PNP                            /* pci plug-and-play */
+#undef CONFIG_PCI_SCAN_SHOW
+#undef CONFIG_SYS_FIRST_PCI_IRQ
+#undef CONFIG_SYS_SECOND_PCI_IRQ
+#undef CONFIG_SYS_THIRD_PCI_IRQ
+#undef CONFIG_SYS_FORTH_PCI_IRQ
+
+/*-----------------------------------------------------------------------
+ * Hardware watchdog configuration
+ */
+#define CONFIG_SYS_WATCHDOG_PIO_BIT  		0x8000
+#define CONFIG_SYS_WATCHDIG_PIO_DATA 		SC520_PIODATA15_0
+#define CONFIG_SYS_WATCHDIG_PIO_CLR  		SC520_PIOCLR15_0
+#define CONFIG_SYS_WATCHDIG_PIO_SET  		SC520_PIOSET15_0
+
+/*-----------------------------------------------------------------------
+ * FPGA configuration
+ */
+#define CONFIG_SYS_FPGA_PROGRAM_PIO_BIT		0x2000
+#define CONFIG_SYS_FPGA_INIT_PIO_BIT		0x4000
+#define CONFIG_SYS_FPGA_DONE_PIO_BIT		0x8000
+#define CONFIG_SYS_FPGA_PIO_DATA 		SC520_PIODATA31_16
+#define CONFIG_SYS_FPGA_PIO_DIRECTION 		SC520_PIODIR31_16
+#define CONFIG_SYS_FPGA_PIO_CLR  		SC520_PIOCLR31_16
+#define CONFIG_SYS_FPGA_PIO_SET  		SC520_PIOSET31_16
+#define CONFIG_SYS_FPGA_PROGRAM_BIT_DROP_TIME	1	/* milliseconds */
+#define CONFIG_SYS_FPGA_MAX_INIT_TIME		10	/* milliseconds */
+#define CONFIG_SYS_FPGA_MAX_FINALISE_TIME	10	/* milliseconds */
+#define CONFIG_SYS_FPGA_SSI_DATA_RATE		8333	/* kHz (33.3333MHz xtal) */
+
+#ifndef __ASSEMBLER__
+extern unsigned long ip;
+
+#define PRINTIP				asm ("call next_line\n" \
+					    "next_line:\n" \
+					    "pop %%eax\n" \
+					    "movl %%eax, %0\n" \
+					    :"=r"(ip) \
+					    : /* No Input Registers */ \
+					    :"%eax"); \
+					    printf("IP: 0x%08lx (File: %s, Line: %d)\n", ip, __FILE__, __LINE__);
+
+#endif
+#endif	/* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/EP1S10.h u-boot/include/configs/EP1S10.h
--- u-boot-2009.01/include/configs/EP1S10.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/EP1S10.h	2009-02-26 14:03:59.000000000 +0100
@@ -170,7 +170,7 @@
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ECHO
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_IRQ
diff -Naur u-boot-2009.01/include/configs/EP1S40.h u-boot/include/configs/EP1S40.h
--- u-boot-2009.01/include/configs/EP1S40.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/EP1S40.h	2009-02-26 14:03:59.000000000 +0100
@@ -170,7 +170,7 @@
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ECHO
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_IRQ
diff -Naur u-boot-2009.01/include/configs/ERIC.h u-boot/include/configs/ERIC.h
--- u-boot-2009.01/include/configs/ERIC.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ERIC.h	2009-02-26 14:03:59.000000000 +0100
@@ -114,7 +114,7 @@
 
 #define CONFIG_CMD_PCI
 #define CONFIG_CMD_IRQ
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 
 
diff -Naur u-boot-2009.01/include/configs/eXalion.h u-boot/include/configs/eXalion.h
--- u-boot-2009.01/include/configs/eXalion.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/eXalion.h	2009-02-26 14:03:59.000000000 +0100
@@ -77,7 +77,7 @@
 #define CONFIG_CMD_I2C
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_FAT
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_PCI
 
 
diff -Naur u-boot-2009.01/include/configs/FLAGADM.h u-boot/include/configs/FLAGADM.h
--- u-boot-2009.01/include/configs/FLAGADM.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/FLAGADM.h	2009-02-26 14:03:59.000000000 +0100
@@ -83,7 +83,7 @@
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_LOADB
 #define CONFIG_CMD_LOADS
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_REGINFO
 #define CONFIG_CMD_IMMAP
 #define CONFIG_CMD_NET
diff -Naur u-boot-2009.01/include/configs/G2000.h u-boot/include/configs/G2000.h
--- u-boot-2009.01/include/configs/G2000.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/G2000.h	2009-02-26 14:03:59.000000000 +0100
@@ -152,7 +152,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 #undef	CONFIG_UART1_CONSOLE		/* define for uart1 as console	*/
 
@@ -205,7 +204,6 @@
 
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS 1
-#define NAND_MAX_CHIPS 1
 
 #define CONFIG_SYS_NAND_CE  (0x80000000 >> 1)	/* our CE is GPIO1 */
 #define CONFIG_SYS_NAND_CLE (0x80000000 >> 2)	/* our CLE is GPIO2 */
diff -Naur u-boot-2009.01/include/configs/gdppc440etx.h u-boot/include/configs/gdppc440etx.h
--- u-boot-2009.01/include/configs/gdppc440etx.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/gdppc440etx.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,194 @@
+/*
+ * (C) Copyright 2008
+ * Dirk Eibach,  Guntermann & Drunck GmbH, eibach@gdsys.de
+ *
+ * Based on include/configs/yosemite.h
+ * (C) Copyright 2005-2007
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * gdppc440etx.h - configuration for G&D 440EP/GR ETX-Module
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_440GR		1		/* Specific PPC440GR support */
+#define CONFIG_HOSTNAME		gdppc440etx
+#define CONFIG_440		1		/* ... PPC440 family         */
+#define CONFIG_4xx		1		/* ... PPC4xx family         */
+#define CONFIG_SYS_CLK_FREQ	66666666	/* external freq to pll      */
+
+/*
+ * Include common defines/options for all AMCC eval boards
+ */
+#include "amcc-common.h"
+
+#define CONFIG_BOARD_EARLY_INIT_F	1	/* call board_early_init_f*/
+#define CONFIG_MISC_INIT_R		1	/* call misc_init_r()     */
+
+/*
+ * Base addresses -- Note these are effective addresses where the
+ * actual resources get mapped (not physical addresses)
+ */
+#define CONFIG_SYS_FLASH_BASE		0xfc000000	/* start of FLASH    */
+#define CONFIG_SYS_PCI_MEMBASE		0xa0000000	/* mapped pci memory */
+#define CONFIG_SYS_PCI_MEMBASE1		CONFIG_SYS_PCI_MEMBASE  + 0x10000000
+#define CONFIG_SYS_PCI_MEMBASE2		CONFIG_SYS_PCI_MEMBASE1 + 0x10000000
+#define CONFIG_SYS_PCI_MEMBASE3		CONFIG_SYS_PCI_MEMBASE2 + 0x10000000
+
+/*Don't change either of these*/
+#define CONFIG_SYS_PERIPHERAL_BASE	0xef600000	/* internal peripheral*/
+#define CONFIG_SYS_PCI_BASE		0xe0000000	/* internal PCI regs */
+/*Don't change either of these*/
+
+#define CONFIG_SYS_USB_DEVICE		0x50000000
+#define CONFIG_SYS_BOOT_BASE_ADDR	0xf0000000
+
+/*
+ * Initial RAM & stack pointer (placed in SDRAM)
+ */
+#define CONFIG_SYS_INIT_RAM_DCACHE	1		/* d-cache as init ram*/
+#define CONFIG_SYS_INIT_RAM_ADDR	0x70000000	/* DCache             */
+#define CONFIG_SYS_INIT_RAM_END		(4 << 10)
+#define CONFIG_SYS_GBL_DATA_SIZE	256		/* num bytes init data*/
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_END \
+					 - CONFIG_SYS_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+/*
+ * Serial Port
+ */
+#define CONFIG_SYS_EXT_SERIAL_CLOCK	11059200	/* ext. 11.059MHz clk */
+#define CONFIG_UART1_CONSOLE
+
+/*
+ * Environment
+ * Define here the location of the environment variables (FLASH or EEPROM).
+ * Note: DENX encourages to use redundant environment in FLASH.
+ */
+#define CONFIG_ENV_IS_IN_FLASH		1		/* FLASH for env. vars*/
+
+/*
+ * FLASH related
+ */
+#define CONFIG_SYS_FLASH_CFI			/* The flash is CFI compatible*/
+#define CONFIG_FLASH_CFI_DRIVER			/* Use common CFI driver      */
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET	1	/* AMD RESET for STM 29W320DB!*/
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	512	/* max number of sectors/chip */
+
+#define CONFIG_SYS_FLASH_ERASE_TOUT 	120000	/* Timeout/Flash Erase (in ms)*/
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Timeout/Flash Write (in ms)*/
+
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1/* use buffered writes (20x faster)*/
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO /* print 'E' for empty sector on flinfo */
+
+#ifdef CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_SECT_SIZE		0x20000 /* size of one complete sector*/
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE-CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE			0x2000 /* Total Size of Env. Sector */
+
+/* Address and size of Redundant Environment Sector */
+#define CONFIG_ENV_ADDR_REDUND		(CONFIG_ENV_ADDR-CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE_REDUND		(CONFIG_ENV_SIZE)
+#endif /* CONFIG_ENV_IS_IN_FLASH */
+
+/*
+ * DDR SDRAM
+ */
+#undef CONFIG_SPD_EEPROM		/* Don't use SPD EEPROM for setup*/
+#define CONFIG_SYS_KBYTES_SDRAM		(128 * 1024)    /* 128MB         */
+#define CONFIG_SYS_SDRAM_BANKS		(2)
+
+#define CONFIG_SDRAM_BANK0
+#define CONFIG_SDRAM_BANK1
+
+#define CONFIG_SYS_SDRAM0_TR0		0x410a4012
+#define CONFIG_SYS_SDRAM0_WDDCTR	0x40000000
+#define CONFIG_SYS_SDRAM0_RTR		0x04080000
+#define CONFIG_SYS_SDRAM0_CFG0		0x80000000
+
+#undef CONFIG_SDRAM_ECC
+
+/*
+ * I2C
+ */
+#define CONFIG_SYS_I2C_SPEED		400000	/* I2C speed+slave address*/
+
+/*
+ * Default environment variables
+ */
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	CONFIG_AMCC_DEF_ENV						\
+	CONFIG_AMCC_DEF_ENV_POWERPC					\
+	CONFIG_AMCC_DEF_ENV_NOR_UPD					\
+	"kernel_addr=fc000000\0"					\
+	"ramdisk_addr=fc180000\0"					\
+	""
+
+#define CONFIG_HAS_ETH1			1	/* add support for "eth1addr" */
+#define CONFIG_PHY_ADDR			1
+#define CONFIG_PHY1_ADDR		3
+
+#ifdef DEBUG
+#define CONFIG_PANIC_HANG
+#endif
+
+/*
+ * Commands additional to the ones defined in amcc-common.h
+ */
+#define CONFIG_CMD_PCI
+#undef CONFIG_CMD_EEPROM
+
+/*
+ * PCI stuff
+ */
+
+/* General PCI */
+#define CONFIG_PCI				/* include pci support        */
+#undef  CONFIG_PCI_PNP				/* do (not) pci plug-and-play */
+#define CONFIG_PCI_SCAN_SHOW			/* show pci devices on startup*/
+#define CONFIG_SYS_PCI_TARGBASE		0x80000000	/* PCIaddr mapped to \
+							CONFIG_SYS_PCI_MEMBASE*/
+
+/* Board-specific PCI */
+#define CONFIG_SYS_PCI_TARGET_INIT
+#define CONFIG_SYS_PCI_MASTER_INIT
+
+#define CONFIG_SYS_PCI_SUBSYS_VENDORID	0x10e8	/* AMCC */
+#define CONFIG_SYS_PCI_SUBSYS_ID	0xcafe	/* tbd */
+
+/*
+ * External Bus Controller (EBC) Setup
+ */
+#define CONFIG_SYS_FLASH		CONFIG_SYS_FLASH_BASE
+
+/* Memory Bank 0 (NOR-FLASH) initialization */
+#define CONFIG_SYS_EBC_PB0AP		0x03017200
+#define CONFIG_SYS_EBC_PB0CR		(CONFIG_SYS_FLASH | 0xda000)
+
+#endif	/* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/gth2.h u-boot/include/configs/gth2.h
--- u-boot-2009.01/include/configs/gth2.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/gth2.h	2009-02-26 14:03:59.000000000 +0100
@@ -90,7 +90,7 @@
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_DHCP
 
-#undef CONFIG_CMD_ENV
+#undef CONFIG_CMD_SAVEENV
 #undef CONFIG_CMD_FAT
 #undef CONFIG_CMD_FLASH
 #undef CONFIG_CMD_FPGA
diff -Naur u-boot-2009.01/include/configs/HH405.h u-boot/include/configs/HH405.h
--- u-boot-2009.01/include/configs/HH405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/HH405.h	2009-02-26 14:03:59.000000000 +0100
@@ -177,7 +177,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef  CONFIG_SYS_EXT_SERIAL_CLOCK           /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59   /* ignore ppc405gp errata #59   */
 #define CONFIG_SYS_BASE_BAUD       691200
 #define CONFIG_UART1_CONSOLE            /* define for uart1 as console  */
 
@@ -209,7 +208,6 @@
  *-----------------------------------------------------------------------
  */
 #define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#define NAND_MAX_CHIPS          1
 #define CONFIG_SYS_MAX_NAND_DEVICE	1         /* Max number of NAND devices */
 #define NAND_BIG_DELAY_US	25
 
diff -Naur u-boot-2009.01/include/configs/hmi1001.h u-boot/include/configs/hmi1001.h
--- u-boot-2009.01/include/configs/hmi1001.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/hmi1001.h	2009-02-26 14:03:59.000000000 +0100
@@ -215,6 +215,7 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 #define CONFIG_PHY_ADDR		0x00
 #define CONFIG_MII		1		/* MII PHY management		*/
 
diff -Naur u-boot-2009.01/include/configs/HUB405.h u-boot/include/configs/HUB405.h
--- u-boot-2009.01/include/configs/HUB405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/HUB405.h	2009-02-26 14:03:59.000000000 +0100
@@ -118,7 +118,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 #undef	CONFIG_UART1_CONSOLE		/* define for uart1 as console	*/
 
@@ -149,7 +148,6 @@
  *-----------------------------------------------------------------------
  */
 #define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#define NAND_MAX_CHIPS          1
 #define CONFIG_SYS_MAX_NAND_DEVICE	1         /* Max number of NAND devices */
 #define NAND_BIG_DELAY_US	25
 
diff -Naur u-boot-2009.01/include/configs/IceCube.h u-boot/include/configs/IceCube.h
--- u-boot-2009.01/include/configs/IceCube.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/IceCube.h	2009-02-26 14:03:59.000000000 +0100
@@ -293,14 +293,12 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 /*
- * Define CONFIG_FEC_10MBIT to force FEC at 10Mb
+ * Define CONFIG_MPC5xxx_FEC_MII10 to force FEC at 10Mb
  */
-/* #define CONFIG_FEC_10MBIT 1 */
+/* #define CONFIG_MPC5xxx_FEC_MII10 */
 #define CONFIG_PHY_ADDR		0x00
-#if defined(CONFIG_LITE5200B)
-#define CONFIG_FEC_MII100	1
-#endif
 
 /*
  * GPIO configuration
diff -Naur u-boot-2009.01/include/configs/icnova/base.h u-boot/include/configs/icnova/base.h
--- u-boot-2009.01/include/configs/icnova/base.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova/base.h	2009-02-27 10:37:23.000000000 +0100
@@ -0,0 +1,62 @@
+
+#include <asm/arch/memory-map.h>
+
+#define CONFIG_AVR32			1
+#define CONFIG_AT32AP			1
+
+/*
+ * Timer clock frequency. We're using the CPU-internal COUNT register
+ * for this, so this is equivalent to the CPU core clock frequency
+ */
+#define CONFIG_SYS_HZ				1000
+
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+#define CONFIG_STACKSIZE		(2048)
+
+#include <config_cmd_default.h>
+#define CONFIG_CMD_ASKENV
+/*
+ * Only interrupt autoboot if <space> is pressed. Otherwise, garbage
+ * data on the serial line may interrupt the boot sequence.
+ */
+#define CONFIG_BOOTDELAY		1
+#define CONFIG_AUTOBOOT			1
+#define CONFIG_AUTOBOOT_KEYED		1
+#define CONFIG_AUTOBOOT_PROMPT		\
+	"Press SPACE to abort autoboot in %d seconds\n", bootdelay
+#define CONFIG_AUTOBOOT_DELAY_STR	"d"
+#define CONFIG_AUTOBOOT_STOP_STR	" "
+
+#define CONFIG_SYS_DCACHE_LINESZ		32
+#define CONFIG_SYS_ICACHE_LINESZ		32
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CONFIG_PIO2			1
+#define CONFIG_SYS_NR_PIOS			5
+#define CONFIG_SYS_HSDRAMC			1
+
+#define CONFIG_SYS_INTRAM_BASE			INTERNAL_SRAM_BASE
+#define CONFIG_SYS_INTRAM_SIZE			INTERNAL_SRAM_SIZE
+#define CONFIG_SYS_SDRAM_BASE			EBI_SDRAM_BASE
+
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_INTRAM_BASE + CONFIG_SYS_INTRAM_SIZE)
+
+#define CONFIG_SYS_MALLOC_LEN			(256*1024)
+#define CONFIG_SYS_DMA_ALLOC_LEN		(16384)
+
+/* Allow 4MB for the kernel run-time image */
+#define CONFIG_SYS_LOAD_ADDR			(EBI_SDRAM_BASE + 0x00400000)
+#define CONFIG_SYS_BOOTPARAMS_LEN		(16 * 1024)
+
+#define CONFIG_SYS_PROMPT			"ICnova> "
+#define CONFIG_SYS_CBSIZE			256
+#define CONFIG_SYS_MAXARGS			16
+#define CONFIG_SYS_PBSIZE			(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_LONGHELP			1
+
+#define CONFIG_SYS_MEMTEST_START		EBI_SDRAM_BASE
+#define CONFIG_SYS_MEMTEST_END			(CONFIG_SYS_MEMTEST_START + 0x700000)
diff -Naur u-boot-2009.01/include/configs/icnova/cpu140MHz.h u-boot/include/configs/icnova/cpu140MHz.h
--- u-boot-2009.01/include/configs/icnova/cpu140MHz.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova/cpu140MHz.h	2009-02-26 15:01:41.000000000 +0100
@@ -0,0 +1,42 @@
+
+/*
+ * Set up the PLL to run at 140 MHz, the CPU to run at the PLL
+ * frequency, the HSB and PBB at 1/2, and the PBA to run at 1/4 the
+ * PLL frequency.
+ * (CONFIG_SYS_OSC0_HZ * CONFIG_SYS_PLL0_MUL) / CONFIG_SYS_PLL0_DIV = PLL MHz
+ */
+#define CONFIG_PLL			1
+#define CONFIG_SYS_POWER_MANAGER		1
+#define CONFIG_SYS_OSC0_HZ			20000000
+#define CONFIG_SYS_PLL0_DIV			1
+#define CONFIG_SYS_PLL0_MUL			7
+#define CONFIG_SYS_PLL0_SUPPRESS_CYCLES	16
+/*
+ * Set the CPU running at:
+ * PLL / (2^CONFIG_SYS_CLKDIV_CPU) = CPU MHz
+ */
+#define CONFIG_SYS_CLKDIV_CPU			0
+/*
+ * Set the HSB running at:
+ * PLL / (2^CONFIG_SYS_CLKDIV_HSB) = HSB MHz
+ */
+#define CONFIG_SYS_CLKDIV_HSB			1
+/*
+ * Set the PBA running at:
+ * PLL / (2^CONFIG_SYS_CLKDIV_PBA) = PBA MHz
+ */
+#define CONFIG_SYS_CLKDIV_PBA			2
+/*
+ * Set the PBB running at:
+ * PLL / (2^CONFIG_SYS_CLKDIV_PBB) = PBB MHz
+ */
+#define CONFIG_SYS_CLKDIV_PBB			1
+
+/*
+ * The PLLOPT register controls the PLL like this:
+ *   icp = PLLOPT<2>
+ *   ivco = PLLOPT<1:0>
+ *
+ * We want icp=1 (default) and ivco=0 (80-160 MHz) or ivco=2 (150-240MHz).
+ */
+#define CONFIG_SYS_PLL0_OPT			0x04
diff -Naur u-boot-2009.01/include/configs/icnova/flash2x8.h u-boot/include/configs/icnova/flash2x8.h
--- u-boot-2009.01/include/configs/icnova/flash2x8.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova/flash2x8.h	2009-03-05 17:29:39.000000000 +0100
@@ -0,0 +1,15 @@
+#define CONFIG_CMD_JFFS2
+#define CONFIG_CMD_FLASH
+
+#define CONFIG_SYS_FLASH_BASE			0x00000000
+#define CONFIG_SYS_FLASH_SIZE			0x00100000
+#define CONFIG_SYS_MAX_FLASH_BANKS		1
+#define CONFIG_SYS_FLASH_SECT			8
+#define CONFIG_SYS_MAX_FLASH_SECT		(CONFIG_SYS_FLASH_SECT+1)
+
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_SIZE			(CONFIG_SYS_FLASH_SIZE / CONFIG_SYS_FLASH_SECT)
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + CONFIG_SYS_FLASH_SIZE - CONFIG_ENV_SIZE)
+
diff -Naur u-boot-2009.01/include/configs/icnova/flash.h u-boot/include/configs/icnova/flash.h
--- u-boot-2009.01/include/configs/icnova/flash.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova/flash.h	2009-03-18 11:15:04.896691839 +0100
@@ -0,0 +1,20 @@
+#define CONFIG_CMD_JFFS2
+#define CONFIG_CMD_FLASH
+
+#define CONFIG_SYS_FLASH_BASE			0x00000000
+#define CONFIG_SYS_FLASH_SIZE			0x800000
+#define CONFIG_SYS_MAX_FLASH_BANKS		1
+#define CONFIG_SYS_MAX_FLASH_SECT		135
+
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_SIZE			65536
+#define CONFIG_ENV_ADDR			0x30000
+
+#undef CONFIG_BOOTARGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_BOOTARGS		"root=1F02 rootfstype=jffs2"
+#define CONFIG_BOOTCOMMAND	\
+	"mtdparts default; chpart nor0,2; fsload boot/uImage; bootm"
diff -Naur u-boot-2009.01/include/configs/icnova/mmc.h u-boot/include/configs/icnova/mmc.h
--- u-boot-2009.01/include/configs/icnova/mmc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova/mmc.h	2009-02-27 12:07:22.000000000 +0100
@@ -0,0 +1,18 @@
+
+#define CONFIG_DOS_PARTITION		1
+
+#undef CONFIG_BOOTARGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_BOOTARGS							\
+	"root=/dev/mmcblk0p1 rootwait=1"
+
+#define CONFIG_BOOTCOMMAND						\
+	"mmcinit; fsload; bootm $(fileaddr)"
+
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_MMC
+
+#define CONFIG_MMC			1
+#define CONFIG_ATMEL_MCI		1
diff -Naur u-boot-2009.01/include/configs/icnova/nand.h u-boot/include/configs/icnova/nand.h
--- u-boot-2009.01/include/configs/icnova/nand.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova/nand.h	2009-03-11 10:49:59.000000000 +0100
@@ -0,0 +1,40 @@
+#ifndef NULL
+#define NULL ((void *) 0)
+#endif
+
+#define CONFIG_CMD_NAND
+#define CONFIG_MTD_NAND_ECC_JFFS2
+#define CONFIG_JFFS2_CMDLINE
+#define CONFIG_JFFS2_NAND
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_MAX_CHIPS	1
+#define NAND_MAX_FLOORS			1
+#define NAND_ChipID_UNKNOWN		0x00
+#define SECTORSIZE			2048
+#define ADDR_COLUMN			1
+#define ADDR_PAGE			2
+#define ADDR_COLUMN_PAGE		3
+#define CONFIG_SYS_NAND_BASE		0x0C000000
+#define NAND_PAGE_SIZE			2048
+
+#ifndef __ASSEMBLY__
+#include <asm/arch/gpio.h>
+
+#define CFG_NAND_ALE	21
+#define CFG_NAND_CLE	22
+
+#define CFG_NAND_CE	GPIO_PIN_PE19
+#define CFG_NAND_RDY	GPIO_PIN_PE23
+
+#endif
+
+#define MTDIDS_DEFAULT		"nand0=nand.0"
+#define MTDPARTS_DEFAULT	"mtdparts=nand.0:2M(kernel),16M(root),-(Data)"
+
+
+#undef CONFIG_BOOTARGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_BOOTARGS		"root=1F01 rootfstype=jffs2"
+#define CONFIG_BOOTCOMMAND	\
+	"mtdparts default; nand read 0x10400000 nand0,0; bootm"
diff -Naur u-boot-2009.01/include/configs/icnova/net.h u-boot/include/configs/icnova/net.h
--- u-boot-2009.01/include/configs/icnova/net.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova/net.h	2009-02-27 12:13:35.000000000 +0100
@@ -0,0 +1,19 @@
+
+/*
+ * After booting the board for the first time, new ethernet addresses
+ * should be generated and assigned to the environment variables
+ * "ethaddr" and "eth1addr". This is normally done during production.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE	1
+#define CONFIG_NET_MULTI		1
+#define CONFIG_MACB			1
+#define AT32AP700x_CHIP_HAS_MACB	1
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/icnova/usart0.h u-boot/include/configs/icnova/usart0.h
--- u-boot-2009.01/include/configs/icnova/usart0.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova/usart0.h	2009-02-27 10:27:56.000000000 +0100
@@ -0,0 +1,9 @@
+
+#define CONFIG_ATMEL_USART		y
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE { 115200, 38400, 19200, 9600, 2400 }
+
+#define CONFIG_USART0
+#undef CONFIG_USART1
+#undef CONFIG_USART2
+#undef CONFIG_USART3
diff -Naur u-boot-2009.01/include/configs/icnova/usart1.h u-boot/include/configs/icnova/usart1.h
--- u-boot-2009.01/include/configs/icnova/usart1.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova/usart1.h	2009-02-27 10:28:02.000000000 +0100
@@ -0,0 +1,9 @@
+
+#define CONFIG_ATMEL_USART		y
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE { 115200, 38400, 19200, 9600, 2400 }
+
+#undef CONFIG_USART0
+#define CONFIG_USART1
+#undef CONFIG_USART2
+#undef CONFIG_USART3
diff -Naur u-boot-2009.01/include/configs/icnova/usart2.h u-boot/include/configs/icnova/usart2.h
--- u-boot-2009.01/include/configs/icnova/usart2.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova/usart2.h	2009-02-27 10:28:07.000000000 +0100
@@ -0,0 +1,9 @@
+
+#define CONFIG_ATMEL_USART		y
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE { 115200, 38400, 19200, 9600, 2400 }
+
+#undef CONFIG_USART0
+#undef CONFIG_USART1
+#define CONFIG_USART2
+#undef CONFIG_USART3
diff -Naur u-boot-2009.01/include/configs/icnova/usart3.h u-boot/include/configs/icnova/usart3.h
--- u-boot-2009.01/include/configs/icnova/usart3.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova/usart3.h	2009-02-27 10:28:11.000000000 +0100
@@ -0,0 +1,9 @@
+
+#define CONFIG_ATMEL_USART		y
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE { 115200, 38400, 19200, 9600, 2400 }
+
+#undef CONFIG_USART0
+#undef CONFIG_USART1
+#undef CONFIG_USART2
+#define CONFIG_USART3
diff -Naur u-boot-2009.01/include/configs/icnova_base.h u-boot/include/configs/icnova_base.h
--- u-boot-2009.01/include/configs/icnova_base.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova_base.h	2009-02-26 16:05:00.000000000 +0100
@@ -0,0 +1,10 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/icnova/base.h>
+#include <configs/icnova/cpu140MHz.h>
+#include <configs/icnova/flash.h>
+#include <configs/icnova/net.h>
+#include <configs/icnova/usart1.h>
+
+#endif
diff -Naur u-boot-2009.01/include/configs/icnova_oem.h u-boot/include/configs/icnova_oem.h
--- u-boot-2009.01/include/configs/icnova_oem.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova_oem.h	2009-02-26 16:05:00.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/icnova/base.h>
+#include <configs/icnova/cpu140MHz.h>
+#include <configs/icnova/mmc.h>
+#include <configs/icnova/flash.h>
+#include <configs/icnova/net.h>
+#include <configs/icnova/usart0.h>
+
+#endif
diff -Naur u-boot-2009.01/include/configs/icnova_oemplus.h u-boot/include/configs/icnova_oemplus.h
--- u-boot-2009.01/include/configs/icnova_oemplus.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova_oemplus.h	2009-03-06 10:18:05.000000000 +0100
@@ -0,0 +1,12 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/icnova/base.h>
+#include <configs/icnova/cpu140MHz.h>
+#include <configs/icnova/mmc.h>
+#include <configs/icnova/flash2x8.h>
+#include <configs/icnova/nand.h>
+#include <configs/icnova/net.h>
+#include <configs/icnova/usart0.h>
+
+#endif
diff -Naur u-boot-2009.01/include/configs/icnova_old.h u-boot/include/configs/icnova_old.h
--- u-boot-2009.01/include/configs/icnova_old.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/icnova_old.h	2009-02-26 16:05:00.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/icnova/base.h>
+#include <configs/icnova/cpu140MHz.h>
+#include <configs/icnova/flash.h>
+#include <configs/icnova/mmc.h>
+#include <configs/icnova/net.h>
+#include <configs/icnova/usart0.h>
+
+#endif
diff -Naur u-boot-2009.01/include/configs/IDS8247.h u-boot/include/configs/IDS8247.h
--- u-boot-2009.01/include/configs/IDS8247.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/IDS8247.h	2009-02-26 14:03:59.000000000 +0100
@@ -275,7 +275,6 @@
 
 #define NAND_ChipID_UNKNOWN     0x00
 #define NAND_MAX_FLOORS 1
-#define NAND_MAX_CHIPS 1
 
 #define NAND_DISABLE_CE(nand) do \
 { \
diff -Naur u-boot-2009.01/include/configs/inka4x0.h u-boot/include/configs/inka4x0.h
--- u-boot-2009.01/include/configs/inka4x0.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/inka4x0.h	2009-02-26 14:03:59.000000000 +0100
@@ -221,10 +221,11 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 /*
- * Define CONFIG_FEC_10MBIT to force FEC at 10Mb
+ * Define CONFIG_MPC5xxx_FEC_MII10 to force FEC at 10Mb
  */
-/* #define CONFIG_FEC_10MBIT 1 */
+/* #define CONFIG_MPC5xxx_FEC_MII10 */
 #define CONFIG_PHY_ADDR		0x00
 #define CONFIG_MII
 
diff -Naur u-boot-2009.01/include/configs/innokom.h u-boot/include/configs/innokom.h
--- u-boot-2009.01/include/configs/innokom.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/innokom.h	2009-02-26 14:03:59.000000000 +0100
@@ -73,7 +73,7 @@
 #define CONFIG_CMD_CACHE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ECHO
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_I2C
 #define CONFIG_CMD_IMI
@@ -119,7 +119,7 @@
 
 #define CONFIG_SYS_LOAD_ADDR           0xa3000000      /* load kernel to this address   */
 
-#define CONFIG_SYS_HZ                  3686400         /* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 						/* RS: the oscillator is actually 3680130?? */
 
 #define CONFIG_SYS_CPUSPEED            0x141           /* set core clock to 200/200/100 MHz */
diff -Naur u-boot-2009.01/include/configs/integratorcp.h u-boot/include/configs/integratorcp.h
--- u-boot-2009.01/include/configs/integratorcp.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/integratorcp.h	2009-02-26 14:03:59.000000000 +0100
@@ -85,7 +85,7 @@
  */
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_DHCP
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_MEMORY
diff -Naur u-boot-2009.01/include/configs/ixdp425.h u-boot/include/configs/ixdp425.h
--- u-boot-2009.01/include/configs/ixdp425.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ixdp425.h	2009-02-26 14:03:59.000000000 +0100
@@ -73,6 +73,7 @@
 
 
 #define CONFIG_PCI
+#define CONFIG_IXP_PCI
 #define CONFIG_NET_MULTI
 #define CONFIG_EEPRO100
 
@@ -134,6 +135,7 @@
 /*
  * select serial console configuration
  */
+#define CONFIG_IXP_SERIAL
 #define CONFIG_SYS_IXP425_CONSOLE	IXP425_UART1   /* we use UART1 for console */
 
 /*
diff -Naur u-boot-2009.01/include/configs/ixdpg425.h u-boot/include/configs/ixdpg425.h
--- u-boot-2009.01/include/configs/ixdpg425.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ixdpg425.h	2009-02-26 14:03:59.000000000 +0100
@@ -72,6 +72,7 @@
 /* allow to overwrite serial and ethaddr */
 #define CONFIG_ENV_OVERWRITE
 
+#define CONFIG_IXP_SERIAL
 #define CONFIG_BAUDRATE         115200
 #define CONFIG_SYS_IXP425_CONSOLE	IXP425_UART1   /* we use UART1 for console */
 
diff -Naur u-boot-2009.01/include/configs/jupiter.h u-boot/include/configs/jupiter.h
--- u-boot-2009.01/include/configs/jupiter.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/jupiter.h	2009-02-26 14:03:59.000000000 +0100
@@ -239,10 +239,11 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 /*
- * Define CONFIG_FEC_10MBIT to force FEC at 10Mb
+ * Define CONFIG_MPC5xxx_FEC_MII10 to force FEC at 10Mb
  */
-/* #define CONFIG_FEC_10MBIT 1 */
+/* #define CONFIG_MPC5xxx_FEC_MII10 */
 #define CONFIG_PHY_ADDR		0x00
 
 /*
diff -Naur u-boot-2009.01/include/configs/katmai.h u-boot/include/configs/katmai.h
--- u-boot-2009.01/include/configs/katmai.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/katmai.h	2009-02-26 14:03:59.000000000 +0100
@@ -45,7 +45,6 @@
  */
 #define CONFIG_PHYS_64BIT
 #define	CONFIG_VERY_BIG_RAM
-#define CONFIG_MAX_MEM_MAPPED	((phys_size_t)2 << 30)
 
 /*
  * Include common defines/options for all AMCC eval boards
diff -Naur u-boot-2009.01/include/configs/keymile-common.h u-boot/include/configs/keymile-common.h
--- u-boot-2009.01/include/configs/keymile-common.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/keymile-common.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,113 @@
+/*
+ * (C) Copyright 2008
+ * Heiko Schocher, DENX Software Engineering, hs@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_KEYMILE_H
+#define __CONFIG_KEYMILE_H
+
+/* Do boardspecific init for all boards */
+#define CONFIG_BOARD_EARLY_INIT_R       1
+
+#if defined(CONFIG_MGCOGE) || defined(CONFIG_MGSUVD)
+#define CONFIG_BOOTCOUNT_LIMIT
+#endif
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ECHO
+#define CONFIG_CMD_IMMAP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+
+/* should go away, if kmeter I2C support is enabled */
+#if defined(CONFIG_MGCOGE) || defined(CONFIG_MGSUVD)
+#define CONFIG_CMD_DTT
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_I2C
+#endif
+
+#undef	CONFIG_WATCHDOG			/* disable platform specific watchdog */
+
+#define CONFIG_BOOTCOMMAND	"run net_nfs"
+#define CONFIG_BOOTDELAY	5	/* autoboot after 5 seconds */
+#undef	CONFIG_BOOTARGS			/* the boot command will set bootargs */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	    */
+#define CONFIG_SYS_PROMPT		"=> "	/* Monitor Command Prompt   */
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_SYS_CBSIZE		1024	/* Console I/O Buffer Size  */
+#else
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size  */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)	/* Print Buffer Size  */
+#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size  */
+#define CONFIG_CMDLINE_EDITING		1	/* add command line history     */
+
+/* should go away, if kmeter I2C support is enabled */
+#if defined(CONFIG_MGCOGE) || defined(CONFIG_MGSUVD)
+#define CONFIG_HUSH_INIT_VAR	1
+#endif
+
+#define CONFIG_SYS_ALT_MEMTEST		/* memory test, takes time */
+#define CONFIG_SYS_MEMTEST_START	0x00100000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x00f00000	/* 1 ... 15 MB in DRAM	*/
+
+#define CONFIG_SYS_LOAD_ADDR		0x100000	/* default load address */
+
+#define CONFIG_SYS_HZ			1000	/* decrementer freq: 1 ms ticks */
+
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200, 230400 }
+
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+/*
+ * How to get access to the slot ID.  Put this here to make it easy
+ * to modify in a centralized location.  This is used in the HDLC
+ * driver to set the MAC.
+*/
+#define CONFIG_CHECK_ETHERNET_PRESENT	1
+#define CONFIG_SYS_SLOT_ID_BASE		CONFIG_SYS_PIGGY_BASE
+#define CONFIG_SYS_SLOT_ID_OFF		(0x07)	/* register offset */
+#define CONFIG_SYS_SLOT_ID_MASK		(0x3f)	/* mask for slot ID bits */
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+#endif /* __CONFIG_KEYMILE_H */
diff -Naur u-boot-2009.01/include/configs/kilauea.h u-boot/include/configs/kilauea.h
--- u-boot-2009.01/include/configs/kilauea.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/kilauea.h	2009-02-26 14:03:59.000000000 +0100
@@ -214,7 +214,6 @@
  * NAND FLASH
  *----------------------------------------------------------------------*/
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_SYS_NAND_BASE		(CONFIG_SYS_NAND_ADDR + CONFIG_SYS_NAND_CS)
 #define CONFIG_SYS_NAND_SELECT_DEVICE  1	/* nand driver supports mutipl. chips	*/
 
@@ -235,16 +234,9 @@
  *
  * DDR Autocalibration Method_B is the default.
  */
-#if 0
-/*
- * Needs FIX!!!
- * Disable autocalibration for now, because of the unresolved problem
- * with kilauea board using 200MHz PLB/DDR2 frequency
- */
 #define	CONFIG_PPC4xx_DDR_AUTOCALIBRATION	/* IBM DDR autocalibration */
 #define	DEBUG_PPC4xx_DDR_AUTOCALIBRATION	/* dynamic DDR autocal debug */
 #undef	CONFIG_PPC4xx_DDR_METHOD_A
-#endif
 
 #define	CONFIG_SYS_SDRAM0_MB0CF_BASE	((  0 << 20) + CONFIG_SYS_SDRAM_BASE)
 
diff -Naur u-boot-2009.01/include/configs/kmeter1.h u-boot/include/configs/kmeter1.h
--- u-boot-2009.01/include/configs/kmeter1.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/kmeter1.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,457 @@
+/*
+ * Copyright (C) 2006 Freescale Semiconductor, Inc.
+ *                    Dave Liu <daveliu@freescale.com>
+ *
+ * Copyright (C) 2007 Logic Product Development, Inc.
+ *                    Peter Barada <peterb@logicpd.com>
+ *
+ * Copyright (C) 2007 MontaVista Software, Inc.
+ *                    Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * (C) Copyright 2008
+ * Heiko Schocher, DENX Software Engineering, hs@denx.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_E300		1 /* E300 family */
+#define CONFIG_QE		1 /* Has QE */
+#define CONFIG_MPC83XX		1 /* MPC83XX family */
+#define CONFIG_MPC8360		1 /* MPC8360 CPU specific */
+#define CONFIG_KMETER1		1 /* KMETER1 board specific */
+
+/* include common defines/options for all Keymile boards */
+#include "keymile-common.h"
+
+/*
+ * System Clock Setup
+ */
+#define CONFIG_83XX_CLKIN		66000000
+#define CONFIG_SYS_CLK_FREQ		66000000
+#define CONFIG_83XX_PCICLK		66000000
+
+/*
+ * Hardware Reset Configuration Word
+ */
+#define CONFIG_SYS_HRCW_LOW (\
+	HRCWL_CSB_TO_CLKIN_4X1 | \
+	HRCWL_CORE_TO_CSB_2X1 | \
+	HRCWL_CE_PLL_VCO_DIV_2 | \
+	HRCWL_CE_TO_PLL_1X6 )
+
+#define CONFIG_SYS_HRCW_HIGH (\
+	HRCWH_CORE_ENABLE | \
+	HRCWH_FROM_0X00000100 | \
+	HRCWH_BOOTSEQ_NORMAL | \
+	HRCWH_SW_WATCHDOG_DISABLE | \
+	HRCWH_ROM_LOC_LOCAL_16BIT | \
+	HRCWH_BIG_ENDIAN | \
+	HRCWH_LDP_CLEAR )
+
+/*
+ * System IO Config
+ */
+#define CONFIG_SYS_SICRH		0x00000006
+#define CONFIG_SYS_SICRL		0x00000000
+
+/*
+ * IMMR new address
+ */
+#define CONFIG_SYS_IMMR		0xE0000000
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_SYS_DDR_BASE		0x00000000 /* DDR is system memory */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_BASE
+#define CONFIG_SYS_DDR_SDRAM_BASE	CONFIG_SYS_DDR_BASE
+#define CONFIG_SYS_DDR_SDRAM_CLK_CNTL	(DDR_SDRAM_CLK_CNTL_SS_EN | \
+					DDR_SDRAM_CLK_CNTL_CLK_ADJUST_05)
+
+#define CFG_83XX_DDR_USES_CS0
+
+#undef CONFIG_DDR_ECC
+
+/*
+ * DDRCDR - DDR Control Driver Register
+ */
+
+#undef CONFIG_SPD_EEPROM	/* Do not use SPD EEPROM for DDR setup */
+
+/*
+ * Manually set up DDR parameters
+ */
+#define CONFIG_DDR_II
+#define CONFIG_SYS_DDR_SIZE		256 /* MB */
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000000f
+#define CONFIG_SYS_DDR_CS0_CONFIG	(CSCONFIG_EN | CSCONFIG_AP | \
+					 CSCONFIG_ROW_BIT_13 | \
+					 CSCONFIG_COL_BIT_10 | CSCONFIG_ODT_WR_ACS)
+
+#define CONFIG_SYS_DDR_SDRAM_CFG	(SDRAM_CFG_SDRAM_TYPE_DDR2 | \
+					 SDRAM_CFG_SREN)
+#define CONFIG_SYS_DDR_SDRAM_CFG2	0x00401000
+#define CONFIG_SYS_DDR_CLK_CNTL	(DDR_SDRAM_CLK_CNTL_CLK_ADJUST_05)
+#define CONFIG_SYS_DDR_INTERVAL	((0x100 << SDRAM_INTERVAL_BSTOPRE_SHIFT) | \
+				 (0x406 << SDRAM_INTERVAL_REFINT_SHIFT))
+
+#define CONFIG_SYS_DDR_MODE		0x04440242
+#define CONFIG_SYS_DDR_MODE2		0x00800000
+
+#define CONFIG_SYS_DDR_TIMING_0	((2 << TIMING_CFG0_MRS_CYC_SHIFT) | \
+				 (8 << TIMING_CFG0_ODT_PD_EXIT_SHIFT) | \
+				 (6 << TIMING_CFG0_PRE_PD_EXIT_SHIFT) | \
+				 (2 << TIMING_CFG0_ACT_PD_EXIT_SHIFT) | \
+				 (0 << TIMING_CFG0_WWT_SHIFT) | \
+				 (0 << TIMING_CFG0_RRT_SHIFT) | \
+				 (0 << TIMING_CFG0_WRT_SHIFT) | \
+				 (0 << TIMING_CFG0_RWT_SHIFT))
+
+#define CONFIG_SYS_DDR_TIMING_1	((      TIMING_CFG1_CASLAT_40) | \
+				 ( 2 << TIMING_CFG1_WRTORD_SHIFT) | \
+				 ( 1 << TIMING_CFG1_ACTTOACT_SHIFT) | \
+				 ( 2 << TIMING_CFG1_WRREC_SHIFT) | \
+				 ( 2 << TIMING_CFG1_REFREC_SHIFT) | \
+				 ( 2 << TIMING_CFG1_ACTTORW_SHIFT) | \
+				 ( 6 << TIMING_CFG1_ACTTOPRE_SHIFT) | \
+				 ( 2 << TIMING_CFG1_PRETOACT_SHIFT))
+
+#define CONFIG_SYS_DDR_TIMING_2	((5 << TIMING_CFG2_FOUR_ACT_SHIFT) | \
+				 (3 << TIMING_CFG2_CKE_PLS_SHIFT) | \
+				 (2 << TIMING_CFG2_WR_DATA_DELAY_SHIFT) | \
+				 (1 << TIMING_CFG2_RD_TO_PRE_SHIFT) | \
+				 (3 << TIMING_CFG2_WR_LAT_DELAY_SHIFT) | \
+				 (0 << TIMING_CFG2_ADD_LAT_SHIFT) | \
+				 (4 << TIMING_CFG2_CPO_SHIFT))
+
+#define CONFIG_SYS_DDR_TIMING_3	0x00000000
+
+/*
+ * The reserved memory
+ */
+#define CONFIG_SYS_MONITOR_BASE	TEXT_BASE /* start of monitor */
+#define CONFIG_SYS_FLASH_BASE		0xF0000000
+#define CONFIG_SYS_FLASH_BASE_1		0xF2000000
+#define CONFIG_SYS_PIGGY_BASE		0x80000000
+#define CONFIG_SYS_PAXE_BASE		0xA0000000
+#define	CONFIG_SYS_PAXE_SIZE		256
+
+#if (CONFIG_SYS_MONITOR_BASE < CONFIG_SYS_FLASH_BASE)
+#define CONFIG_SYS_RAMBOOT
+#else
+#undef	CONFIG_SYS_RAMBOOT
+#endif
+
+#define CONFIG_SYS_MONITOR_LEN		(256 * 1024) /* Reserve 256 kB for Mon */
+#define CONFIG_SYS_MALLOC_LEN		(128 * 1024) /* Reserved for malloc */
+
+/*
+ * Initial RAM Base Address Setup
+ */
+#define CONFIG_SYS_INIT_RAM_LOCK	1
+#define CONFIG_SYS_INIT_RAM_ADDR	0xE6000000 /* Initial RAM address */
+#define CONFIG_SYS_INIT_RAM_END	0x1000 /* End of used area in RAM */
+#define CONFIG_SYS_GBL_DATA_SIZE	0x100 /* num bytes initial data */
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_END - CONFIG_SYS_GBL_DATA_SIZE)
+
+/*
+ * Local Bus Configuration & Clock Setup
+ */
+#define CONFIG_SYS_LCRR		(LCRR_DBYP | LCRR_EADC_2 | LCRR_CLKDIV_4)
+
+/*
+ * Init Local Bus Memory Controller:
+ *
+ * Bank Bus     Machine PortSz  Size  Device
+ * ---- ---     ------- ------  -----  ------
+ *  0   Local   GPCM    16 bit  256MB FLASH
+ *  1   Local   GPCM     8 bit  256KB GPIO/PIGGY
+ *  3   Local   GPCM     8 bit  256MB PAXE
+ *
+ */
+/*
+ * FLASH on the Local Bus
+ */
+#define CONFIG_SYS_FLASH_CFI		/* use the Common Flash Interface */
+#define CONFIG_FLASH_CFI_DRIVER		/* use the CFI driver */
+#define CONFIG_SYS_FLASH_SIZE		256 /* max FLASH size is 256M */
+#define CONFIG_SYS_FLASH_PROTECTION	1
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE	1
+
+#define CONFIG_SYS_LBLAWBAR0_PRELIM	CONFIG_SYS_FLASH_BASE /* Window base at flash base */
+#define CONFIG_SYS_LBLAWAR0_PRELIM	0x8000001b /* 256MB window size */
+
+#define CONFIG_SYS_BR0_PRELIM	(CONFIG_SYS_FLASH_BASE | \
+				(2 << BR_PS_SHIFT) | /* 16 bit port size */ \
+				BR_V)
+
+#define CONFIG_SYS_OR0_PRELIM	(MEG_TO_AM(CONFIG_SYS_FLASH_SIZE) | \
+				OR_GPCM_CSNT | OR_GPCM_ACS_DIV2 | \
+				OR_GPCM_SCY_5 | \
+				OR_GPCM_TRLX | OR_GPCM_EAD)
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* max num of flash banks	*/
+#define CONFIG_SYS_MAX_FLASH_SECT	512	/* max num of sects on one chip */
+#define CONFIG_SYS_FLASH_BANKS_LIST { CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_1 }
+
+#undef	CONFIG_SYS_FLASH_CHECKSUM
+
+/*
+ * PRIO1/PIGGY on the local bus CS1
+ */
+#define CONFIG_SYS_LBLAWBAR1_PRELIM	CONFIG_SYS_PIGGY_BASE /* Window base at flash base */
+#define CONFIG_SYS_LBLAWAR1_PRELIM	0x80000011 /* 256KB window size */
+
+#define CONFIG_SYS_BR1_PRELIM	(CONFIG_SYS_PIGGY_BASE | \
+				(1 << BR_PS_SHIFT) | /* 8 bit port size */ \
+				BR_V)
+#define CONFIG_SYS_OR1_PRELIM		(0xfffc0000 | /* 256KB */ \
+				OR_GPCM_CSNT | OR_GPCM_ACS_DIV2 | \
+				OR_GPCM_SCY_2 | \
+				OR_GPCM_TRLX | OR_GPCM_EAD)
+
+/*
+ * PAXE on the local bus CS3
+ */
+#define CONFIG_SYS_LBLAWBAR3_PRELIM	CONFIG_SYS_PAXE_BASE /* Window base at flash base */
+#define CONFIG_SYS_LBLAWAR3_PRELIM	0x8000001b /* 256MB window size */
+
+#define CONFIG_SYS_BR3_PRELIM	(CONFIG_SYS_PAXE_BASE | \
+				(1 << BR_PS_SHIFT) | /* 8 bit port size */ \
+				BR_V)
+#define CONFIG_SYS_OR3_PRELIM	(MEG_TO_AM(CONFIG_SYS_PAXE_SIZE) | \
+				OR_GPCM_CSNT | OR_GPCM_ACS_DIV2 | \
+				OR_GPCM_SCY_2 | \
+				OR_GPCM_TRLX | OR_GPCM_EAD)
+
+/*
+ * Serial Port
+ */
+#define CONFIG_CONS_INDEX	1
+#undef	CONFIG_SERIAL_SOFTWARE_FIFO
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_IMMR+0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_IMMR+0x4600)
+
+/* Pass open firmware flat tree */
+#define CONFIG_OF_LIBFDT	1
+#define CONFIG_OF_BOARD_SETUP	1
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/*
+ * General PCI
+ * Addresses are mapped 1-1.
+ */
+#undef CONFIG_PCI		/* No PCI */
+
+#ifndef CONFIG_NET_MULTI
+#define CONFIG_NET_MULTI	1
+#endif
+/*
+ * QE UEC ethernet configuration
+ */
+#define CONFIG_UEC_ETH
+#define CONFIG_ETHPRIME		"FSL UEC0"
+
+#define CONFIG_UEC_ETH1		/* GETH1 */
+#define UEC_VERBOSE_DEBUG	1
+
+#ifdef CONFIG_UEC_ETH1
+#define CONFIG_SYS_UEC1_UCC_NUM	3	/* UCC4 */
+#define CONFIG_SYS_UEC1_RX_CLK		QE_CLK_NONE	/* not used in RMII Mode */
+#define CONFIG_SYS_UEC1_TX_CLK		QE_CLK17
+#define CONFIG_SYS_UEC1_ETH_TYPE	FAST_ETH
+#define CONFIG_SYS_UEC1_PHY_ADDR	0
+#define CONFIG_SYS_UEC1_INTERFACE_MODE ENET_100_RMII
+#endif
+
+/*
+ * Environment
+ */
+
+#ifndef CONFIG_SYS_RAMBOOT
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)
+#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K(one sector) for env */
+#define CONFIG_ENV_SIZE		0x20000
+#define CONFIG_ENV_OFFSET	(CONFIG_SYS_MONITOR_LEN)
+
+/* Address and size of Redundant Environment Sector	*/
+#define CONFIG_ENV_OFFSET_REDUND	(CONFIG_ENV_OFFSET+CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE_REDUND	(CONFIG_ENV_SIZE)
+
+#else /* CFG_RAMBOOT */
+#define CONFIG_SYS_NO_FLASH		1	/* Flash is not usable now */
+#define CONFIG_ENV_IS_NOWHERE	1	/* Store ENV in memory only */
+#define CONFIG_ENV_ADDR		(CFG_MONITOR_BASE - 0x1000)
+#define CONFIG_ENV_SIZE		0x2000
+#endif /* CFG_RAMBOOT */
+
+#if defined(CONFIG_PCI)
+#define CONFIG_CMD_PCI
+#endif
+
+#if defined(CFG_RAMBOOT)
+#undef CONFIG_CMD_SAVEENV
+#undef CONFIG_CMD_LOADS
+#endif
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ		(8 << 20) /* Initial Memory map for Linux */
+
+/*
+ * Core HID Setup
+ */
+#define CONFIG_SYS_HID0_INIT		0x000000000
+#define CONFIG_SYS_HID0_FINAL		HID0_ENABLE_MACHINE_CHECK
+#define CONFIG_SYS_HID2			HID2_HBE
+
+/*
+ * MMU Setup
+ */
+
+#define CONFIG_HIGH_BATS	1	/* High BATs supported */
+
+/* DDR: cache cacheable */
+#define CONFIG_SYS_IBAT0L	(CONFIG_SYS_SDRAM_BASE | BATL_PP_10 | \
+				BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CONFIG_SYS_IBAT0U	(CONFIG_SYS_SDRAM_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+#define CONFIG_SYS_DBAT0L	CONFIG_SYS_IBAT0L
+#define CONFIG_SYS_DBAT0U	CONFIG_SYS_IBAT0U
+
+/* IMMRBAR & PCI IO: cache-inhibit and guarded */
+#define CONFIG_SYS_IBAT1L	(CONFIG_SYS_IMMR | BATL_PP_10 | \
+				BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CONFIG_SYS_IBAT1U	(CONFIG_SYS_IMMR | BATU_BL_4M | BATU_VS | BATU_VP)
+#define CONFIG_SYS_DBAT1L	CONFIG_SYS_IBAT1L
+#define CONFIG_SYS_DBAT1U	CONFIG_SYS_IBAT1U
+
+/* PRIO1, PIGGY:  icache cacheable, but dcache-inhibit and guarded */
+#define CONFIG_SYS_IBAT2L	(CONFIG_SYS_PIGGY_BASE | BATL_PP_10 | BATL_MEMCOHERENCE)
+#define CONFIG_SYS_IBAT2U	(CONFIG_SYS_PIGGY_BASE | BATU_BL_256K | BATU_VS | BATU_VP)
+#define CONFIG_SYS_DBAT2L	(CONFIG_SYS_PIGGY_BASE | BATL_PP_10 | \
+				 BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CONFIG_SYS_DBAT2U	CONFIG_SYS_IBAT2U
+
+/* FLASH: icache cacheable, but dcache-inhibit and guarded */
+#define CONFIG_SYS_IBAT3L	(CONFIG_SYS_FLASH_BASE | BATL_PP_10 | BATL_MEMCOHERENCE)
+#define CONFIG_SYS_IBAT3U	(CONFIG_SYS_FLASH_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+#define CONFIG_SYS_DBAT3L	(CONFIG_SYS_FLASH_BASE | BATL_PP_10 | \
+				 BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CONFIG_SYS_DBAT3U	CONFIG_SYS_IBAT3U
+
+/* Stack in dcache: cacheable, no memory coherence */
+#define CONFIG_SYS_IBAT4L	(CONFIG_SYS_INIT_RAM_ADDR | BATL_PP_10)
+#define CONFIG_SYS_IBAT4U	(CONFIG_SYS_INIT_RAM_ADDR | BATU_BL_128K | BATU_VS | BATU_VP)
+#define CONFIG_SYS_DBAT4L	CONFIG_SYS_IBAT4L
+#define CONFIG_SYS_DBAT4U	CONFIG_SYS_IBAT4U
+
+/* PAXE:  icache cacheable, but dcache-inhibit and guarded */
+#define CONFIG_SYS_IBAT5L	(CONFIG_SYS_PAXE_BASE | BATL_PP_10 | BATL_MEMCOHERENCE)
+#define CONFIG_SYS_IBAT5U	(CONFIG_SYS_PAXE_BASE | BATU_BL_256K | BATU_VS | BATU_VP)
+#define CONFIG_SYS_DBAT5L	(CONFIG_SYS_PAXE_BASE | BATL_PP_10 | \
+				 BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CONFIG_SYS_DBAT5U	CONFIG_SYS_IBAT5U
+
+#ifdef CONFIG_PCI
+/* PCI MEM space: cacheable */
+#define CFG_IBAT6L	(CFG_PCI1_MEM_PHYS | BATL_PP_10 | BATL_MEMCOHERENCE)
+#define CFG_IBAT6U	(CFG_PCI1_MEM_PHYS | BATU_BL_256M | BATU_VS | BATU_VP)
+#define CFG_DBAT6L	CFG_IBAT6L
+#define CFG_DBAT6U	CFG_IBAT6U
+/* PCI MMIO space: cache-inhibit and guarded */
+#define CFG_IBAT7L	(CFG_PCI1_MMIO_PHYS | BATL_PP_10 | \
+			 BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CFG_IBAT7U	(CFG_PCI1_MMIO_PHYS | BATU_BL_256M | BATU_VS | BATU_VP)
+#define CFG_DBAT7L	CFG_IBAT7L
+#define CFG_DBAT7U	CFG_IBAT7U
+#else /* CONFIG_PCI */
+#define CONFIG_SYS_IBAT6L	(0)
+#define CONFIG_SYS_IBAT6U	(0)
+#define CONFIG_SYS_IBAT7L	(0)
+#define CONFIG_SYS_IBAT7U	(0)
+#define CONFIG_SYS_DBAT6L	CONFIG_SYS_IBAT6L
+#define CONFIG_SYS_DBAT6U	CONFIG_SYS_IBAT6U
+#define CONFIG_SYS_DBAT7L	CONFIG_SYS_IBAT7L
+#define CONFIG_SYS_DBAT7U	CONFIG_SYS_IBAT7U
+#endif /* CONFIG_PCI */
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01 /* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02 /* Software reboot */
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ENV_OVERWRITE
+
+#if defined(CONFIG_UEC_ETH)
+#define CONFIG_HAS_ETH0
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"netdev=eth0\0"							\
+	"rootpath=/opt/eldk/ppc_82xx\0"					\
+	"nfsargs=setenv bootargs root=/dev/nfs rw "			\
+		"nfsroot=${serverip}:${rootpath}\0"			\
+	"ramargs=setenv bootargs root=/dev/ram rw\0"			\
+	"addip=setenv bootargs ${bootargs} "				\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"	\
+		":${hostname}:${netdev}:off panic=1\0"			\
+	"addtty=setenv bootargs ${bootargs}"				\
+		" console=ttyS0,${baudrate}\0"				\
+	"fdt_addr=f0080000\0"						\
+	"kernel_addr=f00a0000\0"					\
+	"ramdisk_addr=f03a0000\0"					\
+	"kernel_addr_r=400000\0"					\
+	"fdt_addr_r=800000\0"						\
+	"ramdisk_addr_r=810000\0"					\
+	"flash_self=run ramargs addip addtty;"				\
+		"bootm ${kernel_addr} ${ramdisk_addr} ${fdt_addr}\0"	\
+	"flash_nfs=run nfsargs addip addtty;"				\
+		"bootm ${kernel_addr} - ${fdt_addr}\0"			\
+	"net_nfs=tftp ${kernel_addr_r} ${boot_file}; "			\
+		"tftp ${fdt_addr_r} ${fdt_file}; "			\
+		"run nfsargs addip addtty;"				\
+		"bootm ${kernel_addr_r} - ${fdt_addr_r}\0"		\
+	"fdt_file=/tftpboot/kmeter1/kmeter1.dtb\0"			\
+	"boot_file=/tftpboot/kmeter1/uImage\0"				\
+	"ramdisk_file=/tftpboot/kmeter1/uRamdisk\0"			\
+	"u-boot=/tftpboot/kmeter1/u-boot.bin\0"				\
+	"loadaddr=" MK_STR(CONFIG_SYS_LOAD_ADDR) "\0"			\
+	"load=tftp $loadaddr ${u-boot}\0"				\
+	"update=protect off " MK_STR(TEXT_BASE) " +$filesize;"		\
+		"erase " MK_STR(TEXT_BASE) " +$filesize;"		\
+		"cp.b $loadaddr " MK_STR(TEXT_BASE) " $filesize;"	\
+		"protect on " MK_STR(TEXT_BASE) " +$filesize;"		\
+		"cmp.b $loadaddr " MK_STR(TEXT_BASE) " $filesize;"	\
+		"setenv filesize;saveenv\0"				\
+	"upd=run load update\0"						\
+	"loadram=tftp ${ramdisk_addr_r} ${ramdisk_file}\0"		\
+	"loadfdt=tftp ${fdt_addr_r} ${fdt_file}\0"			\
+	"loadkernel=tftp ${kernel_addr_r} ${boot_file}\0"		\
+	"unlock=yes\0"							\
+   ""
+
+#endif /* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/korat.h u-boot/include/configs/korat.h
--- u-boot-2009.01/include/configs/korat.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/korat.h	2009-02-26 14:03:59.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2007-2008
+ * (C) Copyright 2007-2009
  * Larry Johnson, lrj@acm.org
  *
  * (C) Copyright 2006-2007
@@ -138,15 +138,14 @@
 /*
  * DDR SDRAM
  */
-#define CONFIG_SYS_MBYTES_SDRAM        (512)	/* 512 MiB	TODO: remove	*/
 #define CONFIG_DDR_DATA_EYE		/* use DDR2 optimization	*/
 #define CONFIG_SPD_EEPROM		/* Use SPD EEPROM for setup	*/
 #define CONFIG_ZERO_SDRAM		/* Zero SDRAM after setup	*/
 #define CONFIG_DDR_ECC			/* Use ECC when available	*/
 #define SPD_EEPROM_ADDRESS	{0x50}
 #define CONFIG_PROG_SDRAM_TLB
-#define CONFIG_SYS_MEM_TOP_HIDE	(4 << 10) /* don't use last 4kbytes	*/
-					/* 440EPx errata CHIP 11	*/
+#define CONFIG_SYS_MEM_TOP_HIDE	(4 << 10) /* don't use last 4 KiB as	*/
+					/* per 440EPx Errata CHIP_11	*/
 
 /*
  * I2C
@@ -173,42 +172,59 @@
 #define CONFIG_SYS_DTT_MIN_TEMP	-30
 
 #define CONFIG_PREBOOT	"echo;"						\
-	"echo Type \\\"run flash_nfs\\\" to mount root filesystem over NFS;" \
+	"echo Type \\\"run flash_cf\\\" to mount from CompactFlash(R);" \
 	"echo"
 
 #undef	CONFIG_BOOTARGS
 
 /* Setup some board specific values for the default environment variables */
 #define CONFIG_HOSTNAME		korat
-#define CONFIG_SYS_BOOTFILE		"bootfile=/tftpboot/korat/uImage\0"
-#define CONFIG_SYS_ROOTPATH		"rootpath=/opt/eldk/ppc_4xxFP\0"
 
 /* Note: kernel_addr and ramdisk_addr assume that FLASH1 is 64 MiB. */
 #define CONFIG_EXTRA_ENV_SETTINGS					\
-	CONFIG_SYS_BOOTFILE							\
-	CONFIG_SYS_ROOTPATH							\
+	"u_boot=korat/u-boot.bin\0"					\
+	"load=tftp 200000 ${u_boot}\0"					\
+	"update=protect off F7F60000 F7FBFFFF;erase F7F60000 F7FBFFFF;"	\
+		"cp.b ${fileaddr} F7F60000 ${filesize};protect on "	\
+		"F7F60000 F7FBFFFF\0"					\
+	"upd=run load update\0"						\
+	"bootfile=korat/uImage\0"					\
+	"dtb=korat/korat.dtb\0"						\
+	"kernel_addr=F4000000\0"					\
+	"ramdisk_addr=F4400000\0"					\
+	"dtb_addr=F41E0000\0"						\
+	"udl=tftp 200000 ${bootfile}; erase F4000000 F41DFFFF; "	\
+		"cp.b ${fileaddr} F4000000 ${filesize}\0"		\
+	"udd=tftp 200000 ${dtb}; erase F41E0000 F41FFFFF; "		\
+		"cp.b ${fileaddr} F41E0000 ${filesize}\0"		\
+	"ll=setenv kernel_addr 200000; setenv dtb_addr 1000000; "	\
+		"tftp ${kernel_addr} ${uImage}; tftp ${dtb_addr} "	\
+		"${dtb}\0"						\
+	"rd_size=73728\0"						\
+	"ramargs=setenv bootargs root=/dev/ram rw "			\
+		"ramdisk_size=${rd_size}\0"				\
+	"usbdev=sda1\0"							\
+	"usbargs=setenv bootargs root=/dev/${usbdev} ro rootdelay=10\0"	\
+	"rootpath=/opt/eldk/ppc_4xxFP\0"				\
 	"netdev=eth0\0"							\
 	"nfsargs=setenv bootargs root=/dev/nfs rw "			\
 		"nfsroot=${serverip}:${rootpath}\0"			\
-	"ramargs=setenv bootargs root=/dev/ram rw\0"			\
+	"pciclk=33\0"							\
+	"addide=setenv bootargs ${bootargs} ide=reverse "		\
+		"idebus=${pciclk}\0"					\
 	"addip=setenv bootargs ${bootargs} "				\
 		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"	\
 		":${hostname}:${netdev}:off panic=1\0"			\
 	"addtty=setenv bootargs ${bootargs} console=ttyS0,${baudrate}\0"\
-	"flash_nfs=run nfsargs addip addtty;"				\
-		"bootm ${kernel_addr}\0"				\
-	"flash_self=run ramargs addip addtty;"				\
-		"bootm ${kernel_addr} ${ramdisk_addr}\0"		\
-	"net_nfs=tftp 200000 ${bootfile};run nfsargs addip addtty;"     \
-	        "bootm\0"						\
-	"kernel_addr=F4000000\0"					\
-	"ramdisk_addr=F4400000\0"					\
-	"load=tftp 200000 /tftpboot/${hostname}/u-boot.bin\0"		\
-	"update=protect off FFFA0000 FFFFFFFF;era FFFA0000 FFFFFFFF;"	\
-		"cp.b 200000 FFFA0000 60000\0"			        \
-	"upd=run load update\0"						\
+	"flash_cf=run usbargs addide addip addtty; "			\
+		"bootm ${kernel_addr} - ${dtb_addr}\0"			\
+	"flash_nfs=run nfsargs addide addip addtty; "			\
+		"bootm ${kernel_addr} - ${dtb_addr}\0"			\
+	"flash_self=run ramargs addip addtty; "				\
+		"bootm ${kernel_addr} ${ramdisk_addr} ${dtb_addr}\0"	\
 	""
-#define CONFIG_BOOTCOMMAND	"run flash_self"
+
+#define CONFIG_BOOTCOMMAND	"run flash_cf"
 
 #define CONFIG_BOOTDELAY	5	/* autoboot after 5 seconds	*/
 
@@ -278,15 +294,15 @@
 #define CONFIG_CMD_USB
 
 /* POST support */
-#define CONFIG_POST		(CONFIG_SYS_POST_CACHE	   | \
-				 CONFIG_SYS_POST_CPU	   | \
-				 CONFIG_SYS_POST_ECC	   | \
-				 CONFIG_SYS_POST_ETHER	   | \
-				 CONFIG_SYS_POST_FPU	   | \
-				 CONFIG_SYS_POST_I2C	   | \
-				 CONFIG_SYS_POST_MEMORY   | \
-				 CONFIG_SYS_POST_RTC	   | \
-				 CONFIG_SYS_POST_SPR	   | \
+#define CONFIG_POST		(CONFIG_SYS_POST_CACHE	| \
+				 CONFIG_SYS_POST_CPU	| \
+				 CONFIG_SYS_POST_ECC	| \
+				 CONFIG_SYS_POST_ETHER	| \
+				 CONFIG_SYS_POST_FPU	| \
+				 CONFIG_SYS_POST_I2C	| \
+				 CONFIG_SYS_POST_MEMORY	| \
+				 CONFIG_SYS_POST_RTC	| \
+				 CONFIG_SYS_POST_SPR	| \
 				 CONFIG_SYS_POST_UART)
 
 #define CONFIG_SYS_POST_WORD_ADDR	(CONFIG_SYS_GBL_DATA_OFFSET - 0x4)
@@ -403,7 +419,7 @@
  * GPIO10  Alt1   O    x   PerCS5 to expansion bus connector
  * GPIO11  Alt1   I    x   PerErr
  * GPIO12  GPIO   O    0   ATMega !Reset
- * GPIO13  GPIO   O    1   SPI Atmega !SS
+ * GPIO13  GPIO   x    x   Test Point 2 (TP2)
  * GPIO14  GPIO   O    1   Write protect EEPROM #1 (0xA8)
  * GPIO15  GPIO   O    0   CPU Run LED !On
  * GPIO16  Alt1   O    x   GMC1TxD0
@@ -478,7 +494,7 @@
 {GPIO0_BASE, GPIO_OUT, GPIO_ALT1, GPIO_OUT_0}, /* GPIO10 EBC_CS_N(5)			*/	\
 {GPIO0_BASE, GPIO_IN , GPIO_ALT1, GPIO_OUT_0}, /* GPIO11 EBC_BUS_ERR			*/	\
 {GPIO0_BASE, GPIO_OUT, GPIO_SEL , GPIO_OUT_0}, /* GPIO12				*/	\
-{GPIO0_BASE, GPIO_OUT, GPIO_SEL , GPIO_OUT_1}, /* GPIO13				*/	\
+{GPIO0_BASE, GPIO_DIS, GPIO_SEL , GPIO_OUT_0}, /* GPIO13				*/	\
 {GPIO0_BASE, GPIO_OUT, GPIO_SEL , GPIO_OUT_1}, /* GPIO14				*/	\
 {GPIO0_BASE, GPIO_OUT, GPIO_SEL , GPIO_OUT_0}, /* GPIO15				*/	\
 {GPIO0_BASE, GPIO_OUT, GPIO_ALT1, GPIO_OUT_1}, /* GPIO16 GMCTxD(4)			*/	\
diff -Naur u-boot-2009.01/include/configs/logodl.h u-boot/include/configs/logodl.h
--- u-boot-2009.01/include/configs/logodl.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/logodl.h	2009-02-26 14:03:59.000000000 +0100
@@ -69,7 +69,7 @@
  */
 #define CONFIG_CMD_ASKENV
 #define CONFIG_CMD_ECHO
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_MEMORY
 #define CONFIG_CMD_RUN
@@ -112,7 +112,7 @@
 
 #define CONFIG_SYS_LOAD_ADDR           0x08000000      /* load kernel to this address   */
 
-#define CONFIG_SYS_HZ                  3686400         /* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 						/* RS: the oscillator is actually 3680130?? */
 
 #define CONFIG_SYS_CPUSPEED            0x141           /* set core clock to 200/200/100 MHz */
diff -Naur u-boot-2009.01/include/configs/lubbock.h u-boot/include/configs/lubbock.h
--- u-boot-2009.01/include/configs/lubbock.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/lubbock.h	2009-02-26 14:03:59.000000000 +0100
@@ -40,7 +40,7 @@
 #ifdef CONFIG_LCD
 #define CONFIG_SHARP_LM8V31
 #endif
-#define CONFIG_MMC		1
+#define CONFIG_MMC
 #define BOARD_LATE_INIT		1
 #define CONFIG_DOS_PARTITION
 
@@ -83,7 +83,6 @@
  */
 #include <config_cmd_default.h>
 
-#define CONFIG_CMD_MMC
 #define CONFIG_CMD_FAT
 
 
@@ -127,13 +126,17 @@
 
 #define CONFIG_SYS_LOAD_ADDR	(CONFIG_SYS_DRAM_BASE + 0x8000) /* default load address */
 
-#define CONFIG_SYS_HZ			3686400		/* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 #define CONFIG_SYS_CPUSPEED		0x161		/* set core clock to 400/200/100 MHz */
 
 						/* valid baudrates */
 #define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
 
+#ifdef CONFIG_MMC
+#define CONFIG_PXA_MMC
+#define CONFIG_CMD_MMC
 #define CONFIG_SYS_MMC_BASE		0xF0000000
+#endif
 
 /*
  * Stack sizes
diff -Naur u-boot-2009.01/include/configs/m501sk.h u-boot/include/configs/m501sk.h
--- u-boot-2009.01/include/configs/m501sk.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/m501sk.h	2009-02-26 14:03:59.000000000 +0100
@@ -154,7 +154,7 @@
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_NFS
 #define CONFIG_CMD_FLASH
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 
 #define CONFIG_SYS_HUSH_PARSER
 #define CONFIG_AUTO_COMPLETE
diff -Naur u-boot-2009.01/include/configs/M5271EVB.h u-boot/include/configs/M5271EVB.h
--- u-boot-2009.01/include/configs/M5271EVB.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/M5271EVB.h	2009-02-26 14:03:59.000000000 +0100
@@ -82,7 +82,10 @@
 #define CONFIG_CMD_MISC
 
 #undef CONFIG_CMD_LOADS
-#undef CONFIG_CMD_LOADB
+#define CONFIG_CMD_LOADB
+#define CONFIG_CMDLINE_EDITING	1 /* enables command line history */
+#define CONFIG_SYS_HUSH_PARSER /* Use the HUSH parser */
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
 
 #define CONFIG_MCFFEC
 #ifdef CONFIG_MCFFEC
@@ -116,7 +119,7 @@
 #define CONFIG_SYS_I2C_OFFSET		0x00000300
 #define CONFIG_SYS_IMMR		CONFIG_SYS_MBAR
 
-#define CONFIG_BOOTDELAY	1	/* autoboot after 5 seconds */
+#define CONFIG_BOOTDELAY	1	/* autoboot after 1 seconds */
 #define CONFIG_BOOTFILE		"u-boot.bin"
 #ifdef CONFIG_MCFFEC
 #	define CONFIG_NET_RETRY_COUNT	5
@@ -128,16 +131,16 @@
 #	define CONFIG_OVERWRITE_ETHADDR_ONCE
 #endif				/* FEC_ENET */
 
-#define CONFIG_HOSTNAME		M5235EVB
+#define CONFIG_HOSTNAME		M5271EVB
 #define CONFIG_EXTRA_ENV_SETTINGS		\
 	"netdev=eth0\0"				\
 	"loadaddr=10000\0"			\
-	"u-boot=u-boot.bin\0"			\
-	"load=tftp ${loadaddr) ${u-boot}\0"	\
+	"uboot=u-boot.bin\0"		\
+	"load=tftp $loadaddr $uboot\0"	\
 	"upd=run load; run prog\0"		\
-	"prog=prot off ffe00000 ffe2ffff;"		\
-	"era ffe00000 ffe2ffff;"				\
-	"cp.b ${loadaddr} 0 ${filesize};"	\
+	"prog=prot off ffe00000 ffe3ffff;"	\
+	"era ffe00000 ffe3ffff;"		\
+	"cp.b $loadaddr ffe00000 $filesize;"	\
 	"save\0"				\
 	""
 
@@ -159,7 +162,17 @@
 #define CONFIG_SYS_MEMTEST_END		0x380000
 
 #define CONFIG_SYS_HZ			1000000
+
+/* Clock configuration
+ * The external oscillator is a 25.000 MHz
+ * CONFIG_SYS_CLK for ColdFire V2 sets cpu_clk (not bus_clk)
+ * bus_clk = (cpu_clk/2) (fixed ratio)
+ *
+ * If CONFIG_SYS_CLK is changed. the CONFIG_SYS_MCF_SYNCR must be updated to
+ * match the new clock speed. Max cpu_clk is 150 MHz.
+ */
 #define CONFIG_SYS_CLK			100000000
+#define CONFIG_SYS_MCF_SYNCR 	(MCF_SYNCR_MFD_4X | MCF_SYNCR_RFD_DIV1)
 
 /*
  * Low Level Configuration Settings
@@ -216,7 +229,14 @@
 /* Cache Configuration */
 #define CONFIG_SYS_CACHELINE_SIZE	16
 
-/* Port configuration */
-#define CONFIG_SYS_FECI2C		0xF0
+/* Chip Select 0  : Boot Flash */
+#define CONFIG_SYS_CS0_BASE	0xFFE00000
+#define CONFIG_SYS_CS0_MASK	0x001F0001
+#define CONFIG_SYS_CS0_CTRL	0x00001980
+
+/* Chip Select 1 : External SRAM */
+#define CONFIG_SYS_CS1_BASE	0x30000000
+#define CONFIG_SYS_CS1_MASK	0x00070001
+#define CONFIG_SYS_CS1_CTRL	0x00001900
 
 #endif				/* _M5271EVB_H */
diff -Naur u-boot-2009.01/include/configs/M5329EVB.h u-boot/include/configs/M5329EVB.h
--- u-boot-2009.01/include/configs/M5329EVB.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/M5329EVB.h	2009-02-26 14:03:59.000000000 +0100
@@ -215,7 +215,6 @@
 #	define CONFIG_SYS_NAND_BASE		CONFIG_SYS_CS2_BASE
 #	define CONFIG_SYS_NAND_SIZE		1
 #	define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#	define NAND_MAX_CHIPS		1
 #	define NAND_ALLOW_ERASE_ALL	1
 #	define CONFIG_JFFS2_NAND	1
 #	define CONFIG_JFFS2_DEV		"nand0"
diff -Naur u-boot-2009.01/include/configs/M5373EVB.h u-boot/include/configs/M5373EVB.h
--- u-boot-2009.01/include/configs/M5373EVB.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/M5373EVB.h	2009-02-26 14:03:59.000000000 +0100
@@ -215,7 +215,6 @@
 #	define CONFIG_SYS_NAND_BASE		CONFIG_SYS_CS2_BASE
 #	define CONFIG_SYS_NAND_SIZE		1
 #	define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#	define NAND_MAX_CHIPS		1
 #	define NAND_ALLOW_ERASE_ALL	1
 #	define CONFIG_JFFS2_NAND	1
 #	define CONFIG_JFFS2_DEV		"nand0"
diff -Naur u-boot-2009.01/include/configs/mcc200.h u-boot/include/configs/mcc200.h
--- u-boot-2009.01/include/configs/mcc200.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/mcc200.h	2009-02-26 14:03:59.000000000 +0100
@@ -271,11 +271,12 @@
 /*
  * Ethernet configuration
  */
-/*#define CONFIG_MPC5xxx_FEC	1*/
+/* #define CONFIG_MPC5xxx_FEC	1 */
+/* #define CONFIG_MPC5xxx_FEC_MII100 */
 /*
- * Define CONFIG_FEC_10MBIT to force FEC at 10Mb
+ * Define CONFIG_MPC5xxx_FEC_MII10 to force FEC at 10Mb
  */
-/* #define CONFIG_FEC_10MBIT 1 */
+/* #define CONFIG_MPC5xxx_FEC_MII10 */
 #define CONFIG_PHY_ADDR		1
 
 /*
diff -Naur u-boot-2009.01/include/configs/mecp5200.h u-boot/include/configs/mecp5200.h
--- u-boot-2009.01/include/configs/mecp5200.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/mecp5200.h	2009-02-26 14:03:59.000000000 +0100
@@ -243,10 +243,11 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 /*
- * Define CONFIG_FEC_10MBIT to force FEC at 10Mb
+ * Define CONFIG_MPC5xxx_FEC_MII10 to force FEC at 10Mb
  */
-/* #define CONFIG_FEC_10MBIT 1 */
+/* #define CONFIG_MPC5xxx_FEC_MII10 */
 #define CONFIG_PHY_ADDR		0x00
 #define CONFIG_UDP_CHECKSUM     1
 
diff -Naur u-boot-2009.01/include/configs/mgcoge.h u-boot/include/configs/mgcoge.h
--- u-boot-2009.01/include/configs/mgcoge.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/mgcoge.h	2009-02-26 14:03:59.000000000 +0100
@@ -32,11 +32,12 @@
 #define CONFIG_MPC8247		1
 #define CONFIG_MPC8272_FAMILY   1
 #define CONFIG_MGCOGE		1
+#define CONFIG_HOSTNAME		mgcoge
 
 #define CONFIG_CPM2		1	/* Has a CPM2 */
 
-/* Do boardspecific init */
-#define CONFIG_BOARD_EARLY_INIT_R       1
+/* include common defines/options for all Keymile boards */
+#include "keymile-common.h"
 
 /*
  * Select serial console configuration
@@ -49,6 +50,8 @@
 #undef  CONFIG_CONS_ON_SCC		/* It's not on SCC           */
 #undef	CONFIG_CONS_NONE		/* It's not on external UART */
 #define CONFIG_CONS_INDEX	2	/* SMC2 is used for console  */
+#define CONFIG_SYS_SMC_RXBUFLEN	128
+#define CONFIG_SYS_MAXIDLE	10
 
 /*
  * Select ethernet configuration
@@ -64,6 +67,7 @@
 #define	CONFIG_ETHER_ON_SCC		/* Ethernet is on SCC */
 #undef	CONFIG_ETHER_ON_FCC		/* Ethernet is not on FCC     */
 #undef	CONFIG_ETHER_NONE		/* No external Ethernet   */
+#define CONFIG_NET_MULTI	1
 
 #define CONFIG_ETHER_INDEX	4
 #define CONFIG_SYS_SCC_TOUT_LOOP	10000000
@@ -74,22 +78,13 @@
 #define CONFIG_8260_CLKIN	66000000	/* in Hz */
 #endif
 
-#define CONFIG_BAUDRATE		115200
+#define BOOTFLASH_START	FE000000
+#define CONFIG_PRAM	512	/* protected RAM [KBytes] */
 
-#define CONFIG_BOOTCOUNT_LIMIT
-
-/*
- * Command line configuration.
- */
-#include <config_cmd_default.h>
-
-#define CONFIG_CMD_DTT
-#define CONFIG_CMD_ECHO
-#define CONFIG_CMD_EEPROM
-#define CONFIG_CMD_I2C
-#define CONFIG_CMD_IMMAP
-#define CONFIG_CMD_MII
-#define CONFIG_CMD_PING
+#define MTDIDS_DEFAULT		"nor0=boot,nor1=app"
+#define MTDPARTS_DEFAULT	\
+	"mtdparts=boot:384k(u-boot),128k(env),128k(envred),3456k(free);" \
+	"app:3m(esw0),10m(rootfs0),3m(esw1),10m(rootfs1),1m(var),5m(cfg)"
 
 /*
  * Default environment settings
@@ -123,37 +118,9 @@
 		"tftp ${ramdisk_addr} ${ramdisk_file}; "			\
 		"run ramargs addip; "						\
 		"bootm ${kernel_addr} ${ramdisk_addr} ${fdt_addr}\0"		\
+	"EEprom_ivm=pca9544a:70:4 \0"						\
+	"mtdparts=" MK_STR(MTDPARTS_DEFAULT) "\0"				\
 	""
-#define CONFIG_BOOTCOMMAND	"run net_nfs"
-#define CONFIG_BOOTDELAY	5	/* autoboot after 5 seconds */
-
-#undef	CONFIG_WATCHDOG			/* disable platform specific watchdog */
-
-/*
- * Miscellaneous configurable options
- */
-#define CONFIG_SYS_HUSH_PARSER
-#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
-#define CONFIG_SYS_LONGHELP			/* undef to save memory	    */
-#define CONFIG_SYS_PROMPT		"=> "	/* Monitor Command Prompt   */
-#define CONFIG_HUSH_INIT_VAR	1
-#if defined(CONFIG_CMD_KGDB)
-#define CONFIG_SYS_CBSIZE		1024	/* Console I/O Buffer Size  */
-#else
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size  */
-#endif
-#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)	/* Print Buffer Size  */
-#define CONFIG_SYS_MAXARGS		16		/* max number of command args */
-#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size  */
-
-#define CONFIG_SYS_MEMTEST_START	0x00100000	/* memtest works on */
-#define CONFIG_SYS_MEMTEST_END		0x00f00000	/* 1 ... 15 MB in DRAM	*/
-
-#define CONFIG_SYS_LOAD_ADDR		0x100000	/* default load address */
-
-#define CONFIG_SYS_HZ			1000	/* decrementer freq: 1 ms ticks */
-
-#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200, 230400 }
 
 #define CONFIG_SYS_SDRAM_BASE		0x00000000
 #define CONFIG_SYS_FLASH_BASE		0xFE000000
@@ -173,12 +140,12 @@
 #define CONFIG_SYS_RAMBOOT
 #endif
 
-#define CONFIG_SYS_MONITOR_LEN		(256 << 10)	/* Reserve 256KB for Monitor */
+#define CONFIG_SYS_MONITOR_LEN		(384 << 10)     /* Reserve 384KB for Monitor */
 
 #define CONFIG_ENV_IS_IN_FLASH
 
 #ifdef CONFIG_ENV_IS_IN_FLASH
-#define CONFIG_ENV_SECT_SIZE	0x20000
+#define CONFIG_ENV_SECT_SIZE	0x4000
 #define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)
 #define CONFIG_ENV_OFFSET	CONFIG_SYS_MONITOR_LEN
 
@@ -186,6 +153,7 @@
 #define CONFIG_ENV_OFFSET_REDUND	(CONFIG_ENV_OFFSET + CONFIG_ENV_SECT_SIZE)
 #define CONFIG_ENV_SIZE_REDUND		(CONFIG_ENV_SIZE)
 #endif /* CONFIG_ENV_IS_IN_FLASH */
+#define CONFIG_ENV_BUFFER_PRINT		1
 
 /* enable I2C and select the hardware/software driver */
 #undef	CONFIG_HARD_I2C			/* I2C with hardware support	*/
@@ -233,6 +201,8 @@
 #define CONFIG_SYS_DTT_HYSTERESIS	3
 #define CONFIG_SYS_DTT_BUS_NUM		(CONFIG_SYS_MAX_I2C_BUS)
 
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+
 #define CONFIG_SYS_IMMR		0xF0000000
 
 #define CONFIG_SYS_INIT_RAM_ADDR	CONFIG_SYS_IMMR
@@ -379,6 +349,18 @@
 			 ORxG_CSNT | ORxG_ACS_DIV2 |\
 			 ORxG_SCY_3_CLK | ORxG_TRLX )
 
+/* Board FPGA on CS4 initialization values
+*/
+#define CONFIG_SYS_FPGA_BASE	0x40000000
+#define CONFIG_SYS_FPGA_SIZE	1 /*1KB*/
+
+#define CONFIG_SYS_BR4_PRELIM ((CONFIG_SYS_FPGA_BASE & BRx_BA_MSK) |\
+			BRx_PS_8 | BRx_MS_GPCM_P | BRx_V)
+
+#define CONFIG_SYS_OR4_PRELIM (P2SZ_TO_AM(CONFIG_SYS_FPGA_SIZE << 10) |\
+			 ORxG_CSNT | ORxG_ACS_DIV2 |\
+			 ORxG_SCY_3_CLK | ORxG_TRLX )
+
 /* CFG-Flash on CS5 initialization values
 */
 #define CONFIG_SYS_BR5_PRELIM	((CONFIG_SYS_FLASH_BASE_1 & BRx_BA_MSK) |\
diff -Naur u-boot-2009.01/include/configs/mgsuvd.h u-boot/include/configs/mgsuvd.h
--- u-boot-2009.01/include/configs/mgsuvd.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/mgsuvd.h	2009-02-26 14:03:59.000000000 +0100
@@ -35,32 +35,29 @@
 
 #define CONFIG_MPC866		1	/* This is a MPC866 CPU		*/
 #define CONFIG_MGSUVD		1	/* ...on a mgsuvd board	*/
+#define CONFIG_HOSTNAME		mgsuvd
 
-/* Do boardspecific init */
-#define CONFIG_BOARD_EARLY_INIT_R       1
+/* include common defines/options for all Keymile boards */
+#include "keymile-common.h"
 
 #define CONFIG_8xx_GCLK_FREQ		66000000
 
 #define CONFIG_SYS_SMC_UCODE_PATCH	1	/* Relocate SMC1 */
 #define CONFIG_SYS_SMC_DPMEM_OFFSET	0x1fc0
 #define CONFIG_8xx_CONS_SMC1	1	/* Console is on SMC1		*/
+#define CONFIG_SYS_SMC_RXBUFLEN	128
+#define CONFIG_SYS_MAXIDLE	10
 
-#define CONFIG_BAUDRATE		115200	/* console baudrate = 115kbps	*/
-
-#define CONFIG_BOOTCOUNT_LIMIT
 #define CONFIG_SYS_CPM_BOOTCOUNT_ADDR	0x1eb0	/* In case of SMC relocation, the
 					 * default value is not working */
 
-#define CONFIG_BOOTDELAY	5	/* autoboot after 5 seconds	*/
-
-#define CONFIG_BOARD_TYPES	1	/* support board types		*/
+#define BOOTFLASH_START	F0000000
+#define CONFIG_PRAM	512	/* protected RAM [KBytes] */
 
 #define CONFIG_PREBOOT	"echo;" \
 	"echo Type \\\"run flash_nfs\\\" to mount root filesystem over NFS;" \
 	"echo"
 
-#undef	CONFIG_BOOTARGS
-
 #define CONFIG_EXTRA_ENV_SETTINGS						\
 	"netdev=eth0\0"								\
 	"addcons=setenv bootargs ${bootargs} console=ttyCPM0,${baudrate}\0"	\
@@ -88,71 +85,12 @@
 		"cp.b 200000 f0000000 ${filesize};"				\
 		"protect on f0000000 +${filesize}\0"				\
 	""
-#define CONFIG_BOOTCOMMAND	"run flash_self"
-
-#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
-#undef	CONFIG_SYS_LOADS_BAUD_CHANGE		/* don't allow baudrate change	*/
-
-#undef	CONFIG_WATCHDOG			/* watchdog disabled		*/
-
-/*
- * BOOTP options
- */
-#define CONFIG_BOOTP_SUBNETMASK
-#define CONFIG_BOOTP_GATEWAY
-#define CONFIG_BOOTP_HOSTNAME
-#define CONFIG_BOOTP_BOOTPATH
-#define CONFIG_BOOTP_BOOTFILESIZE
 
 #undef CONFIG_RTC_MPC8xx		/* MPC866 does not support RTC	*/
 
 #define	CONFIG_TIMESTAMP		/* but print image timestmps	*/
 
 /*
- * Command line configuration.
- */
-#include <config_cmd_default.h>
-
-#define CONFIG_CMD_ASKENV
-#define CONFIG_CMD_DHCP
-#define CONFIG_CMD_DTT
-#define CONFIG_CMD_EEPROM
-#define CONFIG_CMD_I2C
-#define CONFIG_CMD_NFS
-#define CONFIG_CMD_PING
-
-/*
- * Miscellaneous configurable options
- */
-#define CONFIG_SYS_LONGHELP			/* undef to save memory		*/
-#define CONFIG_SYS_PROMPT		"=> "	/* Monitor Command Prompt	*/
-
-#define CONFIG_CMDLINE_EDITING	1	/* add command line history	*/
-#define CONFIG_SYS_HUSH_PARSER		1	/* Use the HUSH parser		*/
-#ifdef	CONFIG_SYS_HUSH_PARSER
-#define	CONFIG_SYS_PROMPT_HUSH_PS2	"> "
-#define CONFIG_HUSH_INIT_VAR	1
-#endif
-
-#if defined(CONFIG_CMD_KGDB)
-#define CONFIG_SYS_CBSIZE		1024	/* Console I/O Buffer Size	*/
-#else
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size	*/
-#endif
-#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
-#define CONFIG_SYS_MAXARGS		16	/* max number of command args	*/
-#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
-
-#define CONFIG_SYS_MEMTEST_START	0x0400000	/* memtest works on	*/
-#define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
-
-#define CONFIG_SYS_LOAD_ADDR		0x100000	/* default load address */
-
-#define CONFIG_SYS_HZ			1000	/* decrementer freq: 1 ms ticks */
-
-#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
-
-/*
  * Low Level Configuration Settings
  * (address mappings, register initial values, etc.)
  * You should know what you are doing if you make changes here.
@@ -178,7 +116,7 @@
  */
 #define CONFIG_SYS_SDRAM_BASE		0x00000000
 #define CONFIG_SYS_FLASH_BASE		0xf0000000
-#define CONFIG_SYS_MONITOR_LEN		(256 << 10)	/* Reserve 256 kB for Monitor	*/
+#define CONFIG_SYS_MONITOR_LEN		(384 << 10)	/* Reserve 384 kB for Monitor	*/
 #define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_FLASH_BASE
 #define CONFIG_SYS_MALLOC_LEN		(256 << 10)	/* Reserve 256 kB for malloc()	*/
 
@@ -203,13 +141,14 @@
 #define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Timeout for Flash Write (in ms)	*/
 
 #define CONFIG_ENV_IS_IN_FLASH	1
-#define CONFIG_ENV_OFFSET		0x40000 /*   Offset   of Environment Sector	*/
-#define CONFIG_ENV_SIZE		0x08000 /* Total Size of Environment Sector	*/
+#define CONFIG_ENV_OFFSET	CONFIG_SYS_MONITOR_LEN
+#define CONFIG_ENV_SIZE		0x04000 /* Total Size of Environment Sector	*/
 #define CONFIG_ENV_SECT_SIZE	0x20000 /* Total Size of Environment Sector	*/
 
 /* Address and size of Redundant Environment Sector	*/
 #define CONFIG_ENV_OFFSET_REDUND	(CONFIG_ENV_OFFSET+CONFIG_ENV_SECT_SIZE)
 #define CONFIG_ENV_SIZE_REDUND	(CONFIG_ENV_SIZE)
+#define CONFIG_ENV_BUFFER_PRINT		1
 
 /*-----------------------------------------------------------------------
  * Cache Configuration
@@ -392,4 +331,9 @@
 #define CONFIG_SYS_DTT_HYSTERESIS	3
 #define CONFIG_SYS_DTT_BUS_NUM		(CONFIG_SYS_MAX_I2C_BUS)
 
+#define MTDIDS_DEFAULT		"nor0=app"
+#define MTDPARTS_DEFAULT ( \
+	"mtdparts=app:384k(u-boot),128k(env),128k(envred),128k(free),"	\
+	"1536k(esw0),8704k(rootfs0),1536k(esw1),2432k(rootfs1),640k(var),768k(cfg)")
+
 #endif	/* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/microblaze-generic.h u-boot/include/configs/microblaze-generic.h
--- u-boot-2009.01/include/configs/microblaze-generic.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/microblaze-generic.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,302 @@
+/*
+ * (C) Copyright 2007-2008 Michal Simek
+ *
+ * Michal SIMEK <monstr@monstr.eu>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "../board/xilinx/microblaze-generic/xparameters.h"
+
+#define	CONFIG_MICROBLAZE	1	/* MicroBlaze CPU */
+#define	MICROBLAZE_V5		1
+
+/* uart */
+#ifdef XILINX_UARTLITE_BASEADDR
+	#define	CONFIG_XILINX_UARTLITE
+	#define	CONFIG_SERIAL_BASE	XILINX_UARTLITE_BASEADDR
+	#define	CONFIG_BAUDRATE		XILINX_UARTLITE_BAUDRATE
+	#define	CONFIG_SYS_BAUDRATE_TABLE	{ CONFIG_BAUDRATE }
+	#define CONSOLE_ARG	"console=console=ttyUL0,115200\0"
+#elif XILINX_UART16550_BASEADDR
+	#define CONFIG_SYS_NS16550	1
+	#define CONFIG_SYS_NS16550_SERIAL
+	#define CONFIG_SYS_NS16550_REG_SIZE	-4
+	#define CONFIG_CONS_INDEX	1
+	#define CONFIG_SYS_NS16550_COM1	(XILINX_UART16550_BASEADDR + 0x1000 + 0x3)
+	#define CONFIG_SYS_NS16550_CLK	XILINX_UART16550_CLOCK_HZ
+	#define	CONFIG_BAUDRATE		115200
+
+	/* The following table includes the supported baudrates */
+	#define CONFIG_SYS_BAUDRATE_TABLE  \
+		{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400}
+	#define CONSOLE_ARG	"console=console=ttyS0,115200\0"
+#else
+	#error Undefined uart
+#endif
+
+/* setting reset address */
+/*#define	CONFIG_SYS_RESET_ADDRESS	TEXT_BASE*/
+
+/* ethernet */
+#ifdef XILINX_EMAC_BASEADDR
+	#define CONFIG_XILINX_EMAC	1
+	#define CONFIG_SYS_ENET
+#elif XILINX_EMACLITE_BASEADDR
+	#define CONFIG_XILINX_EMACLITE	1
+	#define CONFIG_SYS_ENET
+#elif XILINX_LLTEMAC_BASEADDR
+	#define CONFIG_XILINX_LL_TEMAC	1
+	#define CONFIG_SYS_ENET
+#endif
+
+#undef ET_DEBUG
+
+/* gpio */
+#ifdef XILINX_GPIO_BASEADDR
+	#define	CONFIG_SYS_GPIO_0		1
+	#define	CONFIG_SYS_GPIO_0_ADDR		XILINX_GPIO_BASEADDR
+#endif
+
+/* interrupt controller */
+#ifdef XILINX_INTC_BASEADDR
+	#define	CONFIG_SYS_INTC_0		1
+	#define	CONFIG_SYS_INTC_0_ADDR		XILINX_INTC_BASEADDR
+	#define	CONFIG_SYS_INTC_0_NUM		XILINX_INTC_NUM_INTR_INPUTS
+#endif
+
+/* timer */
+#ifdef XILINX_TIMER_BASEADDR
+	#if (XILINX_TIMER_IRQ != -1)
+		#define	CONFIG_SYS_TIMER_0		1
+		#define	CONFIG_SYS_TIMER_0_ADDR	XILINX_TIMER_BASEADDR
+		#define	CONFIG_SYS_TIMER_0_IRQ		XILINX_TIMER_IRQ
+		#define	FREQUENCE		XILINX_CLOCK_FREQ
+		#define	CONFIG_SYS_TIMER_0_PRELOAD	( FREQUENCE/1000 )
+	#endif
+#elif XILINX_CLOCK_FREQ
+	#define	CONFIG_XILINX_CLOCK_FREQ	XILINX_CLOCK_FREQ
+#else
+	#error BAD CLOCK FREQ
+#endif
+/* FSL */
+/* #define	CONFIG_SYS_FSL_2 */
+/* #define	FSL_INTR_2	1 */
+
+/*
+ * memory layout - Example
+ * TEXT_BASE = 0x1200_0000;
+ * CONFIG_SYS_SRAM_BASE = 0x1000_0000;
+ * CONFIG_SYS_SRAM_SIZE = 0x0400_0000;
+ *
+ * CONFIG_SYS_GBL_DATA_OFFSET = 0x1000_0000 + 0x0400_0000 - 0x1000 = 0x13FF_F000
+ * CONFIG_SYS_MONITOR_BASE = 0x13FF_F000 - 0x40000 = 0x13FB_F000
+ * CONFIG_SYS_MALLOC_BASE = 0x13FB_F000 - 0x40000 = 0x13F7_F000
+ *
+ * 0x1000_0000	CONFIG_SYS_SDRAM_BASE
+ *					FREE
+ * 0x1200_0000	TEXT_BASE
+ *		U-BOOT code
+ * 0x1202_0000
+ *					FREE
+ *
+ *					STACK
+ * 0x13F7_F000	CONFIG_SYS_MALLOC_BASE
+ *					MALLOC_AREA	256kB	Alloc
+ * 0x11FB_F000	CONFIG_SYS_MONITOR_BASE
+ *					MONITOR_CODE	256kB	Env
+ * 0x13FF_F000	CONFIG_SYS_GBL_DATA_OFFSET
+ *					GLOBAL_DATA	4kB	bd, gd
+ * 0x1400_0000	CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_SDRAM_SIZE
+ */
+
+/* ddr sdram - main memory */
+#define	CONFIG_SYS_SDRAM_BASE		XILINX_RAM_START
+#define	CONFIG_SYS_SDRAM_SIZE		XILINX_RAM_SIZE
+#define	CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+#define	CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x1000)
+
+/* global pointer */
+#define	CONFIG_SYS_GBL_DATA_SIZE	0x1000	/* size of global data */
+/* start of global data */
+#define	CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_SDRAM_SIZE - CONFIG_SYS_GBL_DATA_SIZE)
+
+/* monitor code */
+#define	SIZE			0x40000
+#define	CONFIG_SYS_MONITOR_LEN		SIZE
+#define	CONFIG_SYS_MONITOR_BASE	(CONFIG_SYS_GBL_DATA_OFFSET - CONFIG_SYS_MONITOR_LEN)
+#define	CONFIG_SYS_MONITOR_END		(CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)
+#define	CONFIG_SYS_MALLOC_LEN		SIZE
+#define	CONFIG_SYS_MALLOC_BASE		(CONFIG_SYS_MONITOR_BASE - CONFIG_SYS_MALLOC_LEN)
+
+/* stack */
+#define	CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_MONITOR_BASE
+
+/*#define	RAMENV */
+#define	FLASH
+
+#ifdef FLASH
+	#define	CONFIG_SYS_FLASH_BASE		XILINX_FLASH_START
+	#define	CONFIG_SYS_FLASH_SIZE		XILINX_FLASH_SIZE
+	#define	CONFIG_SYS_FLASH_CFI		1
+	#define	CONFIG_FLASH_CFI_DRIVER	1
+	#define	CONFIG_SYS_FLASH_EMPTY_INFO	1	/* ?empty sector */
+	#define	CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
+	#define	CONFIG_SYS_MAX_FLASH_SECT	512	/* max number of sectors on one chip */
+	#define	CONFIG_SYS_FLASH_PROTECTION		/* hardware flash protection */
+
+	#ifdef	RAMENV
+		#define	CONFIG_ENV_IS_NOWHERE	1
+		#define	CONFIG_ENV_SIZE		0x1000
+		#define	CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SIZE)
+
+	#else	/* !RAMENV */
+		#define	CONFIG_ENV_IS_IN_FLASH	1
+		#define	CONFIG_ENV_SECT_SIZE	0x20000	/* 128K(one sector) for env */
+		#define	CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + (2 * CONFIG_ENV_SECT_SIZE))
+		#define	CONFIG_ENV_SIZE		0x20000
+	#endif /* !RAMBOOT */
+#else /* !FLASH */
+	/* ENV in RAM */
+	#define	CONFIG_SYS_NO_FLASH		1
+	#define	CONFIG_ENV_IS_NOWHERE	1
+	#define	CONFIG_ENV_SIZE		0x1000
+	#define	CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SIZE)
+	#define	CONFIG_SYS_FLASH_PROTECTION		/* hardware flash protection */
+#endif /* !FLASH */
+
+/* system ace */
+#ifdef XILINX_SYSACE_BASEADDR
+	#define	CONFIG_SYSTEMACE
+	/* #define DEBUG_SYSTEMACE */
+	#define	SYSTEMACE_CONFIG_FPGA
+	#define	CONFIG_SYS_SYSTEMACE_BASE	XILINX_SYSACE_BASEADDR
+	#define	CONFIG_SYS_SYSTEMACE_WIDTH	XILINX_SYSACE_MEM_WIDTH
+	#define	CONFIG_DOS_PARTITION
+#endif
+
+#if defined(XILINX_USE_ICACHE)
+	#define CONFIG_ICACHE
+#else
+	#undef CONFIG_ICACHE
+#endif
+
+#if defined(XILINX_USE_DCACHE)
+	#define CONFIG_DCACHE
+#else
+	#undef CONFIG_DCACHE
+#endif
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_MFSL
+#define CONFIG_CMD_ECHO
+
+#if defined(CONFIG_DCACHE) || defined(CONFIG_ICACHE)
+	#define CONFIG_CMD_CACHE
+#else
+	#undef CONFIG_CMD_CACHE
+#endif
+
+#ifndef CONFIG_SYS_ENET
+	#undef CONFIG_CMD_NET
+#else
+	#define CONFIG_CMD_PING
+#endif
+
+#if defined(CONFIG_SYSTEMACE)
+	#define CONFIG_CMD_EXT2
+	#define CONFIG_CMD_FAT
+#endif
+
+#if defined(FLASH)
+	#define CONFIG_CMD_ECHO
+	#define CONFIG_CMD_FLASH
+	#define CONFIG_CMD_IMLS
+	#define CONFIG_CMD_JFFS2
+
+	#if !defined(RAMENV)
+		#define CONFIG_CMD_SAVEENV
+		#define CONFIG_CMD_SAVES
+	#endif
+#else
+	#undef CONFIG_CMD_IMLS
+	#undef CONFIG_CMD_FLASH
+	#undef CONFIG_CMD_JFFS2
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+/* JFFS2 partitions */
+#define CONFIG_JFFS2_CMDLINE	/* mtdparts command line support */
+#define MTDIDS_DEFAULT		"nor0=ml401-0"
+
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT	"mtdparts=ml401-0:256k(u-boot),"\
+				"256k(env),3m(kernel),1m(romfs),"\
+				"1m(cramfs),-(jffs2)"
+#endif
+
+/* Miscellaneous configurable options */
+#define	CONFIG_SYS_PROMPT	"U-Boot-mONStR> "
+#define	CONFIG_SYS_CBSIZE	512	/* size of console buffer */
+#define	CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16) /* print buffer size */
+#define	CONFIG_SYS_MAXARGS	15	/* max number of command args */
+#define	CONFIG_SYS_LONGHELP
+#define	CONFIG_SYS_LOAD_ADDR	XILINX_RAM_START /* default load address */
+
+#define	CONFIG_BOOTDELAY	-1	/* -1 disables auto-boot */
+#define	CONFIG_BOOTARGS		"root=romfs"
+#define	CONFIG_HOSTNAME		XILINX_BOARD_NAME
+#define	CONFIG_BOOTCOMMAND	"base 0;tftp 11000000 image.img;bootm"
+#define	CONFIG_IPADDR		192.168.0.3
+#define	CONFIG_SERVERIP		192.168.0.5
+#define	CONFIG_GATEWAYIP	192.168.0.1
+#define	CONFIG_ETHADDR		00:E0:0C:00:00:FD
+
+/* architecture dependent code */
+#define	CONFIG_SYS_USR_EXCEP	/* user exception */
+#define CONFIG_SYS_HZ	1000
+
+#define	CONFIG_PREBOOT		"echo U-BOOT for $(hostname);setenv preboot;echo"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS	"unlock=yes\0" /* hardware flash protection */\
+					"nor0=ml401-0\0"\
+					"mtdparts=mtdparts=ml401-0:"\
+					"256k(u-boot),256k(env),3m(kernel),"\
+					"1m(romfs),1m(cramfs),-(jffs2)\0"
+
+#define CONFIG_CMDLINE_EDITING
+
+#endif	/* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/MigoR.h u-boot/include/configs/MigoR.h
--- u-boot-2009.01/include/configs/MigoR.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MigoR.h	2009-02-26 14:03:59.000000000 +0100
@@ -40,7 +40,7 @@
 #define CONFIG_CMD_NFS
 #define CONFIG_CMD_DFL
 #define CONFIG_CMD_SDRAM
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 
 #define CONFIG_BAUDRATE		115200
 #define CONFIG_BOOTDELAY	3
diff -Naur u-boot-2009.01/include/configs/ml401.h u-boot/include/configs/ml401.h
--- u-boot-2009.01/include/configs/ml401.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ml401.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,281 +0,0 @@
-/*
- * (C) Copyright 2007-2008 Michal Simek
- *
- * Michal SIMEK <monstr@monstr.eu>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-#include "../board/xilinx/ml401/xparameters.h"
-
-#define	CONFIG_MICROBLAZE	1	/* MicroBlaze CPU */
-#define	MICROBLAZE_V5		1
-#define	CONFIG_ML401		1	/* ML401 Board */
-
-/* uart */
-#ifdef XILINX_UARTLITE_BASEADDR
-#define	CONFIG_XILINX_UARTLITE
-#define	CONFIG_SERIAL_BASE	XILINX_UARTLITE_BASEADDR
-#define	CONFIG_BAUDRATE		XILINX_UARTLITE_BAUDRATE
-#define	CONFIG_SYS_BAUDRATE_TABLE	{ CONFIG_BAUDRATE }
-#elif XILINX_UART16550_BASEADDR
-#define CONFIG_SYS_NS16550	1
-#define CONFIG_SYS_NS16550_SERIAL
-#define CONFIG_SYS_NS16550_REG_SIZE	-4
-#define CONFIG_CONS_INDEX	1
-#define CONFIG_SYS_NS16550_COM1	(XILINX_UART16550_BASEADDR + 0x1000 + 0x3)
-#define CONFIG_SYS_NS16550_CLK		XILINX_UART16550_CLOCK_HZ
-#define	CONFIG_BAUDRATE		115200
-
-/* The following table includes the supported baudrates */
-#define CONFIG_SYS_BAUDRATE_TABLE  \
-	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400}
-#else
-#error Undefined uart
-#endif
-
-/* setting reset address */
-/*#define	CONFIG_SYS_RESET_ADDRESS	TEXT_BASE*/
-
-/* ethernet */
-#ifdef XILINX_EMAC_BASEADDR
-#define CONFIG_XILINX_EMAC	1
-#define CONFIG_SYS_ENET
-#else
-#ifdef XILINX_EMACLITE_BASEADDR
-#define CONFIG_XILINX_EMACLITE	1
-#define CONFIG_SYS_ENET
-#endif
-#endif
-#undef ET_DEBUG
-
-/* gpio */
-#ifdef XILINX_GPIO_BASEADDR
-#define	CONFIG_SYS_GPIO_0		1
-#define	CONFIG_SYS_GPIO_0_ADDR		XILINX_GPIO_BASEADDR
-#endif
-
-/* interrupt controller */
-#ifdef XILINX_INTC_BASEADDR
-#define	CONFIG_SYS_INTC_0		1
-#define	CONFIG_SYS_INTC_0_ADDR		XILINX_INTC_BASEADDR
-#define	CONFIG_SYS_INTC_0_NUM		XILINX_INTC_NUM_INTR_INPUTS
-#endif
-
-/* timer */
-#ifdef XILINX_TIMER_BASEADDR
-#if (XILINX_TIMER_IRQ != -1)
-#define	CONFIG_SYS_TIMER_0		1
-#define	CONFIG_SYS_TIMER_0_ADDR	XILINX_TIMER_BASEADDR
-#define	CONFIG_SYS_TIMER_0_IRQ		XILINX_TIMER_IRQ
-#define	FREQUENCE		XILINX_CLOCK_FREQ
-#define	CONFIG_SYS_TIMER_0_PRELOAD	( FREQUENCE/1000 )
-#endif
-#else
-#ifdef XILINX_CLOCK_FREQ
-#define	CONFIG_XILINX_CLOCK_FREQ	XILINX_CLOCK_FREQ
-#else
-#error BAD CLOCK FREQ
-#endif
-#endif
-/* FSL */
-/* #define	CONFIG_SYS_FSL_2 */
-/* #define	FSL_INTR_2	1 */
-
-/*
- * memory layout - Example
- * TEXT_BASE = 0x1200_0000;
- * CONFIG_SYS_SRAM_BASE = 0x1000_0000;
- * CONFIG_SYS_SRAM_SIZE = 0x0400_0000;
- *
- * CONFIG_SYS_GBL_DATA_OFFSET = 0x1000_0000 + 0x0400_0000 - 0x1000 = 0x13FF_F000
- * CONFIG_SYS_MONITOR_BASE = 0x13FF_F000 - 0x40000 = 0x13FB_F000
- * CONFIG_SYS_MALLOC_BASE = 0x13FB_F000 - 0x40000 = 0x13F7_F000
- *
- * 0x1000_0000	CONFIG_SYS_SDRAM_BASE
- *					FREE
- * 0x1200_0000	TEXT_BASE
- *		U-BOOT code
- * 0x1202_0000
- *					FREE
- *
- *					STACK
- * 0x13F7_F000	CONFIG_SYS_MALLOC_BASE
- *					MALLOC_AREA	256kB	Alloc
- * 0x11FB_F000	CONFIG_SYS_MONITOR_BASE
- *					MONITOR_CODE	256kB	Env
- * 0x13FF_F000	CONFIG_SYS_GBL_DATA_OFFSET
- *					GLOBAL_DATA	4kB	bd, gd
- * 0x1400_0000	CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_SDRAM_SIZE
- */
-
-/* ddr sdram - main memory */
-#define	CONFIG_SYS_SDRAM_BASE		XILINX_RAM_START
-#define	CONFIG_SYS_SDRAM_SIZE		XILINX_RAM_SIZE
-#define	CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
-#define	CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x1000)
-
-/* global pointer */
-#define	CONFIG_SYS_GBL_DATA_SIZE	0x1000	/* size of global data */
-/* start of global data */
-#define	CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_SDRAM_SIZE - CONFIG_SYS_GBL_DATA_SIZE)
-
-/* monitor code */
-#define	SIZE			0x40000
-#define	CONFIG_SYS_MONITOR_LEN		SIZE
-#define	CONFIG_SYS_MONITOR_BASE	(CONFIG_SYS_GBL_DATA_OFFSET - CONFIG_SYS_MONITOR_LEN)
-#define	CONFIG_SYS_MONITOR_END		(CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)
-#define	CONFIG_SYS_MALLOC_LEN		SIZE
-#define	CONFIG_SYS_MALLOC_BASE		(CONFIG_SYS_MONITOR_BASE - CONFIG_SYS_MALLOC_LEN)
-
-/* stack */
-#define	CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_MONITOR_BASE
-
-/*#define	RAMENV */
-#define	FLASH
-
-#ifdef FLASH
-	#define	CONFIG_SYS_FLASH_BASE		XILINX_FLASH_START
-	#define	CONFIG_SYS_FLASH_SIZE		XILINX_FLASH_SIZE
-	#define	CONFIG_SYS_FLASH_CFI		1
-	#define	CONFIG_FLASH_CFI_DRIVER	1
-	#define	CONFIG_SYS_FLASH_EMPTY_INFO	1	/* ?empty sector */
-	#define	CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
-	#define	CONFIG_SYS_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
-	#define	CONFIG_SYS_FLASH_PROTECTION		/* hardware flash protection */
-
-	#ifdef	RAMENV
-		#define	CONFIG_ENV_IS_NOWHERE	1
-		#define	CONFIG_ENV_SIZE		0x1000
-		#define	CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SIZE)
-
-	#else	/* !RAMENV */
-		#define	CONFIG_ENV_IS_IN_FLASH	1
-		#define	CONFIG_ENV_SECT_SIZE	0x40000	/* 256K(one sector) for env */
-		#define	CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + (2 * CONFIG_ENV_SECT_SIZE))
-		#define	CONFIG_ENV_SIZE		0x40000
-	#endif /* !RAMBOOT */
-#else /* !FLASH */
-	/* ENV in RAM */
-	#define	CONFIG_SYS_NO_FLASH		1
-	#define	CONFIG_ENV_IS_NOWHERE	1
-	#define	CONFIG_ENV_SIZE		0x1000
-	#define	CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SIZE)
-	#define	CONFIG_SYS_FLASH_PROTECTION		/* hardware flash protection */
-#endif /* !FLASH */
-
-/* system ace */
-#ifdef XILINX_SYSACE_BASEADDR
-	#define	CONFIG_SYSTEMACE
-	/* #define DEBUG_SYSTEMACE */
-	#define	SYSTEMACE_CONFIG_FPGA
-	#define	CONFIG_SYS_SYSTEMACE_BASE	XILINX_SYSACE_BASEADDR
-	#define	CONFIG_SYS_SYSTEMACE_WIDTH	XILINX_SYSACE_MEM_WIDTH
-	#define	CONFIG_DOS_PARTITION
-#endif
-
-/*
- * BOOTP options
- */
-#define CONFIG_BOOTP_BOOTFILESIZE
-#define CONFIG_BOOTP_BOOTPATH
-#define CONFIG_BOOTP_GATEWAY
-#define CONFIG_BOOTP_HOSTNAME
-
-/*
- * Command line configuration.
- */
-#include <config_cmd_default.h>
-
-#define CONFIG_CMD_ASKENV
-#define CONFIG_CMD_CACHE
-#define CONFIG_CMD_IRQ
-#define CONFIG_CMD_MFSL
-
-#ifndef CONFIG_SYS_ENET
-	#undef CONFIG_CMD_NET
-#else
-	#define CONFIG_CMD_PING
-#endif
-
-#if defined(CONFIG_SYSTEMACE)
-	#define CONFIG_CMD_EXT2
-	#define CONFIG_CMD_FAT
-#endif
-
-#if defined(FLASH)
-	#define CONFIG_CMD_ECHO
-	#define CONFIG_CMD_FLASH
-	#define CONFIG_CMD_IMLS
-	#define CONFIG_CMD_JFFS2
-
-	#if !defined(RAMENV)
-		#define CONFIG_CMD_ENV
-		#define CONFIG_CMD_SAVES
-	#endif
-#else
-	#undef CONFIG_CMD_FLASH
-#endif
-
-#if defined(CONFIG_CMD_JFFS2)
-/* JFFS2 partitions */
-#define CONFIG_JFFS2_CMDLINE	/* mtdparts command line support */
-#define MTDIDS_DEFAULT		"nor0=ml401-0"
-
-/* default mtd partition table */
-#define MTDPARTS_DEFAULT	"mtdparts=ml401-0:256k(u-boot),"\
-				"256k(env),3m(kernel),1m(romfs),"\
-				"1m(cramfs),-(jffs2)"
-#endif
-
-/* Miscellaneous configurable options */
-#define	CONFIG_SYS_PROMPT	"U-Boot-mONStR> "
-#define	CONFIG_SYS_CBSIZE	512	/* size of console buffer */
-#define	CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16) /* print buffer size */
-#define	CONFIG_SYS_MAXARGS	15	/* max number of command args */
-#define	CONFIG_SYS_LONGHELP
-#define	CONFIG_SYS_LOAD_ADDR	0x12000000 /* default load address */
-
-#define	CONFIG_BOOTDELAY	30
-#define	CONFIG_BOOTARGS		"root=romfs"
-#define	CONFIG_HOSTNAME		"ml401"
-#define	CONFIG_BOOTCOMMAND	"base 0;tftp 11000000 image.img;bootm"
-#define	CONFIG_IPADDR		192.168.0.3
-#define	CONFIG_SERVERIP		192.168.0.5
-#define	CONFIG_GATEWAYIP	192.168.0.1
-#define	CONFIG_ETHADDR		00:E0:0C:00:00:FD
-
-/* architecture dependent code */
-#define	CONFIG_SYS_USR_EXCEP	/* user exception */
-#define CONFIG_SYS_HZ	1000
-
-#define	CONFIG_PREBOOT		"echo U-BOOT for ML401;setenv preboot;echo"
-
-#define	CONFIG_EXTRA_ENV_SETTINGS	"unlock=yes\0" /* hardware flash protection */\
-					"nor0=ml401-0\0"\
-					"mtdparts=mtdparts=ml401-0:"\
-					"256k(u-boot),256k(env),3m(kernel),"\
-					"1m(romfs),1m(cramfs),-(jffs2)\0"
-
-#define CONFIG_CMDLINE_EDITING
-
-#endif	/* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/motionpro.h u-boot/include/configs/motionpro.h
--- u-boot-2009.01/include/configs/motionpro.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/motionpro.h	2009-02-26 14:03:59.000000000 +0100
@@ -82,6 +82,7 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 #define CONFIG_PHY_ADDR		0x2
 #define CONFIG_PHY_TYPE		0x79c874
 #define CONFIG_RESET_PHY_R	1
diff -Naur u-boot-2009.01/include/configs/mp2usb.h u-boot/include/configs/mp2usb.h
--- u-boot-2009.01/include/configs/mp2usb.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/mp2usb.h	2009-02-26 14:03:59.000000000 +0100
@@ -216,7 +216,6 @@
 #define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
 
 #define CONFIG_SYS_DEVICE_DEREGISTER           /* needs device_deregister */
-#define LITTLEENDIAN            1       /* used by usb_ohci.c  */
 
 #define CONFIG_SYS_HZ 1000
 #define CONFIG_SYS_HZ_CLOCK (AT91C_MASTER_CLOCK/2)	/* AT91C_TC0_CMR is implicitly set to */
diff -Naur u-boot-2009.01/include/configs/mpc7448hpc2.h u-boot/include/configs/mpc7448hpc2.h
--- u-boot-2009.01/include/configs/mpc7448hpc2.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/mpc7448hpc2.h	2009-02-26 14:03:59.000000000 +0100
@@ -163,7 +163,7 @@
 #define CONFIG_CMD_SDRAM
 #define CONFIG_CMD_EEPROM
 #define CONFIG_CMD_FLASH
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_BSP
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_PING
diff -Naur u-boot-2009.01/include/configs/MPC8313ERDB.h u-boot/include/configs/MPC8313ERDB.h
--- u-boot-2009.01/include/configs/MPC8313ERDB.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8313ERDB.h	2009-02-26 14:03:59.000000000 +0100
@@ -232,7 +232,6 @@
 #endif
 
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_MTD_NAND_VERIFY_WRITE
 #define CONFIG_CMD_NAND 1
 #define CONFIG_NAND_FSL_ELBC 1
@@ -431,7 +430,7 @@
 #define CONFIG_CMD_PCI
 
 #if defined(CONFIG_SYS_RAMBOOT) && !defined(CONFIG_NAND_U_BOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8315ERDB.h u-boot/include/configs/MPC8315ERDB.h
--- u-boot-2009.01/include/configs/MPC8315ERDB.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8315ERDB.h	2009-02-26 14:03:59.000000000 +0100
@@ -166,7 +166,7 @@
 #undef CONFIG_SYS_RAMBOOT
 #endif
 
-#define CONFIG_SYS_MONITOR_LEN		(256 * 1024) /* Reserve 256 kB for Mon */
+#define CONFIG_SYS_MONITOR_LEN		(384 * 1024) /* Reserve 384 kB for Mon */
 #define CONFIG_SYS_MALLOC_LEN		(512 * 1024) /* Reserved for malloc */
 
 /*
@@ -223,15 +223,16 @@
  */
 #define CONFIG_SYS_NAND_BASE		0xE0600000	/* 0xE0600000 */
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
-#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_MTD_NAND_VERIFY_WRITE	1
+#define CONFIG_CMD_NAND			1
+#define CONFIG_NAND_FSL_ELBC		1
 
-#define CONFIG_SYS_BR1_PRELIM		( CONFIG_SYS_NAND_BASE \
+#define CONFIG_SYS_BR1_PRELIM	( CONFIG_SYS_NAND_BASE \
 				| (2<<BR_DECC_SHIFT)	/* Use HW ECC */ \
 				| BR_PS_8		/* Port Size = 8 bit */ \
 				| BR_MS_FCM		/* MSEL = FCM */ \
 				| BR_V )		/* valid */
-#define CONFIG_SYS_OR1_PRELIM		( 0xFFFF8000		/* length 32K */ \
+#define CONFIG_SYS_OR1_PRELIM	( 0xFFFF8000		/* length 32K */ \
 				| OR_FCM_CSCT \
 				| OR_FCM_CST \
 				| OR_FCM_CHT \
@@ -308,8 +309,29 @@
 #define CONFIG_SYS_PCI_SLV_MEM_BUS	0x00000000
 #define CONFIG_SYS_PCI_SLV_MEM_SIZE	0x80000000
 
+#define CONFIG_SYS_PCIE1_BASE		0xA0000000
+#define CONFIG_SYS_PCIE1_MEM_BASE	0xA0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xA0000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x10000000
+#define CONFIG_SYS_PCIE1_CFG_BASE	0xB0000000
+#define CONFIG_SYS_PCIE1_CFG_SIZE	0x01000000
+#define CONFIG_SYS_PCIE1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xB1000000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00800000
+
+#define CONFIG_SYS_PCIE2_BASE		0xC0000000
+#define CONFIG_SYS_PCIE2_MEM_BASE	0xC0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xC0000000
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x10000000
+#define CONFIG_SYS_PCIE2_CFG_BASE	0xD0000000
+#define CONFIG_SYS_PCIE2_CFG_SIZE	0x01000000
+#define CONFIG_SYS_PCIE2_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xD1000000
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00800000
+
 #define CONFIG_PCI
 #define CONFIG_83XX_GENERIC_PCI	1 /* Use generic PCI setup */
+#define CONFIG_83XX_GENERIC_PCIE	1
 
 #define CONFIG_NET_MULTI
 #define CONFIG_PCI_PNP		/* do pci plug-and-play */
@@ -412,7 +434,7 @@
 #define CONFIG_CMD_PCI
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8323ERDB.h u-boot/include/configs/MPC8323ERDB.h
--- u-boot-2009.01/include/configs/MPC8323ERDB.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8323ERDB.h	2009-02-26 14:03:59.000000000 +0100
@@ -427,7 +427,7 @@
 	#define CONFIG_CMD_PCI
 #endif
 #if defined(CONFIG_SYS_RAMBOOT)
-	#undef CONFIG_CMD_ENV
+	#undef CONFIG_CMD_SAVEENV
 	#undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC832XEMDS.h u-boot/include/configs/MPC832XEMDS.h
--- u-boot-2009.01/include/configs/MPC832XEMDS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC832XEMDS.h	2009-02-26 14:03:59.000000000 +0100
@@ -8,7 +8,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -441,7 +441,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8349EMDS.h u-boot/include/configs/MPC8349EMDS.h
--- u-boot-2009.01/include/configs/MPC8349EMDS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8349EMDS.h	2009-02-26 14:03:59.000000000 +0100
@@ -509,7 +509,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8360EMDS.h u-boot/include/configs/MPC8360EMDS.h
--- u-boot-2009.01/include/configs/MPC8360EMDS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8360EMDS.h	2009-02-26 14:03:59.000000000 +0100
@@ -470,7 +470,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8360ERDK.h u-boot/include/configs/MPC8360ERDK.h
--- u-boot-2009.01/include/configs/MPC8360ERDK.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8360ERDK.h	2009-02-26 14:03:59.000000000 +0100
@@ -211,7 +211,6 @@
 #define CONFIG_CMD_NAND		1
 #define CONFIG_NAND_FSL_UPM	1
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_MTD_NAND_VERIFY_WRITE
 
 #define CONFIG_SYS_LBLAWBAR1_PRELIM	CONFIG_SYS_NAND_BASE
@@ -377,7 +376,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-#undef CONFIG_CMD_ENV
+#undef CONFIG_CMD_SAVEENV
 #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC837XEMDS.h u-boot/include/configs/MPC837XEMDS.h
--- u-boot-2009.01/include/configs/MPC837XEMDS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC837XEMDS.h	2009-02-26 14:03:59.000000000 +0100
@@ -271,7 +271,6 @@
 #define CONFIG_CMD_NAND		1
 #define CONFIG_MTD_NAND_VERIFY_WRITE	1
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_NAND_FSL_ELBC 	1
 
 #define CONFIG_SYS_NAND_BASE		0xE0600000	/* 0xE0600000 */
@@ -320,6 +319,9 @@
 #define CONFIG_OF_BOARD_SETUP	1
 #define CONFIG_OF_STDOUT_VIA_ALIAS	1
 
+#define CONFIG_SYS_64BIT_STRTOUL		1
+#define CONFIG_SYS_64BIT_VSPRINTF		1
+
 /* I2C */
 #define CONFIG_HARD_I2C		/* I2C with hardware support */
 #undef CONFIG_SOFT_I2C		/* I2C bit-banged */
@@ -354,11 +356,32 @@
 #define CONFIG_SYS_PCI_SLV_MEM_BUS	0x00000000
 #define CONFIG_SYS_PCI_SLV_MEM_SIZE	0x80000000
 
+#define CONFIG_SYS_PCIE1_BASE		0xA0000000
+#define CONFIG_SYS_PCIE1_CFG_BASE	0xA0000000
+#define CONFIG_SYS_PCIE1_CFG_SIZE	0x08000000
+#define CONFIG_SYS_PCIE1_MEM_BASE	0xA8000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xA8000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x10000000
+#define CONFIG_SYS_PCIE1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xB8000000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00800000
+
+#define CONFIG_SYS_PCIE2_BASE		0xC0000000
+#define CONFIG_SYS_PCIE2_CFG_BASE	0xC0000000
+#define CONFIG_SYS_PCIE2_CFG_SIZE	0x08000000
+#define CONFIG_SYS_PCIE2_MEM_BASE	0xC8000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xC8000000
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x10000000
+#define CONFIG_SYS_PCIE2_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xD8000000
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00800000
+
 #ifdef CONFIG_PCI
 #ifndef __ASSEMBLY__
 extern int board_pci_host_broken(void);
 #endif
 #define CONFIG_83XX_GENERIC_PCI	1 /* Use generic PCI setup */
+#define CONFIG_83XX_GENERIC_PCIE	1
 #define CONFIG_PQ_MDS_PIB	1 /* PQ MDS Platform IO Board */
 
 #define CONFIG_HAS_FSL_DR_USB	1 /* fixup device tree for the DR USB */
@@ -474,7 +497,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
@@ -482,6 +505,18 @@
 
 #undef CONFIG_WATCHDOG		/* watchdog disabled */
 
+#define CONFIG_MMC     1
+
+#ifdef CONFIG_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	CONFIG_SYS_MPC83xx_ESDHC_ADDR
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
 /*
  * Miscellaneous configurable options
  */
diff -Naur u-boot-2009.01/include/configs/MPC837XERDB.h u-boot/include/configs/MPC837XERDB.h
--- u-boot-2009.01/include/configs/MPC837XERDB.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC837XERDB.h	2009-02-26 14:03:59.000000000 +0100
@@ -481,7 +481,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-#undef CONFIG_CMD_ENV
+#undef CONFIG_CMD_SAVEENV
 #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8536DS.h u-boot/include/configs/MPC8536DS.h
--- u-boot-2009.01/include/configs/MPC8536DS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8536DS.h	2009-02-26 14:03:59.000000000 +0100
@@ -34,6 +34,7 @@
 #define CONFIG_MPC8536		1
 #define CONFIG_MPC8536DS	1
 
+#define CONFIG_FSL_ELBC		1	/* Has Enhanced localbus controller */
 #define CONFIG_PCI		1	/* Enable PCI/PCIE */
 #define CONFIG_PCI1		1	/* Enable PCI controller 1 */
 #define CONFIG_PCIE1		1	/* PCIE controler 1 (slot 1) */
@@ -71,6 +72,8 @@
 #define CONFIG_L2_CACHE			/* toggle L2 cache */
 #define CONFIG_BTB			/* toggle branch predition */
 
+#define CONFIG_BOARD_EARLY_INIT_F	1	/* Call board_pre_init */
+
 #define CONFIG_ENABLE_36BIT_PHYS	1
 
 #define CONFIG_SYS_MEMTEST_START	0x00000000	/* memtest works on */
@@ -166,12 +169,13 @@
  * Local Bus Definitions
  */
 #define CONFIG_SYS_FLASH_BASE		0xe0000000	/* start of FLASH 128M */
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
 
-#define CONFIG_SYS_BR0_PRELIM		0xe8001001
-#define CONFIG_SYS_OR0_PRELIM		0xf8000ff7
+#define CONFIG_SYS_BR0_PRELIM  (BR_PHYS_ADDR((CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000)) | BR_PS_16 | BR_V)
+#define CONFIG_SYS_OR0_PRELIM	0xf8000ff7
 
-#define CONFIG_SYS_BR1_PRELIM		0xe0001001
-#define CONFIG_SYS_OR1_PRELIM		0xf8000ff7
+#define CONFIG_SYS_BR1_PRELIM  (BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | BR_PS_16 | BR_V)
+#define CONFIG_SYS_OR1_PRELIM	0xf8000ff7
 
 #define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE + 0x8000000, CONFIG_SYS_FLASH_BASE}
 #define CONFIG_SYS_FLASH_QUIET_TEST
@@ -194,8 +198,9 @@
 
 #define CONFIG_FSL_PIXIS	1	/* use common PIXIS code */
 #define PIXIS_BASE	0xffdf0000	/* PIXIS registers */
+#define PIXIS_BASE_PHYS	PIXIS_BASE
 
-#define CONFIG_SYS_BR3_PRELIM	(PIXIS_BASE | 0x0801)	/* port size 8bit */
+#define CONFIG_SYS_BR3_PRELIM	(BR_PHYS_ADDR(PIXIS_BASE_PHYS) | BR_PS_8 | BR_V)
 #define CONFIG_SYS_OR3_PRELIM		0xffffeff7	/* 32KB but only 4k mapped */
 
 #define PIXIS_ID		0x0	/* Board ID at offset 0 */
@@ -248,14 +253,13 @@
 				CONFIG_SYS_NAND_BASE + 0x80000, \
 				CONFIG_SYS_NAND_BASE + 0xC0000}
 #define CONFIG_SYS_MAX_NAND_DEVICE	4
-#define NAND_MAX_CHIPS		1
 #define CONFIG_MTD_NAND_VERIFY_WRITE
 #define CONFIG_CMD_NAND		1
 #define CONFIG_NAND_FSL_ELBC	1
 #define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
 
 /* NAND flash config */
-#define CONFIG_NAND_BR_PRELIM	(CONFIG_SYS_NAND_BASE_PHYS \
+#define CONFIG_NAND_BR_PRELIM  (BR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
 				| (2<<BR_DECC_SHIFT)    /* Use HW ECC */ \
 				| BR_PS_8              /* Port Size = 8 bit */ \
 				| BR_MS_FCM             /* MSEL = FCM */ \
@@ -272,20 +276,20 @@
 #define CONFIG_SYS_BR2_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
 #define CONFIG_SYS_OR2_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
 
-#define CONFIG_SYS_BR4_PRELIM  ((CONFIG_SYS_NAND_BASE_PHYS + 0x40000)\
+#define CONFIG_SYS_BR4_PRELIM  (BR_PHYS_ADDR((CONFIG_SYS_NAND_BASE_PHYS + 0x40000))\
 				| (2<<BR_DECC_SHIFT)    /* Use HW ECC */ \
 				| BR_PS_8              /* Port Size = 8 bit */ \
 				| BR_MS_FCM             /* MSEL = FCM */ \
 				| BR_V)                 /* valid */
 #define CONFIG_SYS_OR4_PRELIM	CONFIG_NAND_OR_PRELIM     /* NAND Options */
-#define CONFIG_SYS_BR5_PRELIM  ((CONFIG_SYS_NAND_BASE_PHYS + 0x80000)\
+#define CONFIG_SYS_BR5_PRELIM  (BR_PHYS_ADDR((CONFIG_SYS_NAND_BASE_PHYS + 0x80000))\
 				| (2<<BR_DECC_SHIFT)    /* Use HW ECC */ \
 				| BR_PS_8              /* Port Size = 8 bit */ \
 				| BR_MS_FCM             /* MSEL = FCM */ \
 				| BR_V)                 /* valid */
 #define CONFIG_SYS_OR5_PRELIM	CONFIG_NAND_OR_PRELIM     /* NAND Options */
 
-#define CONFIG_SYS_BR6_PRELIM  ((CONFIG_SYS_NAND_BASE_PHYS + 0xC0000)\
+#define CONFIG_SYS_BR6_PRELIM  (BR_PHYS_ADDR((CONFIG_SYS_NAND_BASE_PHYS + 0xc0000))\
 				| (2<<BR_DECC_SHIFT)    /* Use HW ECC */ \
 				| BR_PS_8              /* Port Size = 8 bit */ \
 				| BR_MS_FCM             /* MSEL = FCM */ \
@@ -356,34 +360,42 @@
  * Memory space is mapped 1-1, but I/O space must start from 0.
  */
 
-#define CONFIG_SYS_PCI1_MEM_BASE	0x80000000
-#define CONFIG_SYS_PCI1_MEM_PHYS	CONFIG_SYS_PCI1_MEM_BASE
+#define CONFIG_SYS_PCI1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCI1_MEM_BUS		0x80000000
+#define CONFIG_SYS_PCI1_MEM_PHYS	0x80000000
 #define CONFIG_SYS_PCI1_MEM_SIZE	0x10000000	/* 256M */
-#define CONFIG_SYS_PCI1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI1_IO_VIRT	0xffc00000
+#define CONFIG_SYS_PCI1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI1_IO_PHYS	0xffc00000
 #define CONFIG_SYS_PCI1_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 1, Slot 1, tgtid 1, Base address a000 */
-#define CONFIG_SYS_PCIE1_MEM_BASE	0x90000000
-#define CONFIG_SYS_PCIE1_MEM_PHYS	CONFIG_SYS_PCIE1_MEM_BASE
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x90000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x90000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x90000000
 #define CONFIG_SYS_PCIE1_MEM_SIZE	0x08000000	/* 128M */
-#define CONFIG_SYS_PCIE1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc10000
+#define CONFIG_SYS_PCIE1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCIE1_IO_PHYS	0xffc10000
 #define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 2, Slot 2, tgtid 2, Base address 9000 */
-#define CONFIG_SYS_PCIE2_MEM_BASE	0x98000000
-#define CONFIG_SYS_PCIE2_MEM_PHYS	CONFIG_SYS_PCIE2_MEM_BASE
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0x98000000
+#define CONFIG_SYS_PCIE2_MEM_BUS	0x98000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0x98000000
 #define CONFIG_SYS_PCIE2_MEM_SIZE	0x08000000	/* 128M */
-#define CONFIG_SYS_PCIE2_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xffc20000
+#define CONFIG_SYS_PCIE2_IO_BUS	0x00000000
 #define CONFIG_SYS_PCIE2_IO_PHYS	0xffc20000
 #define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 3, direct to uli, tgtid 3, Base address 8000 */
-#define CONFIG_SYS_PCIE3_MEM_BASE	0xa0000000
-#define CONFIG_SYS_PCIE3_MEM_PHYS	CONFIG_SYS_PCIE3_MEM_BASE
+#define CONFIG_SYS_PCIE3_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xa0000000
 #define CONFIG_SYS_PCIE3_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCIE3_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE3_IO_VIRT	0xffc30000
+#define CONFIG_SYS_PCIE3_IO_BUS	0x00000000
 #define CONFIG_SYS_PCIE3_IO_PHYS	0xffc30000
 #define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
 
@@ -393,10 +405,10 @@
 #define CONFIG_PCI_PNP			/* do pci plug-and-play */
 
 /*PCIE video card used*/
-#define VIDEO_IO_OFFSET		CONFIG_SYS_PCIE3_IO_PHYS
+#define VIDEO_IO_OFFSET		CONFIG_SYS_PCIE3_IO_VIRT
 
 /*PCI video card used*/
-/*#define VIDEO_IO_OFFSET	CONFIG_SYS_PCI1_IO_PHYS*/
+/*#define VIDEO_IO_OFFSET	CONFIG_SYS_PCI1_IO_VIRT*/
 
 /* video */
 #define CONFIG_VIDEO
@@ -409,7 +421,7 @@
 #define CONFIG_ATI_RADEON_FB
 #define CONFIG_VIDEO_LOGO
 /*#define CONFIG_CONSOLE_CURSOR*/
-#define CONFIG_SYS_ISA_IO_BASE_ADDRESS CONFIG_SYS_PCIE3_IO_PHYS
+#define CONFIG_SYS_ISA_IO_BASE_ADDRESS CONFIG_SYS_PCIE3_IO_VIRT
 #endif
 
 #undef CONFIG_EEPRO100
@@ -423,8 +435,8 @@
 #endif
 
 #ifndef CONFIG_PCI_PNP
-	#define PCI_ENET0_IOADDR	CONFIG_SYS_PCI1_IO_BASE
-	#define PCI_ENET0_MEMADDR	CONFIG_SYS_PCI1_IO_BASE
+	#define PCI_ENET0_IOADDR	CONFIG_SYS_PCI1_IO_BUS
+	#define PCI_ENET0_MEMADDR	CONFIG_SYS_PCI1_IO_BUS
 	#define PCI_IDSEL_NUMBER	0x11	/* IDSEL = AD11 */
 #endif
 
@@ -518,6 +530,18 @@
 
 #undef CONFIG_WATCHDOG			/* watchdog disabled */
 
+#define CONFIG_MMC     1
+
+#ifdef CONFIG_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
 /*
  * Miscellaneous configurable options
  */
diff -Naur u-boot-2009.01/include/configs/MPC8540ADS.h u-boot/include/configs/MPC8540ADS.h
--- u-boot-2009.01/include/configs/MPC8540ADS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8540ADS.h	2009-02-26 14:03:59.000000000 +0100
@@ -308,18 +308,21 @@
 #define CONFIG_SYS_I2C_OFFSET		0x3000
 
 /* RapidIO MMU */
-#define CONFIG_SYS_RIO_MEM_BASE	0xc0000000	/* base address */
-#define CONFIG_SYS_RIO_MEM_PHYS	CONFIG_SYS_RIO_MEM_BASE
+#define CONFIG_SYS_RIO_MEM_VIRT	0xc0000000	/* base address */
+#define CONFIG_SYS_RIO_MEM_BUS	0xc0000000	/* base address */
+#define CONFIG_SYS_RIO_MEM_PHYS	0xc0000000
 #define CONFIG_SYS_RIO_MEM_SIZE	0x20000000	/* 128M */
 
 /*
  * General PCI
  * Memory space is mapped 1-1, but I/O space must start from 0.
  */
-#define CONFIG_SYS_PCI1_MEM_BASE	0x80000000
-#define CONFIG_SYS_PCI1_MEM_PHYS	CONFIG_SYS_PCI1_MEM_BASE
+#define CONFIG_SYS_PCI1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCI1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCI1_MEM_PHYS	0x80000000
 #define CONFIG_SYS_PCI1_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI1_IO_VIRT	0xe2000000
+#define CONFIG_SYS_PCI1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI1_IO_PHYS	0xe2000000
 #define CONFIG_SYS_PCI1_IO_SIZE	0x100000	/* 1M */
 
@@ -420,7 +423,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8540EVAL.h u-boot/include/configs/MPC8540EVAL.h
--- u-boot-2009.01/include/configs/MPC8540EVAL.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8540EVAL.h	2009-02-26 14:03:59.000000000 +0100
@@ -300,7 +300,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT) || defined(CONFIG_RAM_AS_FLASH)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8541CDS.h u-boot/include/configs/MPC8541CDS.h
--- u-boot-2009.01/include/configs/MPC8541CDS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8541CDS.h	2009-02-26 14:03:59.000000000 +0100
@@ -341,17 +341,21 @@
  * General PCI
  * Memory space is mapped 1-1, but I/O space must start from 0.
  */
-#define CONFIG_SYS_PCI1_MEM_BASE	0x80000000
-#define CONFIG_SYS_PCI1_MEM_PHYS	CONFIG_SYS_PCI1_MEM_BASE
+#define CONFIG_SYS_PCI1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCI1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCI1_MEM_PHYS	0x80000000
 #define CONFIG_SYS_PCI1_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI1_IO_VIRT	0xe2000000
+#define CONFIG_SYS_PCI1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI1_IO_PHYS	0xe2000000
 #define CONFIG_SYS_PCI1_IO_SIZE	0x100000	/* 1M */
 
-#define CONFIG_SYS_PCI2_MEM_BASE	0xa0000000
-#define CONFIG_SYS_PCI2_MEM_PHYS	CONFIG_SYS_PCI2_MEM_BASE
+#define CONFIG_SYS_PCI2_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCI2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCI2_MEM_PHYS	0xa0000000
 #define CONFIG_SYS_PCI2_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI2_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI2_IO_VIRT	0xe2100000
+#define CONFIG_SYS_PCI2_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI2_IO_PHYS	0xe2100000
 #define CONFIG_SYS_PCI2_IO_SIZE	0x100000	/* 1M */
 
diff -Naur u-boot-2009.01/include/configs/MPC8544DS.h u-boot/include/configs/MPC8544DS.h
--- u-boot-2009.01/include/configs/MPC8544DS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8544DS.h	2009-02-26 14:03:59.000000000 +0100
@@ -263,50 +263,61 @@
  * General PCI
  * Memory space is mapped 1-1, but I/O space must start from 0.
  */
+#define CONFIG_SYS_PCIE_VIRT		0x80000000	/* 1G PCIE TLB */
 #define CONFIG_SYS_PCIE_PHYS		0x80000000	/* 1G PCIE TLB */
+#define CONFIG_SYS_PCI_VIRT		0xc0000000	/* 512M PCI TLB */
 #define CONFIG_SYS_PCI_PHYS		0xc0000000	/* 512M PCI TLB */
 
-#define CONFIG_SYS_PCI1_MEM_BASE	0xc0000000
-#define CONFIG_SYS_PCI1_MEM_PHYS	CONFIG_SYS_PCI1_MEM_BASE
+#define CONFIG_SYS_PCI1_MEM_VIRT	0xc0000000
+#define CONFIG_SYS_PCI1_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCI1_MEM_PHYS	0xc0000000
 #define CONFIG_SYS_PCI1_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI1_IO_VIRT	0xe1000000
+#define CONFIG_SYS_PCI1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI1_IO_PHYS	0xe1000000
 #define CONFIG_SYS_PCI1_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 2, Slot 1, tgtid 1, Base address 9000 */
-#define CONFIG_SYS_PCIE2_MEM_BASE	0x80000000
-#define CONFIG_SYS_PCIE2_MEM_PHYS	CONFIG_SYS_PCIE2_MEM_BASE
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCIE2_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0x80000000
 #define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCIE2_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xe1010000
+#define CONFIG_SYS_PCIE2_IO_BUS	0x00000000
 #define CONFIG_SYS_PCIE2_IO_PHYS	0xe1010000
 #define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 1, Slot 2,tgtid 2, Base address a000 */
-#define CONFIG_SYS_PCIE1_MEM_BASE	0xa0000000
-#define CONFIG_SYS_PCIE1_MEM_PHYS	CONFIG_SYS_PCIE1_MEM_BASE
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xa0000000
 #define CONFIG_SYS_PCIE1_MEM_SIZE	0x10000000	/* 256M */
-#define CONFIG_SYS_PCIE1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xe1020000
+#define CONFIG_SYS_PCIE1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCIE1_IO_PHYS	0xe1020000
 #define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 3, direct to uli, tgtid 3, Base address b000 */
-#define CONFIG_SYS_PCIE3_MEM_BASE	0xb0000000
-#define CONFIG_SYS_PCIE3_MEM_PHYS	CONFIG_SYS_PCIE3_MEM_BASE
+#define CONFIG_SYS_PCIE3_MEM_VIRT	0xb0000000
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xb0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xb0000000
 #define CONFIG_SYS_PCIE3_MEM_SIZE	0x00100000	/* 1M */
-#define CONFIG_SYS_PCIE3_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE3_IO_VIRT	0xb0100000	/* reuse mem LAW */
+#define CONFIG_SYS_PCIE3_IO_BUS	0x00000000
 #define CONFIG_SYS_PCIE3_IO_PHYS	0xb0100000	/* reuse mem LAW */
 #define CONFIG_SYS_PCIE3_IO_SIZE	0x00100000	/* 1M */
-#define CONFIG_SYS_PCIE3_MEM_BASE2	0xb0200000
-#define CONFIG_SYS_PCIE3_MEM_PHYS2	CONFIG_SYS_PCIE3_MEM_BASE2
+#define CONFIG_SYS_PCIE3_MEM_VIRT2	0xb0200000
+#define CONFIG_SYS_PCIE3_MEM_BUS2	0xb0200000
+#define CONFIG_SYS_PCIE3_MEM_PHYS2	0xb0200000
 #define CONFIG_SYS_PCIE3_MEM_SIZE2	0x00200000	/* 1M */
 
 #if defined(CONFIG_PCI)
 
 /*PCIE video card used*/
-#define VIDEO_IO_OFFSET		CONFIG_SYS_PCIE2_IO_PHYS
+#define VIDEO_IO_OFFSET		CONFIG_SYS_PCIE2_IO_VIRT
 
 /*PCI video card used*/
-/*#define VIDEO_IO_OFFSET	CONFIG_SYS_PCI1_IO_PHYS*/
+/*#define VIDEO_IO_OFFSET	CONFIG_SYS_PCI1_IO_VIRT*/
 
 /* video */
 #define CONFIG_VIDEO
@@ -336,8 +347,8 @@
 #endif
 
 #ifndef CONFIG_PCI_PNP
-	#define PCI_ENET0_IOADDR	CONFIG_SYS_PCI1_IO_BASE
-	#define PCI_ENET0_MEMADDR	CONFIG_SYS_PCI1_IO_BASE
+	#define PCI_ENET0_IOADDR	CONFIG_SYS_PCI1_IO_BUS
+	#define PCI_ENET0_MEMADDR	CONFIG_SYS_PCI1_IO_BUS
 	#define PCI_IDSEL_NUMBER	0x11	/* IDSEL = AD11 */
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8548CDS.h u-boot/include/configs/MPC8548CDS.h
--- u-boot-2009.01/include/configs/MPC8548CDS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8548CDS.h	2009-02-26 14:03:59.000000000 +0100
@@ -365,29 +365,36 @@
  * General PCI
  * Memory space is mapped 1-1, but I/O space must start from 0.
  */
+#define CONFIG_SYS_PCI_VIRT		0x80000000	/* 1G PCI TLB */
 #define CONFIG_SYS_PCI_PHYS		0x80000000	/* 1G PCI TLB */
 
-#define CONFIG_SYS_PCI1_MEM_BASE	0x80000000
-#define CONFIG_SYS_PCI1_MEM_PHYS	CONFIG_SYS_PCI1_MEM_BASE
+#define CONFIG_SYS_PCI1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCI1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCI1_MEM_PHYS	0x80000000
 #define CONFIG_SYS_PCI1_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI1_IO_VIRT	0xe2000000
+#define CONFIG_SYS_PCI1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI1_IO_PHYS	0xe2000000
 #define CONFIG_SYS_PCI1_IO_SIZE	0x00100000	/* 1M */
 
 #ifdef CONFIG_PCI2
-#define CONFIG_SYS_PCI2_MEM_BASE	0xa0000000
-#define CONFIG_SYS_PCI2_MEM_PHYS	CONFIG_SYS_PCI2_MEM_BASE
+#define CONFIG_SYS_PCI2_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCI2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCI2_MEM_PHYS	0xa0000000
 #define CONFIG_SYS_PCI2_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI2_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI2_IO_VIRT	0xe2800000
+#define CONFIG_SYS_PCI2_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI2_IO_PHYS	0xe2800000
 #define CONFIG_SYS_PCI2_IO_SIZE	0x00100000	/* 1M */
 #endif
 
 #ifdef CONFIG_PCIE1
-#define CONFIG_SYS_PCIE1_MEM_BASE	0xa0000000
-#define CONFIG_SYS_PCIE1_MEM_PHYS	CONFIG_SYS_PCIE1_MEM_BASE
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xa0000000
 #define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCIE1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xe3000000
+#define CONFIG_SYS_PCIE1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCIE1_IO_PHYS	0xe3000000
 #define CONFIG_SYS_PCIE1_IO_SIZE	0x00100000	/*   1M */
 #endif
@@ -396,7 +403,8 @@
 /*
  * RapidIO MMU
  */
-#define CONFIG_SYS_RIO_MEM_BASE	0xC0000000
+#define CONFIG_SYS_RIO_MEM_VIRT	0xC0000000
+#define CONFIG_SYS_RIO_MEM_BUS	0xC0000000
 #define CONFIG_SYS_RIO_MEM_SIZE	0x20000000	/* 512M */
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8555CDS.h u-boot/include/configs/MPC8555CDS.h
--- u-boot-2009.01/include/configs/MPC8555CDS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8555CDS.h	2009-02-26 14:03:59.000000000 +0100
@@ -339,17 +339,21 @@
  * General PCI
  * Addresses are mapped 1-1.
  */
-#define CONFIG_SYS_PCI1_MEM_BASE	0x80000000
-#define CONFIG_SYS_PCI1_MEM_PHYS	CONFIG_SYS_PCI1_MEM_BASE
+#define CONFIG_SYS_PCI1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCI1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCI1_MEM_PHYS	0x80000000
 #define CONFIG_SYS_PCI1_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI1_IO_VIRT	0xe2000000
+#define CONFIG_SYS_PCI1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI1_IO_PHYS	0xe2000000
 #define CONFIG_SYS_PCI1_IO_SIZE	0x00100000	/* 1M */
 
-#define CONFIG_SYS_PCI2_MEM_BASE	0xa0000000
-#define CONFIG_SYS_PCI2_MEM_PHYS	CONFIG_SYS_PCI2_MEM_BASE
+#define CONFIG_SYS_PCI2_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCI2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCI2_MEM_PHYS	0xa0000000
 #define CONFIG_SYS_PCI2_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI2_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI2_IO_VIRT	0xe2100000
+#define CONFIG_SYS_PCI2_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI2_IO_PHYS	0xe2100000
 #define CONFIG_SYS_PCI2_IO_SIZE	0x00100000	/* 1M */
 
diff -Naur u-boot-2009.01/include/configs/MPC8560ADS.h u-boot/include/configs/MPC8560ADS.h
--- u-boot-2009.01/include/configs/MPC8560ADS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8560ADS.h	2009-02-26 14:03:59.000000000 +0100
@@ -300,18 +300,21 @@
 #define CONFIG_SYS_I2C_OFFSET		0x3000
 
 /* RapidIO MMU */
-#define CONFIG_SYS_RIO_MEM_BASE	0xc0000000	/* base address */
-#define CONFIG_SYS_RIO_MEM_PHYS	CONFIG_SYS_RIO_MEM_BASE
+#define CONFIG_SYS_RIO_MEM_VIRT	0xc0000000	/* base address */
+#define CONFIG_SYS_RIO_MEM_BUS	0xc0000000	/* base address */
+#define CONFIG_SYS_RIO_MEM_PHYS	0xc0000000
 #define CONFIG_SYS_RIO_MEM_SIZE	0x20000000	/* 128M */
 
 /*
  * General PCI
  * Memory space is mapped 1-1, but I/O space must start from 0.
  */
-#define CONFIG_SYS_PCI1_MEM_BASE	0x80000000
-#define CONFIG_SYS_PCI1_MEM_PHYS	CONFIG_SYS_PCI1_MEM_BASE
+#define CONFIG_SYS_PCI1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCI1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCI1_MEM_PHYS	0x80000000
 #define CONFIG_SYS_PCI1_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI1_IO_VIRT	0xe2000000
+#define CONFIG_SYS_PCI1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI1_IO_PHYS	0xe2000000
 #define CONFIG_SYS_PCI1_IO_SIZE	0x100000	/* 1M */
 
@@ -454,7 +457,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8568MDS.h u-boot/include/configs/MPC8568MDS.h
--- u-boot-2009.01/include/configs/MPC8568MDS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8568MDS.h	2009-02-26 14:03:59.000000000 +0100
@@ -322,21 +322,27 @@
  * General PCI
  * Memory Addresses are mapped 1-1. I/O is mapped from 0
  */
-#define CONFIG_SYS_PCI1_MEM_BASE	0x80000000
-#define CONFIG_SYS_PCI1_MEM_PHYS	CONFIG_SYS_PCI1_MEM_BASE
+#define CONFIG_SYS_PCI1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCI1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCI1_MEM_PHYS	0x80000000
 #define CONFIG_SYS_PCI1_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI1_IO_VIRT	0xe2000000
+#define CONFIG_SYS_PCI1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI1_IO_PHYS	0xe2000000
 #define CONFIG_SYS_PCI1_IO_SIZE	0x00800000	/* 8M */
 
-#define CONFIG_SYS_PCIE1_MEM_BASE	0xa0000000
-#define CONFIG_SYS_PCIE1_MEM_PHYS	CONFIG_SYS_PCIE1_MEM_BASE
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xa0000000
 #define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCIE1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xe2800000
+#define CONFIG_SYS_PCIE1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCIE1_IO_PHYS	0xe2800000
 #define CONFIG_SYS_PCIE1_IO_SIZE	0x00800000	/* 8M */
 
-#define CONFIG_SYS_SRIO_MEM_BASE	0xc0000000
+#define CONFIG_SYS_SRIO_MEM_VIRT	0xc0000000
+#define CONFIG_SYS_SRIO_MEM_BUS	0xc0000000
+#define CONFIG_SYS_SRIO_MEM_PHYS	0xc0000000
 
 #ifdef CONFIG_QE
 /*
diff -Naur u-boot-2009.01/include/configs/MPC8572DS.h u-boot/include/configs/MPC8572DS.h
--- u-boot-2009.01/include/configs/MPC8572DS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8572DS.h	2009-02-26 14:03:59.000000000 +0100
@@ -36,6 +36,7 @@
 #define CONFIG_MP		1	/* support multiple processors */
 #define CONFIG_NUM_CPUS		2	/* Number of CPUs in the system */
 
+#define CONFIG_FSL_ELBC		1	/* Has Enhanced localbus controller */
 #define CONFIG_PCI		1	/* Enable PCI/PCIE */
 #define CONFIG_PCIE1		1	/* PCIE controler 1 (slot 1) */
 #define CONFIG_PCIE2		1	/* PCIE controler 2 (slot 2) */
@@ -74,6 +75,11 @@
 
 #define CONFIG_ENABLE_36BIT_PHYS	1
 
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP			1
+#define CONFIG_SYS_NUM_ADDR_MAP		16	/* number of TLB1 entries */
+#endif
+
 #define CONFIG_SYS_MEMTEST_START	0x00000000	/* memtest works on */
 #define CONFIG_SYS_MEMTEST_END		0x7fffffff
 #define CONFIG_PANIC_HANG	/* do not reset board on panic */
@@ -84,7 +90,11 @@
  */
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000	/* CCSRBAR Default */
 #define CONFIG_SYS_CCSRBAR		0xffe00000	/* relocated CCSRBAR */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_CCSRBAR_PHYS		0xfffe00000ull	/* physical addr of CCSRBAR */
+#else
 #define CONFIG_SYS_CCSRBAR_PHYS	CONFIG_SYS_CCSRBAR	/* physical addr of CCSRBAR */
+#endif
 #define CONFIG_SYS_IMMR		CONFIG_SYS_CCSRBAR	/* PQII uses CONFIG_SYS_IMMR */
 
 #define CONFIG_SYS_PCIE3_ADDR		(CONFIG_SYS_CCSRBAR+0x8000)
@@ -93,6 +103,7 @@
 
 /* DDR Setup */
 #define CONFIG_SYS_DDR_TLB_START 9
+#define CONFIG_VERY_BIG_RAM
 #define CONFIG_FSL_DDR2
 #undef CONFIG_FSL_DDR_INTERACTIVE
 #define CONFIG_SPD_EEPROM		/* Use SPD EEPROM for DDR setup */
@@ -169,14 +180,19 @@
  * Local Bus Definitions
  */
 #define CONFIG_SYS_FLASH_BASE		0xe0000000	/* start of FLASH 128M */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_FLASH_BASE_PHYS	0xfe0000000ull
+#else
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#endif
 
-#define CONFIG_SYS_BR0_PRELIM		0xe8001001
-#define CONFIG_SYS_OR0_PRELIM		0xf8000ff7
+#define CONFIG_SYS_BR0_PRELIM  (BR_PHYS_ADDR((CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000)) | BR_PS_16 | BR_V)
+#define CONFIG_SYS_OR0_PRELIM	0xf8000ff7
 
-#define CONFIG_SYS_BR1_PRELIM		0xe0001001
-#define CONFIG_SYS_OR1_PRELIM		0xf8000ff7
+#define CONFIG_SYS_BR1_PRELIM  (BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | BR_PS_16 | BR_V)
+#define CONFIG_SYS_OR1_PRELIM	0xf8000ff7
 
-#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE + 0x8000000, CONFIG_SYS_FLASH_BASE}
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000, CONFIG_SYS_FLASH_BASE_PHYS}
 #define CONFIG_SYS_FLASH_QUIET_TEST
 #define CONFIG_FLASH_SHOW_PROGRESS 45 /* count down from 45/5: 9..1 */
 
@@ -197,8 +213,13 @@
 
 #define CONFIG_FSL_PIXIS	1	/* use common PIXIS code */
 #define PIXIS_BASE	0xffdf0000	/* PIXIS registers */
+#ifdef CONFIG_PHYS_64BIT
+#define PIXIS_BASE_PHYS	0xfffdf0000ull
+#else
+#define PIXIS_BASE_PHYS	PIXIS_BASE
+#endif
 
-#define CONFIG_SYS_BR3_PRELIM	(PIXIS_BASE | 0x0801)	/* port size 8bit */
+#define CONFIG_SYS_BR3_PRELIM	(BR_PHYS_ADDR(PIXIS_BASE_PHYS) | BR_PS_8 | BR_V)
 #define CONFIG_SYS_OR3_PRELIM		0xffffeff7	/* 32KB but only 4k mapped */
 
 #define PIXIS_ID		0x0	/* Board ID at offset 0 */
@@ -261,20 +282,23 @@
 #define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)	/* Reserved for malloc */
 
 #define CONFIG_SYS_NAND_BASE		0xffa00000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	0xfffa00000ull
+#else
 #define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
 #define CONFIG_SYS_NAND_BASE_LIST     { CONFIG_SYS_NAND_BASE,\
 				CONFIG_SYS_NAND_BASE + 0x40000, \
 				CONFIG_SYS_NAND_BASE + 0x80000,\
 				CONFIG_SYS_NAND_BASE + 0xC0000}
 #define CONFIG_SYS_MAX_NAND_DEVICE    4
-#define NAND_MAX_CHIPS		1
 #define CONFIG_MTD_NAND_VERIFY_WRITE
 #define CONFIG_CMD_NAND		1
 #define CONFIG_NAND_FSL_ELBC	1
 #define CONFIG_SYS_NAND_BLOCK_SIZE    (128 * 1024)
 
 /* NAND flash config */
-#define CONFIG_NAND_BR_PRELIM  (CONFIG_SYS_NAND_BASE_PHYS \
+#define CONFIG_NAND_BR_PRELIM  (BR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
 			       | (2<<BR_DECC_SHIFT)    /* Use HW ECC */ \
 			       | BR_PS_8	       /* Port Size = 8 bit */ \
 			       | BR_MS_FCM	       /* MSEL = FCM */ \
@@ -291,20 +315,20 @@
 #define CONFIG_SYS_BR2_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
 #define CONFIG_SYS_OR2_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
 
-#define CONFIG_SYS_BR4_PRELIM  ((CONFIG_SYS_NAND_BASE_PHYS + 0x40000)\
+#define CONFIG_SYS_BR4_PRELIM  (BR_PHYS_ADDR((CONFIG_SYS_NAND_BASE_PHYS + 0x40000))\
 			       | (2<<BR_DECC_SHIFT)    /* Use HW ECC */ \
 			       | BR_PS_8	       /* Port Size = 8 bit */ \
 			       | BR_MS_FCM	       /* MSEL = FCM */ \
 			       | BR_V)		       /* valid */
 #define CONFIG_SYS_OR4_PRELIM  CONFIG_NAND_OR_PRELIM	 /* NAND Options */
-#define CONFIG_SYS_BR5_PRELIM  ((CONFIG_SYS_NAND_BASE_PHYS + 0x80000)\
+#define CONFIG_SYS_BR5_PRELIM  (BR_PHYS_ADDR((CONFIG_SYS_NAND_BASE_PHYS + 0x80000))\
 			       | (2<<BR_DECC_SHIFT)    /* Use HW ECC */ \
 			       | BR_PS_8	       /* Port Size = 8 bit */ \
 			       | BR_MS_FCM	       /* MSEL = FCM */ \
 			       | BR_V)		       /* valid */
 #define CONFIG_SYS_OR5_PRELIM  CONFIG_NAND_OR_PRELIM	 /* NAND Options */
 
-#define CONFIG_SYS_BR6_PRELIM  ((CONFIG_SYS_NAND_BASE_PHYS + 0xC0000)\
+#define CONFIG_SYS_BR6_PRELIM  (BR_PHYS_ADDR((CONFIG_SYS_NAND_BASE_PHYS + 0xc0000))\
 			       | (2<<BR_DECC_SHIFT)    /* Use HW ECC */ \
 			       | BR_PS_8	       /* Port Size = 8 bit */ \
 			       | BR_MS_FCM	       /* MSEL = FCM */ \
@@ -379,33 +403,66 @@
  */
 
 /* controller 3, direct to uli, tgtid 3, Base address 8000 */
-#define CONFIG_SYS_PCIE3_MEM_BASE	0x80000000
-#define CONFIG_SYS_PCIE3_MEM_PHYS	CONFIG_SYS_PCIE3_MEM_BASE
+#define CONFIG_SYS_PCIE3_MEM_VIRT	0x80000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xc00000000ull
+#else
+#define CONFIG_SYS_PCIE3_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0x80000000
+#endif
 #define CONFIG_SYS_PCIE3_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCIE3_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE3_IO_VIRT	0xffc00000
+#define CONFIG_SYS_PCIE3_IO_BUS	0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xfffc00000ull
+#else
 #define CONFIG_SYS_PCIE3_IO_PHYS	0xffc00000
+#endif
 #define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 2, Slot 2, tgtid 2, Base address 9000 */
-#define CONFIG_SYS_PCIE2_MEM_BASE	0xa0000000
-#define CONFIG_SYS_PCIE2_MEM_PHYS	CONFIG_SYS_PCIE2_MEM_BASE
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xa0000000
+#endif
 #define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCIE2_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_BUS	0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xfffc10000ull
+#else
 #define CONFIG_SYS_PCIE2_IO_PHYS	0xffc10000
+#endif
 #define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 1, Slot 1, tgtid 1, Base address a000 */
-#define CONFIG_SYS_PCIE1_MEM_BASE	0xc0000000
-#define CONFIG_SYS_PCIE1_MEM_PHYS	CONFIG_SYS_PCIE1_MEM_BASE
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0xc0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc40000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc0000000
+#endif
 #define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCIE1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc20000
+#define CONFIG_SYS_PCIE1_IO_BUS	0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xfffc20000ull
+#else
 #define CONFIG_SYS_PCIE1_IO_PHYS	0xffc20000
+#endif
 #define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
 
 #if defined(CONFIG_PCI)
 
 /*PCIE video card used*/
-#define VIDEO_IO_OFFSET		CONFIG_SYS_PCIE1_IO_PHYS
+#define VIDEO_IO_OFFSET		CONFIG_SYS_PCIE1_IO_VIRT
 
 /* video */
 #define CONFIG_VIDEO
@@ -435,8 +492,8 @@
 #endif
 
 #ifndef CONFIG_PCI_PNP
-	#define PCI_ENET0_IOADDR	CONFIG_SYS_PCIE3_IO_BASE
-	#define PCI_ENET0_MEMADDR	CONFIG_SYS_PCIE3_IO_BASE
+	#define PCI_ENET0_IOADDR	CONFIG_SYS_PCIE3_IO_BUS
+	#define PCI_ENET0_MEMADDR	CONFIG_SYS_PCIE3_IO_BUS
 	#define PCI_IDSEL_NUMBER	0x11	/* IDSEL = AD11 */
 #endif
 
diff -Naur u-boot-2009.01/include/configs/MPC8610HPCD.h u-boot/include/configs/MPC8610HPCD.h
--- u-boot-2009.01/include/configs/MPC8610HPCD.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8610HPCD.h	2009-02-26 14:03:59.000000000 +0100
@@ -34,8 +34,6 @@
 #define CONFIG_SYS_DIAG_ADDR		0xff800000
 #endif
 
-#define CONFIG_SYS_RESET_ADDRESS	0xfff00100
-
 /*
  * virtual address to be used for temporary mappings.  There
  * should be 128k free at this VA.
@@ -491,7 +489,7 @@
 #define CONFIG_CMD_MII
 
 #if defined(CONFIG_SYS_RAMBOOT)
-#undef CONFIG_CMD_ENV
+#undef CONFIG_CMD_SAVEENV
 #endif
 
 #if defined(CONFIG_PCI)
diff -Naur u-boot-2009.01/include/configs/MPC8641HPCN.h u-boot/include/configs/MPC8641HPCN.h
--- u-boot-2009.01/include/configs/MPC8641HPCN.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MPC8641HPCN.h	2009-02-26 14:03:59.000000000 +0100
@@ -39,13 +39,12 @@
 #define CONFIG_NUM_CPUS		2	/* Number of CPUs in the system */
 #define CONFIG_LINUX_RESET_VEC	0x100	/* Reset vector used by Linux */
 /*#define CONFIG_PHYS_64BIT	1*/	/* Place devices in 36-bit space */
+#define CONFIG_ADDR_MAP		1	/* Use addr map */
 
 #ifdef RUN_DIAG
 #define CONFIG_SYS_DIAG_ADDR	     CONFIG_SYS_FLASH_BASE
 #endif
 
-#define CONFIG_SYS_RESET_ADDRESS    0xfff00100
-
 /*
  * virtual address to be used for temporary mappings.  There
  * should be 128k free at this VA.
@@ -70,6 +69,7 @@
 #define CONFIG_ENV_OVERWRITE
 
 #define CONFIG_HIGH_BATS	1	/* High BATs supported and enabled */
+#define CONFIG_SYS_NUM_ADDR_MAP 8	/* Number of addr map slots = 8 dbats */
 
 #define CONFIG_ALTIVEC		1
 
@@ -186,7 +186,7 @@
 #define CONFIG_SYS_FLASH_BASE_PHYS	(CONFIG_SYS_FLASH_BASE \
 					 | CONFIG_SYS_PHYS_ADDR_HIGH)
 
-#define CONFIG_SYS_FLASH_BANKS_LIST {CONFIG_SYS_FLASH_BASE}
+#define CONFIG_SYS_FLASH_BANKS_LIST {CONFIG_SYS_FLASH_BASE_PHYS}
 
 #define CONFIG_SYS_BR0_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) \
 				 | 0x00001001)	/* port size 16bit */
@@ -331,14 +331,17 @@
  * General PCI
  * Addresses are mapped 1-1.
  */
-#define CONFIG_SYS_PCI1_MEM_BASE	0x80000000
+
+#define CONFIG_SYS_PCI1_MEM_VIRT	0x80000000
 #ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCI1_MEM_BUS		0xc0000000
 #define CONFIG_SYS_PCI1_MEM_PHYS	0x0000000c00000000ULL
 #else
-#define CONFIG_SYS_PCI1_MEM_PHYS	CONFIG_SYS_PCI1_MEM_BASE
+#define CONFIG_SYS_PCI1_MEM_BUS		CONFIG_SYS_PCI1_MEM_VIRT
+#define CONFIG_SYS_PCI1_MEM_PHYS	CONFIG_SYS_PCI1_MEM_VIRT
 #endif
 #define CONFIG_SYS_PCI1_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI1_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI1_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI1_IO_VIRT	0xffc00000
 #define CONFIG_SYS_PCI1_IO_PHYS	(CONFIG_SYS_PCI1_IO_VIRT \
 				 | CONFIG_SYS_PHYS_ADDR_HIGH)
@@ -348,12 +351,23 @@
 #define KSEG1ADDR(x)		({u32 _x=le32_to_cpu(*(u32 *)(x)); (&_x);})
 #define _IO_BASE		0x00000000
 
-#define CONFIG_SYS_PCI2_MEM_BASE 	(CONFIG_SYS_PCI1_MEM_BASE \
+#ifdef CONFIG_PHYS_64BIT
+/*
+ * Use the same PCI bus address on PCI1 and PCI2 if we have PHYS_64BIT.
+ * This will increase the amount of PCI address space available for
+ * for mapping RAM.
+ */
+#define CONFIG_SYS_PCI2_MEM_BUS		CONFIG_SYS_PCI1_MEM_BUS
+#else
+#define CONFIG_SYS_PCI2_MEM_BUS		(CONFIG_SYS_PCI1_MEM_BUS \
+					 + CONFIG_SYS_PCI1_MEM_SIZE)
+#endif
+#define CONFIG_SYS_PCI2_MEM_VIRT 	(CONFIG_SYS_PCI1_MEM_VIRT \
 					 + CONFIG_SYS_PCI1_MEM_SIZE)
 #define CONFIG_SYS_PCI2_MEM_PHYS	(CONFIG_SYS_PCI1_MEM_PHYS \
 					 + CONFIG_SYS_PCI1_MEM_SIZE)
 #define CONFIG_SYS_PCI2_MEM_SIZE	0x20000000	/* 512M */
-#define CONFIG_SYS_PCI2_IO_BASE	0x00000000
+#define CONFIG_SYS_PCI2_IO_BUS	0x00000000
 #define CONFIG_SYS_PCI2_IO_VIRT (CONFIG_SYS_PCI1_IO_VIRT \
 				 + CONFIG_SYS_PCI1_IO_SIZE)
 #define CONFIG_SYS_PCI2_IO_PHYS	(CONFIG_SYS_PCI1_IO_PHYS \
@@ -501,7 +515,7 @@
 #define CONFIG_SYS_DBAT2L	(BAT_PHYS_ADDR(CONFIG_SYS_PCI1_MEM_PHYS) \
 				 | BATL_PP_RW | BATL_CACHEINHIBIT \
 				 | BATL_GUARDEDSTORAGE)
-#define CONFIG_SYS_DBAT2U	(CONFIG_SYS_PCI1_MEM_BASE | BATU_BL_1G \
+#define CONFIG_SYS_DBAT2U	(CONFIG_SYS_PCI1_MEM_VIRT | BATU_BL_1G \
 				 | BATU_VS | BATU_VP)
 #define CONFIG_SYS_IBAT2L	(BAT_PHYS_ADDR(CONFIG_SYS_PCI1_MEM_PHYS) \
 				 | BATL_PP_RW | BATL_CACHEINHIBIT)
@@ -635,7 +649,7 @@
 #define CONFIG_CMD_REGINFO
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
 #endif
 
 #if defined(CONFIG_PCI)
diff -Naur u-boot-2009.01/include/configs/mpr2.h u-boot/include/configs/mpr2.h
--- u-boot-2009.01/include/configs/mpr2.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/mpr2.h	2009-02-26 14:03:59.000000000 +0100
@@ -27,7 +27,7 @@
 #define __MPR2_H
 
 /* Supported commands */
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_CACHE
 #define CONFIG_CMD_MEMORY
 #define CONFIG_CMD_FLASH
diff -Naur u-boot-2009.01/include/configs/ms7720se.h u-boot/include/configs/ms7720se.h
--- u-boot-2009.01/include/configs/ms7720se.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ms7720se.h	2009-02-26 14:03:59.000000000 +0100
@@ -31,7 +31,7 @@
 #define CONFIG_MS7720SE		1
 
 #define CONFIG_CMD_FLASH
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_SDRAM
 #define CONFIG_CMD_MEMORY
 #define CONFIG_CMD_CACHE
diff -Naur u-boot-2009.01/include/configs/ms7722se.h u-boot/include/configs/ms7722se.h
--- u-boot-2009.01/include/configs/ms7722se.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ms7722se.h	2009-02-26 14:03:59.000000000 +0100
@@ -38,7 +38,7 @@
 #define CONFIG_CMD_DFL
 #define CONFIG_CMD_SDRAM
 #define CONFIG_CMD_MEMORY
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 
 #define CONFIG_BAUDRATE		115200
 #define CONFIG_BOOTDELAY	3
diff -Naur u-boot-2009.01/include/configs/ms7750se.h u-boot/include/configs/ms7750se.h
--- u-boot-2009.01/include/configs/ms7750se.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ms7750se.h	2009-02-26 14:03:59.000000000 +0100
@@ -40,7 +40,7 @@
 
 #define CONFIG_CMD_DFL
 #define CONFIG_CMD_FLASH
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 
 #define CONFIG_SCIF_CONSOLE	1
 #define CONFIG_BAUDRATE		38400
diff -Naur u-boot-2009.01/include/configs/mucmc52.h u-boot/include/configs/mucmc52.h
--- u-boot-2009.01/include/configs/mucmc52.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/mucmc52.h	2009-02-26 14:03:59.000000000 +0100
@@ -225,6 +225,7 @@
  * Ethernet configuration
  */
 #define	CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 #define	CONFIG_PHY_ADDR		0x00
 #define	CONFIG_MII		1		/* MII PHY management		*/
 
diff -Naur u-boot-2009.01/include/configs/munices.h u-boot/include/configs/munices.h
--- u-boot-2009.01/include/configs/munices.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/munices.h	2009-02-26 14:03:59.000000000 +0100
@@ -166,6 +166,7 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 #define CONFIG_PHY_ADDR		0x01
 #define CONFIG_MII		1
 
diff -Naur u-boot-2009.01/include/configs/MVBLUE.h u-boot/include/configs/MVBLUE.h
--- u-boot-2009.01/include/configs/MVBLUE.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MVBLUE.h	2009-02-26 14:03:59.000000000 +0100
@@ -85,7 +85,7 @@
 #define CONFIG_CMD_CACHE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ECHO
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_IRQ
diff -Naur u-boot-2009.01/include/configs/MVS1.h u-boot/include/configs/MVS1.h
--- u-boot-2009.01/include/configs/MVS1.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/MVS1.h	2009-02-26 14:03:59.000000000 +0100
@@ -92,7 +92,7 @@
 #define CONFIG_CMD_MEMORY
 #define CONFIG_CMD_NET
 #define CONFIG_CMD_DHCP
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_BOOTD
 #define CONFIG_CMD_RUN
 
diff -Naur u-boot-2009.01/include/configs/NC650.h u-boot/include/configs/NC650.h
--- u-boot-2009.01/include/configs/NC650.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/NC650.h	2009-02-26 14:03:59.000000000 +0100
@@ -250,7 +250,6 @@
  * NAND flash support
  */
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 
 /*-----------------------------------------------------------------------
  * SYPCR - System Protection Control					11-9
diff -Naur u-boot-2009.01/include/configs/NETPHONE.h u-boot/include/configs/NETPHONE.h
--- u-boot-2009.01/include/configs/NETPHONE.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/NETPHONE.h	2009-02-26 14:03:59.000000000 +0100
@@ -514,7 +514,6 @@
 #define ADDR_COLUMN_PAGE	3
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS		1
-#define NAND_MAX_CHIPS		1
 
 /* ALE = PD17, CLE = PE18, CE = PE20, F_RY_BY = PE31 */
 #define NAND_DISABLE_CE(nand) \
diff -Naur u-boot-2009.01/include/configs/netstar.h u-boot/include/configs/netstar.h
--- u-boot-2009.01/include/configs/netstar.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/netstar.h	2009-02-26 14:03:59.000000000 +0100
@@ -120,7 +120,6 @@
  * NAND flash
  */
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_SYS_NAND_BASE	0x04000000 + (2 << 23)
 #define NAND_ALLOW_ERASE_ALL	1
 
@@ -141,7 +140,7 @@
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_BOOTD
 #define CONFIG_CMD_DHCP
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_JFFS2
diff -Naur u-boot-2009.01/include/configs/NETTA2.h u-boot/include/configs/NETTA2.h
--- u-boot-2009.01/include/configs/NETTA2.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/NETTA2.h	2009-02-26 14:03:59.000000000 +0100
@@ -515,7 +515,6 @@
 #define ADDR_COLUMN_PAGE	3
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS		1
-#define NAND_MAX_CHIPS		1
 
 /* ALE = PD17, CLE = PE18, CE = PE20, F_RY_BY = PE31 */
 #define NAND_DISABLE_CE(nand) \
diff -Naur u-boot-2009.01/include/configs/NETTA.h u-boot/include/configs/NETTA.h
--- u-boot-2009.01/include/configs/NETTA.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/NETTA.h	2009-02-26 14:03:59.000000000 +0100
@@ -633,7 +633,6 @@
 #define ADDR_COLUMN_PAGE	3
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS		1
-#define NAND_MAX_CHIPS		1
 
 /* ALE = PD3, CLE = PD4, CE = PD5, F_RY_BY = PC13 */
 #define NAND_DISABLE_CE(nand) \
diff -Naur u-boot-2009.01/include/configs/NETVIA.h u-boot/include/configs/NETVIA.h
--- u-boot-2009.01/include/configs/NETVIA.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/NETVIA.h	2009-02-26 14:03:59.000000000 +0100
@@ -411,7 +411,6 @@
 #define ADDR_COLUMN_PAGE	3
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS		1
-#define NAND_MAX_CHIPS		1
 
 #define NAND_DISABLE_CE(nand) \
 	do { \
diff -Naur u-boot-2009.01/include/configs/nmdk8815.h u-boot/include/configs/nmdk8815.h
--- u-boot-2009.01/include/configs/nmdk8815.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/nmdk8815.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,168 @@
+/*
+ * (C) Copyright 2005
+ * STMicroelectronics.
+ * Configuration settings for the STn8815 nomadik board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <nomadik.h>
+
+#define CONFIG_ARM926EJS
+#define CONFIG_NOMADIK
+#define CONFIG_NOMADIK_8815
+#define CONFIG_NOMADIK_NDK15
+#define CONFIG_NOMADIK_NHK15
+
+#define CONFIG_SKIP_LOWLEVEL_INIT /* we have already been loaded to RAM */
+
+/* commands */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_NFS
+/* There is no NOR flash, so undefine these commands */
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_IMLS
+#define CONFIG_SYS_NO_FLASH
+/* There is NAND storage */
+#define CONFIG_NAND_NOMADIK
+#define CONFIG_CMD_JFFS2
+
+/* user interface */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"Nomadik> "
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE \
+					+ sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE /* Boot Arg Buffer Size */
+#define CONFIG_SYS_MAXARGS	16
+#define CONFIG_SYS_LOAD_ADDR	0x800000	/* default load address */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE
+
+/* boot config */
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_BOOTARGS	"root=/dev/ram0 console=ttyAMA1,115200n8 init=linuxrc"
+#define CONFIG_BOOTCOMMAND	"fsload 0x100000 kernel.uimg;" \
+				" fsload 0x800000 initrd.gz.uimg;" \
+				" bootm 0x100000 0x800000"
+
+/* memory-related information */
+#define CONFIG_NR_DRAM_BANKS	2
+#define PHYS_SDRAM_1		0x00000000	/* DDR-SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000	/* 64 MB */
+#define PHYS_SDRAM_2		0x08000000	/* SDR-SDRAM BANK #2*/
+#define PHYS_SDRAM_2_SIZE	0x04000000	/* 64 MB */
+
+#define CONFIG_STACKSIZE	(128 * 1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#  define CONFIG_STACKSIZE_IRQ	(4 * 1024)	/* IRQ stack */
+#  define CONFIG_STACKSIZE_FIQ	(4 * 1024)	/* FIQ stack */
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	0x00000000
+#define CONFIG_SYS_MEMTEST_END		0x0FFFFFFF
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 256 * 1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* for initial data */
+
+#define CONFIG_MISC_INIT_R	/* call misc_init_r during start up */
+
+/* timing informazion */
+#define CONFIG_SYS_HZ		(2400000 / 256)	/* Timer0: 2.4Mhz + divider */
+#define CONFIG_SYS_TIMERBASE	0x101E2000
+#undef	CONFIG_SYS_CLKS_IN_HZ
+
+/* serial port (PL011) configuration */
+#define CONFIG_PL011_SERIAL
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+#define CFG_SERIAL0		0x101FD000
+#define CFG_SERIAL1		0x101FB000
+
+#define CONFIG_PL01x_PORTS	{ (void *)CFG_SERIAL0, (void *)CFG_SERIAL1 }
+#define CONFIG_PL011_CLOCK	48000000
+
+/* Ethernet */
+#define PCI_MEMORY_VADDR	0xe8000000
+#define PCI_IO_VADDR		0xee000000
+#define __io(a)			((void __iomem *)(PCI_IO_VADDR + (a)))
+#define __mem_isa(a)		((a) + PCI_MEMORY_VADDR)
+
+#define CONFIG_DRIVER_SMC91111	/* Using SMC91c111*/
+#define CONFIG_SMC91111_BASE	0x34000300
+#undef  CONFIG_SMC91111_EXT_PHY	/* Internal PHY */
+#define CONFIG_SMC_USE_32_BIT
+#define CONFIG_BOOTFILE		"uImage"
+
+/* flash memory and filesystem information */
+#define CONFIG_DOS_PARTITION
+#define CONFIG_MTD_ONENAND_VERIFY_WRITE
+#define CONFIG_SYS_ONENAND_BASE		0x30000000
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000 /* SMPS0n */
+
+#ifdef CONFIG_BOOT_ONENAND
+
+#   define CONFIG_CMD_ONENAND /* Temporary: nand and onenand can't coexist */
+   /* Partition				Size	Start
+    * XloaderTOC + X-Loader		256KB	0x00000000
+    * Memory init function		256KB	0x00040000
+    * U-Boot				2MB	0x00080000
+    * Sysimage (kernel + ramdisk)	4MB	0x00280000
+    * JFFS2 Root filesystem		22MB	0x00680000
+    * JFFS2 User Data			227.5MB	0x01C80000
+    */
+#   define CONFIG_JFFS2_PART_SIZE	0x400000
+#   define CONFIG_JFFS2_PART_OFFSET	0x280000
+
+#   define CONFIG_ENV_IS_IN_ONENAND
+#   define CONFIG_ENV_SIZE		(256 * 1024)
+#   define CONFIG_ENV_ADDR		0x30300000
+
+#else /* ! CONFIG_BOOT_ONENAND */
+
+#   define CONFIG_CMD_NAND /* Temporary: nand and onenand can't coexist */
+
+#   define CONFIG_JFFS2_DEV		"nand0"
+#   define CONFIG_JFFS2_NAND		1 /* For the jffs2 support*/
+#   define CONFIG_JFFS2_PART_SIZE	0x00300000
+#   define CONFIG_JFFS2_PART_OFFSET	0x00280000
+
+#   define CONFIG_ENV_IS_IN_NAND
+#   define CONFIG_ENV_SIZE		0x20000 /* 128 Kb - one sector */
+#   define CONFIG_ENV_OFFSET		(0x8000000 - CONFIG_ENV_SIZE)
+
+#endif /* CONFIG_BOOT_ONENAND */
+
+/* this is needed to make hello_world.c and other stuff happy */
+#define CONFIG_SYS_MAX_FLASH_SECT	512
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+
+#endif /* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/o2dnt.h u-boot/include/configs/o2dnt.h
--- u-boot-2009.01/include/configs/o2dnt.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/o2dnt.h	2009-02-26 14:03:59.000000000 +0100
@@ -233,10 +233,11 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 /*
- * Define CONFIG_FEC_10MBIT to force FEC at 10Mb
+ * Define CONFIG_MPC5xxx_FEC_MII10 to force FEC at 10Mb
  */
-/* #define CONFIG_FEC_10MBIT 1 */
+/* #define CONFIG_MPC5xxx_FEC_MII10 */
 #define CONFIG_PHY_ADDR		0x00
 
 /*
diff -Naur u-boot-2009.01/include/configs/OCRTC.h u-boot/include/configs/OCRTC.h
--- u-boot-2009.01/include/configs/OCRTC.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/OCRTC.h	2009-02-26 14:03:59.000000000 +0100
@@ -105,7 +105,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 
 /* The following table includes the supported baudrates */
diff -Naur u-boot-2009.01/include/configs/omap2420h4.h u-boot/include/configs/omap2420h4.h
--- u-boot-2009.01/include/configs/omap2420h4.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/omap2420h4.h	2009-02-26 14:03:59.000000000 +0100
@@ -163,7 +163,6 @@
 
 #define NAND_ChipID_UNKNOWN 0x00
 #define NAND_MAX_FLOORS     1
-#define NAND_MAX_CHIPS      1
 
 #define WRITE_NAND_COMMAND(d, adr) do {*(volatile u16 *)0x6800A07C = d;} while(0)
 #define WRITE_NAND_ADDRESS(d, adr) do {*(volatile u16 *)0x6800A080 = d;} while(0)
diff -Naur u-boot-2009.01/include/configs/omap3_beagle.h u-boot/include/configs/omap3_beagle.h
--- u-boot-2009.01/include/configs/omap3_beagle.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/omap3_beagle.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,325 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments.
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Mohammed Khasim <x0khasim@ti.com>
+ *
+ * Configuration settings for the TI OMAP3530 Beagle board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+#include <asm/sizes.h>
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_ARMCORTEXA8	1	/* This is an ARM V7 CPU core */
+#define CONFIG_OMAP		1	/* in a TI OMAP core */
+#define CONFIG_OMAP34XX		1	/* which is a 34XX */
+#define CONFIG_OMAP3430		1	/* which is in a 3430 */
+#define CONFIG_OMAP3_BEAGLE	1	/* working with BEAGLE */
+
+#include <asm/arch/cpu.h>		/* get chip and board defs */
+#include <asm/arch/omap3.h>
+
+/* Clock Defines */
+#define V_OSCK			26000000	/* Clock output from T2 */
+#define V_SCLK			(V_OSCK >> 1)
+
+#undef CONFIG_USE_IRQ				/* no support for IRQs */
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_REVISION_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_ENV_SIZE			SZ_128K	/* Total Size Environment */
+						/* Sector */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + SZ_128K)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* bytes reserved for */
+						/* initial data */
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * NS16550 Configuration
+ */
+#define V_NS16550_CLK			48000000	/* 48MHz (APLL96/2) */
+
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		V_NS16550_CLK
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_CONS_INDEX		3
+#define CONFIG_SYS_NS16550_COM3		OMAP34XX_UART3
+#define CONFIG_SERIAL3			3	/* UART3 on Beagle Rev 2 */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{4800, 9600, 19200, 38400, 57600,\
+					115200}
+#define CONFIG_MMC			1
+#define CONFIG_OMAP3_MMC		1
+#define CONFIG_DOS_PARTITION		1
+
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
+#define CONFIG_CMD_FAT		/* FAT support			*/
+#define CONFIG_CMD_JFFS2	/* JFFS2 Support		*/
+
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#define CONFIG_CMD_MMC		/* MMC support			*/
+#define CONFIG_CMD_NAND		/* NAND support			*/
+
+#undef CONFIG_CMD_FLASH		/* flinfo, erase, protect	*/
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#undef CONFIG_CMD_IMI		/* iminfo			*/
+#undef CONFIG_CMD_IMLS		/* List all found images	*/
+#undef CONFIG_CMD_NET		/* bootp, tftpboot, rarpboot	*/
+#undef CONFIG_CMD_NFS		/* NFS support			*/
+
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_SYS_I2C_BUS		0
+#define CONFIG_SYS_I2C_BUS_SELECT	1
+#define CONFIG_DRIVER_OMAP34XX_I2C	1
+
+/*
+ * Board NAND Info.
+ */
+#define CONFIG_NAND_OMAP_GPMC
+#define CONFIG_SYS_NAND_ADDR		NAND_BASE	/* physical address */
+							/* to access nand */
+#define CONFIG_SYS_NAND_BASE		NAND_BASE	/* physical address */
+							/* to access nand at */
+							/* CS0 */
+#define GPMC_NAND_ECC_LP_x16_LAYOUT	1
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of NAND */
+							/* devices */
+#define SECTORSIZE			512
+
+#define NAND_ALLOW_ERASE_ALL
+#define ADDR_COLUMN			1
+#define ADDR_PAGE			2
+#define ADDR_COLUMN_PAGE		3
+
+#define NAND_ChipID_UNKNOWN		0x00
+#define NAND_MAX_FLOORS			1
+#define NAND_MAX_CHIPS			1
+#define NAND_NO_RB			1
+#define CONFIG_SYS_NAND_WP
+
+#define CONFIG_JFFS2_NAND
+/* nand device jffs2 lives on */
+#define CONFIG_JFFS2_DEV		"nand0"
+/* start of jffs2 partition */
+#define CONFIG_JFFS2_PART_OFFSET	0x680000
+#define CONFIG_JFFS2_PART_SIZE		0xf980000	/* size of jffs2 */
+							/* partition */
+
+/* Environment information */
+#define CONFIG_BOOTDELAY		10
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x82000000\0" \
+	"console=ttyS2,115200n8\0" \
+	"videomode=1024x768@60,vxres=1024,vyres=768\0" \
+	"videospec=omapfb:vram:2M,vram:4M\0" \
+	"mmcargs=setenv bootargs console=${console} " \
+		"video=${videospec},mode:${videomode} " \
+		"root=/dev/mmcblk0p2 rw " \
+		"rootfstype=ext3 rootwait\0" \
+	"nandargs=setenv bootargs console=${console} " \
+		"video=${videospec},mode:${videomode} " \
+		"root=/dev/mtdblock4 rw " \
+		"rootfstype=jffs2\0" \
+	"loadbootscript=fatload mmc 0 ${loadaddr} boot.scr\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"autoscr ${loadaddr}\0" \
+	"loaduimage=fatload mmc 0 ${loadaddr} uImage\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootm ${loadaddr}\0" \
+	"nandboot=echo Booting from nand ...; " \
+		"run nandargs; " \
+		"nand read ${loadaddr} 280000 400000; " \
+		"bootm ${loadaddr}\0" \
+
+#define CONFIG_BOOTCOMMAND \
+	"if mmcinit; then " \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"else " \
+			"if run loaduimage; then " \
+				"run mmcboot; " \
+			"else run nandboot; " \
+			"fi; " \
+		"fi; " \
+	"else run nandboot; fi"
+
+#define CONFIG_AUTO_COMPLETE		1
+/*
+ * Miscellaneous configurable options
+ */
+#define V_PROMPT			"OMAP3 beagleboard.org # "
+
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_PROMPT		V_PROMPT
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		(CONFIG_SYS_CBSIZE)
+
+#define CONFIG_SYS_MEMTEST_START	(OMAP34XX_SDRC_CS0)	/* memtest */
+								/* works on */
+#define CONFIG_SYS_MEMTEST_END		(OMAP34XX_SDRC_CS0 + \
+					0x01F00000) /* 31MB */
+
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		(OMAP34XX_SDRC_CS0)	/* default */
+							/* load address */
+
+/*
+ * 2430 has 12 GP timers, they can be driven by the SysClk (12/13/19.2) or by
+ * 32KHz clk, or from external sig. This rate is divided by a local divisor.
+ */
+#define V_PVT				7
+
+#define CONFIG_SYS_TIMERBASE		(OMAP34XX_GPT2)
+#define CONFIG_SYS_PVT			V_PVT	/* 2^(pvt+1) */
+#define CONFIG_SYS_HZ			((V_SCLK) / (2 << CONFIG_SYS_PVT))
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	SZ_128K	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	SZ_4K	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	SZ_4K	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	2	/* CS1 may or may not be populated */
+#define PHYS_SDRAM_1		OMAP34XX_SDRC_CS0
+#define PHYS_SDRAM_1_SIZE	SZ_32M	/* at least 32 meg */
+#define PHYS_SDRAM_2		OMAP34XX_SDRC_CS1
+
+/* SDRAM Bank Allocation method */
+#define SDRC_R_B_C		1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+/* **** PISMO SUPPORT *** */
+
+/* Configure the PISMO */
+#define PISMO1_NAND_SIZE		GPMC_SIZE_128M
+#define PISMO1_ONEN_SIZE		GPMC_SIZE_128M
+
+#define CONFIG_SYS_MAX_FLASH_SECT	520	/* max number of sectors on */
+						/* one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* max number of flash banks */
+#define CONFIG_SYS_MONITOR_LEN		SZ_256K	/* Reserve 2 sectors */
+
+#define CONFIG_SYS_FLASH_BASE		boot_flash_base
+
+/* Monitor at start of flash */
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+#define CONFIG_SYS_ONENAND_BASE		ONENAND_MAP
+
+#define CONFIG_ENV_IS_IN_NAND		1
+#define ONENAND_ENV_OFFSET		0x260000 /* environment starts here */
+#define SMNAND_ENV_OFFSET		0x260000 /* environment starts here */
+
+#define CONFIG_SYS_ENV_SECT_SIZE	boot_flash_sec
+#define CONFIG_ENV_OFFSET		boot_flash_off
+#define CONFIG_ENV_ADDR			SMNAND_ENV_OFFSET
+
+/*-----------------------------------------------------------------------
+ * CFI FLASH driver setup
+ */
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(100 * CONFIG_SYS_HZ)
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(100 * CONFIG_SYS_HZ)
+
+/* Flash banks JFFS2 should use */
+#define CONFIG_SYS_MAX_MTD_BANKS	(CONFIG_SYS_MAX_FLASH_BANKS + \
+					CONFIG_SYS_MAX_NAND_DEVICE)
+#define CONFIG_SYS_JFFS2_MEM_NAND
+/* use flash_info[2] */
+#define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
+#define CONFIG_SYS_JFFS2_NUM_BANKS	1
+
+#ifndef __ASSEMBLY__
+extern gpmc_csx_t *nand_cs_base;
+extern gpmc_t *gpmc_cfg_base;
+extern unsigned int boot_flash_base;
+extern volatile unsigned int boot_flash_env_addr;
+extern unsigned int boot_flash_off;
+extern unsigned int boot_flash_sec;
+extern unsigned int boot_flash_type;
+#endif
+
+
+#define WRITE_NAND_COMMAND(d, adr)\
+			writel(d, &nand_cs_base->nand_cmd)
+#define WRITE_NAND_ADDRESS(d, adr)\
+			writel(d, &nand_cs_base->nand_adr)
+#define WRITE_NAND(d, adr) writew(d, &nand_cs_base->nand_dat)
+#define READ_NAND(adr) readl(&nand_cs_base->nand_dat)
+
+/* Other NAND Access APIs */
+#define NAND_WP_OFF() do {readl(&gpmc_cfg_base->config) |= GPMC_CONFIG_WP; } \
+			while (0)
+#define NAND_WP_ON() do {readl(&gpmc_cfg_base->config) &= ~GPMC_CONFIG_WP; } \
+			while (0)
+#define NAND_DISABLE_CE(nand)
+#define NAND_ENABLE_CE(nand)
+#define NAND_WAIT_READY(nand)	udelay(10)
+
+#endif /* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/omap3_evm.h u-boot/include/configs/omap3_evm.h
--- u-boot-2009.01/include/configs/omap3_evm.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/omap3_evm.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,345 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments.
+ * Author :
+ *	Manikandan Pillai <mani.pillai@ti.com>
+ * Derived from Beagle Board and 3430 SDP code by
+ *	Richard Woodruff <r-woodruff2@ti.com>
+ *	Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * Manikandan Pillai <mani.pillai@ti.com>
+ *
+ * Configuration settings for the TI OMAP3 EVM board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+#include <asm/sizes.h>
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_ARMCORTEXA8	1	/* This is an ARM V7 CPU core */
+#define CONFIG_OMAP		1	/* in a TI OMAP core */
+#define CONFIG_OMAP34XX		1	/* which is a 34XX */
+#define CONFIG_OMAP3430		1	/* which is in a 3430 */
+#define CONFIG_OMAP3_EVM	1	/* working with EVM */
+
+#include <asm/arch/cpu.h>	/* get chip and board defs */
+#include <asm/arch/omap3.h>
+
+/* Clock Defines */
+#define V_OSCK			26000000	/* Clock output from T2 */
+#define V_SCLK			(V_OSCK >> 1)
+
+#undef CONFIG_USE_IRQ			/* no support for IRQs */
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_REVISION_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_ENV_SIZE			SZ_128K	/* Total Size Environment */
+						/* Sector */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + SZ_128K)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* bytes reserved for */
+						/* initial data */
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * NS16550 Configuration
+ */
+#define V_NS16550_CLK			48000000	/* 48MHz (APLL96/2) */
+
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		V_NS16550_CLK
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		OMAP34XX_UART1
+#define CONFIG_SERIAL1			1	/* UART1 on OMAP3 EVM */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{4800, 9600, 19200, 38400, 57600,\
+					115200}
+#define CONFIG_MMC			1
+#define CONFIG_OMAP3_MMC		1
+#define CONFIG_DOS_PARTITION		1
+
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
+#define CONFIG_CMD_FAT		/* FAT support			*/
+#define CONFIG_CMD_JFFS2	/* JFFS2 Support		*/
+
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#define CONFIG_CMD_MMC		/* MMC support			*/
+#define CONFIG_CMD_ONENAND	/* ONENAND support		*/
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_PING
+
+#undef CONFIG_CMD_FLASH		/* flinfo, erase, protect	*/
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#undef CONFIG_CMD_IMI		/* iminfo			*/
+#undef CONFIG_CMD_IMLS		/* List all found images	*/
+
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_SYS_I2C_BUS		0
+#define CONFIG_SYS_I2C_BUS_SELECT	1
+#define CONFIG_DRIVER_OMAP34XX_I2C	1
+
+/*
+ * Board NAND Info.
+ */
+#define CONFIG_SYS_NAND_ADDR		NAND_BASE	/* physical address */
+							/* to access nand */
+#define CONFIG_SYS_NAND_BASE		NAND_BASE	/* physical address */
+							/* to access */
+							/* nand at CS0 */
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of */
+							/* NAND devices */
+#define SECTORSIZE			512
+
+#define NAND_ALLOW_ERASE_ALL
+#define ADDR_COLUMN			1
+#define ADDR_PAGE			2
+#define ADDR_COLUMN_PAGE		3
+
+#define NAND_ChipID_UNKNOWN		0x00
+#define NAND_MAX_FLOORS			1
+#define NAND_MAX_CHIPS			1
+#define NAND_NO_RB			1
+#define CONFIG_SYS_NAND_WP
+
+#define CONFIG_JFFS2_NAND
+/* nand device jffs2 lives on */
+#define CONFIG_JFFS2_DEV		"nand0"
+/* start of jffs2 partition */
+#define CONFIG_JFFS2_PART_OFFSET	0x680000
+#define CONFIG_JFFS2_PART_SIZE		0xf980000	/* sz of jffs2 part */
+
+/* Environment information */
+#define CONFIG_BOOTDELAY	10
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x82000000\0" \
+	"console=ttyS2,115200n8\0" \
+	"mmcargs=setenv bootargs console=${console} " \
+		"root=/dev/mmcblk0p2 rw " \
+		"rootfstype=ext3 rootwait\0" \
+	"nandargs=setenv bootargs console=${console} " \
+		"root=/dev/mtdblock4 rw " \
+		"rootfstype=jffs2\0" \
+	"loadbootscript=fatload mmc 0 ${loadaddr} boot.scr\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"autoscr ${loadaddr}\0" \
+	"loaduimage=fatload mmc 0 ${loadaddr} uImage\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootm ${loadaddr}\0" \
+	"nandboot=echo Booting from nand ...; " \
+		"run nandargs; " \
+		"onenand read ${loadaddr} 280000 400000; " \
+		"bootm ${loadaddr}\0" \
+
+#define CONFIG_BOOTCOMMAND \
+	"if mmcinit; then " \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"else " \
+			"if run loaduimage; then " \
+				"run mmcboot; " \
+			"else run nandboot; " \
+			"fi; " \
+		"fi; " \
+	"else run nandboot; fi"
+
+#define CONFIG_AUTO_COMPLETE	1
+/*
+ * Miscellaneous configurable options
+ */
+#define V_PROMPT		"OMAP3_EVM # "
+
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_PROMPT		V_PROMPT
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		16	/* max number of command */
+						/* args */
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		(CONFIG_SYS_CBSIZE)
+/* memtest works on */
+#define CONFIG_SYS_MEMTEST_START	(OMAP34XX_SDRC_CS0)
+#define CONFIG_SYS_MEMTEST_END		(OMAP34XX_SDRC_CS0 + \
+					0x01F00000) /* 31MB */
+
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, */
+					/* in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		(OMAP34XX_SDRC_CS0) /* default load */
+								/* address */
+
+/*
+ * 2430 has 12 GP timers, they can be driven by the SysClk (12/13/19.2) or by
+ * 32KHz clk, or from external sig. This rate is divided by a local divisor.
+ */
+#define V_PVT				7
+
+#define CONFIG_SYS_TIMERBASE		OMAP34XX_GPT2
+#define CONFIG_SYS_PVT			V_PVT	/* 2^(pvt+1) */
+#define CONFIG_SYS_HZ			((V_SCLK) / (2 << CONFIG_SYS_PVT))
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	SZ_128K	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	SZ_4K	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	SZ_4K	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	2	/* CS1 may or may not be populated */
+#define PHYS_SDRAM_1		OMAP34XX_SDRC_CS0
+#define PHYS_SDRAM_1_SIZE	SZ_32M	/* at least 32 meg */
+#define PHYS_SDRAM_2		OMAP34XX_SDRC_CS1
+
+/* SDRAM Bank Allocation method */
+#define SDRC_R_B_C		1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+/* **** PISMO SUPPORT *** */
+
+/* Configure the PISMO */
+#define PISMO1_NAND_SIZE		GPMC_SIZE_128M
+#define PISMO1_ONEN_SIZE		GPMC_SIZE_128M
+
+#define CONFIG_SYS_MAX_FLASH_SECT	520	/* max number of sectors */
+						/* on one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* max number of flash banks */
+#define CONFIG_SYS_MONITOR_LEN		SZ_256K	/* Reserve 2 sectors */
+
+#define CONFIG_SYS_FLASH_BASE		boot_flash_base
+
+/* Monitor at start of flash */
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+#define CONFIG_SYS_ONENAND_BASE		ONENAND_MAP
+
+#define CONFIG_ENV_IS_IN_ONENAND	1
+#define ONENAND_ENV_OFFSET		0x260000 /* environment starts here */
+#define SMNAND_ENV_OFFSET		0x260000 /* environment starts here */
+
+#define CONFIG_SYS_ENV_SECT_SIZE	boot_flash_sec
+#define CONFIG_ENV_OFFSET		boot_flash_off
+#define CONFIG_ENV_ADDR			boot_flash_env_addr
+
+/*-----------------------------------------------------------------------
+ * CFI FLASH driver setup
+ */
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(100 * CONFIG_SYS_HZ)
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(100 * CONFIG_SYS_HZ)
+
+/* Flash banks JFFS2 should use */
+#define CONFIG_SYS_MAX_MTD_BANKS	(CONFIG_SYS_MAX_FLASH_BANKS + \
+					CONFIG_SYS_MAX_NAND_DEVICE)
+#define CONFIG_SYS_JFFS2_MEM_NAND
+/* use flash_info[2] */
+#define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
+#define CONFIG_SYS_JFFS2_NUM_BANKS	1
+
+#ifndef __ASSEMBLY__
+extern gpmc_csx_t *nand_cs_base;
+extern gpmc_t *gpmc_cfg_base;
+extern unsigned int boot_flash_base;
+extern volatile unsigned int boot_flash_env_addr;
+extern unsigned int boot_flash_off;
+extern unsigned int boot_flash_sec;
+extern unsigned int boot_flash_type;
+#endif
+
+
+#define WRITE_NAND_COMMAND(d, adr)\
+			writel(d, &nand_cs_base->nand_cmd)
+#define WRITE_NAND_ADDRESS(d, adr)\
+			writel(d, &nand_cs_base->nand_adr)
+#define WRITE_NAND(d, adr) writew(d, &nand_cs_base->nand_dat)
+#define READ_NAND(adr) readl(&nand_cs_base->nand_dat)
+
+/* Other NAND Access APIs */
+#define NAND_WP_OFF() do {readl(&gpmc_cfg_base->config) |= GPMC_CONFIG_WP; } \
+			while (0)
+#define NAND_WP_ON() do {readl(&gpmc_cfg_base->config) &= ~GPMC_CONFIG_WP; } \
+			while (0)
+#define NAND_DISABLE_CE(nand)
+#define NAND_ENABLE_CE(nand)
+#define NAND_WAIT_READY(nand)	udelay(10)
+
+/*----------------------------------------------------------------------------
+ * SMSC9115 Ethernet from SMSC9118 family
+ *----------------------------------------------------------------------------
+ */
+#if defined(CONFIG_CMD_NET)
+
+#define CONFIG_DRIVER_SMC911X
+#define CONFIG_DRIVER_SMC911X_32_BIT
+#define CONFIG_DRIVER_SMC911X_BASE	0x2C000000
+
+#endif /* (CONFIG_CMD_NET) */
+
+/*
+ * BOOTP fields
+ */
+
+#define CONFIG_BOOTP_SUBNETMASK		0x00000001
+#define CONFIG_BOOTP_GATEWAY		0x00000002
+#define CONFIG_BOOTP_HOSTNAME		0x00000004
+#define CONFIG_BOOTP_BOOTPATH		0x00000010
+
+#endif /* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/omap3_overo.h u-boot/include/configs/omap3_overo.h
--- u-boot-2009.01/include/configs/omap3_overo.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/omap3_overo.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,318 @@
+/*
+ * Configuration settings for the Gumstix Overo board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+#include <asm/sizes.h>
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_ARMCORTEXA8	1	/* This is an ARM V7 CPU core */
+#define CONFIG_OMAP		1	/* in a TI OMAP core */
+#define CONFIG_OMAP34XX		1	/* which is a 34XX */
+#define CONFIG_OMAP3430		1	/* which is in a 3430 */
+#define CONFIG_OMAP3_OVERO		1	/* working with overo */
+
+#include <asm/arch/cpu.h>	/* get chip and board defs */
+#include <asm/arch/omap3.h>
+
+/* Clock Defines */
+#define V_OSCK			26000000	/* Clock output from T2 */
+#define V_SCLK			(V_OSCK >> 1)
+
+#undef CONFIG_USE_IRQ		/* no support for IRQs */
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_REVISION_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_ENV_SIZE			SZ_128K	/* Total Size Environment */
+						/* Sector */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + SZ_128K)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* bytes reserved for */
+						/* initial data */
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * NS16550 Configuration
+ */
+#define V_NS16550_CLK			48000000	/* 48MHz (APLL96/2) */
+
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		V_NS16550_CLK
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_CONS_INDEX		3
+#define CONFIG_SYS_NS16550_COM3		OMAP34XX_UART3
+#define CONFIG_SERIAL3			3
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{4800, 9600, 19200, 38400, 57600, \
+					115200}
+#define CONFIG_MMC			1
+#define CONFIG_OMAP3_MMC		1
+#define CONFIG_DOS_PARTITION		1
+
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
+#define CONFIG_CMD_FAT		/* FAT support			*/
+#define CONFIG_CMD_JFFS2	/* JFFS2 Support		*/
+
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#define CONFIG_CMD_MMC		/* MMC support			*/
+#define CONFIG_CMD_NAND		/* NAND support			*/
+
+#undef CONFIG_CMD_FLASH		/* flinfo, erase, protect	*/
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#undef CONFIG_CMD_IMI		/* iminfo			*/
+#undef CONFIG_CMD_IMLS		/* List all found images	*/
+#undef CONFIG_CMD_NET		/* bootp, tftpboot, rarpboot	*/
+#undef CONFIG_CMD_NFS		/* NFS support			*/
+
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_SYS_I2C_BUS		0
+#define CONFIG_SYS_I2C_BUS_SELECT	1
+#define CONFIG_DRIVER_OMAP34XX_I2C	1
+
+/*
+ * Board NAND Info.
+ */
+#define CONFIG_NAND_OMAP_GPMC
+#define CONFIG_SYS_NAND_ADDR		NAND_BASE	/* physical address */
+							/* to access nand */
+#define CONFIG_SYS_NAND_BASE		NAND_BASE	/* physical address */
+							/* to access nand */
+							/* at CS0 */
+#define GPMC_NAND_ECC_LP_x16_LAYOUT	1
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1	/* Max number of NAND */
+						/* devices */
+#define SECTORSIZE			512
+
+#define NAND_ALLOW_ERASE_ALL
+#define ADDR_COLUMN			1
+#define ADDR_PAGE			2
+#define ADDR_COLUMN_PAGE		3
+
+#define NAND_ChipID_UNKNOWN		0x00
+#define NAND_MAX_FLOORS			1
+#define NAND_MAX_CHIPS			1
+#define NAND_NO_RB			1
+#define CONFIG_SYS_NAND_WP
+
+#define CONFIG_JFFS2_NAND
+/* nand device jffs2 lives on */
+#define CONFIG_JFFS2_DEV		"nand0"
+/* start of jffs2 partition */
+#define CONFIG_JFFS2_PART_OFFSET	0x680000
+#define CONFIG_JFFS2_PART_SIZE		0xf980000	/* size of jffs2 */
+							/* partition */
+
+/* Environment information */
+#define CONFIG_BOOTDELAY		5
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x82000000\0" \
+	"console=ttyS2,115200n8\0" \
+	"videomode=1024x768@60,vxres=1024,vyres=768\0" \
+	"videospec=omapfb:vram:2M,vram:4M\0" \
+	"mmcargs=setenv bootargs console=${console} " \
+		"video=${videospec},mode:${videomode} " \
+		"root=/dev/mmcblk0p2 rw " \
+		"rootfstype=ext3 rootwait\0" \
+	"nandargs=setenv bootargs console=${console} " \
+		"video=${videospec},mode:${videomode} " \
+		"root=/dev/mtdblock4 rw " \
+		"rootfstype=jffs2\0" \
+	"loadbootscript=fatload mmc 0 ${loadaddr} boot.scr\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"autoscr ${loadaddr}\0" \
+	"loaduimage=fatload mmc 0 ${loadaddr} uImage\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootm ${loadaddr}\0" \
+	"nandboot=echo Booting from nand ...; " \
+		"run nandargs; " \
+		"nand read ${loadaddr} 280000 400000; " \
+		"bootm ${loadaddr}\0" \
+
+#define CONFIG_BOOTCOMMAND \
+	"if mmcinit; then " \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"else " \
+			"if run loaduimage; then " \
+				"run mmcboot; " \
+			"else run nandboot; " \
+			"fi; " \
+		"fi; " \
+	"else run nandboot; fi"
+
+#define CONFIG_AUTO_COMPLETE	1
+/*
+ * Miscellaneous configurable options
+ */
+#define V_PROMPT		"Overo # "
+
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_PROMPT		V_PROMPT
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		16	/* max number of command */
+						/* args */
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+/* memtest works on */
+#define CONFIG_SYS_MEMTEST_START	(OMAP34XX_SDRC_CS0)
+#define CONFIG_SYS_MEMTEST_END		(OMAP34XX_SDRC_CS0 + \
+					0x01F00000) /* 31MB */
+
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, */
+					/* in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		(OMAP34XX_SDRC_CS0) /* default load */
+								/* address */
+
+/*
+ * 2430 has 12 GP timers, they can be driven by the SysClk (12/13/19.2) or by
+ * 32KHz clk, or from external sig. This rate is divided by a local divisor.
+ */
+#define V_PVT				7
+
+#define CONFIG_SYS_TIMERBASE		(OMAP34XX_GPT2)
+#define CONFIG_SYS_PVT			V_PVT	/* 2^(pvt+1) */
+#define CONFIG_SYS_HZ			((V_SCLK) / (2 << CONFIG_SYS_PVT))
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	SZ_128K	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	SZ_4K	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	SZ_4K	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	2	/* CS1 may or may not be populated */
+#define PHYS_SDRAM_1		OMAP34XX_SDRC_CS0
+#define PHYS_SDRAM_1_SIZE	SZ_32M	/* at least 32 meg */
+#define PHYS_SDRAM_2		OMAP34XX_SDRC_CS1
+
+/* SDRAM Bank Allocation method */
+#define SDRC_R_B_C		1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+/* **** PISMO SUPPORT *** */
+
+/* Configure the PISMO */
+#define PISMO1_NAND_SIZE		GPMC_SIZE_128M
+#define PISMO1_ONEN_SIZE		GPMC_SIZE_128M
+
+#define CONFIG_SYS_MAX_FLASH_SECT	520	/* max number of sectors on */
+						/* one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* max number of flash banks */
+#define CONFIG_SYS_MONITOR_LEN		SZ_256K	/* Reserve 2 sectors */
+
+#define CONFIG_SYS_FLASH_BASE		boot_flash_base
+
+/* Monitor at start of flash */
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+#define CONFIG_SYS_ONENAND_BASE		ONENAND_MAP
+
+#define CONFIG_ENV_IS_IN_NAND		1
+#define ONENAND_ENV_OFFSET		0x240000 /* environment starts here */
+#define SMNAND_ENV_OFFSET		0x240000 /* environment starts here */
+
+#define CONFIG_SYS_ENV_SECT_SIZE	boot_flash_sec
+#define CONFIG_ENV_OFFSET		boot_flash_off
+#define CONFIG_ENV_ADDR			SMNAND_ENV_OFFSET
+
+/*-----------------------------------------------------------------------
+ * CFI FLASH driver setup
+ */
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(100 * CONFIG_SYS_HZ)
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(100 * CONFIG_SYS_HZ)
+
+/* Flash banks JFFS2 should use */
+#define CONFIG_SYS_MAX_MTD_BANKS	(CONFIG_SYS_MAX_FLASH_BANKS + \
+					CONFIG_SYS_MAX_NAND_DEVICE)
+#define CONFIG_SYS_JFFS2_MEM_NAND
+/* use flash_info[2] */
+#define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
+#define CONFIG_SYS_JFFS2_NUM_BANKS	1
+
+#ifndef __ASSEMBLY__
+extern gpmc_csx_t *nand_cs_base;
+extern gpmc_t *gpmc_cfg_base;
+extern unsigned int boot_flash_base;
+extern volatile unsigned int boot_flash_env_addr;
+extern unsigned int boot_flash_off;
+extern unsigned int boot_flash_sec;
+extern unsigned int boot_flash_type;
+#endif
+
+
+#define WRITE_NAND_COMMAND(d, adr)\
+			writel(d, &nand_cs_base->nand_cmd)
+#define WRITE_NAND_ADDRESS(d, adr)\
+			writel(d, &nand_cs_base->nand_adr)
+#define WRITE_NAND(d, adr) writew(d, &nand_cs_base->nand_dat)
+#define READ_NAND(adr) readl(&nand_cs_base->nand_dat)
+
+/* Other NAND Access APIs */
+#define NAND_WP_OFF() do {readl(&gpmc_cfg_base->config) |= GPMC_CONFIG_WP; } \
+			while (0)
+#define NAND_WP_ON() do {readl(&gpmc_cfg_base->config) &= ~GPMC_CONFIG_WP; } \
+			while (0)
+#define NAND_DISABLE_CE(nand)
+#define NAND_ENABLE_CE(nand)
+#define NAND_WAIT_READY(nand)	udelay(10)
+
+#endif				/* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/omap3_pandora.h u-boot/include/configs/omap3_pandora.h
--- u-boot-2009.01/include/configs/omap3_pandora.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/omap3_pandora.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,320 @@
+/*
+ * (C) Copyright 2008
+ * Grazvydas Ignotas <notasas@gmail.com>
+ *
+ * Configuration settings for the OMAP3 Pandora.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+#include <asm/sizes.h>
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_ARMCORTEXA8	1	/* This is an ARM V7 CPU core */
+#define CONFIG_OMAP		1	/* in a TI OMAP core */
+#define CONFIG_OMAP34XX		1	/* which is a 34XX */
+#define CONFIG_OMAP3430		1	/* which is in a 3430 */
+#define CONFIG_OMAP3_PANDORA	1	/* working with pandora */
+
+#include <asm/arch/cpu.h>	/* get chip and board defs */
+#include <asm/arch/omap3.h>
+
+/* Clock Defines */
+#define V_OSCK			26000000	/* Clock output from T2 */
+#define V_SCLK			(V_OSCK >> 1)
+
+#undef CONFIG_USE_IRQ		/* no support for IRQs */
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_REVISION_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_ENV_SIZE			SZ_128K	/* Total Size Environment */
+						/* Sector */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + SZ_128K)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* bytes reserved for */
+						/* initial data */
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * NS16550 Configuration
+ */
+#define V_NS16550_CLK			48000000	/* 48MHz (APLL96/2) */
+
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		V_NS16550_CLK
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_CONS_INDEX		3
+#define CONFIG_SYS_NS16550_COM3		OMAP34XX_UART3
+#define CONFIG_SERIAL3			3
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{4800, 9600, 19200, 38400, 57600, \
+					115200}
+#define CONFIG_MMC			1
+#define CONFIG_OMAP3_MMC		1
+#define CONFIG_DOS_PARTITION		1
+
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
+#define CONFIG_CMD_FAT		/* FAT support			*/
+#define CONFIG_CMD_JFFS2	/* JFFS2 Support		*/
+
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#define CONFIG_CMD_MMC		/* MMC support			*/
+#define CONFIG_CMD_NAND		/* NAND support			*/
+
+#undef CONFIG_CMD_FLASH		/* flinfo, erase, protect	*/
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#undef CONFIG_CMD_IMI		/* iminfo			*/
+#undef CONFIG_CMD_IMLS		/* List all found images	*/
+#undef CONFIG_CMD_NET		/* bootp, tftpboot, rarpboot	*/
+#undef CONFIG_CMD_NFS		/* NFS support			*/
+
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_SYS_I2C_BUS		0
+#define CONFIG_SYS_I2C_BUS_SELECT	1
+#define CONFIG_DRIVER_OMAP34XX_I2C	1
+
+/*
+ * Board NAND Info.
+ */
+#define CONFIG_NAND_OMAP_GPMC
+#define CONFIG_SYS_NAND_ADDR		NAND_BASE	/* physical address */
+							/* to access nand */
+#define CONFIG_SYS_NAND_BASE		NAND_BASE	/* physical address */
+							/* to access nand */
+							/* at CS0 */
+#define GPMC_NAND_ECC_LP_x16_LAYOUT	1
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1	/* Max number of NAND */
+						/* devices */
+#define SECTORSIZE			512
+
+#define NAND_ALLOW_ERASE_ALL
+#define ADDR_COLUMN			1
+#define ADDR_PAGE			2
+#define ADDR_COLUMN_PAGE		3
+
+#define NAND_ChipID_UNKNOWN		0x00
+#define NAND_MAX_FLOORS			1
+#define NAND_MAX_CHIPS			1
+#define NAND_NO_RB			1
+#define CONFIG_SYS_NAND_WP
+
+#define CONFIG_JFFS2_NAND
+/* nand device jffs2 lives on */
+#define CONFIG_JFFS2_DEV		"nand0"
+/* start of jffs2 partition */
+#define CONFIG_JFFS2_PART_OFFSET	0x680000
+#define CONFIG_JFFS2_PART_SIZE		0xf980000	/* size of jffs2 */
+							/* partition */
+
+/* Environment information */
+#define CONFIG_BOOTDELAY		1
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x82000000\0" \
+	"console=ttyS0,115200n8\0" \
+	"videospec=omapfb:vram:2M,vram:4M\0" \
+	"mmcargs=setenv bootargs console=${console} " \
+		"video=${videospec} " \
+		"root=/dev/mmcblk0p2 rw " \
+		"rootfstype=ext3 rootwait\0" \
+	"nandargs=setenv bootargs console=${console} " \
+		"video=${videospec} " \
+		"root=/dev/mtdblock4 rw " \
+		"rootfstype=jffs2\0" \
+	"loadbootscript=fatload mmc 0 ${loadaddr} boot.scr\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"autoscr ${loadaddr}\0" \
+	"loaduimage=fatload mmc 0 ${loadaddr} uImage\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootm ${loadaddr}\0" \
+	"nandboot=echo Booting from nand ...; " \
+		"run nandargs; " \
+		"nand read ${loadaddr} 280000 400000; " \
+		"bootm ${loadaddr}\0" \
+
+#define CONFIG_BOOTCOMMAND \
+	"if mmcinit; then " \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"else " \
+			"if run loaduimage; then " \
+				"run mmcboot; " \
+			"else run nandboot; " \
+			"fi; " \
+		"fi; " \
+	"else run nandboot; fi"
+
+#define CONFIG_AUTO_COMPLETE	1
+/*
+ * Miscellaneous configurable options
+ */
+#define V_PROMPT		"Pandora # "
+
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_PROMPT		V_PROMPT
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		16	/* max number of command */
+						/* args */
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+/* memtest works on */
+#define CONFIG_SYS_MEMTEST_START	(OMAP34XX_SDRC_CS0)
+#define CONFIG_SYS_MEMTEST_END		(OMAP34XX_SDRC_CS0 + \
+					0x01F00000) /* 31MB */
+
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, */
+					/* in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		(OMAP34XX_SDRC_CS0) /* default load */
+								/* address */
+
+/*
+ * 2430 has 12 GP timers, they can be driven by the SysClk (12/13/19.2) or by
+ * 32KHz clk, or from external sig. This rate is divided by a local divisor.
+ */
+#define V_PVT				7
+
+#define CONFIG_SYS_TIMERBASE		(OMAP34XX_GPT2)
+#define CONFIG_SYS_PVT			V_PVT	/* 2^(pvt+1) */
+#define CONFIG_SYS_HZ			((V_SCLK) / (2 << CONFIG_SYS_PVT))
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	SZ_128K	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	SZ_4K	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	SZ_4K	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	2	/* CS1 may or may not be populated */
+#define PHYS_SDRAM_1		OMAP34XX_SDRC_CS0
+#define PHYS_SDRAM_1_SIZE	SZ_32M	/* at least 32 meg */
+#define PHYS_SDRAM_2		OMAP34XX_SDRC_CS1
+
+/* SDRAM Bank Allocation method */
+#define SDRC_R_B_C		1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+/* **** PISMO SUPPORT *** */
+
+/* Configure the PISMO */
+#define PISMO1_NAND_SIZE		GPMC_SIZE_128M
+#define PISMO1_ONEN_SIZE		GPMC_SIZE_128M
+
+#define CONFIG_SYS_MAX_FLASH_SECT	520	/* max number of sectors on */
+						/* one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* max number of flash banks */
+#define CONFIG_SYS_MONITOR_LEN		SZ_256K	/* Reserve 2 sectors */
+
+#define CONFIG_SYS_FLASH_BASE		boot_flash_base
+
+/* Monitor at start of flash */
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+#define CONFIG_SYS_ONENAND_BASE		ONENAND_MAP
+
+#define CONFIG_ENV_IS_IN_NAND		1
+#define ONENAND_ENV_OFFSET		0x240000 /* environment starts here */
+#define SMNAND_ENV_OFFSET		0x240000 /* environment starts here */
+
+#define CONFIG_SYS_ENV_SECT_SIZE	boot_flash_sec
+#define CONFIG_ENV_OFFSET		boot_flash_off
+#define CONFIG_ENV_ADDR			SMNAND_ENV_OFFSET
+
+/*-----------------------------------------------------------------------
+ * CFI FLASH driver setup
+ */
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(100 * CONFIG_SYS_HZ)
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(100 * CONFIG_SYS_HZ)
+
+/* Flash banks JFFS2 should use */
+#define CONFIG_SYS_MAX_MTD_BANKS	(CONFIG_SYS_MAX_FLASH_BANKS + \
+					CONFIG_SYS_MAX_NAND_DEVICE)
+#define CONFIG_SYS_JFFS2_MEM_NAND
+/* use flash_info[2] */
+#define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
+#define CONFIG_SYS_JFFS2_NUM_BANKS	1
+
+#ifndef __ASSEMBLY__
+extern gpmc_csx_t *nand_cs_base;
+extern gpmc_t *gpmc_cfg_base;
+extern unsigned int boot_flash_base;
+extern volatile unsigned int boot_flash_env_addr;
+extern unsigned int boot_flash_off;
+extern unsigned int boot_flash_sec;
+extern unsigned int boot_flash_type;
+#endif
+
+
+#define WRITE_NAND_COMMAND(d, adr)\
+			writel(d, &nand_cs_base->nand_cmd)
+#define WRITE_NAND_ADDRESS(d, adr)\
+			writel(d, &nand_cs_base->nand_adr)
+#define WRITE_NAND(d, adr) writew(d, &nand_cs_base->nand_dat)
+#define READ_NAND(adr) readl(&nand_cs_base->nand_dat)
+
+/* Other NAND Access APIs */
+#define NAND_WP_OFF() do {readl(&gpmc_cfg_base->config) |= GPMC_CONFIG_WP; } \
+			while (0)
+#define NAND_WP_ON() do {readl(&gpmc_cfg_base->config) &= ~GPMC_CONFIG_WP; } \
+			while (0)
+#define NAND_DISABLE_CE(nand)
+#define NAND_ENABLE_CE(nand)
+#define NAND_WAIT_READY(nand)	udelay(10)
+
+#endif				/* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/omap3_zoom1.h u-boot/include/configs/omap3_zoom1.h
--- u-boot-2009.01/include/configs/omap3_zoom1.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/omap3_zoom1.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,327 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments.
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Mohammed Khasim <x0khasim@ti.com>
+ * Nishanth Menon <nm@ti.com>
+ *
+ * Configuration settings for the TI OMAP3430 Zoom MDK board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+#include <asm/sizes.h>
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_ARMCORTEXA8	1	/* This is an ARM V7 CPU core */
+#define CONFIG_OMAP		1	/* in a TI OMAP core */
+#define CONFIG_OMAP34XX		1	/* which is a 34XX */
+#define CONFIG_OMAP3430		1	/* which is in a 3430 */
+#define CONFIG_OMAP3_ZOOM1	1	/* working with Zoom MDK Rev1 */
+
+#include <asm/arch/cpu.h>		/* get chip and board defs */
+#include <asm/arch/omap3.h>
+
+/* Clock Defines */
+#define V_OSCK			26000000	/* Clock output from T2 */
+#define V_SCLK			(V_OSCK >> 1)
+
+#undef CONFIG_USE_IRQ				/* no support for IRQs */
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_REVISION_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_ENV_SIZE			SZ_128K	/* Total Size Environment */
+						/* Sector */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + SZ_128K)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* bytes reserved for */
+						/* initial data */
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * NS16550 Configuration
+ */
+#define V_NS16550_CLK			48000000	/* 48MHz (APLL96/2) */
+
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		V_NS16550_CLK
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_CONS_INDEX		3
+#define CONFIG_SYS_NS16550_COM3		OMAP34XX_UART3
+#define CONFIG_SERIAL3			3	/* UART3 */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{4800, 9600, 19200, 38400, 57600,\
+					115200}
+#define CONFIG_MMC			1
+#define CONFIG_OMAP3_MMC		1
+#define CONFIG_DOS_PARTITION		1
+
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
+#define CONFIG_CMD_FAT		/* FAT support			*/
+#define CONFIG_CMD_JFFS2	/* JFFS2 Support		*/
+
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#define CONFIG_CMD_MMC		/* MMC support			*/
+#define CONFIG_CMD_NAND		/* NAND support			*/
+#define CONFIG_CMD_NAND_LOCK_UNLOCK /* Enable lock/unlock support */
+
+#undef CONFIG_CMD_FLASH		/* flinfo, erase, protect	*/
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#undef CONFIG_CMD_IMI		/* iminfo			*/
+#undef CONFIG_CMD_IMLS		/* List all found images	*/
+#undef CONFIG_CMD_NET		/* bootp, tftpboot, rarpboot	*/
+#undef CONFIG_CMD_NFS		/* NFS support			*/
+
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_SYS_I2C_BUS		0
+#define CONFIG_SYS_I2C_BUS_SELECT	1
+#define CONFIG_DRIVER_OMAP34XX_I2C	1
+
+/*
+ * Board NAND Info.
+ */
+#define CONFIG_NAND_OMAP_GPMC
+#define CONFIG_SYS_NAND_ADDR		NAND_BASE	/* physical address */
+							/* to access nand */
+#define CONFIG_SYS_NAND_BASE		NAND_BASE	/* physical address */
+							/* to access nand at */
+							/* CS0 */
+#define GPMC_NAND_ECC_LP_x16_LAYOUT	1
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of NAND */
+							/* devices */
+#define SECTORSIZE			512
+
+#define NAND_ALLOW_ERASE_ALL
+#define ADDR_COLUMN			1
+#define ADDR_PAGE			2
+#define ADDR_COLUMN_PAGE		3
+
+#define NAND_ChipID_UNKNOWN		0x00
+#define NAND_MAX_FLOORS			1
+#define NAND_MAX_CHIPS			1
+#define NAND_NO_RB			1
+#define CONFIG_SYS_NAND_WP
+
+#define CONFIG_JFFS2_NAND
+/* nand device jffs2 lives on */
+#define CONFIG_JFFS2_DEV		"nand0"
+/* start of jffs2 partition */
+#define CONFIG_JFFS2_PART_OFFSET	0x680000
+#define CONFIG_JFFS2_PART_SIZE		0xf980000	/* size of jffs2 */
+							/* partition */
+
+/* Environment information */
+#define CONFIG_BOOTDELAY		10
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x82000000\0" \
+	"console=ttyS2,115200n8\0" \
+	"videomode=1024x768@60,vxres=1024,vyres=768\0" \
+	"videospec=omapfb:vram:2M,vram:4M\0" \
+	"mmcargs=setenv bootargs console=${console} " \
+		"video=${videospec},mode:${videomode} " \
+		"root=/dev/mmcblk0p2 rw " \
+		"rootfstype=ext3 rootwait\0" \
+	"nandargs=setenv bootargs console=${console} " \
+		"video=${videospec},mode:${videomode} " \
+		"root=/dev/mtdblock4 rw " \
+		"rootfstype=jffs2\0" \
+	"loadbootscript=fatload mmc 0 ${loadaddr} boot.scr\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"autoscr ${loadaddr}\0" \
+	"loaduimage=fatload mmc 0 ${loadaddr} uImage\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootm ${loadaddr}\0" \
+	"nandboot=echo Booting from nand ...; " \
+		"run nandargs; " \
+		"nand read ${loadaddr} 280000 400000; " \
+		"bootm ${loadaddr}\0" \
+
+#define CONFIG_BOOTCOMMAND \
+	"if mmcinit; then " \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"else " \
+			"if run loaduimage; then " \
+				"run mmcboot; " \
+			"else run nandboot; " \
+			"fi; " \
+		"fi; " \
+	"else run nandboot; fi"
+
+#define CONFIG_AUTO_COMPLETE		1
+/*
+ * Miscellaneous configurable options
+ */
+#define V_PROMPT			"OMAP3 Zoom1# "
+
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_PROMPT		V_PROMPT
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		(CONFIG_SYS_CBSIZE)
+
+#define CONFIG_SYS_MEMTEST_START	(OMAP34XX_SDRC_CS0)	/* memtest */
+								/* works on */
+#define CONFIG_SYS_MEMTEST_END		(OMAP34XX_SDRC_CS0 + \
+					0x01F00000) /* 31MB */
+
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		(OMAP34XX_SDRC_CS0)	/* default */
+							/* load address */
+
+/*
+ * 2430 has 12 GP timers, they can be driven by the SysClk (12/13/19.2) or by
+ * 32KHz clk, or from external sig. This rate is divided by a local divisor.
+ */
+#define V_PVT				7
+
+#define CONFIG_SYS_TIMERBASE		(OMAP34XX_GPT2)
+#define CONFIG_SYS_PVT			V_PVT	/* 2^(pvt+1) */
+#define CONFIG_SYS_HZ			((V_SCLK) / (2 << CONFIG_SYS_PVT))
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	SZ_128K	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	SZ_4K	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	SZ_4K	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	2	/* CS1 may or may not be populated */
+#define PHYS_SDRAM_1		OMAP34XX_SDRC_CS0
+#define PHYS_SDRAM_1_SIZE	SZ_32M	/* at least 32 meg */
+#define PHYS_SDRAM_2		OMAP34XX_SDRC_CS1
+
+/* SDRAM Bank Allocation method */
+#define SDRC_R_B_C		1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+/* **** PISMO SUPPORT *** */
+
+/* Configure the PISMO */
+#define PISMO1_NAND_SIZE		GPMC_SIZE_128M
+#define PISMO1_ONEN_SIZE		GPMC_SIZE_128M
+
+#define CONFIG_SYS_MAX_FLASH_SECT	520	/* max number of sectors on */
+						/* one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* max number of flash banks */
+#define CONFIG_SYS_MONITOR_LEN		SZ_256K	/* Reserve 2 sectors */
+
+#define CONFIG_SYS_FLASH_BASE		boot_flash_base
+
+/* Monitor at start of flash */
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+#define CONFIG_SYS_ONENAND_BASE		ONENAND_MAP
+
+#define CONFIG_ENV_IS_IN_NAND		1
+#define ONENAND_ENV_OFFSET		0x260000 /* environment starts here */
+#define SMNAND_ENV_OFFSET		0x260000 /* environment starts here */
+
+#define CONFIG_SYS_ENV_SECT_SIZE	boot_flash_sec
+#define CONFIG_ENV_OFFSET		boot_flash_off
+#define CONFIG_ENV_ADDR			SMNAND_ENV_OFFSET
+
+/*-----------------------------------------------------------------------
+ * CFI FLASH driver setup
+ */
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(100 * CONFIG_SYS_HZ)
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(100 * CONFIG_SYS_HZ)
+
+/* Flash banks JFFS2 should use */
+#define CONFIG_SYS_MAX_MTD_BANKS	(CONFIG_SYS_MAX_FLASH_BANKS + \
+					CONFIG_SYS_MAX_NAND_DEVICE)
+#define CONFIG_SYS_JFFS2_MEM_NAND
+/* use flash_info[2] */
+#define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
+#define CONFIG_SYS_JFFS2_NUM_BANKS	1
+
+#ifndef __ASSEMBLY__
+extern gpmc_csx_t *nand_cs_base;
+extern gpmc_t *gpmc_cfg_base;
+extern unsigned int boot_flash_base;
+extern volatile unsigned int boot_flash_env_addr;
+extern unsigned int boot_flash_off;
+extern unsigned int boot_flash_sec;
+extern unsigned int boot_flash_type;
+#endif
+
+
+#define WRITE_NAND_COMMAND(d, adr)\
+			writel(d, &nand_cs_base->nand_cmd)
+#define WRITE_NAND_ADDRESS(d, adr)\
+			writel(d, &nand_cs_base->nand_adr)
+#define WRITE_NAND(d, adr) writew(d, &nand_cs_base->nand_dat)
+#define READ_NAND(adr) readl(&nand_cs_base->nand_dat)
+
+/* Other NAND Access APIs */
+#define NAND_WP_OFF() do {readl(&gpmc_cfg_base->config) |= GPMC_CONFIG_WP; } \
+			while (0)
+#define NAND_WP_ON() do {readl(&gpmc_cfg_base->config) &= ~GPMC_CONFIG_WP; } \
+			while (0)
+#define NAND_DISABLE_CE(nand)
+#define NAND_ENABLE_CE(nand)
+#define NAND_WAIT_READY(nand)	udelay(10)
+
+#endif				/* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/ORSG.h u-boot/include/configs/ORSG.h
--- u-boot-2009.01/include/configs/ORSG.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ORSG.h	2009-02-26 14:03:59.000000000 +0100
@@ -105,7 +105,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 
 /* The following table includes the supported baudrates */
diff -Naur u-boot-2009.01/include/configs/PATI.h u-boot/include/configs/PATI.h
--- u-boot-2009.01/include/configs/PATI.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PATI.h	2009-02-26 14:03:59.000000000 +0100
@@ -57,7 +57,7 @@
 #define CONFIG_CMD_REGINFO
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_LOADS
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_REGINFO
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_CONSOLE
diff -Naur u-boot-2009.01/include/configs/pb1x00.h u-boot/include/configs/pb1x00.h
--- u-boot-2009.01/include/configs/pb1x00.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/pb1x00.h	2009-02-26 14:03:59.000000000 +0100
@@ -198,7 +198,7 @@
 #define CONFIG_CMD_MII
 #define CONFIG_CMD_PING
 
-#undef CONFIG_CMD_ENV
+#undef CONFIG_CMD_SAVEENV
 #undef CONFIG_CMD_FAT
 #undef CONFIG_CMD_FLASH
 #undef CONFIG_CMD_FPGA
diff -Naur u-boot-2009.01/include/configs/PCI405.h u-boot/include/configs/PCI405.h
--- u-boot-2009.01/include/configs/PCI405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PCI405.h	2009-02-26 14:03:59.000000000 +0100
@@ -111,7 +111,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 
 /* The following table includes the supported baudrates */
diff -Naur u-boot-2009.01/include/configs/PCI5441.h u-boot/include/configs/PCI5441.h
--- u-boot-2009.01/include/configs/PCI5441.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PCI5441.h	2009-02-26 14:03:59.000000000 +0100
@@ -137,7 +137,7 @@
  */
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_ECHO
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_IRQ
diff -Naur u-boot-2009.01/include/configs/pdnb3.h u-boot/include/configs/pdnb3.h
--- u-boot-2009.01/include/configs/pdnb3.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/pdnb3.h	2009-02-26 14:03:59.000000000 +0100
@@ -68,6 +68,7 @@
 /* allow to overwrite serial and ethaddr */
 #define CONFIG_ENV_OVERWRITE
 
+#define CONFIG_IXP_SERIAL
 #define CONFIG_BAUDRATE         115200
 #define CONFIG_SYS_IXP425_CONSOLE	IXP425_UART1   /* we use UART1 for console */
 
@@ -264,7 +265,6 @@
  * NAND-FLASH stuff
  */
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_SYS_NAND_BASE		0x51000000	/* NAND FLASH Base Address	*/
 #endif
 
diff -Naur u-boot-2009.01/include/configs/pf5200.h u-boot/include/configs/pf5200.h
--- u-boot-2009.01/include/configs/pf5200.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/pf5200.h	2009-02-26 14:03:59.000000000 +0100
@@ -245,10 +245,11 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 /*
- * Define CONFIG_FEC_10MBIT to force FEC at 10Mb
+ * Define CONFIG_MPC5xxx_FEC_MII10 to force FEC at 10Mb
  */
-/* #define CONFIG_FEC_10MBIT 1 */
+/* #define CONFIG_MPC5xxx_FEC_MII10 */
 #define CONFIG_PHY_ADDR		0x00
 #define CONFIG_UDP_CHECKSUM	1
 
diff -Naur u-boot-2009.01/include/configs/PK1C20.h u-boot/include/configs/PK1C20.h
--- u-boot-2009.01/include/configs/PK1C20.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PK1C20.h	2009-02-26 14:03:59.000000000 +0100
@@ -177,7 +177,7 @@
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ECHO
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_IRQ
diff -Naur u-boot-2009.01/include/configs/pleb2.h u-boot/include/configs/pleb2.h
--- u-boot-2009.01/include/configs/pleb2.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/pleb2.h	2009-02-26 14:03:59.000000000 +0100
@@ -126,12 +126,17 @@
 
 #define CONFIG_SYS_LOAD_ADDR		0xa2000000	/* default load address */
 
-#define CONFIG_SYS_HZ			3686400		/* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 #define CONFIG_SYS_CPUSPEED		0x141		/* set core clock to 200/200/100 MHz */
 
 						/* valid baudrates */
 #define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
 
+#ifdef CONFIG_MMC
+#define CONFIG_PXA_MMC
+#define CONFIG_CMD_MMC
+#endif
+
 /*
  * Stack sizes
  *
diff -Naur u-boot-2009.01/include/configs/PLU405.h u-boot/include/configs/PLU405.h
--- u-boot-2009.01/include/configs/PLU405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PLU405.h	2009-02-26 14:03:59.000000000 +0100
@@ -138,7 +138,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 #undef	CONFIG_UART1_CONSOLE		/* define for uart1 as console	*/
 
@@ -173,7 +172,6 @@
  * NAND-FLASH stuff
  */
 #define CONFIG_SYS_NAND_BASE_LIST	{CONFIG_SYS_NAND_BASE}
-#define NAND_MAX_CHIPS          1
 #define CONFIG_SYS_MAX_NAND_DEVICE	1         /* Max number of NAND devices */
 #define NAND_BIG_DELAY_US	25
 
diff -Naur u-boot-2009.01/include/configs/PM520.h u-boot/include/configs/PM520.h
--- u-boot-2009.01/include/configs/PM520.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PM520.h	2009-02-26 14:03:59.000000000 +0100
@@ -279,10 +279,11 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 /*
- * Define CONFIG_FEC_10MBIT to force FEC at 10Mb
+ * Define CONFIG_MPC5xxx_FEC_MII10 to force FEC at 10Mb
  */
-/* #define CONFIG_FEC_10MBIT 1 */
+/* #define CONFIG_MPC5xxx_FEC_MII10 */
 #define CONFIG_PHY_ADDR		0x00
 
 /*
diff -Naur u-boot-2009.01/include/configs/PM854.h u-boot/include/configs/PM854.h
--- u-boot-2009.01/include/configs/PM854.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PM854.h	2009-02-26 14:03:59.000000000 +0100
@@ -331,7 +331,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/PM856.h u-boot/include/configs/PM856.h
--- u-boot-2009.01/include/configs/PM856.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PM856.h	2009-02-26 14:03:59.000000000 +0100
@@ -330,7 +330,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/PMC405.h u-boot/include/configs/PMC405.h
--- u-boot-2009.01/include/configs/PMC405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PMC405.h	2009-02-26 14:03:59.000000000 +0100
@@ -12,7 +12,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -21,16 +21,11 @@
  * MA 02111-1307 USA
  */
 
-/*
- * board/config.h - configuration options, board specific
- */
-
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
 /*
  * High Level Configuration Options
- * (easy to change)
  */
 
 #define CONFIG_405GP		1	/* This is a PPC405 CPU		*/
@@ -45,13 +40,22 @@
 #define CONFIG_BAUDRATE		9600
 #define CONFIG_BOOTDELAY	3	/* autoboot after 3 seconds	*/
 
-#undef	CONFIG_BOOTARGS
-#undef	CONFIG_BOOTCOMMAND
+/* Only interrupt boot if space is pressed. */
+#define CONFIG_AUTOBOOT_KEYED 1
+#define CONFIG_AUTOBOOT_PROMPT	\
+	"Press SPACE to abort autoboot in %d seconds\n", bootdelay
+#undef CONFIG_AUTOBOOT_DELAY_STR
+#define CONFIG_AUTOBOOT_STOP_STR " "
+
+#undef CONFIG_BOOTARGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_PREBOOT			/* enable preboot variable	*/
 
-#define CONFIG_PREBOOT                  /* enable preboot variable      */
+#define CFG_BOOTM_LEN		0x1000000 /* support booting of huge images */
 
 #define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
-#define CONFIG_SYS_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+#define CONFIG_SYS_LOADS_BAUD_CHANGE 1	/* allow baudrate change	*/
 
 #define CONFIG_NET_MULTI	1
 #undef  CONFIG_HAS_ETH1
@@ -59,11 +63,8 @@
 #define CONFIG_PPC4xx_EMAC
 #define CONFIG_MII		1	/* MII PHY management		*/
 #define CONFIG_PHY_ADDR		0	/* PHY address			*/
-#define CONFIG_LXT971_NO_SLEEP  1       /* disable sleep mode in LXT971 */
-#define CONFIG_RESET_PHY_R      1       /* use reset_phy() to disable phy sleep mode */
-
-#define CONFIG_NETCONSOLE		/* include NetConsole support	*/
-
+#define CONFIG_LXT971_NO_SLEEP	1	/* disable sleep mode in LXT971	*/
+#define CONFIG_RESET_PHY_R	1	/* use reset_phy()		*/
 
 /*
  * BOOTP options
@@ -73,7 +74,6 @@
 #define CONFIG_BOOTP_GATEWAY
 #define CONFIG_BOOTP_HOSTNAME
 
-
 /*
  * Command line configuration.
  */
@@ -91,250 +91,241 @@
 #define CONFIG_CMD_UNIVERSE
 #define CONFIG_CMD_EEPROM
 
-
 #define CONFIG_MAC_PARTITION
 #define CONFIG_DOS_PARTITION
 
-#undef	CONFIG_WATCHDOG			/* watchdog disabled		*/
+#undef CONFIG_WATCHDOG			/* watchdog disabled		*/
 
-#define CONFIG_RTC_MC146818             /* DS1685 is MC146818 compatible*/
-#define CONFIG_SYS_RTC_REG_BASE_ADDR	 0xF0000500 /* RTC Base Address         */
+#define CONFIG_RTC_MC146818		/* DS1685 is MC146818 compatible */
+#define CONFIG_SYS_RTC_REG_BASE_ADDR	0xF0000500 /* RTC Base Address */
 
 #define CONFIG_SDRAM_BANK0	1	/* init onboard SDRAM bank 0	*/
 
 /*
  * Miscellaneous configurable options
  */
-#define CONFIG_SYS_LONGHELP			/* undef to save memory		*/
-#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt	*/
+#define CONFIG_SYS_LONGHELP			/* undef to save memory */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
 
-#undef	CONFIG_SYS_HUSH_PARSER			/* use "hush" command parser	*/
-#ifdef	CONFIG_SYS_HUSH_PARSER
+#undef CONFIG_SYS_HUSH_PARSER			/* use "hush" command parser */
+#ifdef CONFIG_SYS_HUSH_PARSER
 #define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
 #endif
 
 #if defined(CONFIG_CMD_KGDB)
-#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
 #else
-#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_CBSIZE	512		/* Console I/O Buffer Size */
 #endif
-#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
-#define CONFIG_SYS_MAXARGS	16		/* max number of command args	*/
-#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE /* Boot Argument Buffer Sz */
 
-#define CONFIG_SYS_DEVICE_NULLDEV	1	/* include nulldev device	*/
+#define CONFIG_SYS_DEVICE_NULLDEV	1	/* include nulldev device */
 
-#define CONFIG_SYS_CONSOLE_INFO_QUIET	1	/* don't print console @ startup*/
+#define CONFIG_SYS_CONSOLE_INFO_QUIET	1	/* don't print console info */
 
-#define CONFIG_AUTO_COMPLETE	1       /* add autocompletion support   */
+#define CONFIG_AUTO_COMPLETE		1       /* add autocompletion support */
 
-#define CONFIG_SYS_MEMTEST_START	0x0400000	/* memtest works on	*/
-#define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
+#define CONFIG_SYS_MEMTEST_START	0x0400000 /* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x0C00000 /* 4 ... 12 MB in DRAM */
 
-#undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
-#define CONFIG_SYS_BASE_BAUD	    691200
+#undef CONFIG_SYS_EXT_SERIAL_CLOCK		/* no external serial clock */
+#define CONFIG_SYS_BASE_BAUD	806400
 
 /* The following table includes the supported baudrates */
 #define CONFIG_SYS_BAUDRATE_TABLE	\
-	{ 300, 600, 1200, 2400, 4800, 9600, 19200, 38400,     \
-	 57600, 115200, 230400, 460800, 921600 }
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
 
 #define CONFIG_SYS_LOAD_ADDR	0x100000	/* default load address */
-#define CONFIG_SYS_EXTBDINFO	1		/* To use extended board_into (bd_t) */
+#define CONFIG_SYS_EXTBDINFO	1	/* To use extended board_into (bd_t) */
 
-#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1 ms ticks */
+#define CONFIG_SYS_HZ		1000	/* decrementer freq: 1 ms ticks */
 
-#define CONFIG_LOOPW            1       /* enable loopw command         */
+#define CONFIG_CMDLINE_EDITING	1	/* add command line history */
+#define CONFIG_LOOPW		1	/* enable loopw command */
 
 #define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
 
 #define CONFIG_VERSION_VARIABLE 1	/* include version env variable */
 
-#define CONFIG_SYS_RX_ETH_BUFFER	16	/* use 16 rx buffer on 405 emac */
+#define CONFIG_SYS_RX_ETH_BUFFER	16
 
-/*-----------------------------------------------------------------------
+/*
  * PCI stuff
- *-----------------------------------------------------------------------
  */
-#define PCI_HOST_ADAPTER 0              /* configure as pci adapter     */
-#define PCI_HOST_FORCE  1               /* configure as pci host        */
-#define PCI_HOST_AUTO   2               /* detected via arbiter enable  */
-
-#define CONFIG_PCI			/* include pci support	        */
-#define CONFIG_PCI_HOST	PCI_HOST_AUTO   /* select pci host function     */
-#define CONFIG_PCI_PNP			/* do pci plug-and-play         */
-					/* resource configuration       */
-
-#define CONFIG_PCI_SCAN_SHOW            /* print pci devices @ startup  */
-
-#define CONFIG_PCI_CONFIG_HOST_BRIDGE 1 /* don't skip host bridge config*/
-
-#define CONFIG_PCI_BOOTDELAY    0       /* enable pci bootdelay variable*/
-
-#define CONFIG_SYS_PCI_SUBSYS_VENDORID 0x12FE  /* PCI Vendor ID: esd gmbh      */
-#define CONFIG_SYS_PCI_SUBSYS_DEVICEID_NONMONARCH 0x0408  /* PCI Device ID: Non-Monarch */
-#define CONFIG_SYS_PCI_SUBSYS_DEVICEID_MONARCH 0x0409     /* PCI Device ID: Monarch */
+#define PCI_HOST_ADAPTER	0	/* configure as pci adapter	*/
+#define PCI_HOST_FORCE		1	/* configure as pci host	*/
+#define PCI_HOST_AUTO		2	/* detected via arbiter enable	*/
+
+#define CONFIG_PCI			/* include pci support		*/
+#define CONFIG_PCI_HOST	PCI_HOST_AUTO   /* select pci host function	*/
+#define CONFIG_PCI_PNP			/* do pci plug-and-play		*/
+					/* resource configuration	*/
+
+#define CONFIG_PCI_SCAN_SHOW		/* print pci devices @ startup	*/
+
+#define CONFIG_PCI_CONFIG_HOST_BRIDGE 1	/* don't skip host bridge config */
+
+#define CONFIG_SYS_PCI_SUBSYS_VENDORID 0x12FE  /* PCI Vendor ID: esd gmbh */
+#define CONFIG_SYS_PCI_SUBSYS_DEVICEID_NONMONARCH 0x0408 /* PCI Device ID */
+#define CONFIG_SYS_PCI_SUBSYS_DEVICEID_MONARCH 0x0409 /* PCI Device ID */
 #define CONFIG_SYS_PCI_SUBSYS_DEVICEID pmc405_pci_subsys_deviceid()
 
-#define CONFIG_SYS_PCI_CLASSCODE       0x0b20  /* PCI Class Code: Processor/PPC*/
+#define CONFIG_SYS_PCI_CLASSCODE       0x0b20 /* Processor/PPC */
 
-#define CONFIG_SYS_PCI_PTM1LA  (bd->bi_memstart) /* point to sdram               */
-#define CONFIG_SYS_PCI_PTM1MS  (~(bd->bi_memsize - 1) | 1) /* memsize, enable hard-wired to 1 */
-#define CONFIG_SYS_PCI_PTM1PCI 0x00000000      /* Host: use this pci address   */
-#if 1
-#define CONFIG_SYS_PCI_PTM2LA	0xef000000	/* point to internal regs       */
-#define CONFIG_SYS_PCI_PTM2MS  0xff000001      /* 16MB, enable                 */
-#define CONFIG_SYS_PCI_PTM2PCI 0x00000000      /* Host: use this pci address   */
-#else /* old mapping */
-#define CONFIG_SYS_PCI_PTM2LA  0xffc00000      /* point to flash               */
-#define CONFIG_SYS_PCI_PTM2MS  0xffc00001      /* 4MB, enable                  */
-#define CONFIG_SYS_PCI_PTM2PCI 0x04000000      /* Host: use this pci address   */
-#endif
-/*-----------------------------------------------------------------------
+#define CONFIG_SYS_PCI_PTM1LA  (bd->bi_memstart) /* point to sdram	*/
+#define CONFIG_SYS_PCI_PTM1MS  (~(bd->bi_memsize - 1) | 1) /* memsize, enable */
+#define CONFIG_SYS_PCI_PTM1PCI 0x00000000	/* Host: use this pci address */
+#define CONFIG_SYS_PCI_PTM2LA  0xef000000	/* point to internal regs */
+#define CONFIG_SYS_PCI_PTM2MS  0xff000001	/* 16MB, enable */
+#define CONFIG_SYS_PCI_PTM2PCI 0x00000000	/* Host: use this pci address */
+
+/*
  * Start addresses for the final memory configuration
  * (Set up by the startup code)
  * Please note that CONFIG_SYS_SDRAM_BASE _must_ start at 0
  */
 #define CONFIG_SYS_SDRAM_BASE		0x00000000
-#define CONFIG_SYS_MONITOR_BASE	0xFFFC0000
-#define CONFIG_SYS_MONITOR_LEN		(256 * 1024)	/* Reserve 256 kB for Monitor	*/
-#define CONFIG_SYS_MALLOC_LEN		(128 * 1024)	/* Reserve 128 kB for malloc()	*/
+#define CONFIG_SYS_MONITOR_BASE		TEXT_BASE
+#define CONFIG_SYS_MONITOR_LEN		(~(TEXT_BASE) + 1)
+#define CONFIG_SYS_MALLOC_LEN		(128 * 1024) /* 128 kB for malloc() */
+
+#define CONFIG_PRAM			0 /* use pram variable to overwrite */
 
 /*
  * For booting Linux, the board info and command line data
  * have to be in the first 8 MB of memory, since this is
  * the maximum mapped by the Linux kernel during initialization.
  */
-#define CONFIG_SYS_BOOTMAPSZ		(8 << 20)	/* Initial Memory map for Linux */
+#define CONFIG_SYS_BOOTMAPSZ	(8 << 20) /* Initial Memory map for Linux */
 
-/*-----------------------------------------------------------------------
+/*
  * FLASH organization
  */
 #define CONFIG_SYS_FLASH_BASE		0xFE000000
 #define CONFIG_SYS_FLASH_INCREMENT	0x01000000
 
-#define CONFIG_SYS_FLASH_CFI         1       /* Flash is CFI conformant */
-#define CONFIG_FLASH_CFI_DRIVER  1       /* Use the common driver */
-#define CONFIG_SYS_FLASH_PROTECTION  1       /* don't use hardware protection        */
-#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1  /* use buffered writes (20x faster)     */
-#define CONFIG_SYS_MAX_FLASH_BANKS   2       /* max num of flash banks */
-#define CONFIG_SYS_FLASH_BANKS_LIST { CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE + CONFIG_SYS_FLASH_INCREMENT }
-#define CONFIG_SYS_MAX_FLASH_SECT    128     /* max num of sects on one chip */
-
-#define CONFIG_SYS_FLASH_EMPTY_INFO		/* print 'E' for empty sector on flinfo */
+#define CONFIG_SYS_FLASH_CFI		1 /* Flash is CFI conformant */
+#define CONFIG_FLASH_CFI_DRIVER		1 /* Use the common driver */
+#define CONFIG_SYS_FLASH_PROTECTION	1 /* don't use hardware protection */
+#define CONFIG_SYS_FLASH_AUTOPROTECT_LIST {{0xfff80000, 0x80000}}
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1 /* use buffered writes (faster) */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2 /* max num of flash banks */
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE, \
+			CONFIG_SYS_FLASH_BASE + CONFIG_SYS_FLASH_INCREMENT}
+#define CONFIG_SYS_MAX_FLASH_SECT	128 /* max num of sects on one chip */
+#define CONFIG_SYS_FLASH_EMPTY_INFO	/* print 'E' for empty sector on fli */
 
 /*
- * JFFS2 partitions - second bank contains u-boot
- *
- */
-/* No command line, one static partition, whole device */
-#undef CONFIG_JFFS2_CMDLINE
-#define CONFIG_JFFS2_DEV		"nor0"
-#define CONFIG_JFFS2_PART_SIZE		0x01b00000
-#define CONFIG_JFFS2_PART_OFFSET	0x00400000
-
-/* mtdparts command line support */
-/* Note: fake mtd_id used, no linux mtd map file */
-/*
-#define CONFIG_JFFS2_CMDLINE
-#define MTDIDS_DEFAULT		"nor0=pmc405-0"
-#define MTDPARTS_DEFAULT	"mtdparts=pmc405-0:-(jffs2)"
-*/
-
-/*-----------------------------------------------------------------------
  * Environment Variable setup
  */
 #define CONFIG_ENV_IS_IN_EEPROM	1	/* use EEPROM for environment vars */
-#define CONFIG_ENV_OFFSET		0x000	/* environment starts at the beginning of the EEPROM */
-#define CONFIG_ENV_SIZE		0x800	/* 2048 bytes may be used for env vars*/
-				   /* total size of a CAT24WC16 is 2048 bytes */
 
-#define CONFIG_SYS_NVRAM_BASE_ADDR	0xF0000500		/* NVRAM base address	*/
-#define CONFIG_SYS_NVRAM_SIZE		242			/* NVRAM size		*/
+/* environment starts at the beginning of the EEPROM */
+#define CONFIG_ENV_OFFSET	0x000
+#define CONFIG_ENV_SIZE		0x800 /* 2048 bytes may be used for env vars */
 
-/*-----------------------------------------------------------------------
+#define CONFIG_SYS_NVRAM_BASE_ADDR	0xF0000500	/* NVRAM base address */
+#define CONFIG_SYS_NVRAM_SIZE		242		/* NVRAM size */
+
+/*
  * I2C EEPROM (CAT24WC16) for environment
  */
 #define CONFIG_HARD_I2C			/* I2c with hardware support */
-#define CONFIG_SYS_I2C_SPEED		400000	/* I2C speed and slave address */
+#define CONFIG_SYS_I2C_SPEED		100000 /* I2C speed and slave address */
 #define CONFIG_SYS_I2C_SLAVE		0x7F
 
-#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50	/* EEPROM CAT28WC08		*/
-#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1	/* Bytes of address		*/
-/* mask of address bits that overflow into the "EEPROM chip address"	*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50	/* EEPROM CAT24W16 */
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1	/* Bytes of address */
+/* mask of address bits that overflow into the "EEPROM chip address" */
 #define CONFIG_SYS_I2C_EEPROM_ADDR_OVERFLOW	0x07
-#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 4	/* The Catalyst CAT24WC08 has	*/
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 4	/* The Catalyst CAT24W16 has */
 					/* 16 byte page write mode using*/
-					/* last 4 bits of the address	*/
-#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS	10   /* and takes up to 10 msec */
+					/* last	4 bits of the address */
 
-/*-----------------------------------------------------------------------
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 10 /* and takes up to 10 msec */
+
+/*
  * External Bus Controller (EBC) Setup
  */
-#define FLASH0_BA	0xFF000000	    /* FLASH 0 Base Address		*/
-#define FLASH1_BA	0xFE000000	    /* FLASH 1 Base Address		*/
-#define CAN_BA		0xF0000000	    /* CAN Base Address			*/
-#define RTC_BA		0xF0000500	    /* RTC Base Address			*/
-#define NVRAM_BA        0xF0200000          /* NVRAM Base Address               */
+#define FLASH0_BA	0xFF000000	/* FLASH 0 Base Address	*/
+#define FLASH1_BA	0xFE000000	/* FLASH 1 Base Address	*/
+#define CAN_BA		0xF0000000	/* CAN Base Addres	*/
+#define RTC_BA		0xF0000500	/* RTC Base Address	*/
+#define NVRAM_BA	0xF0200000	/* NVRAM Base Address	*/
 
-/* Memory Bank 0 (Flash Bank 0) initialization					*/
+/* Memory Bank 0 (Flash Bank 0) initialization */
 #define CONFIG_SYS_EBC_PB0AP	0x92015480
-#define CONFIG_SYS_EBC_PB0CR	FLASH0_BA | 0x9A000 /* BAS=0xFF0,BS=16MB,BU=R/W,BW=16bit*/
+/* BAS=0xFF0,BS=16MB,BU=R/W,BW=16bit */
+#define CONFIG_SYS_EBC_PB0CR	(FLASH0_BA | 0x9A000)
 
-/* Memory Bank 1 (Flash Bank 1) initialization					*/
+/* Memory Bank 1 (Flash Bank 1) initialization */
 #define CONFIG_SYS_EBC_PB1AP	0x92015480
-#define CONFIG_SYS_EBC_PB1CR	FLASH1_BA | 0x9A000 /* BAS=0xFE0,BS=16MB,BU=R/W,BW=16bit*/
+/* BAS=0xFE0,BS=16MB,BU=R/W,BW=16bit*/
+#define CONFIG_SYS_EBC_PB1CR	(FLASH1_BA | 0x9A000)
 
-/* Memory Bank 2 (CAN0, 1, RTC) initialization					*/
-#define CONFIG_SYS_EBC_PB2AP	0x03000440   /* TWT=5,TH=2,CSN=0,OEN=0,WBN=0,WBF=0      */
-#define CONFIG_SYS_EBC_PB2CR	CAN_BA | 0x18000    /* BAS=0xF00,BS=1MB,BU=R/W,BW=8bit	*/
+/* Memory Bank 2 (CAN0, 1, RTC) initialization */
+/* TWT=5,TH=2,CSN=0,OEN=0,WBN=0,WBF=0      */
+#define CONFIG_SYS_EBC_PB2AP	0x03000440
+/* BAS=0xF00,BS=1MB,BU=R/W,BW=8bit */
+#define CONFIG_SYS_EBC_PB2CR	(CAN_BA | 0x18000)
 
 /* Memory Bank 3 -> unused */
 
-/* Memory Bank 4 (NVRAM) initialization					*/
-#define CONFIG_SYS_EBC_PB4AP	0x03000440   /* TWT=5,TH=2,CSN=0,OEN=0,WBN=0,WBF=0      */
-#define CONFIG_SYS_EBC_PB4CR	NVRAM_BA | 0x18000    /* BAS=0xF00,BS=1MB,BU=R/W,BW=8bit	*/
+/* Memory Bank 4 (NVRAM) initialization */
+/* TWT=5,TH=2,CSN=0,OEN=0,WBN=0,WBF=0 */
+#define CONFIG_SYS_EBC_PB4AP	0x03000440
+/* BAS=0xF00,BS=1MB,BU=R/W,BW=8bit */
+#define CONFIG_SYS_EBC_PB4CR	(NVRAM_BA | 0x18000)
 
-/*-----------------------------------------------------------------------
+/*
  * FPGA stuff
  */
-#define CONFIG_SYS_FPGA_XC95XL		1	    /* using Xilinx XC95XL CPLD	     */
-#define CONFIG_SYS_FPGA_MAX_SIZE	32*1024	    /* 32kByte is enough for CPLD    */
+#define CONFIG_SYS_FPGA_XC95XL		1	/* using Xilinx XC95XL CPLD */
+#define CONFIG_SYS_FPGA_MAX_SIZE	(32 * 1024) /* 32kByte for CPLD */
 
 /* FPGA program pin configuration */
-#define CONFIG_SYS_FPGA_PRG		0x04000000  /* JTAG TMS pin (ppc output)     */
-#define CONFIG_SYS_FPGA_CLK		0x02000000  /* JTAG TCK pin (ppc output)     */
-#define CONFIG_SYS_FPGA_DATA		0x01000000  /* JTAG TDO->TDI data pin (ppc output) */
-#define CONFIG_SYS_FPGA_INIT		0x00010000  /* unused (ppc input)	     */
-#define CONFIG_SYS_FPGA_DONE		0x00008000  /* JTAG TDI->TDO pin (ppc input) */
+#define CONFIG_SYS_FPGA_PRG		0x04000000 /* JTAG TMS pin (output) */
+#define CONFIG_SYS_FPGA_CLK		0x02000000 /* JTAG TCK pin (output) */
+#define CONFIG_SYS_FPGA_DATA		0x01000000 /* JTAG TDO pin (output) */
+#define CONFIG_SYS_FPGA_INIT		0x00010000 /* unused (ppc input) */
+#define CONFIG_SYS_FPGA_DONE		0x00008000 /* JTAG TDI pin (input) */
 
-#define CONFIG_SYS_VXWORKS_MAC_PTR	0x00000000	/* Pass Ethernet MAC to VxWorks */
+/* pass Ethernet MAC to VxWorks */
+#define CONFIG_SYS_VXWORKS_MAC_PTR	0x00000000
 
-/*-----------------------------------------------------------------------
+/*
  * GPIOs
  */
-#define CONFIG_SYS_NONMONARCH		(0x80000000 >> 14)   /* GPIO24 */
-#define CONFIG_SYS_XEREADY		(0x80000000 >> 15)   /* GPIO15 */
-#define CONFIG_SYS_INTA_FAKE		(0x80000000 >> 19)   /* GPIO19 */
-#define CONFIG_SYS_SELF_RST		(0x80000000 >> 21)   /* GPIO21 */
-#define CONFIG_SYS_REV1_2		(0x80000000 >> 23)   /* GPIO23 */
+#define CONFIG_SYS_VPEN			(0x80000000 >>  3) /* GPIO3 */
+#define CONFIG_SYS_NONMONARCH		(0x80000000 >> 14) /* GPIO14 */
+#define CONFIG_SYS_XEREADY		(0x80000000 >> 15) /* GPIO15 */
+#define CONFIG_SYS_INTA_FAKE		(0x80000000 >> 19) /* GPIO19 */
+#define CONFIG_SYS_SELF_RST		(0x80000000 >> 21) /* GPIO21 */
+#define CONFIG_SYS_REV1_2		(0x80000000 >> 23) /* GPIO23 */
 
-/*-----------------------------------------------------------------------
+/*
  * Definitions for initial stack pointer and data area (in data cache)
  */
 
-/* use on chip memory ( OCM ) for temperary stack until sdram is tested */
+/* use on chip memory (OCM) for temperary stack until sdram is tested */
 #define CONFIG_SYS_TEMP_STACK_OCM	1
 
 /* On Chip Memory location */
 #define CONFIG_SYS_OCM_DATA_ADDR	0xF8000000
 #define CONFIG_SYS_OCM_DATA_SIZE	0x1000
 
-#define CONFIG_SYS_INIT_RAM_ADDR	CONFIG_SYS_OCM_DATA_ADDR /* inside of SDRAM		*/
-#define CONFIG_SYS_INIT_RAM_END	CONFIG_SYS_OCM_DATA_SIZE /* End of used area in RAM	*/
-#define CONFIG_SYS_GBL_DATA_SIZE      128  /* size in bytes reserved for initial data */
-#define CONFIG_SYS_GBL_DATA_OFFSET    (CONFIG_SYS_INIT_RAM_END - CONFIG_SYS_GBL_DATA_SIZE)
+/* inside of SDRAM */
+#define CONFIG_SYS_INIT_RAM_ADDR	CONFIG_SYS_OCM_DATA_ADDR
+
+/* End of used area in RAM */
+#define CONFIG_SYS_INIT_RAM_END		CONFIG_SYS_OCM_DATA_SIZE
+
+/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_SIZE	128
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_END - \
+					 CONFIG_SYS_GBL_DATA_SIZE)
 #define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
 
 /*
@@ -342,7 +333,10 @@
  *
  * Boot Flags
  */
-#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH	*/
-#define BOOTFLAG_WARM	0x02		/* Software reboot			*/
+#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02		/* Software reboot */
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
 
-#endif	/* __CONFIG_H */
+#endif /* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/PMC440.h u-boot/include/configs/PMC440.h
--- u-boot-2009.01/include/configs/PMC440.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PMC440.h	2009-02-26 14:03:59.000000000 +0100
@@ -505,7 +505,6 @@
  * NAND FLASH
  *----------------------------------------------------------------------*/
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_SYS_NAND_BASE		(CONFIG_SYS_NAND_ADDR + CONFIG_SYS_NAND_CS)
 #define CONFIG_SYS_NAND_SELECT_DEVICE	1 /* nand driver supports mutipl. chips */
 #define CONFIG_SYS_NAND_QUIET_TEST	1
diff -Naur u-boot-2009.01/include/configs/PN62.h u-boot/include/configs/PN62.h
--- u-boot-2009.01/include/configs/PN62.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PN62.h	2009-02-26 14:03:59.000000000 +0100
@@ -61,7 +61,7 @@
 
 #undef CONFIG_CMD_AUTOSCRIPT
 #undef CONFIG_CMD_LOADS
-#undef CONFIG_CMD_ENV
+#undef CONFIG_CMD_SAVEENV
 #undef CONFIG_CMD_FLASH
 #undef CONFIG_CMD_IMLS
 
diff -Naur u-boot-2009.01/include/configs/PPChameleonEVB.h u-boot/include/configs/PPChameleonEVB.h
--- u-boot-2009.01/include/configs/PPChameleonEVB.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/PPChameleonEVB.h	2009-02-26 14:03:59.000000000 +0100
@@ -192,7 +192,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK		/* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD		691200
 
 /* The following table includes the supported baudrates */
@@ -224,8 +223,6 @@
 #define NAND_BIG_DELAY_US	25
 #define CONFIG_SYS_MAX_NAND_DEVICE	2	/* Max number of NAND devices */
 
-#define NAND_MAX_CHIPS 1
-
 #define CONFIG_SYS_NAND0_CE  (0x80000000 >> 1)	 /* our CE is GPIO1 */
 #define CONFIG_SYS_NAND0_RDY (0x80000000 >> 4)	 /* our RDY is GPIO4 */
 #define CONFIG_SYS_NAND0_CLE (0x80000000 >> 2)	 /* our CLE is GPIO2 */
diff -Naur u-boot-2009.01/include/configs/ppmc7xx.h u-boot/include/configs/ppmc7xx.h
--- u-boot-2009.01/include/configs/ppmc7xx.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/ppmc7xx.h	2009-02-26 14:03:59.000000000 +0100
@@ -83,7 +83,7 @@
 #include <config_cmd_default.h>
 
 #define CONFIG_CMD_FLASH
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_RUN
 #define CONFIG_CMD_ELF
 #define CONFIG_CMD_NET
diff -Naur u-boot-2009.01/include/configs/pxa255_idp.h u-boot/include/configs/pxa255_idp.h
--- u-boot-2009.01/include/configs/pxa255_idp.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/pxa255_idp.h	2009-02-26 14:03:59.000000000 +0100
@@ -119,7 +119,6 @@
  */
 #include <config_cmd_default.h>
 
-#define CONFIG_CMD_MMC
 #define CONFIG_CMD_FAT
 #define CONFIG_CMD_DHCP
 
@@ -241,7 +240,7 @@
 
 #define CONFIG_SYS_LOAD_ADDR		0xa0800000	/* default load address */
 
-#define CONFIG_SYS_HZ			3686400		/* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 #define CONFIG_SYS_CPUSPEED		0x161		/* set core clock to 400/200/100 MHz */
 
 #define RTC	1				/* enable 32KHz osc */
@@ -249,7 +248,11 @@
 						/* valid baudrates */
 #define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
 
+#ifdef CONFIG_MMC
+#define CONFIG_PXA_MMC
+#define CONFIG_CMD_MMC
 #define CONFIG_SYS_MMC_BASE		0xF0000000
+#endif
 
 /*
  * Stack sizes
diff -Naur u-boot-2009.01/include/configs/qong.h u-boot/include/configs/qong.h
--- u-boot-2009.01/include/configs/qong.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/qong.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2009, Ilya Yanok, Emcraft Systems, <yanok@emcraft.com>
+ *
+ * Configuration settings for the Dave/DENX QongEVB-LITE board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/mx31-regs.h>
+
+ /* High Level Configuration Options */
+#define CONFIG_ARM1136		1	/* This is an arm1136 CPU core */
+#define CONFIG_MX31		1	/* in a mx31 */
+#define CONFIG_QONG		1
+#define CONFIG_MX31_HCLK_FREQ	26000000	/* 26MHz */
+#define CONFIG_MX31_CLK32	32768
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128 * 1024)
+/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_SIZE	128
+
+/*
+ * Hardware drivers
+ */
+
+#define CONFIG_MX31_UART	1
+#define CONFIG_SYS_MX31_UART1	1
+
+/* FPGA */
+#define CONFIG_QONG_FPGA	1
+#define CONFIG_FPGA_BASE	(CS1_BASE)
+
+#ifdef CONFIG_QONG_FPGA
+/* Ethernet */
+#define CONFIG_DNET		1
+#define CONFIG_DNET_BASE	(CS1_BASE + QONG_FPGA_PERIPH_SIZE)
+#define CONFIG_NET_MULTI	1
+
+/*
+ * Reducing the ARP timeout from default 5 seconds to 200ms we speed up the
+ * initial TFTP transfer, should the user wish one, significantly.
+ */
+#define CONFIG_ARP_TIMEOUT	200UL
+
+#endif /* CONFIG_QONG_FPGA */
+
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{9600, 19200, 38400, 57600, 115200}
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_JFFS2
+
+/*
+ * You can compile in a MAC address and your custom net settings by using
+ * the following syntax.
+ *
+ * #define CONFIG_ETHADDR		xx:xx:xx:xx:xx:xx
+ * #define CONFIG_SERVERIP		<server ip>
+ * #define CONFIG_IPADDR		<board ip>
+ * #define CONFIG_GATEWAYIP		<gateway ip>
+ * #define CONFIG_NETMASK		<your netmask>
+ */
+
+#define CONFIG_BOOTDELAY	5
+
+#define CONFIG_LOADADDR		0x80800000	/* loadaddr env var */
+
+#define xstr(s)	str(s)
+#define str(s)	#s
+
+#define	CONFIG_EXTRA_ENV_SETTINGS					\
+	"netdev=eth0\0"							\
+	"nfsargs=setenv bootargs root=/dev/nfs rw "			\
+		"nfsroot=${serverip}:${rootpath}\0"			\
+	"ramargs=setenv bootargs root=/dev/ram rw\0"			\
+	"addip=setenv bootargs ${bootargs} "				\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"	\
+		":${hostname}:${netdev}:off panic=1\0"			\
+	"addtty=setenv bootargs ${bootargs}"				\
+		" console=ttymxc0,${baudrate}\0"			\
+	"addmtd=setenv bootargs ${bootargs} ${mtdparts}\0"		\
+	"addmisc=setenv bootargs ${bootargs}\0"				\
+	"uboot_addr=a0000000\0"						\
+	"kernel_addr=a0080000\0"					\
+	"ramdisk_addr=a0300000\0"					\
+	"u-boot=qong/u-boot.bin\0"					\
+	"kernel_addr_r=80800000\0"					\
+	"hostname=qong\0"						\
+	"bootfile=qong/uImage\0"					\
+	"rootpath=/opt/eldk-4.2-arm/armVFP\0"				\
+	"flash_self=run ramargs addip addtty addmtd addmisc;"		\
+		"bootm ${kernel_addr} ${ramdisk_addr}\0"		\
+	"flash_nfs=run nfsargs addip addtty addmtd addmisc;"		\
+		"bootm ${kernel_addr}\0"				\
+	"net_nfs=tftp ${kernel_addr_r} ${bootfile};"			\
+		"run nfsargs addip addtty addmtd addmisc;"		\
+		"bootm\0"						\
+	"bootcmd=run flash_self\0"					\
+	"load=tftp ${loadaddr} ${u-boot}\0"				\
+	"update=protect off " xstr(CONFIG_SYS_MONITOR_BASE)		\
+		" +${filesize};era " xstr(CONFIG_SYS_MONITOR_BASE)	\
+		" +${filesize};cp.b ${fileaddr} "			\
+		xstr(CONFIG_SYS_MONITOR_BASE) " ${filesize}\0"		\
+	"upd=run load update\0"						\
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+		sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		32	/* max number of command args */
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+/* memtest works on first 255MB of RAM */
+#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM_1
+#define CONFIG_SYS_MEMTEST_END		(PHYS_SDRAM_1 + 0xff000000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_CMDLINE_EDITING	1
+
+#define CONFIG_MISC_INIT_R	1
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128 * 1024)	/* regular stack */
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+#define PHYS_SDRAM_1		CSD0_BASE
+#define PHYS_SDRAM_1_SIZE	0x10000000	/* 256 MB */
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_SYS_FLASH_BASE		CS0_BASE
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
+/* max number of sectors on one chip */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024
+/* Monitor at beginning of flash */
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+#define CONFIG_SYS_MONITOR_LEN		0x40000		/* Reserve 256KiB */
+
+#define	CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_SECT_SIZE	0x20000
+#define CONFIG_ENV_SIZE		CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + 0x40000)
+
+/* Address and size of Redundant Environment Sector	*/
+#define CONFIG_ENV_OFFSET_REDUND	(CONFIG_ENV_OFFSET + CONFIG_ENV_SIZE)
+#define CONFIG_ENV_SIZE_REDUND	CONFIG_ENV_SIZE
+
+/*-----------------------------------------------------------------------
+ * CFI FLASH driver setup
+ */
+/* Flash memory is CFI compliant */
+#define CONFIG_SYS_FLASH_CFI			1
+/* Use drivers/cfi_flash.c */
+#define CONFIG_FLASH_CFI_DRIVER			1
+/* Use buffered writes (~10x faster) */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE	1
+/* Use hardware sector protection */
+#define CONFIG_SYS_FLASH_PROTECTION		1
+
+/*
+ * JFFS2 partitions
+ */
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT		"nor0=physmap-flash.0"
+#define MTDPARTS_DEFAULT	\
+	"mtdparts=physmap-flash.0:256k(U-Boot),128k(env1),"	\
+	"128k(env2),2560k(kernel),13m(ramdisk),-(user)"
+
+#endif /* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/QS823.h u-boot/include/configs/QS823.h
--- u-boot-2009.01/include/configs/QS823.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/QS823.h	2009-02-26 14:03:59.000000000 +0100
@@ -211,7 +211,7 @@
 #define CONFIG_CMD_BOOTD
 #define CONFIG_CMD_CONSOLE
 #define CONFIG_CMD_DATE
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_IMMAP
diff -Naur u-boot-2009.01/include/configs/QS850.h u-boot/include/configs/QS850.h
--- u-boot-2009.01/include/configs/QS850.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/QS850.h	2009-02-26 14:03:59.000000000 +0100
@@ -211,7 +211,7 @@
 #define CONFIG_CMD_BOOTD
 #define CONFIG_CMD_CONSOLE
 #define CONFIG_CMD_DATE
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_IMMAP
diff -Naur u-boot-2009.01/include/configs/quad100hd.h u-boot/include/configs/quad100hd.h
--- u-boot-2009.01/include/configs/quad100hd.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/quad100hd.h	2009-02-26 14:03:59.000000000 +0100
@@ -224,7 +224,6 @@
 #define CONFIG_SYS_NAND_CE	24   /* our CE is GPIO24  */
 #define CONFIG_SYS_NAND_CLE	31   /* our CLE is GPIO31 */
 #define CONFIG_SYS_NAND_ALE	30   /* our ALE is GPIO30 */
-#define NAND_MAX_CHIPS	1
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
 #endif
 
diff -Naur u-boot-2009.01/include/configs/r7780mp.h u-boot/include/configs/r7780mp.h
--- u-boot-2009.01/include/configs/r7780mp.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/r7780mp.h	2009-02-26 14:03:59.000000000 +0100
@@ -43,7 +43,7 @@
 #define CONFIG_CMD_PCI
 #define CONFIG_CMD_NET
 #define CONFIG_CMD_PING
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_NFS
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_EXT2
diff -Naur u-boot-2009.01/include/configs/rsk7203.h u-boot/include/configs/rsk7203.h
--- u-boot-2009.01/include/configs/rsk7203.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/rsk7203.h	2009-02-26 14:03:59.000000000 +0100
@@ -37,7 +37,7 @@
 #define CONFIG_CMD_NET
 #define CONFIG_CMD_NFS
 #define CONFIG_CMD_PING
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_SDRAM
 #define CONFIG_CMD_MEMORY
 #define CONFIG_CMD_CACHE
diff -Naur u-boot-2009.01/include/configs/sbc2410x.h u-boot/include/configs/sbc2410x.h
--- u-boot-2009.01/include/configs/sbc2410x.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/sbc2410x.h	2009-02-26 14:03:59.000000000 +0100
@@ -209,7 +209,6 @@
 
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS 1
-#define NAND_MAX_CHIPS 1
 
 #define NAND_WAIT_READY(nand)	NF_WaitRB()
 #define NAND_DISABLE_CE(nand)	NF_SetCE(NFCE_HIGH)
diff -Naur u-boot-2009.01/include/configs/sbc405.h u-boot/include/configs/sbc405.h
--- u-boot-2009.01/include/configs/sbc405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/sbc405.h	2009-02-26 14:03:59.000000000 +0100
@@ -147,7 +147,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef CONFIG_SYS_EXT_SERIAL_CLOCK		/* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD		691200
 
 /* The following table includes the supported baudrates */
diff -Naur u-boot-2009.01/include/configs/sbc8240.h u-boot/include/configs/sbc8240.h
--- u-boot-2009.01/include/configs/sbc8240.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/sbc8240.h	2009-02-26 14:03:59.000000000 +0100
@@ -96,7 +96,7 @@
 #define CONFIG_CMD_BSP
 #define CONFIG_CMD_DIAG
 #define CONFIG_CMD_ELF
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_PCI
 #define CONFIG_CMD_PING
diff -Naur u-boot-2009.01/include/configs/sbc8349.h u-boot/include/configs/sbc8349.h
--- u-boot-2009.01/include/configs/sbc8349.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/sbc8349.h	2009-02-26 14:03:59.000000000 +0100
@@ -455,7 +455,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/SBC8540.h u-boot/include/configs/SBC8540.h
--- u-boot-2009.01/include/configs/SBC8540.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/SBC8540.h	2009-02-26 14:03:59.000000000 +0100
@@ -382,7 +382,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/sbc8560.h u-boot/include/configs/sbc8560.h
--- u-boot-2009.01/include/configs/sbc8560.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/sbc8560.h	2009-02-26 14:03:59.000000000 +0100
@@ -380,7 +380,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT) || defined(CONFIG_RAM_AS_FLASH)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/sc3.h u-boot/include/configs/sc3.h
--- u-boot-2009.01/include/configs/sc3.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/sc3.h	2009-02-26 14:03:59.000000000 +0100
@@ -424,7 +424,6 @@
  * NAND-FLASH stuff
  */
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_SYS_NAND_BASE		0x77D00000
 
 
diff -Naur u-boot-2009.01/include/configs/sc520_cdp.h u-boot/include/configs/sc520_cdp.h
--- u-boot-2009.01/include/configs/sc520_cdp.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/sc520_cdp.h	2009-02-26 14:03:59.000000000 +0100
@@ -47,7 +47,6 @@
 #define CONFIG_SYS_SDRAM_CAS_LATENCY_3T
 
 #define CONFIG_SYS_SC520_HIGH_SPEED    0       /* 100 or 133MHz */
-#define CONFIG_SYS_RESET_GENERIC       1       /* use tripple-fault to reset cpu */
 #undef  CONFIG_SYS_RESET_SC520                 /* use SC520 MMCR's to reset cpu */
 #undef  CONFIG_SYS_TIMER_SC520                 /* use SC520 swtimers */
 #define CONFIG_SYS_TIMER_GENERIC       1       /* use the i8254 PIT timers */
diff -Naur u-boot-2009.01/include/configs/sc520_spunk.h u-boot/include/configs/sc520_spunk.h
--- u-boot-2009.01/include/configs/sc520_spunk.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/sc520_spunk.h	2009-02-26 14:03:59.000000000 +0100
@@ -45,7 +45,6 @@
 #define CONFIG_SYS_SDRAM_CAS_LATENCY_3T
 
 #define CONFIG_SYS_SC520_HIGH_SPEED    0       /* 100 or 133MHz */
-#define CONFIG_SYS_RESET_GENERIC       1       /* use tripple-fault to reset cpu */
 #undef  CONFIG_SYS_RESET_SC520                 /* use SC520 MMCR's to reset cpu */
 #undef  CONFIG_SYS_TIMER_SC520                 /* use SC520 swtimers */
 #define CONFIG_SYS_TIMER_GENERIC       1       /* use the i8254 PIT timers */
diff -Naur u-boot-2009.01/include/configs/sequoia.h u-boot/include/configs/sequoia.h
--- u-boot-2009.01/include/configs/sequoia.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/sequoia.h	2009-02-26 14:03:59.000000000 +0100
@@ -373,7 +373,6 @@
  * NAND FLASH
  */
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_SYS_NAND_BASE		(CONFIG_SYS_NAND_ADDR + CONFIG_SYS_NAND_CS)
 #define CONFIG_SYS_NAND_SELECT_DEVICE  1	/* nand driver supports mutipl. chips */
 
diff -Naur u-boot-2009.01/include/configs/sh7763rdp.h u-boot/include/configs/sh7763rdp.h
--- u-boot-2009.01/include/configs/sh7763rdp.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/sh7763rdp.h	2009-02-26 14:03:59.000000000 +0100
@@ -40,7 +40,7 @@
 #define CONFIG_CMD_MEMORY
 #define CONFIG_CMD_NET
 #define CONFIG_CMD_PING
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_NFS
 #define CONFIG_CMD_JFFS2
 
@@ -118,6 +118,7 @@
 #define CONFIG_SYS_HZ				(CONFIG_SYS_CLK_FREQ / TMU_CLK_DIVIDER)
 
 /* Ether */
+#define CONFIG_NET_MULTI 1
 #define CONFIG_SH_ETHER 1
 #define CONFIG_SH_ETHER_USE_PORT (1)
 #define CONFIG_SH_ETHER_PHY_ADDR (0x01)
diff -Naur u-boot-2009.01/include/configs/sh7785lcr.h u-boot/include/configs/sh7785lcr.h
--- u-boot-2009.01/include/configs/sh7785lcr.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/sh7785lcr.h	2009-02-26 14:03:59.000000000 +0100
@@ -40,7 +40,7 @@
 #define CONFIG_CMD_DFL
 #define CONFIG_CMD_SDRAM
 #define CONFIG_CMD_RUN
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 
 #define CONFIG_CMD_USB
 #define CONFIG_USB_STORAGE
@@ -123,7 +123,6 @@
 #undef	CONFIG_SYS_DIRECT_FLASH_TFTP
 
 /* R8A66597 */
-#define LITTLEENDIAN			/* for include/usb.h */
 #define CONFIG_USB_R8A66597_HCD
 #define CONFIG_R8A66597_BASE_ADDR	SH7785LCR_USB_BASE
 #define CONFIG_R8A66597_XTAL		0x0000	/* 12MHz */
diff -Naur u-boot-2009.01/include/configs/SIMPC8313.h u-boot/include/configs/SIMPC8313.h
--- u-boot-2009.01/include/configs/SIMPC8313.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/SIMPC8313.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,547 @@
+/*
+ * Copyright (C) Sheldon Instruments, Inc. 2008
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * simpc8313 board configuration file
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_NAND_U_BOOT
+
+#define CONFIG_E300			1
+#define CONFIG_MPC83XX			1
+#define CONFIG_MPC831X			1
+#define CONFIG_MPC8313			1
+
+#define CONFIG_PCI
+#define CONFIG_83XX_GENERIC_PCI
+
+#define CONFIG_MISC_INIT_R
+
+/*
+ * On-board devices
+ *
+ * TSEC1 is Marvell PHY 88E1118
+ */
+
+#define CONFIG_SYS_33MHZ
+
+#define CONFIG_83XX_CLKIN		33333333	/* in Hz */
+
+#define CONFIG_SYS_CLK_FREQ		CONFIG_83XX_CLKIN
+
+#define CONFIG_SYS_IMMR			0xE0000000
+
+#if defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CONFIG_DEFAULT_IMMR		CONFIG_SYS_IMMR
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	0x00001000
+#define CONFIG_SYS_MEMTEST_END		0x07f00000
+
+#define CONFIG_SYS_ACR_PIPE_DEP		3	/* Arbiter pipeline depth (0-3) */
+#define CONFIG_SYS_ACR_RPTCNT		3	/* Arbiter repeat count (0-7) */
+
+/*
+ * Device configurations
+ */
+#define CONFIG_TSEC1
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_SYS_DDR_BASE		0x00000000	/* DDR is system memory*/
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_BASE
+#define CONFIG_SYS_DDR_SDRAM_BASE	CONFIG_SYS_DDR_BASE
+
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_MAX_MEM_MAPPED		(512 << 20)
+
+#define CONFIG_SYS_DDRCDR		( DDRCDR_EN \
+					| DDRCDR_PZ_NOMZ \
+					| DDRCDR_NZ_NOMZ \
+					| DDRCDR_M_ODR )
+					/* 0x73000002 TODO ODR & DRN ? */
+
+/*
+ * FLASH on the Local Bus
+ */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_SYS_MONITOR_BASE	TEXT_BASE	/* start of monitor */
+
+#if !defined(CONFIG_NAND_SPL)
+#define CONFIG_SYS_RAMBOOT
+#endif
+
+#define CONFIG_SYS_INIT_RAM_LOCK	1
+#define CONFIG_SYS_INIT_RAM_ADDR	0xFD000000	/* Initial RAM address */
+#define CONFIG_SYS_INIT_RAM_END		0x1000		/* End of used area in RAM*/
+
+#define CONFIG_SYS_GBL_DATA_SIZE	0x100		/* num bytes initial data */
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_END - CONFIG_SYS_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+/* CONFIG_SYS_MONITOR_LEN must be a multiple of CONFIG_ENV_SECT_SIZE */
+#define CONFIG_SYS_MONITOR_LEN		(256 * 1024)	/* Reserve 256 kB for Mon */
+#define CONFIG_SYS_MALLOC_LEN		(512 * 1024)	/* Reserved for malloc */
+
+/*
+ * Local Bus LCRR and LBCR regs
+ */
+#define CONFIG_SYS_LCRR		(LCRR_DBYP | LCRR_EADC_1 | LCRR_CLKDIV_2)
+#define CONFIG_SYS_LBC_LBCR	(0x00040000 /* TODO */ \
+				| (0xFF << LBCR_BMT_SHIFT) \
+				| 0xF )	/* 0x0004ff0f */
+
+#define CONFIG_SYS_LBC_MRTPR	0x20000000	/* LB refresh timer prescal, 266MHz/32 */
+
+/* drivers/mtd/nand/nand.c */
+#ifdef CONFIG_NAND_SPL
+#define CONFIG_SYS_NAND_BASE		0xFFF00000
+#else
+#define CONFIG_SYS_NAND_BASE		0xE2800000
+#endif
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define NAND_MAX_CHIPS			1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND 		1
+#define CONFIG_NAND_FSL_ELBC		1
+
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(512 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_DST	0x00100000
+#define CONFIG_SYS_NAND_U_BOOT_START	0x00100100
+#define CONFIG_SYS_NAND_U_BOOT_RELOC	0x00010000
+
+#define CONFIG_SYS_NAND_BR_PRELIM	( CONFIG_SYS_NAND_BASE \
+					| (2<<BR_DECC_SHIFT)	/* Use HW ECC */ \
+					| BR_PS_8		/* Port Size = 8 bit */ \
+					| BR_MS_FCM		/* MSEL = FCM */ \
+					| BR_V )		/* valid */
+
+#ifdef CONFIG_NAND_SP
+#define CONFIG_SYS_NAND_OR_PRELIM	( 0xFFFF8000	/* length 32K */ \
+					| OR_FCM_CSCT \
+					| OR_FCM_CST \
+					| OR_FCM_CHT \
+					| OR_FCM_SCY_1 \
+					| OR_FCM_TRLX \
+					| OR_FCM_EHTR )
+#define CONFIG_SYS_LBLAWAR0_PRELIM	0x8000000E	/* 32KB */
+#define CONFIG_SYS_NAND_PAGE_SIZE	(512)		/* NAND chip page size */
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(16 << 10)	/* NAND chip block size */
+#define NAND_CACHE_PAGES		32
+#elif defined(CONFIG_NAND_LP)
+#define CONFIG_SYS_NAND_OR_PRELIM	( 0xFFFC0000	/* length 256K */ \
+					| OR_FCM_PGS \
+					| OR_FCM_CSCT \
+					| OR_FCM_CST \
+					| OR_FCM_CHT \
+					| OR_FCM_SCY_1 \
+					| OR_FCM_TRLX \
+					| OR_FCM_EHTR )
+#define CONFIG_SYS_LBLAWAR0_PRELIM	0x80000011	/* 256KB */
+#define CONFIG_SYS_NAND_PAGE_SIZE	(2048)		/* NAND chip page size */
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 << 10)	/* NAND chip block size */
+#define NAND_CACHE_PAGES		64
+#else
+#error Page size of NAND not defined.
+#endif /* CONFIG_NAND_SP */
+
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	CONFIG_SYS_NAND_BLOCK_SIZE
+
+#define CONFIG_SYS_BR0_PRELIM		CONFIG_SYS_NAND_BR_PRELIM
+#define CONFIG_SYS_OR0_PRELIM		CONFIG_SYS_NAND_OR_PRELIM
+
+#define CONFIG_SYS_LBLAWBAR0_PRELIM	CONFIG_SYS_NAND_BASE
+
+#define CONFIG_SYS_NAND_LBLAWBAR_PRELIM	CONFIG_SYS_LBLAWBAR0_PRELIM
+#define CONFIG_SYS_NAND_LBLAWAR_PRELIM	CONFIG_SYS_LBLAWAR0_PRELIM
+
+/*
+ * JFFS2 configuration
+ */
+#define CONFIG_JFFS2_NAND
+#define CONFIG_JFFS2_DEV	"nand0"
+
+/* mtdparts command line support */
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT		"nand0=nand0"
+#define MTDPARTS_DEFAULT	"mtdparts=nand0:2M(u-boot),6M(kernel),-(jffs2)"
+
+/* pass open firmware flat tree */
+#define CONFIG_OF_LIBFDT		1
+#define CONFIG_OF_BOARD_SETUP		1
+#define CONFIG_OF_STDOUT_VIA_ALIAS	1
+
+/*
+ * Serial Port
+ */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#ifdef CONFIG_NAND_SPL
+#define CONFIG_NS16550_MIN_FUNCTIONS
+#endif
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 115200}
+
+#define CONFIG_SYS_NS16550_COM1		(CONFIG_SYS_IMMR+0x4500)
+#define CONFIG_SYS_NS16550_COM2		(CONFIG_SYS_IMMR+0x4600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+
+/* I2C */
+#define CONFIG_HARD_I2C			/* I2C with hardware support*/
+#define CONFIG_FSL_I2C
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		400000	/* I2C speed and slave address */
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_NOPROBES		{{0,0x69}} /* Don't probe these addrs */
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+#define CONFIG_SYS_I2C2_OFFSET		0x3100
+
+/*
+ * General PCI
+ * Addresses are mapped 1-1.
+ */
+#define CONFIG_SYS_PCI1_MEM_BASE	0x80000000
+#define CONFIG_SYS_PCI1_MEM_PHYS	CONFIG_SYS_PCI1_MEM_BASE
+#define CONFIG_SYS_PCI1_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCI1_MMIO_BASE	0x90000000
+#define CONFIG_SYS_PCI1_MMIO_PHYS	CONFIG_SYS_PCI1_MMIO_BASE
+#define CONFIG_SYS_PCI1_MMIO_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCI1_IO_BASE		0x00000000
+#define CONFIG_SYS_PCI1_IO_PHYS		0xE2000000
+#define CONFIG_SYS_PCI1_IO_SIZE		0x00100000	/* 1M */
+
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+#define CONFIG_SYS_PCI_SUBSYS_VENDORID	0x1057	/* Motorola */
+
+/*
+ * TSEC
+ */
+#define CONFIG_TSEC_ENET		/* TSEC ethernet support */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_GMII			/* MII PHY management */
+
+#ifdef CONFIG_TSEC1
+#define CONFIG_HAS_ETH0
+#define CONFIG_TSEC1_NAME		"TSEC0"
+#define CONFIG_SYS_TSEC1_OFFSET		0x24000
+#define TSEC1_PHY_ADDR			0x0
+#define TSEC1_FLAGS			TSEC_GIGABIT
+#define TSEC1_PHYIDX			0
+#endif
+
+#ifdef CONFIG_TSEC2
+#define CONFIG_HAS_ETH1
+#define CONFIG_TSEC2_NAME		"TSEC1"
+#define CONFIG_SYS_TSEC2_OFFSET		0x25000
+#define TSEC2_PHY_ADDR			4
+#define TSEC2_FLAGS			TSEC_GIGABIT
+#define TSEC2_PHYIDX			0
+#endif
+
+
+/* Options are: TSEC[0-1] */
+#define CONFIG_ETHPRIME			"TSEC1"
+
+/*
+ * Configure on-board RTC
+ */
+#define CONFIG_RTC_DS1337
+#define CONFIG_SYS_I2C_RTC_ADDR		0x68
+
+/*
+ * Environment
+ */
+#if defined(CONFIG_NAND_U_BOOT)
+	#define CONFIG_ENV_IS_IN_NAND		1
+	#define CONFIG_ENV_OFFSET		(768 * 1024)
+	#define CONFIG_ENV_SECT_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
+	#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+	#define CONFIG_ENV_SIZE_REDUND		CONFIG_ENV_SIZE
+	#define CONFIG_ENV_RANGE		(CONFIG_ENV_SECT_SIZE * 4)
+	#define CONFIG_ENV_OFFSET_REDUND	(CONFIG_ENV_OFFSET + CONFIG_ENV_RANGE)
+#elif !defined(CONFIG_SYS_RAMBOOT)
+	#define CONFIG_ENV_IS_IN_FLASH		1
+	#define CONFIG_ENV_ADDR			(CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)
+	#define CONFIG_ENV_SECT_SIZE		0x10000	/* 64K(one sector) for env */
+	#define CONFIG_ENV_SIZE			0x2000
+
+/* Address and size of Redundant Environment Sector */
+#else
+	#define CONFIG_ENV_IS_NOWHERE		1	/* Store ENV in memory only */
+	#define CONFIG_ENV_ADDR			(CONFIG_SYS_MONITOR_BASE - 0x1000)
+	#define CONFIG_ENV_SIZE			0x2000
+#endif
+
+#define CONFIG_LOADS_ECHO			1	/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE		1	/* allow baudrate change */
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_FLASH
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_JFFS2
+
+#if defined(CONFIG_SYS_RAMBOOT) && !defined(CONFIG_NAND_U_BOOT)
+	#undef CONFIG_CMD_SAVEENV
+	#undef CONFIG_CMD_LOADS
+#endif
+
+#define CONFIG_CMDLINE_EDITING		1
+
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory */
+#define CONFIG_SYS_LOAD_ADDR		0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT		"=> "		/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024		/* Console I/O Buffer Size */
+
+#define CONFIG_SYS_PBSIZE		( CONFIG_SYS_CBSIZE		\
+					+ sizeof(CONFIG_SYS_PROMPT)	\
+					+ 16 )	/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ			1000		/* decrementer freq: 1ms ticks */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ		(8 << 20)	/* Initial Memory map for Linux*/
+
+#define CONFIG_SYS_RCWH_PCIHOST		0x80000000	/* PCIHOST */
+
+#define CONFIG_SYS_HRCW_LOW		( HRCWL_LCL_BUS_TO_SCB_CLK_1X1	\
+					| 0x20000000 /* reserved */	\
+					| HRCWL_DDR_TO_SCB_CLK_2X1	\
+					| HRCWL_CSB_TO_CLKIN_4X1	\
+					| HRCWL_CORE_TO_CSB_2_5X1 )
+
+#define CONFIG_SYS_NS16550_CLK		(CONFIG_83XX_CLKIN * 4)
+
+#define CONFIG_SYS_HRCW_HIGH_BASE	( HRCWH_PCI_HOST		\
+					| HRCWH_PCI1_ARBITER_ENABLE	\
+					| HRCWH_CORE_ENABLE		\
+					| HRCWH_BOOTSEQ_DISABLE		\
+					| HRCWH_SW_WATCHDOG_DISABLE	\
+					| HRCWH_TSEC1M_IN_RGMII		\
+					| HRCWH_TSEC2M_IN_RGMII		\
+					| HRCWH_BIG_ENDIAN		\
+					| HRCWH_LALE_NORMAL )
+
+#ifdef CONFIG_NAND_LP
+#define CONFIG_SYS_HRCW_HIGH	( CONFIG_SYS_HRCW_HIGH_BASE		\
+				| HRCWH_FROM_0XFFF00100			\
+				| HRCWH_ROM_LOC_NAND_LP_8BIT		\
+				| HRCWH_RL_EXT_NAND)
+#else
+#define CONFIG_SYS_HRCW_HIGH	( CONFIG_SYS_HRCW_HIGH_BASE		\
+				| HRCWH_FROM_0XFFF00100			\
+				| HRCWH_ROM_LOC_NAND_SP_8BIT		\
+				| HRCWH_RL_EXT_NAND )
+#endif
+
+/* System IO Config */
+#define CONFIG_SYS_SICRH	( SICRH_ETSEC2_B	\
+				| SICRH_ETSEC2_C	\
+				| SICRH_ETSEC2_D	\
+				| SICRH_ETSEC2_E	\
+				| SICRH_ETSEC2_F	\
+				| SICRH_ETSEC2_G	\
+				| SICRH_TSOBI1		\
+				| SICRH_TSOBI2 )
+#define CONFIG_SYS_SICRL	(SICRL_USBDR		\
+				| SICRL_ETSEC2_A )
+
+#define CONFIG_SYS_HID0_INIT	0x000000000
+#define CONFIG_SYS_HID0_FINAL	(HID0_ENABLE_MACHINE_CHECK	\
+				| HID0_ENABLE_DYNAMIC_POWER_MANAGMENT )
+
+#define CONFIG_SYS_HID2		HID2_HBE
+
+#define CONFIG_HIGH_BATS	1	/* High BATs supported */
+
+/* DDR @ 0x00000000 */
+#define CONFIG_SYS_IBAT0L	(CONFIG_SYS_SDRAM_BASE | BATL_PP_10)
+#define CONFIG_SYS_IBAT0U	(CONFIG_SYS_SDRAM_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+#define CONFIG_SYS_IBAT1L	((CONFIG_SYS_SDRAM_BASE + 0x10000000) | BATL_PP_10)
+#define CONFIG_SYS_IBAT1U	((CONFIG_SYS_SDRAM_BASE + 0x10000000) | BATU_BL_256M | BATU_VS | BATU_VP)
+
+/* PCI @ 0x80000000 */
+#define CONFIG_SYS_IBAT2L	(CONFIG_SYS_PCI1_MEM_BASE | BATL_PP_10)
+#define CONFIG_SYS_IBAT2U	(CONFIG_SYS_PCI1_MEM_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+#define CONFIG_SYS_IBAT3L	(CONFIG_SYS_PCI1_MMIO_BASE | BATL_PP_10 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CONFIG_SYS_IBAT3U	(CONFIG_SYS_PCI1_MMIO_BASE | BATU_BL_256M | BATU_VS | BATU_VP)
+
+/* PCI2 not supported on 8313 */
+#define CONFIG_SYS_IBAT4L	(0)
+#define CONFIG_SYS_IBAT4U	(0)
+
+/* IMMRBAR @ 0xE0000000, PCI IO @ 0xE2000000 */
+#define CONFIG_SYS_IBAT5L	(CONFIG_SYS_IMMR | BATL_PP_10 | BATL_CACHEINHIBIT | BATL_GUARDEDSTORAGE)
+#define CONFIG_SYS_IBAT5U	(CONFIG_SYS_IMMR | BATU_BL_256M | BATU_VS | BATU_VP)
+
+/* SDRAM @ 0xF0000000, stack in DCACHE 0xFDF00000 & FLASH @ 0xFE000000 */
+#define CONFIG_SYS_IBAT6L	(0xF0000000 | BATL_PP_10)
+#define CONFIG_SYS_IBAT6U	(0xF0000000 | BATU_BL_256M | BATU_VS | BATU_VP)
+
+#define CONFIG_SYS_IBAT7L	(0)
+#define CONFIG_SYS_IBAT7U	(0)
+
+#define CONFIG_SYS_DBAT0L	CONFIG_SYS_IBAT0L
+#define CONFIG_SYS_DBAT0U	CONFIG_SYS_IBAT0U
+#define CONFIG_SYS_DBAT1L	CONFIG_SYS_IBAT1L
+#define CONFIG_SYS_DBAT1U	CONFIG_SYS_IBAT1U
+#define CONFIG_SYS_DBAT2L	CONFIG_SYS_IBAT2L
+#define CONFIG_SYS_DBAT2U	CONFIG_SYS_IBAT2U
+#define CONFIG_SYS_DBAT3L	CONFIG_SYS_IBAT3L
+#define CONFIG_SYS_DBAT3U	CONFIG_SYS_IBAT3U
+#define CONFIG_SYS_DBAT4L	CONFIG_SYS_IBAT4L
+#define CONFIG_SYS_DBAT4U	CONFIG_SYS_IBAT4U
+#define CONFIG_SYS_DBAT5L	CONFIG_SYS_IBAT5L
+#define CONFIG_SYS_DBAT5U	CONFIG_SYS_IBAT5U
+#define CONFIG_SYS_DBAT6L	CONFIG_SYS_IBAT6L
+#define CONFIG_SYS_DBAT6U	CONFIG_SYS_IBAT6U
+#define CONFIG_SYS_DBAT7L	CONFIG_SYS_IBAT7L
+#define CONFIG_SYS_DBAT7U	CONFIG_SYS_IBAT7U
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01	/* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02	/* Software reboot */
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_NETDEV		eth1
+
+#define CONFIG_HOSTNAME		simpc8313
+#define CONFIG_ROOTPATH		/tftpboot/
+#define CONFIG_BOOTFILE		/tftpboot/uImage
+#define CONFIG_UBOOTPATH	u-boot-nand.bin	/* U-Boot image on TFTP server */
+#define CONFIG_FDTFILE		simpc8313.dtb
+
+#define CONFIG_LOADADDR		500000	/* default location for tftp and bootm */
+#define CONFIG_BOOTDELAY	5	/* 5 second delay */
+#define CONFIG_BAUDRATE		115200
+
+#define CONFIG_BOOTCOMMAND	"nand read $loadaddr kernel 600000;bootm $loadaddr - $fdtaddr"
+
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"netdev=" MK_STR(CONFIG_NETDEV) "\0"				\
+	"ethprime=TSEC1\0"						\
+	"uboot=" MK_STR(CONFIG_UBOOTPATH) "\0"				\
+	"tftpflash=tftpboot $loadaddr $uboot; "				\
+		"protect off " MK_STR(TEXT_BASE) " +$filesize; "	\
+		"erase " MK_STR(TEXT_BASE) " +$filesize; "		\
+		"cp.b $loadaddr " MK_STR(TEXT_BASE) " $filesize; "	\
+		"protect on " MK_STR(TEXT_BASE) " +$filesize; "		\
+		"cmp.b $loadaddr " MK_STR(TEXT_BASE) " $filesize\0"	\
+	"fdtaddr=ae0000\0"						\
+	"fdtfile=" MK_STR(CONFIG_FDTFILE) "\0"				\
+	"console=ttyS0\0"						\
+	"setbootargs=setenv bootargs "					\
+		"root=$rootdev rw console=$console,$baudrate $othbootargs\0" \
+	"setipargs=setenv bootargs nfsroot=$serverip:$rootpath "	 \
+		"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+		"root=$rootdev rw console=$console,$baudrate $othbootargs\0"	\
+	"load_uboot=tftp 100000 u-boot-nand.bin\0"			\
+	"burn_uboot=nand erase u-boot 80000; "				\
+		"nand write 100000 u-boot $filesize\0"			\
+	"update_uboot=run load_uboot;run burn_uboot\0"			\
+	"mtdids=nand0=nand0\0"						\
+	"mtdparts=mtdparts=nand0:2M(u-boot),6M(kernel),-(jffs2)\0"	\
+	"nfsargs=setenv bootargs root=/dev/nfs rw "			\
+		"nfsroot=${serverip}:${rootpath}\0"			\
+	"ramargs=setenv bootargs root=/dev/ram rw\0"			\
+	"addip=setenv bootargs ${bootargs} "				\
+		"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}"	\
+		":${hostname}:${netdev}:off panic=1\0"			\
+	"addtty=setenv bootargs ${bootargs} console=ttyS0,${baudrate}\0"	\
+	"bootargs=root=/dev/mtdblock2 rootfstype=jffs2 rw "		\
+		"console=ttyS0,115200\0"				\
+	""
+
+#define CONFIG_NFSBOOTCOMMAND						\
+	"setenv rootdev /dev/nfs;"					\
+	"run setbootargs;"						\
+	"run setipargs;"						\
+	"tftp $loadaddr $bootfile;"					\
+	"tftp $fdtaddr $fdtfile;"					\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND						\
+	"setenv rootdev /dev/ram;"					\
+	"run setbootargs;"						\
+	"tftp $ramdiskaddr $ramdiskfile;"				\
+	"tftp $loadaddr $bootfile;"					\
+	"tftp $fdtaddr $fdtfile;"					\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#undef MK_STR
+#undef XMK_STR
+
+#endif	/* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/smdk6400.h u-boot/include/configs/smdk6400.h
--- u-boot-2009.01/include/configs/smdk6400.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/smdk6400.h	2009-02-26 14:03:59.000000000 +0100
@@ -104,7 +104,7 @@
 #define CONFIG_CMD_REGINFO
 #define CONFIG_CMD_LOADS
 #define CONFIG_CMD_LOADB
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_NAND
 #if defined(CONFIG_BOOT_ONENAND)
 #define CONFIG_CMD_ONENAND
@@ -227,7 +227,6 @@
 /* NAND configuration */
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
 #define CONFIG_SYS_NAND_BASE		0x70200010
-#define NAND_MAX_CHIPS		1
 #define CONFIG_SYS_S3C_NAND_HWECC
 
 #define CONFIG_SYS_NAND_SKIP_BAD_DOT_I	1  /* ".i" read skips bad blocks	      */
@@ -294,7 +293,6 @@
 #define CONFIG_SYS_USB_OHCI_SLOT_NAME		"s3c6400"
 #define CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS	3
 #define CONFIG_SYS_USB_OHCI_CPU_INIT		1
-#define LITTLEENDIAN			1	/* used by usb_ohci.c	*/
 
 #define CONFIG_USB_STORAGE	1
 #endif
diff -Naur u-boot-2009.01/include/configs/socrates.h u-boot/include/configs/socrates.h
--- u-boot-2009.01/include/configs/socrates.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/socrates.h	2009-02-26 14:03:59.000000000 +0100
@@ -186,7 +186,6 @@
 
 #define CONFIG_SYS_NAND_BASE		(CONFIG_SYS_FPGA_BASE + 0x70)
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS		1
 #define CONFIG_CMD_NAND
 
 /* LIME GDC */
diff -Naur u-boot-2009.01/include/configs/SPD823TS.h u-boot/include/configs/SPD823TS.h
--- u-boot-2009.01/include/configs/SPD823TS.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/SPD823TS.h	2009-02-26 14:03:59.000000000 +0100
@@ -67,6 +67,7 @@
 
 #define CONFIG_CMD_IDE
 
+#undef CONFIG_CMD_SAVEENV
 #undef CONFIG_CMD_FLASH
 
 
diff -Naur u-boot-2009.01/include/configs/stxgp3.h u-boot/include/configs/stxgp3.h
--- u-boot-2009.01/include/configs/stxgp3.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/stxgp3.h	2009-02-26 14:03:59.000000000 +0100
@@ -322,7 +322,7 @@
 #define CONFIG_CMD_I2C
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #else
     #define CONFIG_CMD_ELF
diff -Naur u-boot-2009.01/include/configs/stxssa.h u-boot/include/configs/stxssa.h
--- u-boot-2009.01/include/configs/stxssa.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/stxssa.h	2009-02-26 14:03:59.000000000 +0100
@@ -363,7 +363,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #else
     #define CONFIG_CMD_ELF
diff -Naur u-boot-2009.01/include/configs/stxxtc.h u-boot/include/configs/stxxtc.h
--- u-boot-2009.01/include/configs/stxxtc.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/stxxtc.h	2009-02-26 14:03:59.000000000 +0100
@@ -464,7 +464,6 @@
 #define ADDR_COLUMN_PAGE	3
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS		1
-#define NAND_MAX_CHIPS		1
 
 /* ALE = PC15, CLE = PB23, CE = PA7, F_RY_BY = PA6 */
 #define NAND_DISABLE_CE(nand) \
diff -Naur u-boot-2009.01/include/configs/suzaku.h u-boot/include/configs/suzaku.h
--- u-boot-2009.01/include/configs/suzaku.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/suzaku.h	2009-02-26 14:03:59.000000000 +0100
@@ -62,7 +62,7 @@
 #include <config_cmd_default.h>
 
 #undef CONFIG_CMD_BDI
-#undef CONFIG_CMD_ENV
+#undef CONFIG_CMD_SAVEENV
 #undef CONFIG_CMD_MEMORY
 #undef CONFIG_CMD_NET
 #undef CONFIG_CMD_MISC
diff -Naur u-boot-2009.01/include/configs/SX1.h u-boot/include/configs/SX1.h
--- u-boot-2009.01/include/configs/SX1.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/SX1.h	2009-02-26 14:03:59.000000000 +0100
@@ -116,7 +116,9 @@
 #include <configs/omap1510.h>
 
 #define CONFIG_BOOTARGS		"mem=16M console=ttyS0,115200n8 root=/dev/mtdblock3 rw"
+#ifdef CONFIG_STDOUT_USBTTY
 #define CONFIG_PREBOOT		"setenv stdout usbtty;setenv stdin usbtty"
+#endif
 
 /*
  * Miscellaneous configurable options
@@ -167,15 +169,19 @@
 
 /*-----------------------------------------------------------------------
  * FLASH and environment organization
+ * V1
+ * PHYS_FLASH_SIZE_1			(16 << 10)	16 MB
+ * PHYS_FLASH_SIZE_2			(8 << 10)	 8 MB
+ * V2 only 1 flash
+ * PHYS_FLASH_SIZE_1			(32 << 10)	32 MB
  */
 #define CONFIG_SYS_MAX_FLASH_BANKS	2	/* max number of memory banks */
-#define PHYS_FLASH_SIZE		(16 << 10) /* 16 MB */
 #define PHYS_FLASH_SECT_SIZE	(128*1024) /* Size of a sector (128kB) */
-#define CONFIG_SYS_MAX_FLASH_SECT	(128)	/* max number of sectors on one chip */
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)	/* max number of sectors on one chip */
 #define CONFIG_ENV_ADDR	(CONFIG_SYS_FLASH_BASE + PHYS_FLASH_SECT_SIZE) /* addr of environment */
 #define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_FLASH_BASE	/* Monitor at beginning of flash */
 #define CONFIG_SYS_MONITOR_LEN		PHYS_FLASH_SECT_SIZE	/* Reserve 1 sector */
-#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE + PHYS_FLASH_SIZE }
+#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE, PHYS_FLASH_2 }
 
 /*-----------------------------------------------------------------------
  * FLASH driver setup
diff -Naur u-boot-2009.01/include/configs/SXNI855T.h u-boot/include/configs/SXNI855T.h
--- u-boot-2009.01/include/configs/SXNI855T.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/SXNI855T.h	2009-02-26 14:03:59.000000000 +0100
@@ -206,7 +206,6 @@
 
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS 1
-#define NAND_MAX_CHIPS 1
 
 /* DFBUSY is available on Port C, bit 12; 0 if busy */
 #define NAND_WAIT_READY(nand)	\
diff -Naur u-boot-2009.01/include/configs/TB5200.h u-boot/include/configs/TB5200.h
--- u-boot-2009.01/include/configs/TB5200.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TB5200.h	2009-02-26 14:03:59.000000000 +0100
@@ -344,10 +344,11 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 /*
- * Define CONFIG_FEC_10MBIT to force FEC at 10Mb
+ * Define CONFIG_MPC5xxx_FEC_MII10 to force FEC at 10Mb
  */
-/* #define CONFIG_FEC_10MBIT 1 */
+/* #define CONFIG_MPC5xxx_FEC_MII10 */
 #define CONFIG_PHY_ADDR		0x00
 
 /*
diff -Naur u-boot-2009.01/include/configs/TOP5200.h u-boot/include/configs/TOP5200.h
--- u-boot-2009.01/include/configs/TOP5200.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TOP5200.h	2009-02-26 14:03:59.000000000 +0100
@@ -312,7 +312,7 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
-#define CONFIG_FEC_10MBIT	1		/* Workaround for FEC 100Mbit problem */
+#define CONFIG_MPC5xxx_FEC_MII10	/* Workaround for FEC 100Mbit problem */
 #define	CONFIG_PHY_ADDR		0x1f
 #define	CONFIG_PHY_TYPE		0x79c874
 /*
diff -Naur u-boot-2009.01/include/configs/Total5200.h u-boot/include/configs/Total5200.h
--- u-boot-2009.01/include/configs/Total5200.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/Total5200.h	2009-02-26 14:03:59.000000000 +0100
@@ -268,6 +268,7 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_SEVENWIRE
 /* dummy, 7-wire FEC does not have phy address */
 #define CONFIG_PHY_ADDR		0x00
 
diff -Naur u-boot-2009.01/include/configs/TQM5200.h u-boot/include/configs/TQM5200.h
--- u-boot-2009.01/include/configs/TQM5200.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM5200.h	2009-02-26 14:03:59.000000000 +0100
@@ -507,10 +507,11 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 /*
- * Define CONFIG_FEC_10MBIT to force FEC at 10Mb
+ * Define CONFIG_MPC5xxx_FEC_MII10 to force FEC at 10Mb
  */
-/* #define CONFIG_FEC_10MBIT 1 */
+/* #define CONFIG_MPC5xxx_FEC_MII10 */
 #define CONFIG_PHY_ADDR		0x00
 
 /*
diff -Naur u-boot-2009.01/include/configs/TQM823L.h u-boot/include/configs/TQM823L.h
--- u-boot-2009.01/include/configs/TQM823L.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM823L.h	2009-02-26 14:03:59.000000000 +0100
@@ -123,6 +123,7 @@
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ELF
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
 #define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/TQM823M.h u-boot/include/configs/TQM823M.h
--- u-boot-2009.01/include/configs/TQM823M.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM823M.h	2009-02-26 14:03:59.000000000 +0100
@@ -121,6 +121,7 @@
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ELF
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
 #define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/TQM8260.h u-boot/include/configs/TQM8260.h
--- u-boot-2009.01/include/configs/TQM8260.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM8260.h	2009-02-26 14:03:59.000000000 +0100
@@ -81,8 +81,8 @@
 	"net_nfs=tftp 200000 ${bootfile};run nfsargs addip;bootm\0"	\
 	"rootpath=/opt/eldk/ppc_6xx\0"					\
 	"bootfile=tqm8260/uImage\0"				\
-	"kernel_addr=40080000\0"					\
-	"ramdisk_addr=40200000\0"					\
+	"kernel_addr=400C0000\0"					\
+	"ramdisk_addr=40240000\0"					\
 	""
 #define CONFIG_BOOTCOMMAND	"run flash_self"
 
diff -Naur u-boot-2009.01/include/configs/TQM8272.h u-boot/include/configs/TQM8272.h
--- u-boot-2009.01/include/configs/TQM8272.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM8272.h	2009-02-26 14:03:59.000000000 +0100
@@ -424,7 +424,6 @@
 #define CONFIG_SYS_NAND3_BASE (CONFIG_SYS_NAND2_BASE + CONFIG_SYS_NAND_CS_DIST)
 
 #define CONFIG_SYS_MAX_NAND_DEVICE     4       /* Max number of NAND devices           */
-#define NAND_MAX_CHIPS 1
 
 #define CONFIG_SYS_NAND_BASE_LIST { CONFIG_SYS_NAND0_BASE, \
 			     CONFIG_SYS_NAND1_BASE, \
diff -Naur u-boot-2009.01/include/configs/TQM834x.h u-boot/include/configs/TQM834x.h
--- u-boot-2009.01/include/configs/TQM834x.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM834x.h	2009-02-26 14:03:59.000000000 +0100
@@ -340,7 +340,7 @@
 #endif
 
 #if defined(CONFIG_SYS_RAMBOOT)
-    #undef CONFIG_CMD_ENV
+    #undef CONFIG_CMD_SAVEENV
     #undef CONFIG_CMD_LOADS
 #endif
 
diff -Naur u-boot-2009.01/include/configs/TQM850L.h u-boot/include/configs/TQM850L.h
--- u-boot-2009.01/include/configs/TQM850L.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM850L.h	2009-02-26 14:03:59.000000000 +0100
@@ -112,6 +112,7 @@
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ELF
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
 #define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/TQM850M.h u-boot/include/configs/TQM850M.h
--- u-boot-2009.01/include/configs/TQM850M.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM850M.h	2009-02-26 14:03:59.000000000 +0100
@@ -110,6 +110,7 @@
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ELF
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
 #define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/TQM855L.h u-boot/include/configs/TQM855L.h
--- u-boot-2009.01/include/configs/TQM855L.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM855L.h	2009-02-26 14:03:59.000000000 +0100
@@ -116,6 +116,7 @@
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ELF
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
 #define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/TQM855M.h u-boot/include/configs/TQM855M.h
--- u-boot-2009.01/include/configs/TQM855M.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM855M.h	2009-02-26 14:03:59.000000000 +0100
@@ -149,6 +149,7 @@
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ELF
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_EEPROM
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
diff -Naur u-boot-2009.01/include/configs/TQM85xx.h u-boot/include/configs/TQM85xx.h
--- u-boot-2009.01/include/configs/TQM85xx.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM85xx.h	2009-02-26 14:03:59.000000000 +0100
@@ -41,14 +41,21 @@
 #define CONFIG_E500		1	/* BOOKE e500 family		*/
 #define CONFIG_MPC85xx		1	/* MPC8540/60/55/41		*/
 
+#if defined(CONFIG_TQM8548_AG) || defined(CONFIG_TQM8548_BE)
+#define CONFIG_TQM8548
+#endif
+
 #define CONFIG_PCI
+#ifndef CONFIG_TQM8548_AG
+#define CONFIG_PCI1			/* PCI/PCI-X controller		*/
+#endif
+#ifdef CONFIG_TQM8548
+#define CONFIG_PCIE1			/* PCI Express interface	*/
+#endif
+
 #define CONFIG_FSL_PCI_INIT	1	/* Use common FSL init code	*/
 #define CONFIG_PCIX_CHECK		/* PCIX olny works at 66 MHz	*/
-#ifdef CONFIG_TQM8548
-#define CONFIG_PCI1
-#define CONFIG_PCIE1
 #define CONFIG_FSL_PCIE_RESET	1	/* need PCIe reset errata	*/
-#endif
 
 #define CONFIG_TSEC_ENET		/* tsec ethernet support	*/
 
@@ -70,7 +77,9 @@
  * Warning: NAND support will likely increase the U-Boot image size
  * to more than 256 KB. Please adjust TEXT_BASE if necessary.
  */
-#undef CONFIG_NAND
+#ifdef CONFIG_TQM8548_BE
+#define CONFIG_NAND
+#endif
 
 /*
  * MPC8540 and MPC8548 don't have CPM module
@@ -81,7 +90,9 @@
 
 #define CONFIG_FSL_LAW		1	/* Use common FSL init code	*/
 
-#undef	CONFIG_CAN_DRIVER		/* CAN Driver support		*/
+#if defined(CONFIG_TQM8548_AG) || defined(CONFIG_TQM8548_BE)
+#define	CONFIG_CAN_DRIVER		/* CAN Driver support		*/
+#endif
 
 /*
  * sysclk for MPC85xx
@@ -135,6 +146,9 @@
  */
 #define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000	/* DDR is system memory	*/
 #define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+#ifdef CONFIG_TQM8548_AG
+#define CONFIG_VERY_BIG_RAM
+#endif
 
 #define CONFIG_NUM_DDR_CONTROLLERS	1
 #define CONFIG_DIMM_SLOTS_PER_CTLR	1
@@ -363,7 +377,6 @@
 #define CONFIG_SYS_NAND3_BASE		(CONFIG_SYS_NAND2_BASE + CONFIG_SYS_NAND_CS_DIST)
 
 #define CONFIG_SYS_MAX_NAND_DEVICE     2	/* Max number of NAND devices	*/
-#define NAND_MAX_CHIPS		1
 
 #if (CONFIG_SYS_MAX_NAND_DEVICE == 1)
 #define CONFIG_SYS_NAND_BASE_LIST { CONFIG_SYS_NAND0_BASE }
@@ -605,7 +618,9 @@
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_NFS
 #define CONFIG_CMD_SNTP
+#ifndef CONFIG_TQM8548_AG
 #define CONFIG_CMD_DATE
+#endif
 #define CONFIG_CMD_EEPROM
 #define CONFIG_CMD_DTT
 #define CONFIG_CMD_MII
diff -Naur u-boot-2009.01/include/configs/TQM860L.h u-boot/include/configs/TQM860L.h
--- u-boot-2009.01/include/configs/TQM860L.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM860L.h	2009-02-26 14:03:59.000000000 +0100
@@ -116,6 +116,7 @@
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ELF
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
 #define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/TQM860M.h u-boot/include/configs/TQM860M.h
--- u-boot-2009.01/include/configs/TQM860M.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM860M.h	2009-02-26 14:03:59.000000000 +0100
@@ -116,6 +116,7 @@
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ELF
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
 #define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/TQM862L.h u-boot/include/configs/TQM862L.h
--- u-boot-2009.01/include/configs/TQM862L.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM862L.h	2009-02-26 14:03:59.000000000 +0100
@@ -119,6 +119,7 @@
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ELF
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
 #define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/TQM862M.h u-boot/include/configs/TQM862M.h
--- u-boot-2009.01/include/configs/TQM862M.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM862M.h	2009-02-26 14:03:59.000000000 +0100
@@ -119,6 +119,7 @@
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_ELF
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
 #define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/TQM866M.h u-boot/include/configs/TQM866M.h
--- u-boot-2009.01/include/configs/TQM866M.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM866M.h	2009-02-26 14:03:59.000000000 +0100
@@ -160,6 +160,7 @@
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_EEPROM
 #define CONFIG_CMD_ELF
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
 #define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/TQM885D.h u-boot/include/configs/TQM885D.h
--- u-boot-2009.01/include/configs/TQM885D.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/TQM885D.h	2009-02-26 14:03:59.000000000 +0100
@@ -157,6 +157,7 @@
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_I2C
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_MII
diff -Naur u-boot-2009.01/include/configs/trab.h u-boot/include/configs/trab.h
--- u-boot-2009.01/include/configs/trab.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/trab.h	2009-02-26 14:03:59.000000000 +0100
@@ -44,7 +44,6 @@
 #define CONFIG_S3C2400		1	/* in a SAMSUNG S3C2400 SoC	*/
 #define CONFIG_TRAB		1	/* on a TRAB Board		*/
 #undef CONFIG_TRAB_50MHZ		/* run the CPU at 50 MHz	*/
-#define LITTLEENDIAN		1	/* used by usb_ohci.c		*/
 
 /* automatic software updates (see board/trab/auto_update.c) */
 #define CONFIG_AUTO_UPDATE	1
diff -Naur u-boot-2009.01/include/configs/trizepsiv.h u-boot/include/configs/trizepsiv.h
--- u-boot-2009.01/include/configs/trizepsiv.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/trizepsiv.h	2009-02-26 14:03:59.000000000 +0100
@@ -42,8 +42,6 @@
  */
 #define CONFIG_PXA27X		1	/* This is an PXA27x CPU    */
 
-#define LITTLEENDIAN		1	/* used by usb_ohci.c		*/
-
 #define CONFIG_MMC		1
 #define BOARD_LATE_INIT		1
 
@@ -81,7 +79,6 @@
  */
 #include <config_cmd_default.h>
 
-#define CONFIG_CMD_MMC
 #define CONFIG_CMD_FAT
 #define CONFIG_CMD_IMLS
 #define CONFIG_CMD_PING
@@ -170,13 +167,17 @@
 
 #define CONFIG_SYS_LOAD_ADDR		0xa1000000	/* default load address */
 
-#define CONFIG_SYS_HZ			3686400		/* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 #define CONFIG_SYS_CPUSPEED		0x207		/* need to look more closely, I think this is Turbo = 2x, L=91Mhz */
 
 						/* valid baudrates */
 #define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
 
+#ifdef CONFIG_MMC
+#define CONFIG_PXA_MMC
+#define CONFIG_CMD_MMC
 #define CONFIG_SYS_MMC_BASE		0xF0000000
+#endif
 
 /*
  * Stack sizes
diff -Naur u-boot-2009.01/include/configs/uc101.h u-boot/include/configs/uc101.h
--- u-boot-2009.01/include/configs/uc101.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/uc101.h	2009-02-26 14:03:59.000000000 +0100
@@ -233,6 +233,7 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 #define CONFIG_PHY_ADDR		0x00
 #define CONFIG_MII		1
 
diff -Naur u-boot-2009.01/include/configs/utx8245.h u-boot/include/configs/utx8245.h
--- u-boot-2009.01/include/configs/utx8245.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/utx8245.h	2009-02-26 14:03:59.000000000 +0100
@@ -105,7 +105,7 @@
 #define CONFIG_CMD_PCI
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_MEMORY
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_CONSOLE
 #define CONFIG_CMD_LOADS
 #define CONFIG_CMD_LOADB
diff -Naur u-boot-2009.01/include/configs/v38b.h u-boot/include/configs/v38b.h
--- u-boot-2009.01/include/configs/v38b.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/v38b.h	2009-02-26 14:03:59.000000000 +0100
@@ -247,6 +247,7 @@
  * Ethernet configuration
  */
 #define CONFIG_MPC5xxx_FEC	1
+#define CONFIG_MPC5xxx_FEC_MII100
 #define CONFIG_PHY_ADDR		0x00
 #define CONFIG_MII		1
 
diff -Naur u-boot-2009.01/include/configs/VCMA9.h u-boot/include/configs/VCMA9.h
--- u-boot-2009.01/include/configs/VCMA9.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/VCMA9.h	2009-02-26 14:03:59.000000000 +0100
@@ -36,7 +36,6 @@
 #define CONFIG_ARM920T		1	/* This is an ARM920T Core	*/
 #define	CONFIG_S3C2410		1	/* in a SAMSUNG S3C2410 SoC     */
 #define CONFIG_VCMA9		1	/* on a MPL VCMA9 Board  */
-#define LITTLEENDIAN		1	/* used by usb_ohci.c		*/
 
 /* input clock of PLL */
 #define CONFIG_SYS_CLK_FREQ	12000000/* VCMA9 has 12MHz input clock	*/
@@ -264,7 +263,6 @@
 
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS 1
-#define NAND_MAX_CHIPS 1
 
 #define NAND_WAIT_READY(nand)	NF_WaitRB()
 
diff -Naur u-boot-2009.01/include/configs/vct.h u-boot/include/configs/vct.h
--- u-boot-2009.01/include/configs/vct.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/configs/vct.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,340 @@
+/*
+ * (C) Copyright 2008 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the VCT board
+ * family:
+ *
+ * vct_premium
+ * vct_premium_small
+ * vct_premium_onenand
+ * vct_premium_onenand_small
+ * vct_platinum
+ * vct_platinum_small
+ * vct_platinum_onenand
+ * vct_platinum_onenand_small
+ * vct_platinumavc
+ * vct_platinumavc_small
+ * vct_platinumavc_onenand
+ * vct_platinumavc_onenand_small
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32				/* MIPS 4Kc CPU core	*/
+#define CPU_CLOCK_RATE			324000000 /* Clock for the MIPS core */
+#define CONFIG_SYS_MIPS_TIMER_FREQ	(CPU_CLOCK_RATE / 2)
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_SKIP_LOWLEVEL_INIT	/* SDRAM is initialized by the bootstrap code */
+
+#define CONFIG_SYS_MONITOR_BASE		TEXT_BASE
+#define CONFIG_SYS_MONITOR_LEN		(256 << 10)
+#define CONFIG_STACKSIZE		(256 << 10)
+#define CONFIG_SYS_MALLOC_LEN		(1 << 20)
+#define CONFIG_SYS_BOOTPARAMS_LEN	(128 << 10)
+#define CONFIG_SYS_INIT_SP_OFFSET	0x400000
+
+#if !defined(CONFIG_VCT_NAND) && !defined(CONFIG_VCT_ONENAND)
+#define CONFIG_VCT_NOR
+#else
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+/*
+ * UART
+ */
+#define CONFIG_VCT_SERIAL
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * SDRAM
+ */
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+#define CONFIG_SYS_MBYTES_SDRAM		128
+#define CONFIG_SYS_MEMTEST_START	0x80200000
+#define CONFIG_SYS_MEMTEST_END		0x80400000
+#define CONFIG_SYS_LOAD_ADDR		0x80400000	/* default load address */
+
+#if defined(CONFIG_VCT_PREMIUM) || defined(CONFIG_VCT_PLATINUM)
+/*
+ * SMSC91C11x Network Card
+ */
+#define CONFIG_DRIVER_SMC911X
+#define CONFIG_DRIVER_SMC911X_BASE	0x00000000
+#define CONFIG_DRIVER_SMC911X_32_BIT
+#define CONFIG_NET_RETRY_COUNT		20
+#endif
+
+/*
+ * Commands
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_I2C
+
+/*
+ * Only Premium/Platinum have ethernet support right now
+ */
+#if defined(CONFIG_VCT_PREMIUM) || defined(CONFIG_VCT_PLATINUM)
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SNTP
+#else
+#undef CONFIG_CMD_NET
+#endif
+
+/*
+ * Only Premium/Platinum have USB-EHCI support right now
+ */
+#if defined(CONFIG_VCT_PREMIUM) || defined(CONFIG_VCT_PLATINUM)
+#define CONFIG_CMD_USB
+#define CONFIG_CMD_FAT
+#endif
+
+#if defined(CONFIG_CMD_USB)
+#define CONFIG_USB_STORAGE
+#define CONFIG_DOS_PARTITION
+#define CONFIG_ISO_PARTITION
+
+#define CONFIG_SUPPORT_VFAT
+
+/*
+ * USB/EHCI
+ */
+#define CONFIG_USB_EHCI			/* Enable EHCI USB support	*/
+#define CONFIG_USB_EHCI_VCT		/* on VCT platform		*/
+#define CONFIG_EHCI_DCACHE		/* with dcache handling support	*/
+#define CONFIG_EHCI_MMIO_BIG_ENDIAN
+#define CONFIG_EHCI_DESC_BIG_ENDIAN
+#define CONFIG_EHCI_IS_TDI
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET /* re-init HCD after CMD_RESET */
+#endif /* CONFIG_CMD_USB */
+
+#if !defined(CONFIG_VCT_NOR)
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_IMLS
+#endif
+
+#if defined(CONFIG_VCT_NAND)
+#define CONFIG_CMD_NAND
+#endif
+
+#if defined(CONFIG_VCT_ONENAND)
+#define CONFIG_CMD_ONENAND
+#endif
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_SUBNETMASK
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory		*/
+#define CONFIG_SYS_PROMPT	"VCT# "		/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE	512		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE + \
+				 sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args	*/
+#define CONFIG_TIMESTAMP			/* Print image info with timestamp */
+#define CONFIG_CMDLINE_EDITING			/* add command line history	*/
+#define CONFIG_SYS_CONSOLE_INFO_QUIET		/* don't print console @ startup*/
+
+/*
+ * FLASH and environment organization
+ */
+#if defined(CONFIG_VCT_NOR)
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_FLASH_NOT_MEM_MAPPED
+
+/*
+ * We need special accessor functions for the CFI FLASH driver. This
+ * can be enabled via the CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS option.
+ */
+#define CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
+
+/*
+ * For the non-memory-mapped NOR FLASH, we need to define the
+ * NOR FLASH area. This can't be detected via the addr2info()
+ * function, since we check for flash access in the very early
+ * U-Boot code, before the NOR FLASH is detected.
+ */
+#define CONFIG_FLASH_BASE		0xb0000000
+#define CONFIG_FLASH_END		0xbfffffff
+
+/*
+ * CFI driver settings
+ */
+#define CONFIG_SYS_FLASH_CFI			/* The flash is CFI compatible	*/
+#define CONFIG_FLASH_CFI_DRIVER		/* Use common CFI driver	*/
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET	1	/* Use AMD (Spansion) reset cmd */
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT	/* no byte writes on IXP4xx	*/
+
+#define CONFIG_SYS_FLASH_BASE		0xb0000000
+#define CONFIG_SYS_FLASH_BANKS_LIST    { CONFIG_SYS_FLASH_BASE }
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CONFIG_SYS_MAX_FLASH_SECT	512	/* max number of sectors on one chip	*/
+
+#define CONFIG_SYS_FLASH_ERASE_TOUT	120000	/* Timeout for Flash Erase (in ms)	*/
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Timeout for Flash Write (in ms)	*/
+
+#ifdef CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_SECT_SIZE	0x10000		/* size of one complete sector	*/
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + CONFIG_SYS_MONITOR_LEN)
+#define	CONFIG_ENV_SIZE		0x4000	/* Total Size of Environment Sector	*/
+
+/* Address and size of Redundant Environment Sector	*/
+#define CONFIG_ENV_ADDR_REDUND	(CONFIG_ENV_ADDR + CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE_REDUND	(CONFIG_ENV_SIZE)
+#endif /* CONFIG_ENV_IS_IN_FLASH */
+#endif /* CONFIG_VCT_NOR */
+
+#if defined(CONFIG_VCT_ONENAND)
+#define CONFIG_USE_ONENAND_BOARD_INIT
+#define	CONFIG_ENV_IS_IN_ONENAND
+#define	CONFIG_SYS_ONENAND_BASE		0x00000000	/* this is not real address */
+#define CONFIG_SYS_FLASH_BASE		0x00000000
+#define CONFIG_ENV_ADDR			(128 << 10)	/* after compr. U-Boot image */
+#define	CONFIG_ENV_SIZE			(128 << 10)	/* erase size */
+#endif /* CONFIG_VCT_ONENAND */
+
+/*
+ * Cache Configuration
+ */
+#define CONFIG_SYS_DCACHE_SIZE		16384
+#define CONFIG_SYS_ICACHE_SIZE		16384
+#define CONFIG_SYS_CACHELINE_SIZE	32
+
+/*
+ * I2C/EEPROM
+ */
+#undef	CONFIG_HARD_I2C			/* I2C with hardware support	*/
+#define	CONFIG_SOFT_I2C			/* I2C bit-banged		*/
+
+#define CONFIG_SYS_I2C_SPEED		83000	/* 83 kHz is supposed to work	*/
+#define CONFIG_SYS_I2C_SLAVE		0x7f
+
+/*
+ * Software (bit-bang) I2C driver configuration
+ */
+#define CONFIG_SYS_GPIO_I2C_SCL		11
+#define CONFIG_SYS_GPIO_I2C_SDA		10
+
+#ifndef __ASSEMBLY__
+int vct_gpio_dir(int pin, int dir);
+void vct_gpio_set(int pin, int val);
+int vct_gpio_get(int pin);
+#endif
+
+#define I2C_INIT	vct_gpio_dir(CONFIG_SYS_GPIO_I2C_SCL, 1)
+#define I2C_ACTIVE	vct_gpio_dir(CONFIG_SYS_GPIO_I2C_SDA, 1)
+#define I2C_TRISTATE	vct_gpio_dir(CONFIG_SYS_GPIO_I2C_SDA, 0)
+#define I2C_READ	vct_gpio_get(CONFIG_SYS_GPIO_I2C_SDA)
+#define I2C_SDA(bit)	vct_gpio_set(CONFIG_SYS_GPIO_I2C_SDA, bit)
+#define I2C_SCL(bit)	vct_gpio_set(CONFIG_SYS_GPIO_I2C_SCL, bit)
+#define I2C_DELAY	udelay(5)	/* 1/4 I2C clock duration */
+
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50
+/* CAT24WC32 */
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	2	/* Bytes of address		*/
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 5	/* The Catalyst CAT24WC32 has	*/
+					/* 32 byte page write mode using*/
+					/* last 5 bits of the address	*/
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS	10   /* and takes up to 10 msec */
+
+#define CONFIG_BOOTCOMMAND	"run test3"
+#define CONFIG_BOOTDELAY	5	/* autoboot after 5 seconds	*/
+
+/*
+ * Needed for 64bit printf format
+ */
+#define CONFIG_SYS_64BIT_VSPRINTF	1
+#define CONFIG_SYS_64BIT_STRTOUL	1
+
+/*
+ * UBI configuration
+ */
+#if defined(CONFIG_VCT_ONENAND)
+#define CONFIG_SYS_USE_UBI
+#define	CONFIG_CMD_JFFS2
+#define	CONFIG_CMD_UBI
+#define	CONFIG_RBTREE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_JFFS2_CMDLINE
+
+#define MTDIDS_DEFAULT		"onenand0=onenand"
+#define MTDPARTS_DEFAULT	"mtdparts=onenand:128k(u-boot),"	\
+					"128k(env),"		\
+					"20m(kernel),"		\
+					"-(rootfs)"
+#endif
+
+/*
+ * We need a small, stripped down image to fit into the first 128k OneNAND
+ * erase block (gzipped). This image only needs basic commands for FLASH
+ * (NOR/OneNAND) usage and Linux kernel booting.
+ */
+#if defined(CONFIG_VCT_SMALL_IMAGE)
+#undef CONFIG_CMD_EEPROM
+#undef CONFIG_CMD_I2C
+#undef CONFIG_CMD_NET
+#undef CONFIG_CMD_PING
+#undef CONFIG_CMD_SNTP
+#undef CONFIG_CMD_ELF
+#undef CONFIG_CMD_CONSOLE
+#undef CONFIG_CMD_CACHE
+#undef CONFIG_CMD_BEDBUG
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_IRQ
+#undef CONFIG_CMD_ITEST
+#undef CONFIG_CMD_MII
+#undef CONFIG_CMD_MISC
+#undef CONFIG_CMD_REGINFO
+#undef CONFIG_CMD_STRINGS
+#undef CONFIG_CMD_TERMINAL
+#undef CONFIG_CMD_ASKENV
+#undef CONFIG_CMD_CRC32
+#undef CONFIG_CMD_DHCP
+#undef CONFIG_CMD_EEPROM
+#undef CONFIG_CMD_I2C
+#undef CONFIG_CMD_LOADB
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_LOADY
+#undef CONFIG_CMD_BDI
+#undef CONFIG_CMD_USB
+#undef CONFIG_CMD_FAT
+
+#undef CONFIG_DRIVER_SMC911X
+#undef CONFIG_SOFT_I2C
+#undef CONFIG_AUTOSCRIPT
+#undef CONFIG_SYS_LONGHELP
+#undef CONFIG_TIMESTAMP
+#endif /* CONFIG_VCT_SMALL_IMAGE */
+
+#endif  /* __CONFIG_H */
diff -Naur u-boot-2009.01/include/configs/versatile.h u-boot/include/configs/versatile.h
--- u-boot-2009.01/include/configs/versatile.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/versatile.h	2009-02-26 14:03:59.000000000 +0100
@@ -108,7 +108,7 @@
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_MEMORY
 #define CONFIG_CMD_FLASH
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 
 
 /*
diff -Naur u-boot-2009.01/include/configs/virtlab2.h u-boot/include/configs/virtlab2.h
--- u-boot-2009.01/include/configs/virtlab2.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/virtlab2.h	2009-02-26 14:03:59.000000000 +0100
@@ -117,6 +117,7 @@
 #define CONFIG_CMD_ASKENV
 #define CONFIG_CMD_DATE
 #define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
 #define CONFIG_CMD_IDE
 #define CONFIG_CMD_JFFS2
 #define CONFIG_CMD_NFS
diff -Naur u-boot-2009.01/include/configs/VOH405.h u-boot/include/configs/VOH405.h
--- u-boot-2009.01/include/configs/VOH405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/VOH405.h	2009-02-26 14:03:59.000000000 +0100
@@ -134,7 +134,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef  CONFIG_SYS_EXT_SERIAL_CLOCK           /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59   /* ignore ppc405gp errata #59   */
 #define CONFIG_SYS_BASE_BAUD       691200
 #define CONFIG_UART1_CONSOLE            /* define for uart1 as console  */
 
@@ -159,7 +158,6 @@
  *-----------------------------------------------------------------------
  */
 #define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#define NAND_MAX_CHIPS          1
 #define CONFIG_SYS_MAX_NAND_DEVICE	1         /* Max number of NAND devices */
 #define NAND_BIG_DELAY_US	25
 
diff -Naur u-boot-2009.01/include/configs/voiceblue.h u-boot/include/configs/voiceblue.h
--- u-boot-2009.01/include/configs/voiceblue.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/voiceblue.h	2009-02-26 14:03:59.000000000 +0100
@@ -127,7 +127,7 @@
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_BOOTD
 #define CONFIG_CMD_DHCP
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_JFFS2
diff -Naur u-boot-2009.01/include/configs/VOM405.h u-boot/include/configs/VOM405.h
--- u-boot-2009.01/include/configs/VOM405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/VOM405.h	2009-02-26 14:03:59.000000000 +0100
@@ -121,7 +121,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 #undef	CONFIG_UART1_CONSOLE		/* define for uart1 as console	*/
 
diff -Naur u-boot-2009.01/include/configs/VoVPN-GW.h u-boot/include/configs/VoVPN-GW.h
--- u-boot-2009.01/include/configs/VoVPN-GW.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/VoVPN-GW.h	2009-02-26 14:03:59.000000000 +0100
@@ -154,7 +154,7 @@
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_CONSOLE
 #define CONFIG_CMD_ECHO
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_IMI
 #define CONFIG_CMD_IMLS
diff -Naur u-boot-2009.01/include/configs/wepep250.h u-boot/include/configs/wepep250.h
--- u-boot-2009.01/include/configs/wepep250.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/wepep250.h	2009-02-26 14:03:59.000000000 +0100
@@ -81,7 +81,7 @@
 
 #undef  CONFIG_SYS_CLKS_IN_HZ                       /* use HZ for freq. display     */
 
-#define CONFIG_SYS_HZ                  3686400      /* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 #define CONFIG_SYS_CPUSPEED            0x141        /* core clock - register value  */
 
 #define CONFIG_SYS_BAUDRATE_TABLE      { 9600, 19200, 38400, 57600, 115200 }
diff -Naur u-boot-2009.01/include/configs/WUH405.h u-boot/include/configs/WUH405.h
--- u-boot-2009.01/include/configs/WUH405.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/WUH405.h	2009-02-26 14:03:59.000000000 +0100
@@ -122,7 +122,6 @@
 #define CONFIG_SYS_MEMTEST_END		0x0C00000	/* 4 ... 12 MB in DRAM	*/
 
 #undef	CONFIG_SYS_EXT_SERIAL_CLOCK	       /* no external serial clock used */
-#define CONFIG_SYS_IGNORE_405_UART_ERRATA_59	/* ignore ppc405gp errata #59	*/
 #define CONFIG_SYS_BASE_BAUD	    691200
 #define	CONFIG_UART1_CONSOLE		/* define for uart1 as console	*/
 
@@ -147,7 +146,6 @@
  *-----------------------------------------------------------------------
  */
 #define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#define NAND_MAX_CHIPS          1
 #define CONFIG_SYS_MAX_NAND_DEVICE	1         /* Max number of NAND devices */
 #define NAND_BIG_DELAY_US	25
 
diff -Naur u-boot-2009.01/include/configs/xaeniax.h u-boot/include/configs/xaeniax.h
--- u-boot-2009.01/include/configs/xaeniax.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/xaeniax.h	2009-02-26 14:03:59.000000000 +0100
@@ -138,7 +138,7 @@
 
 #define CONFIG_SYS_LOAD_ADDR		0xa1000000	/* default load address */
 
-#define CONFIG_SYS_HZ			3686400		/* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 #define CONFIG_SYS_CPUSPEED		0x141		/* set core clock to 400/200/100 MHz */
 
 /*
diff -Naur u-boot-2009.01/include/configs/xm250.h u-boot/include/configs/xm250.h
--- u-boot-2009.01/include/configs/xm250.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/xm250.h	2009-02-26 14:03:59.000000000 +0100
@@ -121,7 +121,7 @@
 
 #define CONFIG_SYS_LOAD_ADDR		0xa3000000	/* default load address */
 
-#define CONFIG_SYS_HZ			3686400		/* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 #define CONFIG_SYS_CPUSPEED		0x161		/* set core clock to 400/400/100 MHz */
 
 						/* valid baudrates */
diff -Naur u-boot-2009.01/include/configs/XPEDITE5200.h u-boot/include/configs/XPEDITE5200.h
--- u-boot-2009.01/include/configs/XPEDITE5200.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/XPEDITE5200.h	2009-02-26 14:03:59.000000000 +0100
@@ -330,7 +330,7 @@
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_EEPROM
 #define CONFIG_CMD_ELF
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_I2C
 #define CONFIG_CMD_JFFS2
diff -Naur u-boot-2009.01/include/configs/XPEDITE5370.h u-boot/include/configs/XPEDITE5370.h
--- u-boot-2009.01/include/configs/XPEDITE5370.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/XPEDITE5370.h	2009-02-26 14:03:59.000000000 +0100
@@ -375,7 +375,7 @@
 #define CONFIG_CMD_DTT
 #define CONFIG_CMD_EEPROM
 #define CONFIG_CMD_ELF
-#define CONFIG_CMD_ENV
+#define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_FLASH
 #define CONFIG_CMD_I2C
 #define CONFIG_CMD_JFFS2
diff -Naur u-boot-2009.01/include/configs/xsengine.h u-boot/include/configs/xsengine.h
--- u-boot-2009.01/include/configs/xsengine.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/xsengine.h	2009-02-26 14:03:59.000000000 +0100
@@ -35,10 +35,7 @@
 #define CONFIG_DOS_PARTITION		1
 #define BOARD_LATE_INIT			1
 #undef  CONFIG_USE_IRQ					/* we don't need IRQ/FIQ stuff */
-#define CONFIG_SYS_HZ				3686400		/* incrementer freq: 3.6864 MHz */
-
-#undef  CONFIG_USE_IRQ					/* we don't need IRQ/FIQ stuff */
-#define CONFIG_SYS_HZ				3686400		/* incrementer freq: 3.6864 MHz */
+#define CONFIG_SYS_HZ			1000
 #define CONFIG_SYS_CPUSPEED			0x161           /* set core clock to 400/200/100 MHz */
 
 #define CONFIG_NR_DRAM_BANKS		1		/* we have 1 bank of DRAM */
@@ -118,7 +115,6 @@
  */
 #include <config_cmd_default.h>
 
-#define CONFIG_CMD_MMC
 #define CONFIG_CMD_FAT
 #define CONFIG_CMD_PING
 #define CONFIG_CMD_JFFS2
@@ -145,9 +141,14 @@
 #define CONFIG_SYS_MEMTEST_END			0xA0800000				/* 4 ... 8 MB in DRAM   */
 #undef  CONFIG_SYS_CLKS_IN_HZ								/* everything, incl board info, in Hz */
 #define CONFIG_SYS_BAUDRATE_TABLE		{ 9600, 19200, 38400, 57600, 115200 }	/* valid baudrates */
-#define CONFIG_SYS_MMC_BASE			0xF0000000
 #define CONFIG_SYS_LOAD_ADDR			0xA0000000				/* load kernel to this address   */
 
+#ifdef CONFIG_MMC
+#define CONFIG_PXA_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_SYS_MMC_BASE			0xF0000000
+#endif
+
 /* Stack sizes - The stack sizes are set up in start.S using the settings below */
 #define CONFIG_STACKSIZE		(128*1024)	/* regular stack */
 #ifdef  CONFIG_USE_IRQ
diff -Naur u-boot-2009.01/include/configs/zylonite.h u-boot/include/configs/zylonite.h
--- u-boot-2009.01/include/configs/zylonite.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/configs/zylonite.h	2009-02-26 14:03:59.000000000 +0100
@@ -41,7 +41,7 @@
 #ifdef CONFIG_LCD
 #define CONFIG_SHARP_LM8V31
 #endif
-/* #define CONFIG_MMC		1 */
+#undef CONFIG_MMC
 #define BOARD_LATE_INIT		1
 
 #undef CONFIG_SKIP_RELOCATE_UBOOT
@@ -94,7 +94,7 @@
 #ifdef TURN_ON_ETHERNET
     #define CONFIG_CMD_PING
 #else
-    #define CONFIG_CMD_ENV
+    #define CONFIG_CMD_SAVEENV
     #define CONFIG_CMD_NAND
 
     #undef CONFIG_CMD_NET
@@ -143,7 +143,7 @@
 
 #define CONFIG_SYS_LOAD_ADDR	(CONFIG_SYS_DRAM_BASE + 0x8000) /* default load address */
 
-#define CONFIG_SYS_HZ			3250000		/* incrementer freq: 3.25 MHz */
+#define CONFIG_SYS_HZ			1000
 
 /* Monahans Core Frequency */
 #define CONFIG_SYS_MONAHANS_RUN_MODE_OSC_RATIO		16 /* valid values: 8, 16, 24, 31 */
@@ -152,7 +152,11 @@
 						/* valid baudrates */
 #define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
 
-/* #define CONFIG_SYS_MMC_BASE		0xF0000000 */
+#ifdef CONFIG_MMC
+#define CONFIG_PXA_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_SYS_MMC_BASE		0xF0000000
+#endif
 
 /*
  * Stack sizes
@@ -227,7 +231,6 @@
 
 #define NAND_ChipID_UNKNOWN	0x00
 #define NAND_MAX_FLOORS		1
-#define NAND_MAX_CHIPS		1
 
 #define CONFIG_SYS_NO_FLASH		1
 
diff -Naur u-boot-2009.01/include/devices.h u-boot/include/devices.h
--- u-boot-2009.01/include/devices.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/devices.h	2009-02-26 14:03:59.000000000 +0100
@@ -98,6 +98,9 @@
 device_t* device_get_by_name(char* name);
 device_t* device_clone(device_t *dev);
 
+#ifdef CONFIG_ARM_DCC_MULTI
+int drv_arm_dcc_init(void);
+#endif
 #ifdef CONFIG_LCD
 int	drv_lcd_init (void);
 #endif
@@ -116,5 +119,8 @@
 #ifdef CONFIG_NETCONSOLE
 int	drv_nc_init (void);
 #endif
+#ifdef CONFIG_JTAG_CONSOLE
+int drv_jtag_console_init (void);
+#endif
 
 #endif	/* _DEVICES_H_ */
diff -Naur u-boot-2009.01/include/div64.h u-boot/include/div64.h
--- u-boot-2009.01/include/div64.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/div64.h	2009-02-26 14:03:59.000000000 +0100
@@ -36,4 +36,14 @@
 	__rem;						\
  })
 
+/* Wrapper for do_div(). Doesn't modify dividend and returns
+ * the result, not reminder.
+ */
+static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
+{
+	uint64_t __res = dividend;
+	do_div(__res, divisor);
+	return(__res);
+}
+
 #endif /* _ASM_GENERIC_DIV64_H */
diff -Naur u-boot-2009.01/include/ds4510.h u-boot/include/ds4510.h
--- u-boot-2009.01/include/ds4510.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/ds4510.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2008 Extreme Engineering Solutions, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * Version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DS4510_H_
+#define __DS4510_H_
+
+/* General defines */
+#define DS4510_NUM_IO				0x04
+#define DS4510_IO_MASK				((1 << DS4510_NUM_IO) - 1)
+#define DS4510_EEPROM_PAGE_WRITE_DELAY_MS	20
+
+/* EEPROM from 0x00 - 0x39 */
+#define DS4510_EEPROM				0x00
+#define DS4510_EEPROM_SIZE			0x40
+#define DS4510_EEPROM_PAGE_SIZE			0x08
+#define DS4510_EEPROM_PAGE_OFFSET(x)	((x) & (DS4510_EEPROM_PAGE_SIZE - 1))
+
+/* SEEPROM from 0xf0 - 0xf7 */
+#define DS4510_SEEPROM				0xf0
+#define DS4510_SEEPROM_SIZE			0x08
+
+/* Registers overlapping SEEPROM from 0xf0 - 0xf7 */
+#define DS4510_PULLUP				0xF0
+#define DS4510_PULLUP_DIS			0x00
+#define DS4510_PULLUP_EN			0x01
+#define DS4510_RSTDELAY				0xF1
+#define DS4510_RSTDELAY_MASK			0x03
+#define DS4510_RSTDELAY_125			0x00
+#define DS4510_RSTDELAY_250			0x01
+#define DS4510_RSTDELAY_500			0x02
+#define DS4510_RSTDELAY_1000			0x03
+#define DS4510_IO3				0xF4
+#define DS4510_IO2				0xF5
+#define DS4510_IO1				0xF6
+#define DS4510_IO0				0xF7
+
+/* Status configuration registers from 0xf8 - 0xf9*/
+#define DS4510_IO_STATUS			0xF8
+#define DS4510_CFG				0xF9
+#define DS4510_CFG_READY			0x80
+#define DS4510_CFG_TRIP_POINT			0x40
+#define DS4510_CFG_RESET			0x20
+#define DS4510_CFG_SEE				0x10
+#define DS4510_CFG_SWRST			0x08
+
+/* SRAM from 0xfa - 0xff */
+#define DS4510_SRAM				0xfa
+#define DS4510_SRAM_SIZE			0x06
+
+int ds4510_mem_write(uint8_t chip, int offset, uint8_t *buf, int count);
+int ds4510_mem_read(uint8_t chip, int offset, uint8_t *buf, int count);
+int ds4510_see_write(uint8_t chip, uint8_t nv);
+int ds4510_rstdelay_write(uint8_t chip, uint8_t delay);
+int ds4510_pullup_write(uint8_t chip, uint8_t val);
+int ds4510_pullup_read(uint8_t chip);
+int ds4510_gpio_write(uint8_t chip, uint8_t val);
+int ds4510_gpio_read(uint8_t chip);
+int ds4510_gpio_read_val(uint8_t chip);
+
+#endif /* __DS4510_H_ */
diff -Naur u-boot-2009.01/include/e500.h u-boot/include/e500.h
--- u-boot-2009.01/include/e500.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/e500.h	2009-02-26 14:03:59.000000000 +0100
@@ -8,9 +8,13 @@
 
 #ifndef __ASSEMBLY__
 
+#ifndef CONFIG_NUM_CPUS
+#define CONFIG_NUM_CPUS 1
+#endif
+
 typedef struct
 {
-  unsigned long freqProcessor;
+  unsigned long freqProcessor[CONFIG_NUM_CPUS];
   unsigned long freqSystemBus;
   unsigned long freqDDRBus;
   unsigned long freqLocalBus;
diff -Naur u-boot-2009.01/include/flash.h u-boot/include/flash.h
--- u-boot-2009.01/include/flash.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/flash.h	2009-02-26 14:03:59.000000000 +0100
@@ -33,7 +33,7 @@
 	ulong	size;			/* total bank size in bytes		*/
 	ushort	sector_count;		/* number of erase units		*/
 	ulong	flash_id;		/* combined device & manufacturer code	*/
-	ulong	start[CONFIG_SYS_MAX_FLASH_SECT];   /* physical sector start addresses */
+	ulong	start[CONFIG_SYS_MAX_FLASH_SECT];   /* virtual sector start address */
 	uchar	protect[CONFIG_SYS_MAX_FLASH_SECT]; /* sector protection status	*/
 #ifdef CONFIG_SYS_FLASH_CFI
 	uchar	portwidth;		/* the width of the port		*/
@@ -124,6 +124,9 @@
 #define CFI_CMDSET_AMD_LEGACY		0xFFF0
 #endif
 
+#if defined(CONFIG_SYS_FLASH_CFI)
+extern flash_info_t *flash_get_info(ulong base);
+#endif
 
 /*-----------------------------------------------------------------------
  * return codes from flash_write():
diff -Naur u-boot-2009.01/include/fsl_esdhc.h u-boot/include/fsl_esdhc.h
--- u-boot-2009.01/include/fsl_esdhc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/fsl_esdhc.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,145 @@
+/*
+ * FSL SD/MMC Defines
+ *-------------------------------------------------------------------
+ *
+ * Copyright 2007-2008, Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ *-------------------------------------------------------------------
+ *
+ */
+
+#ifndef  __FSL_ESDHC_H__
+#define	__FSL_ESDHC_H__
+
+/* FSL eSDHC-specific constants */
+#define SYSCTL			0x0002e02c
+#define SYSCTL_INITA		0x08000000
+#define SYSCTL_TIMEOUT_MASK	0x000f0000
+#define SYSCTL_CLOCK_MASK	0x00000fff
+#define SYSCTL_PEREN		0x00000004
+#define SYSCTL_HCKEN		0x00000002
+#define SYSCTL_IPGEN		0x00000001
+
+#define IRQSTAT			0x0002e030
+#define IRQSTAT_DMAE		(0x10000000)
+#define IRQSTAT_AC12E		(0x01000000)
+#define IRQSTAT_DEBE		(0x00400000)
+#define IRQSTAT_DCE		(0x00200000)
+#define IRQSTAT_DTOE		(0x00100000)
+#define IRQSTAT_CIE		(0x00080000)
+#define IRQSTAT_CEBE		(0x00040000)
+#define IRQSTAT_CCE		(0x00020000)
+#define IRQSTAT_CTOE		(0x00010000)
+#define IRQSTAT_CINT		(0x00000100)
+#define IRQSTAT_CRM		(0x00000080)
+#define IRQSTAT_CINS		(0x00000040)
+#define IRQSTAT_BRR		(0x00000020)
+#define IRQSTAT_BWR		(0x00000010)
+#define IRQSTAT_DINT		(0x00000008)
+#define IRQSTAT_BGE		(0x00000004)
+#define IRQSTAT_TC		(0x00000002)
+#define IRQSTAT_CC		(0x00000001)
+
+#define CMD_ERR		(IRQSTAT_CIE | IRQSTAT_CEBE | IRQSTAT_CCE)
+#define DATA_ERR	(IRQSTAT_DEBE | IRQSTAT_DCE | IRQSTAT_DTOE)
+
+#define IRQSTATEN		0x0002e034
+#define IRQSTATEN_DMAE		(0x10000000)
+#define IRQSTATEN_AC12E		(0x01000000)
+#define IRQSTATEN_DEBE		(0x00400000)
+#define IRQSTATEN_DCE		(0x00200000)
+#define IRQSTATEN_DTOE		(0x00100000)
+#define IRQSTATEN_CIE		(0x00080000)
+#define IRQSTATEN_CEBE		(0x00040000)
+#define IRQSTATEN_CCE		(0x00020000)
+#define IRQSTATEN_CTOE		(0x00010000)
+#define IRQSTATEN_CINT		(0x00000100)
+#define IRQSTATEN_CRM		(0x00000080)
+#define IRQSTATEN_CINS		(0x00000040)
+#define IRQSTATEN_BRR		(0x00000020)
+#define IRQSTATEN_BWR		(0x00000010)
+#define IRQSTATEN_DINT		(0x00000008)
+#define IRQSTATEN_BGE		(0x00000004)
+#define IRQSTATEN_TC		(0x00000002)
+#define IRQSTATEN_CC		(0x00000001)
+
+#define PRSSTAT			0x0002e024
+#define PRSSTAT_CLSL		(0x00800000)
+#define PRSSTAT_WPSPL		(0x00080000)
+#define PRSSTAT_CDPL		(0x00040000)
+#define PRSSTAT_CINS		(0x00010000)
+#define PRSSTAT_BREN		(0x00000800)
+#define PRSSTAT_DLA		(0x00000004)
+#define PRSSTAT_CICHB		(0x00000002)
+#define PRSSTAT_CIDHB		(0x00000001)
+
+#define PROCTL			0x0002e028
+#define PROCTL_INIT		0x00000020
+#define PROCTL_DTW_4		0x00000002
+#define PROCTL_DTW_8		0x00000004
+
+#define CMDARG			0x0002e008
+
+#define XFERTYP			0x0002e00c
+#define XFERTYP_CMD(x)		((x & 0x3f) << 24)
+#define XFERTYP_CMDTYP_NORMAL	0x0
+#define XFERTYP_CMDTYP_SUSPEND	0x00400000
+#define XFERTYP_CMDTYP_RESUME	0x00800000
+#define XFERTYP_CMDTYP_ABORT	0x00c00000
+#define XFERTYP_DPSEL		0x00200000
+#define XFERTYP_CICEN		0x00100000
+#define XFERTYP_CCCEN		0x00080000
+#define XFERTYP_RSPTYP_NONE	0
+#define XFERTYP_RSPTYP_136	0x00010000
+#define XFERTYP_RSPTYP_48	0x00020000
+#define XFERTYP_RSPTYP_48_BUSY	0x00030000
+#define XFERTYP_MSBSEL		0x00000020
+#define XFERTYP_DTDSEL		0x00000010
+#define XFERTYP_AC12EN		0x00000004
+#define XFERTYP_BCEN		0x00000002
+#define XFERTYP_DMAEN		0x00000001
+
+#define CINS_TIMEOUT		1000
+
+#define DSADDR		0x2e004
+
+#define CMDRSP0		0x2e010
+#define CMDRSP1		0x2e014
+#define CMDRSP2		0x2e018
+#define CMDRSP3		0x2e01c
+
+#define DATPORT		0x2e020
+
+#define WML		0x2e044
+#define WML_WRITE	0x00010000
+
+#define BLKATTR		0x2e004
+#define BLKATTR_CNT(x)	((x & 0xffff) << 16)
+#define BLKATTR_SIZE(x)	(x & 0x1fff)
+#define MAX_BLK_CNT	0x7fff	/* so malloc will have enough room with 32M */
+
+#define ESDHC_HOSTCAPBLT_VS18	0x04000000
+#define ESDHC_HOSTCAPBLT_VS30	0x02000000
+#define ESDHC_HOSTCAPBLT_VS33	0x01000000
+#define ESDHC_HOSTCAPBLT_SRS	0x00800000
+#define ESDHC_HOSTCAPBLT_DMAS	0x00400000
+#define ESDHC_HOSTCAPBLT_HSS	0x00200000
+
+int fsl_esdhc_mmc_init(bd_t *bis);
+
+#endif  /* __FSL_ESDHC_H__ */
diff -Naur u-boot-2009.01/include/i2c.h u-boot/include/i2c.h
--- u-boot-2009.01/include/i2c.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/i2c.h	2009-02-26 14:03:59.000000000 +0100
@@ -159,14 +159,7 @@
 	printf("%s: addr=0x%02x, reg=0x%02x\n", __func__, addr, reg);
 #endif
 
-#ifdef CONFIG_BLACKFIN
-	/* This ifdef will become unneccessary in a future version of the
-	 * blackfin I2C driver.
-	 */
-	i2c_read(addr, reg, 0, &buf, 1);
-#else
 	i2c_read(addr, reg, 1, &buf, 1);
-#endif
 
 	return buf;
 }
@@ -183,14 +176,7 @@
 	       __func__, addr, reg, val);
 #endif
 
-#ifdef CONFIG_BLACKFIN
-	/* This ifdef will become unneccessary in a future version of the
-	 * blackfin I2C driver.
-	 */
-	i2c_write(addr, reg, 0, &val, 1);
-#else
 	i2c_write(addr, reg, 1, &val, 1);
-#endif
 }
 
 /*
diff -Naur u-boot-2009.01/include/image.h u-boot/include/image.h
--- u-boot-2009.01/include/image.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/image.h	2009-02-26 14:03:59.000000000 +0100
@@ -338,23 +338,23 @@
 	{ \
 		return uimage_to_cpu (hdr->ih_##f); \
 	}
-image_get_hdr_l (magic);
-image_get_hdr_l (hcrc);
-image_get_hdr_l (time);
-image_get_hdr_l (size);
-image_get_hdr_l (load);
-image_get_hdr_l (ep);
-image_get_hdr_l (dcrc);
+image_get_hdr_l (magic);	/* image_get_magic */
+image_get_hdr_l (hcrc);		/* image_get_hcrc */
+image_get_hdr_l (time);		/* image_get_time */
+image_get_hdr_l (size);		/* image_get_size */
+image_get_hdr_l (load);		/* image_get_load */
+image_get_hdr_l (ep);		/* image_get_ep */
+image_get_hdr_l (dcrc);		/* image_get_dcrc */
 
 #define image_get_hdr_b(f) \
 	static inline uint8_t image_get_##f(image_header_t *hdr) \
 	{ \
 		return hdr->ih_##f; \
 	}
-image_get_hdr_b (os);
-image_get_hdr_b (arch);
-image_get_hdr_b (type);
-image_get_hdr_b (comp);
+image_get_hdr_b (os);		/* image_get_os */
+image_get_hdr_b (arch);		/* image_get_arch */
+image_get_hdr_b (type);		/* image_get_type */
+image_get_hdr_b (comp);		/* image_get_comp */
 
 static inline char *image_get_name (image_header_t *hdr)
 {
@@ -396,23 +396,23 @@
 	{ \
 		hdr->ih_##f = cpu_to_uimage (val); \
 	}
-image_set_hdr_l (magic);
-image_set_hdr_l (hcrc);
-image_set_hdr_l (time);
-image_set_hdr_l (size);
-image_set_hdr_l (load);
-image_set_hdr_l (ep);
-image_set_hdr_l (dcrc);
+image_set_hdr_l (magic);	/* image_set_magic */
+image_set_hdr_l (hcrc);		/* image_set_hcrc */
+image_set_hdr_l (time);		/* image_set_time */
+image_set_hdr_l (size);		/* image_set_size */
+image_set_hdr_l (load);		/* image_set_load */
+image_set_hdr_l (ep);		/* image_set_ep */
+image_set_hdr_l (dcrc);		/* image_set_dcrc */
 
 #define image_set_hdr_b(f) \
 	static inline void image_set_##f(image_header_t *hdr, uint8_t val) \
 	{ \
 		hdr->ih_##f = val; \
 	}
-image_set_hdr_b (os);
-image_set_hdr_b (arch);
-image_set_hdr_b (type);
-image_set_hdr_b (comp);
+image_set_hdr_b (os);		/* image_set_os */
+image_set_hdr_b (arch);		/* image_set_arch */
+image_set_hdr_b (type);		/* image_set_type */
+image_set_hdr_b (comp);		/* image_set_comp */
 
 static inline void image_set_name (image_header_t *hdr, const char *name)
 {
diff -Naur u-boot-2009.01/include/linux/mtd/bbm.h u-boot/include/linux/mtd/bbm.h
--- u-boot-2009.01/include/linux/mtd/bbm.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/linux/mtd/bbm.h	2009-02-26 14:03:59.000000000 +0100
@@ -18,8 +18,8 @@
 #define __LINUX_MTD_BBM_H
 
 /* The maximum number of NAND chips in an array */
-#ifndef NAND_MAX_CHIPS
-#define NAND_MAX_CHIPS		8
+#ifndef CONFIG_SYS_NAND_MAX_CHIPS
+#define CONFIG_SYS_NAND_MAX_CHIPS	1
 #endif
 
 /**
@@ -48,10 +48,10 @@
  */
 struct nand_bbt_descr {
 	int options;
-	int pages[NAND_MAX_CHIPS];
+	int pages[CONFIG_SYS_NAND_MAX_CHIPS];
 	int offs;
 	int veroffs;
-	uint8_t version[NAND_MAX_CHIPS];
+	uint8_t version[CONFIG_SYS_NAND_MAX_CHIPS];
 	int len;
 	int maxblocks;
 	int reserved_block_code;
diff -Naur u-boot-2009.01/include/linux/mtd/nand.h u-boot/include/linux/mtd/nand.h
--- u-boot-2009.01/include/linux/mtd/nand.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/linux/mtd/nand.h	2009-02-26 14:03:59.000000000 +0100
@@ -46,11 +46,6 @@
 /* Internal helper for board drivers which need to override command function */
 extern void nand_wait_ready(struct mtd_info *mtd);
 
-/* The maximum number of NAND chips in an array */
-#ifndef NAND_MAX_CHIPS
-#define NAND_MAX_CHIPS		8
-#endif
-
 /* This constant declares the max. oobsize / page, which
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
@@ -477,10 +472,6 @@
 extern struct nand_flash_dev nand_flash_ids[];
 extern struct nand_manufacturers nand_manuf_ids[];
 
-#ifndef NAND_MAX_CHIPS
-#define NAND_MAX_CHIPS 8
-#endif
-
 extern int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd);
 extern int nand_update_bbt(struct mtd_info *mtd, loff_t offs);
 extern int nand_default_bbt(struct mtd_info *mtd);
diff -Naur u-boot-2009.01/include/linux/mtd/nand_legacy.h u-boot/include/linux/mtd/nand_legacy.h
--- u-boot-2009.01/include/linux/mtd/nand_legacy.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/linux/mtd/nand_legacy.h	2009-02-26 14:03:59.000000000 +0100
@@ -40,6 +40,11 @@
 #error This module is for the legacy NAND support
 #endif
 
+/* The maximum number of NAND chips in an array */
+#ifndef CONFIG_SYS_NAND_MAX_CHIPS
+#define CONFIG_SYS_NAND_MAX_CHIPS	1
+#endif
+
 /*
  * Standard NAND flash commands
  */
diff -Naur u-boot-2009.01/include/linux/mtd/onenand.h u-boot/include/linux/mtd/onenand.h
--- u-boot-2009.01/include/linux/mtd/onenand.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/linux/mtd/onenand.h	2009-02-26 14:03:59.000000000 +0100
@@ -30,14 +30,10 @@
 
 /**
  * struct onenand_bufferram - OneNAND BufferRAM Data
- * @param block		block address in BufferRAM
- * @param page		page address in BufferRAM
- * @param valid		valid flag
+ * @param blockpage	block & page address in BufferRAM
  */
 struct onenand_bufferram {
-	int block;
-	int page;
-	int valid;
+	int blockpage;
 };
 
 /**
@@ -70,6 +66,8 @@
 	void __iomem *base;
 	unsigned int chipsize;
 	unsigned int device_id;
+	unsigned int version_id;
+	unsigned int density_mask;
 	unsigned int options;
 
 	unsigned int erase_shift;
@@ -81,26 +79,36 @@
 	unsigned int bufferram_index;
 	struct onenand_bufferram bufferram[MAX_BUFFERRAM];
 
-	int (*command) (struct mtd_info * mtd, int cmd, loff_t address,
+	int (*command) (struct mtd_info *mtd, int cmd, loff_t address,
 			size_t len);
-	int (*wait) (struct mtd_info * mtd, int state);
-	int (*read_bufferram) (struct mtd_info * mtd, int area,
+	int (*wait) (struct mtd_info *mtd, int state);
+	int (*bbt_wait) (struct mtd_info *mtd, int state);
+	int (*read_bufferram) (struct mtd_info *mtd, loff_t addr, int area,
 			       unsigned char *buffer, int offset, size_t count);
-	int (*write_bufferram) (struct mtd_info * mtd, int area,
+	int (*read_spareram) (struct mtd_info *mtd, loff_t addr, int area,
+			       unsigned char *buffer, int offset, size_t count);
+	int (*write_bufferram) (struct mtd_info *mtd, loff_t addr, int area,
 				const unsigned char *buffer, int offset,
 				size_t count);
-	unsigned short (*read_word) (void __iomem * addr);
-	void (*write_word) (unsigned short value, void __iomem * addr);
-	void (*mmcontrol) (struct mtd_info * mtd, int sync_read);
+	unsigned short (*read_word) (void __iomem *addr);
+	void (*write_word) (unsigned short value, void __iomem *addr);
+	void (*mmcontrol) (struct mtd_info *mtd, int sync_read);
 	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
 	int (*scan_bbt)(struct mtd_info *mtd);
 
+	unsigned char		*main_buf;
+	unsigned char		*spare_buf;
+#ifdef DONT_USE_UBOOT
+	spinlock_t chip_lock;
+	wait_queue_head_t wq;
+#endif
 	int state;
-	unsigned char *page_buf;
-	unsigned char *oob_buf;
+	unsigned char		*page_buf;
+	unsigned char		*oob_buf;
 
 	struct nand_oobinfo *autooob;
-	struct nand_ecclayout *ecclayout;
+	int			subpagesize;
+	struct nand_ecclayout	*ecclayout;
 
 	void *bbm;
 
@@ -125,7 +133,9 @@
 /*
  * Options bits
  */
-#define ONENAND_CONT_LOCK		(0x0001)
+#define ONENAND_HAS_CONT_LOCK		(0x0001)
+#define ONENAND_HAS_UNLOCK_ALL		(0x0002)
+#define ONENAND_HAS_2PLANE		(0x0004)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
 #define ONENAND_OOBBUF_ALLOC		(0x2000)
 
@@ -133,7 +143,6 @@
  * OneNAND Flash Manufacturer ID Codes
  */
 #define ONENAND_MFR_SAMSUNG	0xec
-#define ONENAND_MFR_UNKNOWN	0x00
 
 /**
  * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
diff -Naur u-boot-2009.01/include/linux/mtd/onenand_regs.h u-boot/include/linux/mtd/onenand_regs.h
--- u-boot-2009.01/include/linux/mtd/onenand_regs.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/linux/mtd/onenand_regs.h	2009-02-26 14:03:59.000000000 +0100
@@ -119,6 +119,7 @@
 #define ONENAND_CMD_UNLOCK		(0x23)
 #define ONENAND_CMD_LOCK		(0x2A)
 #define ONENAND_CMD_LOCK_TIGHT		(0x2C)
+#define ONENAND_CMD_UNLOCK_ALL		(0x27)
 #define ONENAND_CMD_ERASE		(0x94)
 #define ONENAND_CMD_RESET		(0xF0)
 #define ONENAND_CMD_READID		(0x90)
diff -Naur u-boot-2009.01/include/mb862xx.h u-boot/include/mb862xx.h
--- u-boot-2009.01/include/mb862xx.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/mb862xx.h	2009-02-26 14:03:59.000000000 +0100
@@ -12,7 +12,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
diff -Naur u-boot-2009.01/include/mmc.h u-boot/include/mmc.h
--- u-boot-2009.01/include/mmc.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/mmc.h	2009-02-26 14:03:59.000000000 +0100
@@ -1,6 +1,8 @@
 /*
- * (C) Copyright 2000-2003
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ * Copyright 2008, Freescale Semiconductor, Inc
+ * Andy Fleming
+ *
+ * Based (loosely) on the Linux code
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -23,35 +25,255 @@
 
 #ifndef _MMC_H_
 #define _MMC_H_
-#include <asm/arch/mmc.h>
 
-/* MMC command numbers */
+#include <linux/list.h>
+
+#define SD_VERSION_SD	0x20000
+#define SD_VERSION_2	(SD_VERSION_SD | 0x20)
+#define SD_VERSION_1_0	(SD_VERSION_SD | 0x10)
+#define SD_VERSION_1_10	(SD_VERSION_SD | 0x1a)
+#define MMC_VERSION_MMC		0x10000
+#define MMC_VERSION_UNKNOWN	(MMC_VERSION_MMC)
+#define MMC_VERSION_1_2		(MMC_VERSION_MMC | 0x12)
+#define MMC_VERSION_1_4		(MMC_VERSION_MMC | 0x14)
+#define MMC_VERSION_2_2		(MMC_VERSION_MMC | 0x22)
+#define MMC_VERSION_3		(MMC_VERSION_MMC | 0x30)
+#define MMC_VERSION_4		(MMC_VERSION_MMC | 0x40)
+
+#define MMC_MODE_HS		0x001
+#define MMC_MODE_HS_52MHz	0x010
+#define MMC_MODE_4BIT		0x100
+#define MMC_MODE_8BIT		0x200
+
+#define SD_DATA_4BIT	0x00040000
+
+#define IS_SD(x) (mmc->version & SD_VERSION_SD)
+
+#define MMC_DATA_READ		1
+#define MMC_DATA_WRITE		2
+
+#define NO_CARD_ERR		-16 /* No SD/MMC card inserted */
+#define UNUSABLE_ERR		-17 /* Unusable Card */
+#define COMM_ERR		-18 /* Communications Error */
+#define TIMEOUT			-19
+
 #define MMC_CMD_GO_IDLE_STATE		0
 #define MMC_CMD_SEND_OP_COND		1
 #define MMC_CMD_ALL_SEND_CID		2
 #define MMC_CMD_SET_RELATIVE_ADDR	3
 #define MMC_CMD_SET_DSR			4
+#define MMC_CMD_SWITCH			6
 #define MMC_CMD_SELECT_CARD		7
+#define MMC_CMD_SEND_EXT_CSD		8
 #define MMC_CMD_SEND_CSD		9
 #define MMC_CMD_SEND_CID		10
+#define MMC_CMD_STOP_TRANSMISSION	12
 #define MMC_CMD_SEND_STATUS		13
 #define MMC_CMD_SET_BLOCKLEN		16
 #define MMC_CMD_READ_SINGLE_BLOCK	17
 #define MMC_CMD_READ_MULTIPLE_BLOCK	18
-#define MMC_CMD_WRITE_BLOCK		24
+#define MMC_CMD_WRITE_SINGLE_BLOCK	24
+#define MMC_CMD_WRITE_MULTIPLE_BLOCK	25
 #define MMC_CMD_APP_CMD			55
 
-/* SD Card command numbers */
 #define SD_CMD_SEND_RELATIVE_ADDR	3
-#define SD_CMD_SWITCH			6
+#define SD_CMD_SWITCH_FUNC		6
 #define SD_CMD_SEND_IF_COND		8
 
 #define SD_CMD_APP_SET_BUS_WIDTH	6
 #define SD_CMD_APP_SEND_OP_COND		41
+#define SD_CMD_APP_SEND_SCR		51
+
+/* SCR definitions in different words */
+#define SD_HIGHSPEED_BUSY	0x00020000
+#define SD_HIGHSPEED_SUPPORTED	0x00020000
+
+#define MMC_HS_TIMING		0x00000100
+#define MMC_HS_52MHZ		0x2
+
+#define OCR_BUSY	0x80
+#define OCR_HCS		0x40000000
+
+#define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
+#define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
+#define MMC_VDD_21_22		0x00000200	/* VDD voltage 2.1 ~ 2.2 */
+#define MMC_VDD_22_23		0x00000400	/* VDD voltage 2.2 ~ 2.3 */
+#define MMC_VDD_23_24		0x00000800	/* VDD voltage 2.3 ~ 2.4 */
+#define MMC_VDD_24_25		0x00001000	/* VDD voltage 2.4 ~ 2.5 */
+#define MMC_VDD_25_26		0x00002000	/* VDD voltage 2.5 ~ 2.6 */
+#define MMC_VDD_26_27		0x00004000	/* VDD voltage 2.6 ~ 2.7 */
+#define MMC_VDD_27_28		0x00008000	/* VDD voltage 2.7 ~ 2.8 */
+#define MMC_VDD_28_29		0x00010000	/* VDD voltage 2.8 ~ 2.9 */
+#define MMC_VDD_29_30		0x00020000	/* VDD voltage 2.9 ~ 3.0 */
+#define MMC_VDD_30_31		0x00040000	/* VDD voltage 3.0 ~ 3.1 */
+#define MMC_VDD_31_32		0x00080000	/* VDD voltage 3.1 ~ 3.2 */
+#define MMC_VDD_32_33		0x00100000	/* VDD voltage 3.2 ~ 3.3 */
+#define MMC_VDD_33_34		0x00200000	/* VDD voltage 3.3 ~ 3.4 */
+#define MMC_VDD_34_35		0x00400000	/* VDD voltage 3.4 ~ 3.5 */
+#define MMC_VDD_35_36		0x00800000	/* VDD voltage 3.5 ~ 3.6 */
+
+#define MMC_SWITCH_MODE_CMD_SET		0x00 /* Change the command set */
+#define MMC_SWITCH_MODE_SET_BITS	0x01 /* Set bits in EXT_CSD byte
+						addressed by index which are
+						1 in value field */
+#define MMC_SWITCH_MODE_CLEAR_BITS	0x02 /* Clear bits in EXT_CSD byte
+						addressed by index, which are
+						1 in value field */
+#define MMC_SWITCH_MODE_WRITE_BYTE	0x03 /* Set target byte to value */
+
+#define SD_SWITCH_CHECK		0
+#define SD_SWITCH_SWITCH	1
+
+/*
+ * EXT_CSD fields
+ */
+
+#define EXT_CSD_BUS_WIDTH	183	/* R/W */
+#define EXT_CSD_HS_TIMING	185	/* R/W */
+#define EXT_CSD_CARD_TYPE	196	/* RO */
+#define EXT_CSD_REV		192	/* RO */
+#define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
+
+/*
+ * EXT_CSD field definitions
+ */
+
+#define EXT_CSD_CMD_SET_NORMAL		(1<<0)
+#define EXT_CSD_CMD_SET_SECURE		(1<<1)
+#define EXT_CSD_CMD_SET_CPSECURE	(1<<2)
+
+#define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
+#define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
+
+#define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
+#define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
+#define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
+
+#define R1_ILLEGAL_COMMAND		(1 << 22)
+#define R1_APP_CMD			(1 << 5)
+
+#define MMC_RSP_PRESENT (1 << 0)
+#define MMC_RSP_136     (1 << 1)                /* 136 bit response */
+#define MMC_RSP_CRC     (1 << 2)                /* expect valid crc */
+#define MMC_RSP_BUSY    (1 << 3)                /* card may send busy */
+#define MMC_RSP_OPCODE  (1 << 4)                /* response contains opcode */
+
+#define MMC_RSP_NONE    (0)
+#define MMC_RSP_R1      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R1b	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE| \
+			MMC_RSP_BUSY)
+#define MMC_RSP_R2      (MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
+#define MMC_RSP_R3      (MMC_RSP_PRESENT)
+#define MMC_RSP_R4      (MMC_RSP_PRESENT)
+#define MMC_RSP_R5      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R6      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R7      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+
+
+struct mmc_cid {
+	unsigned long psn;
+	unsigned short oid;
+	unsigned char mid;
+	unsigned char prv;
+	unsigned char mdt;
+	char pnm[7];
+};
+
+struct mmc_csd
+{
+	u8	csd_structure:2,
+		spec_vers:4,
+		rsvd1:2;
+	u8	taac;
+	u8	nsac;
+	u8	tran_speed;
+	u16	ccc:12,
+		read_bl_len:4;
+	u64	read_bl_partial:1,
+		write_blk_misalign:1,
+		read_blk_misalign:1,
+		dsr_imp:1,
+		rsvd2:2,
+		c_size:12,
+		vdd_r_curr_min:3,
+		vdd_r_curr_max:3,
+		vdd_w_curr_min:3,
+		vdd_w_curr_max:3,
+		c_size_mult:3,
+		sector_size:5,
+		erase_grp_size:5,
+		wp_grp_size:5,
+		wp_grp_enable:1,
+		default_ecc:2,
+		r2w_factor:3,
+		write_bl_len:4,
+		write_bl_partial:1,
+		rsvd3:5;
+	u8	file_format_grp:1,
+		copy:1,
+		perm_write_protect:1,
+		tmp_write_protect:1,
+		file_format:2,
+		ecc:2;
+	u8	crc:7;
+	u8	one:1;
+};
+
+struct mmc_cmd {
+	ushort cmdidx;
+	uint resp_type;
+	uint cmdarg;
+	char response[18];
+	uint flags;
+};
+
+struct mmc_data {
+	union {
+		char *dest;
+		const char *src; /* src buffers don't get written to */
+	};
+	uint flags;
+	uint blocks;
+	uint blocksize;
+};
+
+struct mmc {
+	struct list_head link;
+	char name[32];
+	void *priv;
+	uint voltages;
+	uint version;
+	uint f_min;
+	uint f_max;
+	int high_capacity;
+	uint bus_width;
+	uint clock;
+	uint card_caps;
+	uint host_caps;
+	uint ocr;
+	uint scr[2];
+	uint csd[4];
+	char cid[16];
+	ushort rca;
+	uint tran_speed;
+	uint read_bl_len;
+	uint write_bl_len;
+	u64 capacity;
+	block_dev_desc_t block_dev;
+	int (*send_cmd)(struct mmc *mmc,
+			struct mmc_cmd *cmd, struct mmc_data *data);
+	void (*set_ios)(struct mmc *mmc);
+	int (*init)(struct mmc *mmc);
+};
 
-int mmc_init(int verbose);
-int mmc_read(ulong src, uchar *dst, int size);
-int mmc_write(uchar *src, ulong dst, int size);
-int mmc2info(ulong addr);
+int mmc_register(struct mmc *mmc);
+int mmc_initialize(bd_t *bis);
+int mmc_init(struct mmc *mmc);
+int mmc_read(struct mmc *mmc, u64 src, uchar *dst, int size);
+struct mmc *find_mmc_device(int dev_num);
+void print_mmc_devices(char separator);
 
+#ifndef CONFIG_GENERIC_MMC
+int mmc_legacy_init(int verbose);
+#endif
 #endif /* _MMC_H_ */
diff -Naur u-boot-2009.01/include/mpc512x.h u-boot/include/mpc512x.h
--- u-boot-2009.01/include/mpc512x.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/mpc512x.h	2009-02-26 14:03:59.000000000 +0100
@@ -573,6 +573,31 @@
 
  /* Register Offset Base */
 #define MPC512X_FEC		(CONFIG_SYS_IMMR + 0x02800)
+#define MPC512X_PATA		(CONFIG_SYS_IMMR + 0x10200)
+
+/* IIM control */
+#define IIM_SET_UA(bk, f)	((bk << 3) | (f >> 5))
+#define IIM_SET_LA(f, bit)	(((f & 0x0000001f) << 3) | bit)
+#define IIM_STAT_BUSY		0x00000080
+#define IIM_STAT_PRGD		0x00000002
+#define IIM_STAT_SNSD		0x00000001
+#define IIM_ERR_WPE		0x00000040
+#define IIM_ERR_OPE		0x00000020
+#define IIM_ERR_RPE		0x00000010
+#define IIM_ERR_WLRE		0x00000008
+#define IIM_ERR_SNSE		0x00000004
+#define IIM_ERR_PARITYE		0x00000002
+#define IIM_PRG_P_SET		0x000000aa
+#define IIM_PRG_P_UNSET		0
+#define IIM_FCTL_PROG_PULSE	0x00000020
+#define IIM_FCTL_PROG		0x00000001
+#define IIM_FCTL_ESNS_N		0x00000008
+#define	IIM_FBAC_FBWP		0x00000080
+#define IIM_FBAC_FBOP		0x00000040
+#define IIM_FBAC_FBRP		0x00000020
+#define	IIM_FBAC_FBESP		0x00000008
+#define IIM_PROTECTION		0x000000e8
+#define IIM_FMAX			31
 
 /* Number of I2C buses */
 #define I2C_BUS_CNT	3
diff -Naur u-boot-2009.01/include/mpc824x.h u-boot/include/mpc824x.h
--- u-boot-2009.01/include/mpc824x.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/mpc824x.h	2009-02-26 14:03:59.000000000 +0100
@@ -451,45 +451,6 @@
 #define MICR_EADDR_MASK		0x30000000
 #define MICR_EADDR_SHIFT	28
 
-#define BATU_BEPI_MSK		0xfffe0000
-#define BATU_BL_MSK		0x00001ffc
-
-#define BATU_BL_128K		0x00000000
-#define BATU_BL_256K		0x00000004
-#define BATU_BL_512K		0x0000000c
-#define BATU_BL_1M		0x0000001c
-#define BATU_BL_2M		0x0000003c
-#define BATU_BL_4M		0x0000007c
-#define BATU_BL_8M		0x000000fc
-#define BATU_BL_16M		0x000001fc
-#define BATU_BL_32M		0x000003fc
-#define BATU_BL_64M		0x000007fc
-#define BATU_BL_128M		0x00000ffc
-#define BATU_BL_256M		0x00001ffc
-
-#define BATU_VS			0x00000002
-#define BATU_VP			0x00000001
-
-#define BATL_BRPN_MSK		0xfffe0000
-#define BATL_WIMG_MSK		0x00000078
-
-#define BATL_WRITETHROUGH	0x00000040
-#define BATL_CACHEINHIBIT	0x00000020
-#define BATL_MEMCOHERENCE	0x00000010
-#define BATL_GUARDEDSTORAGE	0x00000008
-
-#define BATL_PP_MSK		0x00000003
-#define BATL_PP_00		0x00000000 /* No access */
-#define BATL_PP_01		0x00000001 /* Read-only */
-#define BATL_PP_10		0x00000002 /* Read-write */
-#define BATL_PP_11		0x00000003
-
-/*
- * I'd attempt to do defines for the PP bits, but it's use is a bit
- * too complex, see the PowerPC Operating Environment Architecture
- * section in the PowerPc arch book, chapter 4.
- */
-
 /*eumb and epic config*/
 
 #define EPIC_FPR		0x00041000
diff -Naur u-boot-2009.01/include/mpc83xx.h u-boot/include/mpc83xx.h
--- u-boot-2009.01/include/mpc83xx.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/mpc83xx.h	2009-02-26 14:03:59.000000000 +0100
@@ -266,6 +266,7 @@
 /* SICRL bits - MPC837x specific */
 #define SICRL_USB_A			0xC0000000
 #define SICRL_USB_B			0x30000000
+#define SICRL_USB_B_SD			0x20000000
 #define SICRL_UART			0x0C000000
 #define SICRL_GPIO_A			0x02000000
 #define SICRL_GPIO_B			0x01000000
@@ -307,10 +308,12 @@
 #define SICRH_GPIO2_C			0x00002000
 #define SICRH_GPIO2_D			0x00001000
 #define SICRH_GPIO2_E			0x00000C00
+#define SICRH_GPIO2_E_SD		0x00000800
 #define SICRH_GPIO2_F			0x00000300
 #define SICRH_GPIO2_G			0x000000C0
 #define SICRH_GPIO2_H			0x00000030
 #define SICRH_SPI			0x00000003
+#define SICRH_SPI_SD			0x00000001
 #endif
 
 /* SWCRR - System Watchdog Control Register
@@ -751,9 +754,6 @@
 #define SCCR_USBDRCM_2			0x00800000
 #define SCCR_USBDRCM_3			0x00c00000
 
-#define SCCR_PCIEXP1CM			0x00300000
-#define SCCR_PCIEXP2CM			0x000c0000
-
 #define SCCR_SATA1CM			0x00003000
 #define SCCR_SATA1CM_SHIFT		12
 #define SCCR_SATACM			0x00003c00
@@ -800,6 +800,17 @@
 #define SCCR_USBDRCM_2			0x00800000
 #define SCCR_USBDRCM_3			0x00c00000
 
+/* All of the four SATA controllers must have the same clock ratio */
+#define SCCR_SATA1CM			0x000000c0
+#define SCCR_SATA1CM_SHIFT		6
+#define SCCR_SATACM			0x000000ff
+#define SCCR_SATACM_SHIFT		0
+#define SCCR_SATACM_0			0x00000000
+#define SCCR_SATACM_1			0x00000055
+#define SCCR_SATACM_2			0x000000aa
+#define SCCR_SATACM_3			0x000000ff
+#endif
+
 #define SCCR_PCIEXP1CM			0x00300000
 #define SCCR_PCIEXP1CM_SHIFT		20
 #define SCCR_PCIEXP1CM_0		0x00000000
@@ -814,17 +825,6 @@
 #define SCCR_PCIEXP2CM_2		0x00080000
 #define SCCR_PCIEXP2CM_3		0x000c0000
 
-/* All of the four SATA controllers must have the same clock ratio */
-#define SCCR_SATA1CM			0x000000c0
-#define SCCR_SATA1CM_SHIFT		6
-#define SCCR_SATACM			0x000000ff
-#define SCCR_SATACM_SHIFT		0
-#define SCCR_SATACM_0			0x00000000
-#define SCCR_SATACM_1			0x00000055
-#define SCCR_SATACM_2			0x000000aa
-#define SCCR_SATACM_3			0x000000ff
-#endif
-
 /* CSn_BDNS - Chip Select memory Bounds Register
  */
 #define CSBNDS_SA			0x00FF0000
@@ -1170,9 +1170,52 @@
 #define DDRCDR_M_ODR		0x00000002
 #define DDRCDR_Q_DRN		0x00000001
 
+/* PCIE Bridge Register
+*/
+#define PEX_CSB_CTRL_OBPIOE	0x00000001
+#define PEX_CSB_CTRL_IBPIOE	0x00000002
+#define PEX_CSB_CTRL_WDMAE	0x00000004
+#define PEX_CSB_CTRL_RDMAE	0x00000008
+
+#define PEX_CSB_OBCTRL_PIOE	0x00000001
+#define PEX_CSB_OBCTRL_MEMWE	0x00000002
+#define PEX_CSB_OBCTRL_IOWE	0x00000004
+#define PEX_CSB_OBCTRL_CFGWE	0x00000008
+
+#define PEX_CSB_IBCTRL_PIOE	0x00000001
+
+#define PEX_OWAR_EN		0x00000001
+#define PEX_OWAR_TYPE_CFG	0x00000000
+#define PEX_OWAR_TYPE_IO	0x00000002
+#define PEX_OWAR_TYPE_MEM	0x00000004
+#define PEX_OWAR_RLXO		0x00000008
+#define PEX_OWAR_NANP		0x00000010
+#define PEX_OWAR_SIZE		0xFFFFF000
+
+#define PEX_IWAR_EN		0x00000001
+#define PEX_IWAR_TYPE_INT	0x00000000
+#define PEX_IWAR_TYPE_PF	0x00000004
+#define PEX_IWAR_TYPE_NO_PF	0x00000006
+#define PEX_IWAR_NSOV		0x00000008
+#define PEX_IWAR_NSNP		0x00000010
+#define PEX_IWAR_SIZE		0xFFFFF000
+#define PEX_IWAR_SIZE_1M	0x000FF000
+#define PEX_IWAR_SIZE_2M	0x001FF000
+#define PEX_IWAR_SIZE_4M	0x003FF000
+#define PEX_IWAR_SIZE_8M	0x007FF000
+#define PEX_IWAR_SIZE_16M	0x00FFF000
+#define PEX_IWAR_SIZE_32M	0x01FFF000
+#define PEX_IWAR_SIZE_64M	0x03FFF000
+#define PEX_IWAR_SIZE_128M	0x07FFF000
+#define PEX_IWAR_SIZE_256M	0x0FFFF000
+
+#define PEX_GCLK_RATIO		0x440
+
 #ifndef __ASSEMBLY__
 struct pci_region;
 void mpc83xx_pci_init(int num_buses, struct pci_region **reg, int warmboot);
+void mpc83xx_pcislave_unlock(int bus);
+void mpc83xx_pcie_init(int num_buses, struct pci_region **reg, int warmboot);
 #endif
 
 #endif	/* __MPC83XX_H__ */
diff -Naur u-boot-2009.01/include/mpc86xx.h u-boot/include/mpc86xx.h
--- u-boot-2009.01/include/mpc86xx.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/mpc86xx.h	2009-02-26 14:03:59.000000000 +0100
@@ -34,47 +34,6 @@
 #define L2CR_HWF         0x00000800 /* bit 20 - hardware flush */
 #define L2CR_L2IP        0x00000001 /* global invalidate in progress */
 
-/*
- * BAT settings.  Look in config_<BOARD>.h for the actual setup
- */
-
-#define BATU_BL_128K            0x00000000
-#define BATU_BL_256K            0x00000004
-#define BATU_BL_512K            0x0000000c
-#define BATU_BL_1M              0x0000001c
-#define BATU_BL_2M              0x0000003c
-#define BATU_BL_4M              0x0000007c
-#define BATU_BL_8M              0x000000fc
-#define BATU_BL_16M             0x000001fc
-#define BATU_BL_32M             0x000003fc
-#define BATU_BL_64M             0x000007fc
-#define BATU_BL_128M            0x00000ffc
-#define BATU_BL_256M            0x00001ffc
-#define BATU_BL_512M            0x00003ffc
-#define BATU_BL_1G              0x00007ffc
-#define BATU_BL_2G              0x0000fffc
-#define BATU_BL_4G              0x0001fffc
-
-#define BATU_VS                 0x00000002
-#define BATU_VP                 0x00000001
-#define BATU_INVALID            0x00000000
-
-#define BATL_WRITETHROUGH       0x00000040
-#define BATL_CACHEINHIBIT       0x00000020
-#define BATL_MEMCOHERENCE	0x00000010
-#define BATL_GUARDEDSTORAGE     0x00000008
-#define BATL_NO_ACCESS		0x00000000
-
-#define BATL_PP_MSK		0x00000003
-#define BATL_PP_00		0x00000000 /* No access */
-#define BATL_PP_01		0x00000001 /* Read-only */
-#define BATL_PP_10		0x00000002 /* Read-write */
-#define BATL_PP_11		0x00000003
-
-#define BATL_PP_NO_ACCESS	BATL_PP_00
-#define BATL_PP_RO		BATL_PP_01
-#define BATL_PP_RW		BATL_PP_10
-
 #define HID0_XBSEN              0x00000100
 #define HID0_HIGH_BAT_EN        0x00800000
 #define HID0_XAEN               0x00020000
diff -Naur u-boot-2009.01/include/nand.h u-boot/include/nand.h
--- u-boot-2009.01/include/nand.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/nand.h	2009-02-26 14:03:59.000000000 +0100
@@ -31,6 +31,8 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
 
+extern int board_nand_init(struct nand_chip *nand);
+
 typedef struct mtd_info nand_info_t;
 
 extern int nand_curr_device;
diff -Naur u-boot-2009.01/include/netdev.h u-boot/include/netdev.h
--- u-boot-2009.01/include/netdev.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/netdev.h	2009-02-26 14:03:59.000000000 +0100
@@ -12,7 +12,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -44,6 +44,7 @@
 int au1x00_enet_initialize(bd_t*);
 int bfin_EMAC_initialize(bd_t *bis);
 int dc21x4x_initialize(bd_t *bis);
+int dnet_eth_initialize(int id, void *regs, unsigned int phy_addr);
 int e1000_initialize(bd_t *bis);
 int eepro100_initialize(bd_t *bis);
 int eth_3com_initialize (bd_t * bis);
@@ -57,6 +58,7 @@
 int mpc512x_fec_initialize(bd_t *bis);
 int mpc5xxx_fec_initialize(bd_t *bis);
 int mpc8220_fec_initialize(bd_t *bis);
+int mpc82xx_scc_enet_initialize(bd_t *bis);
 int natsemi_initialize(bd_t *bis);
 int npe_initialize(bd_t *bis);
 int ns8382x_initialize(bd_t *bis);
@@ -70,6 +72,7 @@
 int tsi108_eth_initialize(bd_t *bis);
 int uec_initialize(int index);
 int uli526x_initialize(bd_t *bis);
+int sh_eth_initialize(bd_t *bis);
 
 /* Boards with PCI network controllers can call this from their board_eth_init()
  * function to initialize whatever's on board.
diff -Naur u-boot-2009.01/include/net.h u-boot/include/net.h
--- u-boot-2009.01/include/net.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/net.h	2009-02-26 14:03:59.000000000 +0100
@@ -109,25 +109,26 @@
 	void *priv;
 };
 
-extern int eth_initialize(bd_t *bis);		/* Initialize network subsystem */
-extern int eth_register(struct eth_device* dev);/* Register network device	*/
-extern void eth_try_another(int first_restart);	/* Change the device		*/
+extern int eth_initialize(bd_t *bis);	/* Initialize network subsystem */
+extern int eth_register(struct eth_device* dev);/* Register network device */
+extern void eth_try_another(int first_restart);	/* Change the device */
 #ifdef CONFIG_NET_MULTI
-extern void eth_set_current(void);		/* set nterface to ethcur var.  */
+extern void eth_set_current(void);		/* set nterface to ethcur var */
 #endif
-extern struct eth_device *eth_get_dev(void);	/* get the current device MAC	*/
-extern struct eth_device *eth_get_dev_by_name(char *devname); /* get device	*/
-extern int eth_get_dev_index (void);		/* get the device index         */
-extern void eth_set_enetaddr(int num, char* a);	/* Set new MAC address		*/
+extern struct eth_device *eth_get_dev(void);	/* get the current device MAC */
+extern struct eth_device *eth_get_dev_by_name(char *devname); /* get device */
+extern struct eth_device *eth_get_dev_by_index(int index); /* get dev @ index */
+extern int eth_get_dev_index (void);		/* get the device index */
+extern void eth_set_enetaddr(int num, char* a);	/* Set new MAC address */
 
-extern int eth_init(bd_t *bis);			/* Initialize the device	*/
-extern int eth_send(volatile void *packet, int length);	   /* Send a packet	*/
+extern int eth_init(bd_t *bis);			/* Initialize the device */
+extern int eth_send(volatile void *packet, int length);	   /* Send a packet */
 #ifdef CONFIG_API
-extern int eth_receive(volatile void *packet, int length); /* Receive a packet	*/
+extern int eth_receive(volatile void *packet, int length); /* Receive a packet*/
 #endif
-extern int eth_rx(void);			/* Check for received packets	*/
-extern void eth_halt(void);			/* stop SCC			*/
-extern char *eth_get_name(void);		/* get name of current device	*/
+extern int eth_rx(void);			/* Check for received packets */
+extern void eth_halt(void);			/* stop SCC */
+extern char *eth_get_name(void);		/* get name of current device */
 
 #ifdef CONFIG_MCAST_TFTP
 int eth_mcast_join( IPaddr_t mcast_addr, u8 join);
@@ -474,6 +475,22 @@
 	return (0x01 & addr[0]);
 }
 
+/**
+ * is_valid_ether_addr - Determine if the given Ethernet address is valid
+ * @addr: Pointer to a six-byte array containing the Ethernet address
+ *
+ * Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not
+ * a multicast address, and is not FF:FF:FF:FF:FF:FF.
+ *
+ * Return true if the address is valid.
+ */
+static inline int is_valid_ether_addr(const u8 * addr)
+{
+	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
+	 * explicitly check for it here. */
+	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
+}
+
 /* Convert an IP address to a string */
 extern void	ip_to_string (IPaddr_t x, char *s);
 
diff -Naur u-boot-2009.01/include/nomadik.h u-boot/include/nomadik.h
--- u-boot-2009.01/include/nomadik.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/include/nomadik.h	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,39 @@
+/* Collection of constants used to access Nomadik registers */
+
+#ifndef __NOMADIK_H__
+#define __NOMADIK_H__
+
+/* Base addresses of our peripherals */
+#define NOMADIK_SRC_BASE	0x101E0000	/* System and Reset Cnt */
+#define NOMADIK_PMU_BASE	0x101E9000	/* Power Management Unit */
+#define NOMADIK_MPMC_BASE	0x10110000	/* SDRAM Controller */
+#define NOMADIK_FSMC_BASE	0x10100000	/* FSMC Controller */
+#define NOMADIK_1NAND_BASE	0x30000000
+#define NOMADIK_GPIO0_BASE	0x101E4000
+#define NOMADIK_GPIO1_BASE	0x101E5000
+#define NOMADIK_GPIO2_BASE	0x101E6000
+#define NOMADIK_GPIO3_BASE	0x101E7000
+#define NOMADIK_CPLD_BASE	0x36000000
+#define NOMADIK_UART0_BASE	0x101FD000
+#define NOMADIK_UART1_BASE	0x101FB000
+#define NOMADIK_UART2_BASE	0x101F2000
+
+#define NOMADIK_I2C1_BASE	0x101F7000	/* I2C1 interface */
+#define NOMADIK_I2C0_BASE	0x101F8000	/* I2C0 interface */
+
+#define NOMADIK_RTC_BASE	0x101E8000
+#define NOMADIK_ETH0_BASE	0x36800300
+#define NOMADIK_CPLD_UART_BASE	0x36480000
+
+/* Chip select registers ("Flexible Static Memory Controller") */
+
+#define REG_FSMC_BCR0	(NOMADIK_FSMC_BASE + 0x00)
+#define REG_FSMC_BTR0	(NOMADIK_FSMC_BASE + 0x04)
+#define REG_FSMC_BCR1	(NOMADIK_FSMC_BASE + 0x08)
+#define REG_FSMC_BTR1	(NOMADIK_FSMC_BASE + 0x0c)
+#define REG_FSMC_PCR0	(NOMADIK_FSMC_BASE + 0x40)
+#define REG_FSMC_PMEM0	(NOMADIK_FSMC_BASE + 0x48)
+#define REG_FSMC_PATT0	(NOMADIK_FSMC_BASE + 0x4c)
+#define REG_FSMC_ECCR0	(NOMADIK_FSMC_BASE + 0x54)
+
+#endif /* __NOMADIK_H__ */
diff -Naur u-boot-2009.01/include/onenand_uboot.h u-boot/include/onenand_uboot.h
--- u-boot-2009.01/include/onenand_uboot.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/onenand_uboot.h	2009-02-26 14:03:59.000000000 +0100
@@ -15,25 +15,31 @@
 #define __UBOOT_ONENAND_H
 
 #include <linux/types.h>
-#include <linux/mtd/mtd.h>
 
+/* Forward declarations */
 struct mtd_info;
+struct mtd_oob_ops;
 struct erase_info;
+struct onenand_chip;
 
 extern struct mtd_info onenand_mtd;
 
+/* board */
+extern void onenand_board_init(struct mtd_info *);
+
 /* Functions */
 extern void onenand_init(void);
 extern int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
 			size_t * retlen, u_char * buf);
-extern int onenand_read_oob(struct mtd_info *mtd, loff_t from,
-			    struct mtd_oob_ops *ops);
+extern int onenand_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops);
 extern int onenand_write(struct mtd_info *mtd, loff_t from, size_t len,
 			 size_t * retlen, const u_char * buf);
 extern int onenand_erase(struct mtd_info *mtd, struct erase_info *instr);
 
-extern int onenand_unlock(struct mtd_info *mtd, loff_t ofs, size_t len);
+extern char *onenand_print_device_info(int device, int version);
 
-extern char *onenand_print_device_info(int device);
+/* S3C64xx */
+extern void s3c64xx_onenand_init(struct mtd_info *);
+extern void s3c64xx_set_width_regs(struct onenand_chip *);
 
 #endif /* __UBOOT_ONENAND_H */
diff -Naur u-boot-2009.01/include/pci.h u-boot/include/pci.h
--- u-boot-2009.01/include/pci.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/pci.h	2009-02-26 14:03:59.000000000 +0100
@@ -334,7 +334,7 @@
 #define PCI_REGION_TYPE		0x00000001
 #define PCI_REGION_PREFETCH	0x00000008	/* prefetchable PCI memory */
 
-#define PCI_REGION_MEMORY	0x00000100	/* System memory */
+#define PCI_REGION_SYS_MEMORY	0x00000100	/* System memory */
 #define PCI_REGION_RO		0x00000200	/* Read-only memory */
 
 extern __inline__ void pci_set_region(struct pci_region *reg,
@@ -382,6 +382,8 @@
 
 #define MAX_PCI_REGIONS		7
 
+#define INDIRECT_TYPE_NO_PCIE_LINK	1
+
 /*
  * Structure of a PCI controller (host bridge)
  */
@@ -394,6 +396,8 @@
 	volatile unsigned int *cfg_addr;
 	volatile unsigned char *cfg_data;
 
+	int indirect_type;
+
 	struct pci_region regions[MAX_PCI_REGIONS];
 	int region_count;
 
@@ -450,10 +454,29 @@
 #define pci_bus_to_phys(dev, addr, flags) \
 	pci_hose_bus_to_phys(pci_bus_to_hose(PCI_BUS(dev)), (addr), (flags))
 
-#define pci_phys_to_mem(dev, addr)	pci_phys_to_bus((dev), (addr), PCI_REGION_MEM)
-#define pci_mem_to_phys(dev, addr)	pci_bus_to_phys((dev), (addr), PCI_REGION_MEM)
-#define pci_phys_to_io(dev, addr)	pci_phys_to_bus((dev), (addr), PCI_REGION_IO)
-#define pci_io_to_phys(dev, addr)	pci_bus_to_phys((dev), (addr), PCI_REGION_IO)
+#define pci_virt_to_bus(dev, addr, flags) \
+	pci_hose_phys_to_bus(pci_bus_to_hose(PCI_BUS(dev)), \
+			     (virt_to_phys(addr)), (flags))
+#define pci_bus_to_virt(dev, addr, flags, len, map_flags) \
+	map_physmem(pci_hose_bus_to_phys(pci_bus_to_hose(PCI_BUS(dev)), \
+					 (addr), (flags)), \
+		    (len), (map_flags))
+
+#define pci_phys_to_mem(dev, addr) \
+	pci_phys_to_bus((dev), (addr), PCI_REGION_MEM)
+#define pci_mem_to_phys(dev, addr) \
+	pci_bus_to_phys((dev), (addr), PCI_REGION_MEM)
+#define pci_phys_to_io(dev, addr)  pci_phys_to_bus((dev), (addr), PCI_REGION_IO)
+#define pci_io_to_phys(dev, addr)  pci_bus_to_phys((dev), (addr), PCI_REGION_IO)
+
+#define pci_virt_to_mem(dev, addr) \
+	pci_virt_to_bus((dev), (addr), PCI_REGION_MEM)
+#define pci_mem_to_virt(dev, addr, len, map_flags) \
+	pci_bus_to_virt((dev), (addr), PCI_REGION_MEM, (len), (map_flags))
+#define pci_virt_to_io(dev, addr) \
+	pci_virt_to_bus((dev), (addr), PCI_REGION_IO)
+#define pci_io_to_virt(dev, addr, len, map_flags) \
+	pci_bus_to_virt((dev), (addr), PCI_REGION_IO, (len), (map_flags))
 
 extern int pci_hose_read_config_byte(struct pci_controller *hose,
 				     pci_dev_t dev, int where, u8 *val);
@@ -484,6 +507,7 @@
 extern int pci_hose_write_config_word_via_dword(struct pci_controller *hose,
 						pci_dev_t dev, int where, u16 val);
 
+extern void *pci_map_bar(pci_dev_t pdev, int bar, int flags);
 extern void pci_register_hose(struct pci_controller* hose);
 extern struct pci_controller* pci_bus_to_hose(int bus);
 
diff -Naur u-boot-2009.01/include/post.h u-boot/include/post.h
--- u-boot-2009.01/include/post.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/post.h	2009-02-26 14:03:59.000000000 +0100
@@ -80,6 +80,19 @@
 extern unsigned int post_list_size;
 extern int post_hotkeys_pressed(void);
 
+/*
+ *  If GCC is configured to use a version of GAS that supports
+ * the .gnu_attribute directive, it will use that directive to
+ * record certain properties of the output code.
+ *  This feature is new to GCC 4.3.0.
+ *  .gnu_attribute is new to GAS 2.18.
+ */
+#if (__GNUC__ >= 4 && __GNUC_MINOR__ >= 3)
+/* Tag_GNU_Power_ABI_FP/soft-float */
+#define GNU_FPOST_ATTR	asm(".gnu_attribute	4, 2");
+#else
+#define GNU_FPOST_ATTR
+#endif /* __GNUC__ */
 #endif /* __ASSEMBLY__ */
 
 #define CONFIG_SYS_POST_RTC		0x00000001
diff -Naur u-boot-2009.01/include/sata.h u-boot/include/sata.h
--- u-boot-2009.01/include/sata.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/sata.h	2009-02-26 14:03:59.000000000 +0100
@@ -7,5 +7,6 @@
 ulong sata_write(int dev, ulong blknr, ulong blkcnt, const void *buffer);
 
 int sata_initialize(void);
+int __sata_initialize(void);
 
 #endif
diff -Naur u-boot-2009.01/include/status_led.h u-boot/include/status_led.h
--- u-boot-2009.01/include/status_led.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/status_led.h	2009-02-26 14:03:59.000000000 +0100
@@ -346,6 +346,9 @@
 #elif defined(CONFIG_NIOS2)
 /* XXX empty just to avoid the error */
 /************************************************************************/
+#elif defined(CONFIG_BLACKFIN)
+/* XXX empty just to avoid the error */
+/************************************************************************/
 #elif defined(CONFIG_V38B)
 
 # define STATUS_LED_BIT		0x0010			/* Timer7 GPIO */
diff -Naur u-boot-2009.01/include/usb_defs.h u-boot/include/usb_defs.h
--- u-boot-2009.01/include/usb_defs.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/usb_defs.h	2009-02-26 14:03:59.000000000 +0100
@@ -80,6 +80,12 @@
 #define USB_DIR_OUT           0
 #define USB_DIR_IN            0x80
 
+/* USB device speeds */
+#define USB_SPEED_FULL		0x0	/* 12Mbps */
+#define USB_SPEED_LOW		0x1	/* 1.5Mbps */
+#define USB_SPEED_HIGH		0x2	/* 480Mbps */
+#define USB_SPEED_RESERVED	0x3
+
 /* Descriptor types */
 #define USB_DT_DEVICE        0x01
 #define USB_DT_CONFIG        0x02
@@ -202,6 +208,7 @@
 #define USB_PORT_FEAT_RESET          4
 #define USB_PORT_FEAT_POWER          8
 #define USB_PORT_FEAT_LOWSPEED       9
+#define USB_PORT_FEAT_HIGHSPEED      10
 #define USB_PORT_FEAT_C_CONNECTION   16
 #define USB_PORT_FEAT_C_ENABLE       17
 #define USB_PORT_FEAT_C_SUSPEND      18
@@ -216,6 +223,9 @@
 #define USB_PORT_STAT_RESET         0x0010
 #define USB_PORT_STAT_POWER         0x0100
 #define USB_PORT_STAT_LOW_SPEED     0x0200
+#define USB_PORT_STAT_HIGH_SPEED    0x0400	/* support for EHCI */
+#define USB_PORT_STAT_SPEED	\
+	(USB_PORT_STAT_LOW_SPEED | USB_PORT_STAT_HIGH_SPEED)
 
 /* wPortChange bits */
 #define USB_PORT_STAT_C_CONNECTION  0x0001
diff -Naur u-boot-2009.01/include/usb.h u-boot/include/usb.h
--- u-boot-2009.01/include/usb.h	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/include/usb.h	2009-02-26 14:03:59.000000000 +0100
@@ -138,7 +138,7 @@
 
 struct usb_device {
 	int	devnum;			/* Device number on USB bus */
-	int	slow;			/* Slow device? */
+	int	speed;			/* full/low/high */
 	char	mf[32];			/* manufacturer */
 	char	prod[32];		/* product */
 	char	serial[32];		/* serial number */
@@ -171,6 +171,7 @@
 	unsigned long status;
 	int act_len;			/* transfered bytes */
 	int maxchild;			/* Number of ports if hub */
+	int portnr;
 	struct usb_device *parent;
 	struct usb_device *children[USB_MAXCHILDREN];
 };
@@ -180,8 +181,9 @@
  */
 
 #if defined(CONFIG_USB_UHCI) || defined(CONFIG_USB_OHCI) || \
-	defined(CONFIG_USB_OHCI_NEW) || defined(CONFIG_USB_SL811HS) || \
-	defined(CONFIG_USB_ISP116X_HCD) || defined(CONFIG_USB_R8A66597_HCD)
+	defined(CONFIG_USB_EHCI) || defined(CONFIG_USB_OHCI_NEW) || \
+	defined(CONFIG_USB_SL811HS) || defined(CONFIG_USB_ISP116X_HCD) || \
+	defined(CONFIG_USB_R8A66597_HCD) || defined(CONFIG_USB_DAVINCI)
 
 int usb_lowlevel_init(void);
 int usb_lowlevel_stop(void);
@@ -263,13 +265,13 @@
 		((x_ & 0xFF000000UL) >> 24)); \
 	})
 
-#ifdef LITTLEENDIAN
+#ifdef __LITTLE_ENDIAN
 # define swap_16(x) (x)
 # define swap_32(x) (x)
 #else
 # define swap_16(x) __swap_16(x)
 # define swap_32(x) __swap_32(x)
-#endif /* LITTLEENDIAN */
+#endif
 
 /*
  * Calling this entity a "pipe" is glorifying it. A USB pipe
@@ -279,7 +281,7 @@
  *  - endpoint number (4 bits)
  *  - current Data0/1 state (1 bit)
  *  - direction (1 bit)
- *  - speed (1 bit)
+ *  - speed (2 bits)
  *  - max packet size (2 bits: 8, 16, 32 or 64)
  *  - pipe type (2 bits: control, interrupt, bulk, isochronous)
  *
@@ -296,7 +298,7 @@
  *  - device:		bits 8-14
  *  - endpoint:		bits 15-18
  *  - Data0/1:		bit 19
- *  - speed:		bit 26		(0 = Full, 1 = Low Speed)
+ *  - speed:		bit 26		(0 = Full, 1 = Low Speed, 2 = High)
  *  - pipe type:	bits 30-31	(00 = isochronous, 01 = interrupt,
  *					 10 = control, 11 = bulk)
  *
@@ -308,8 +310,8 @@
 /* Create various pipes... */
 #define create_pipe(dev,endpoint) \
 		(((dev)->devnum << 8) | (endpoint << 15) | \
-		((dev)->slow << 26) | (dev)->maxpacketsize)
-#define default_pipe(dev) ((dev)->slow << 26)
+		((dev)->speed << 26) | (dev)->maxpacketsize)
+#define default_pipe(dev) ((dev)->speed << 26)
 
 #define usb_sndctrlpipe(dev, endpoint)	((PIPE_CONTROL << 30) | \
 					 create_pipe(dev, endpoint))
@@ -359,7 +361,8 @@
 #define usb_pipe_endpdev(pipe)	(((pipe) >> 8) & 0x7ff)
 #define usb_pipeendpoint(pipe)	(((pipe) >> 15) & 0xf)
 #define usb_pipedata(pipe)	(((pipe) >> 19) & 1)
-#define usb_pipeslow(pipe)	(((pipe) >> 26) & 1)
+#define usb_pipespeed(pipe)	(((pipe) >> 26) & 3)
+#define usb_pipeslow(pipe)	(usb_pipespeed(pipe) == USB_SPEED_LOW)
 #define usb_pipetype(pipe)	(((pipe) >> 30) & 3)
 #define usb_pipeisoc(pipe)	(usb_pipetype((pipe)) == PIPE_ISOCHRONOUS)
 #define usb_pipeint(pipe)	(usb_pipetype((pipe)) == PIPE_INTERRUPT)
diff -Naur u-boot-2009.01/lib_arm/board.c u-boot/lib_arm/board.c
--- u-boot-2009.01/lib_arm/board.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_arm/board.c	2009-02-26 14:03:59.000000000 +0100
@@ -145,6 +145,9 @@
  * but let's get it working (again) first...
  */
 
+#if defined(CONFIG_ARM_DCC) && !defined(CONFIG_BAUDRATE)
+#define CONFIG_BAUDRATE 115200
+#endif
 static int init_baudrate (void)
 {
 	char tmp[64];	/* long enough for environment variables */
@@ -221,6 +224,15 @@
 }
 #endif
 
+#if defined(CONFIG_CMD_PCI) || defined (CONFIG_PCI)
+#include <pci.h>
+static int arm_pci_init(void)
+{
+	pci_init();
+	return 0;
+}
+#endif /* CONFIG_CMD_PCI || CONFIG_PCI */
+
 /*
  * Breathe some life into the board...
  *
@@ -267,6 +279,9 @@
 	init_func_i2c,
 #endif
 	dram_init,		/* configure available RAM banks */
+#if defined(CONFIG_CMD_PCI) || defined (CONFIG_PCI)
+	arm_pci_init,
+#endif
 	display_dram_config,
 	NULL,
 };
@@ -275,9 +290,6 @@
 {
 	init_fnc_t **init_fnc_ptr;
 	char *s;
-#if !defined(CONFIG_SYS_NO_FLASH) || defined (CONFIG_VFD) || defined(CONFIG_LCD)
-	ulong size;
-#endif
 #if defined(CONFIG_VFD) || defined(CONFIG_LCD)
 	unsigned long addr;
 #endif
@@ -303,8 +315,7 @@
 
 #ifndef CONFIG_SYS_NO_FLASH
 	/* configure available FLASH banks */
-	size = flash_init ();
-	display_flash_config (size);
+	display_flash_config (flash_init ());
 #endif /* CONFIG_SYS_NO_FLASH */
 
 #ifdef CONFIG_VFD
@@ -316,7 +327,7 @@
 	 */
 	/* bss_end is defined in the board-specific linker script */
 	addr = (_bss_end + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
-	size = vfd_setmem (addr);
+	vfd_setmem (addr);
 	gd->fb_base = addr;
 #endif /* CONFIG_VFD */
 
@@ -331,7 +342,7 @@
 		 */
 		/* bss_end is defined in the board-specific linker script */
 		addr = (_bss_end + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
-		size = lcd_setmem (addr);
+		lcd_setmem (addr);
 		gd->fb_base = addr;
 	}
 #endif /* CONFIG_LCD */
@@ -404,6 +415,11 @@
 
 	jumptable_init ();
 
+#if defined(CONFIG_API)
+	/* Initialize API */
+	api_init ();
+#endif
+
 	console_init_r ();	/* fully init console as a device */
 
 #if defined(CONFIG_MISC_INIT_R)
diff -Naur u-boot-2009.01/lib_avr32/board.c u-boot/lib_avr32/board.c
--- u-boot-2009.01/lib_avr32/board.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_avr32/board.c	2009-03-07 20:45:30.000000000 +0100
@@ -34,6 +34,10 @@
 #define CONFIG_IDENT_STRING ""
 #endif
 
+#ifdef CONFIG_CMD_NAND
+#include <nand.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 const char version_string[] =
@@ -335,6 +339,9 @@
 	if (!gd->bd->bi_boot_params)
 		puts("WARNING: Cannot allocate space for boot parameters\n");
 
+#ifdef CONFIG_CMD_NAND
+	nand_init();
+#endif
 	/* initialize environment */
 	env_relocate();
 
diff -Naur u-boot-2009.01/lib_blackfin/board.c u-boot/lib_blackfin/board.c
--- u-boot-2009.01/lib_blackfin/board.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_blackfin/board.c	2009-02-26 14:03:59.000000000 +0100
@@ -13,10 +13,10 @@
 #include <command.h>
 #include <devices.h>
 #include <environment.h>
-#include <i2c.h>
 #include <malloc.h>
 #include <net.h>
 #include <timestamp.h>
+#include <status_led.h>
 #include <version.h>
 
 #include <asm/cplb.h>
@@ -44,50 +44,6 @@
 #endif
 }
 
-/* Get the input voltage */
-static u_long get_vco(void)
-{
-	u_long msel;
-	u_long vco;
-
-	msel = (*pPLL_CTL >> 9) & 0x3F;
-	if (0 == msel)
-		msel = 64;
-
-	vco = CONFIG_CLKIN_HZ;
-	vco >>= (1 & *pPLL_CTL);	/* DF bit */
-	vco = msel * vco;
-	return vco;
-}
-
-/* Get the Core clock */
-u_long get_cclk(void)
-{
-	u_long csel, ssel;
-	if (*pPLL_STAT & 0x1)
-		return CONFIG_CLKIN_HZ;
-
-	ssel = *pPLL_DIV;
-	csel = ((ssel >> 4) & 0x03);
-	ssel &= 0xf;
-	if (ssel && ssel < (1 << csel))	/* SCLK > CCLK */
-		return get_vco() / ssel;
-	return get_vco() >> csel;
-}
-
-/* Get the System clock */
-u_long get_sclk(void)
-{
-	u_long ssel;
-
-	if (*pPLL_STAT & 0x1)
-		return CONFIG_CLKIN_HZ;
-
-	ssel = (*pPLL_DIV & 0xf);
-
-	return get_vco() / ssel;
-}
-
 static void *mem_malloc_start, *mem_malloc_end, *mem_malloc_brk;
 
 static void mem_malloc_init(void)
@@ -114,7 +70,11 @@
 static int display_banner(void)
 {
 	printf("\n\n%s\n\n", version_string);
-	printf("CPU:   ADSP " MK_STR(CONFIG_BFIN_CPU) " (Detected Rev: 0.%d)\n", bfin_revid());
+	printf("CPU:   ADSP " MK_STR(CONFIG_BFIN_CPU) " "
+		"(Detected Rev: 0.%d) "
+		"(%s boot)\n",
+		bfin_revid(),
+		get_bfin_boot_mode(CONFIG_BFIN_BOOT_MODE));
 	return 0;
 }
 
@@ -257,6 +217,7 @@
 {
 	ulong addr;
 	bd_t *bd;
+	char buf[32];
 
 #ifdef CONFIG_BOARD_EARLY_INIT_F
 	serial_early_puts("Board early init flash\n");
@@ -278,9 +239,13 @@
 	dcache_enable();
 #endif
 
+#ifdef DEBUG
+	if (CONFIG_SYS_GBL_DATA_SIZE < sizeof(*gd))
+		hang();
+#endif
 	serial_early_puts("Init global data\n");
 	gd = (gd_t *) (CONFIG_SYS_GBL_DATA_ADDR);
-	memset((void *)gd, 0, sizeof(gd_t));
+	memset((void *)gd, 0, CONFIG_SYS_GBL_DATA_SIZE);
 
 	/* Board data initialization */
 	addr = (CONFIG_SYS_GBL_DATA_ADDR + sizeof(gd_t));
@@ -315,8 +280,9 @@
 	checkboard();
 	timer_init();
 
-	printf("Clock: VCO: %lu MHz, Core: %lu MHz, System: %lu MHz\n",
-	       get_vco() / 1000000, get_cclk() / 1000000, get_sclk() / 1000000);
+	printf("Clock: VCO: %s MHz, ", strmhz(buf, get_vco()));
+	printf("Core: %s MHz, ", strmhz(buf, get_cclk()));
+	printf("System: %s MHz\n", strmhz(buf, get_sclk()));
 
 	printf("RAM:   ");
 	print_size(initdram(0), "\n");
@@ -329,16 +295,6 @@
 	board_init_r((gd_t *) gd, 0x20000010);
 }
 
-#if defined(CONFIG_SOFT_I2C) || defined(CONFIG_HARD_I2C)
-static int init_func_i2c(void)
-{
-	puts("I2C:   ");
-	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
-	puts("ready\n");
-	return (0);
-}
-#endif
-
 void board_init_r(gd_t * id, ulong dest_addr)
 {
 	extern void malloc_bin_reloc(void);
@@ -354,14 +310,14 @@
 #endif
 
 #if	!defined(CONFIG_SYS_NO_FLASH)
-	/* There are some other pointer constants we must deal with */
-	/* configure available FLASH banks */
+	/* Initialize the flash and protect u-boot by default */
 	extern flash_info_t flash_info[];
 	ulong size = flash_init();
 	puts("Flash: ");
 	print_size(size, "\n");
 	flash_protect(FLAG_PROTECT_SET, CONFIG_SYS_FLASH_BASE,
-		      CONFIG_SYS_FLASH_BASE + 0x1ffff, &flash_info[0]);
+		CONFIG_SYS_FLASH_BASE + CONFIG_SYS_MONITOR_LEN - 1,
+		&flash_info[0]);
 	bd->bi_flashstart = CONFIG_SYS_FLASH_BASE;
 	bd->bi_flashsize = size;
 	bd->bi_flashoffset = 0;
@@ -418,6 +374,11 @@
 	/* Initialize the console (after the relocation and devices init) */
 	console_init_r();
 
+#ifdef CONFIG_STATUS_LED
+	status_led_set(STATUS_LED_BOOT, STATUS_LED_BLINKING);
+	status_led_set(STATUS_LED_CRASH, STATUS_LED_OFF);
+#endif
+
 	/* Initialize from environment */
 	if ((s = getenv("loadaddr")) != NULL)
 		load_addr = simple_strtoul(s, NULL, 16);
@@ -434,14 +395,19 @@
 #ifdef CONFIG_CMD_NET
 	printf("Net:   ");
 	eth_initialize(gd->bd);
-	if (getenv("ethaddr"))
+	if ((s = getenv("ethaddr"))) {
+# ifndef CONFIG_NET_MULTI
+		size_t i;
+		char *e;
+		for (i = 0; i < 6; ++i) {
+			bd->bi_enetaddr[i] = simple_strtoul(s, &e, 16);
+			s = (*e) ? e + 1 : e;
+		}
+# endif
 		printf("MAC:   %02X:%02X:%02X:%02X:%02X:%02X\n",
 			bd->bi_enetaddr[0], bd->bi_enetaddr[1], bd->bi_enetaddr[2],
 			bd->bi_enetaddr[3], bd->bi_enetaddr[4], bd->bi_enetaddr[5]);
-#endif
-
-#if defined(CONFIG_SOFT_I2C) || defined(CONFIG_HARD_I2C)
-	init_func_i2c();
+	}
 #endif
 
 	display_global_data();
@@ -458,6 +424,10 @@
 
 void hang(void)
 {
+#ifdef CONFIG_STATUS_LED
+	status_led_set(STATUS_LED_BOOT, STATUS_LED_OFF);
+	status_led_set(STATUS_LED_CRASH, STATUS_LED_BLINKING);
+#endif
 	puts("### ERROR ### Please RESET the board ###\n");
 	while (1)
 		/* If a JTAG emulator is hooked up, we'll automatically trigger
diff -Naur u-boot-2009.01/lib_blackfin/boot.c u-boot/lib_blackfin/boot.c
--- u-boot-2009.01/lib_blackfin/boot.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/lib_blackfin/boot.c	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,63 @@
+/*
+ * U-boot - boot.c - misc boot helper functions
+ *
+ * Copyright (c) 2005-2008 Analog Devices Inc.
+ *
+ * (C) Copyright 2000-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <image.h>
+#include <asm/blackfin.h>
+
+#ifdef SHARED_RESOURCES
+extern void swap_to(int device_id);
+#endif
+
+static char *make_command_line(void)
+{
+	char *dest = (char *)CONFIG_LINUX_CMDLINE_ADDR;
+	char *bootargs = getenv("bootargs");
+
+	if (bootargs == NULL)
+		return NULL;
+
+	strncpy(dest, bootargs, CONFIG_LINUX_CMDLINE_SIZE);
+	dest[CONFIG_LINUX_CMDLINE_SIZE - 1] = 0;
+	return dest;
+}
+
+extern ulong bfin_poweron_retx;
+
+int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
+{
+	int	(*appl) (char *cmdline);
+	char	*cmdline;
+
+	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
+		return 1;
+
+#ifdef SHARED_RESOURCES
+	swap_to(FLASH);
+#endif
+
+	appl = (int (*)(char *))images->ep;
+
+	printf("Starting Kernel at = %p\n", appl);
+	cmdline = make_command_line();
+	icache_disable();
+	dcache_disable();
+	asm __volatile__(
+		"RETX = %[retx];"
+		"CALL (%0);"
+		:
+		: "p"(appl), "q0"(cmdline), [retx] "d"(bfin_poweron_retx)
+	);
+	/* does not return */
+
+	return 1;
+}
diff -Naur u-boot-2009.01/lib_blackfin/bootm.c u-boot/lib_blackfin/bootm.c
--- u-boot-2009.01/lib_blackfin/bootm.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_blackfin/bootm.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,56 +0,0 @@
-/*
- * U-boot - bootm.c - misc boot helper functions
- *
- * Copyright (c) 2005-2008 Analog Devices Inc.
- *
- * (C) Copyright 2000-2004
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * Licensed under the GPL-2 or later.
- */
-
-#include <common.h>
-#include <command.h>
-#include <image.h>
-#include <asm/blackfin.h>
-
-#ifdef SHARED_RESOURCES
-extern void swap_to(int device_id);
-#endif
-
-static char *make_command_line(void)
-{
-	char *dest = (char *)CMD_LINE_ADDR;
-	char *bootargs = getenv("bootargs");
-
-	if (bootargs == NULL)
-		return NULL;
-
-	strncpy(dest, bootargs, 0x1000);
-	dest[0xfff] = 0;
-	return dest;
-}
-
-int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
-{
-	int	(*appl) (char *cmdline);
-	char	*cmdline;
-
-	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
-		return 1;
-
-#ifdef SHARED_RESOURCES
-	swap_to(FLASH);
-#endif
-
-	appl = (int (*)(char *))images->ep;
-
-	printf("Starting Kernel at = %x\n", appl);
-	cmdline = make_command_line();
-	icache_disable();
-	dcache_disable();
-	(*appl) (cmdline);
-	/* does not return */
-
-	return 1;
-}
diff -Naur u-boot-2009.01/lib_blackfin/cache.c u-boot/lib_blackfin/cache.c
--- u-boot-2009.01/lib_blackfin/cache.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_blackfin/cache.c	2009-02-26 14:03:59.000000000 +0100
@@ -15,15 +15,25 @@
 
 void flush_cache(unsigned long addr, unsigned long size)
 {
+	void *start_addr, *end_addr;
+	int istatus, dstatus;
+
 	/* no need to flush stuff in on chip memory (L1/L2/etc...) */
 	if (addr >= 0xE0000000)
 		return;
 
-	if (icache_status())
-		blackfin_icache_flush_range((void *)addr, (void *)(addr + size));
-
-	if (dcache_status())
-		blackfin_dcache_flush_range((void *)addr, (void *)(addr + size));
+	start_addr = (void *)addr;
+	end_addr = (void *)(addr + size);
+	istatus = icache_status();
+	dstatus = dcache_status();
+
+	if (istatus) {
+		if (dstatus)
+			blackfin_icache_dcache_flush_range(start_addr, end_addr);
+		else
+			blackfin_icache_flush_range(start_addr, end_addr);
+	} else if (dstatus)
+		blackfin_dcache_flush_range(start_addr, end_addr);
 }
 
 void icache_enable(void)
diff -Naur u-boot-2009.01/lib_blackfin/clocks.c u-boot/lib_blackfin/clocks.c
--- u-boot-2009.01/lib_blackfin/clocks.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/lib_blackfin/clocks.c	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,77 @@
+/*
+ * clocks.c - figure out sclk/cclk/vco and such
+ *
+ * Copyright (c) 2005-2008 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <asm/blackfin.h>
+
+/* Get the voltage input multiplier */
+static u_long cached_vco_pll_ctl, cached_vco;
+u_long get_vco(void)
+{
+	u_long msel;
+
+	u_long pll_ctl = bfin_read_PLL_CTL();
+	if (pll_ctl == cached_vco_pll_ctl)
+		return cached_vco;
+	else
+		cached_vco_pll_ctl = pll_ctl;
+
+	msel = (pll_ctl >> 9) & 0x3F;
+	if (0 == msel)
+		msel = 64;
+
+	cached_vco = CONFIG_CLKIN_HZ;
+	cached_vco >>= (1 & pll_ctl);	/* DF bit */
+	cached_vco *= msel;
+	return cached_vco;
+}
+
+/* Get the Core clock */
+static u_long cached_cclk_pll_div, cached_cclk;
+u_long get_cclk(void)
+{
+	u_long csel, ssel;
+
+	if (bfin_read_PLL_STAT() & 0x1)
+		return CONFIG_CLKIN_HZ;
+
+	ssel = bfin_read_PLL_DIV();
+	if (ssel == cached_cclk_pll_div)
+		return cached_cclk;
+	else
+		cached_cclk_pll_div = ssel;
+
+	csel = ((ssel >> 4) & 0x03);
+	ssel &= 0xf;
+	if (ssel && ssel < (1 << csel))	/* SCLK > CCLK */
+		cached_cclk = get_vco() / ssel;
+	else
+		cached_cclk = get_vco() >> csel;
+	return cached_cclk;
+}
+
+/* Get the System clock */
+static u_long cached_sclk_pll_div, cached_sclk;
+u_long get_sclk(void)
+{
+	u_long ssel;
+
+	if (bfin_read_PLL_STAT() & 0x1)
+		return CONFIG_CLKIN_HZ;
+
+	ssel = bfin_read_PLL_DIV();
+	if (ssel == cached_sclk_pll_div)
+		return cached_sclk;
+	else
+		cached_sclk_pll_div = ssel;
+
+	ssel &= 0xf;
+
+	cached_sclk = get_vco() / ssel;
+	return cached_sclk;
+}
diff -Naur u-boot-2009.01/lib_blackfin/Makefile u-boot/lib_blackfin/Makefile
--- u-boot-2009.01/lib_blackfin/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_blackfin/Makefile	2009-02-26 14:03:59.000000000 +0100
@@ -37,12 +37,12 @@
 SOBJS-y	+= memset.o
 
 COBJS-y	+= board.o
-COBJS-y	+= bootm.o
+COBJS-y	+= boot.o
 COBJS-y	+= cache.o
+COBJS-y	+= clocks.o
 COBJS-y	+= muldi3.o
-COBJS-y	+= post.o
+COBJS-$(CONFIG_POST) += post.o tests.o
 COBJS-y	+= string.o
-COBJS-y	+= tests.o
 
 SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS-y) $(COBJS-y))
diff -Naur u-boot-2009.01/lib_blackfin/post.c u-boot/lib_blackfin/post.c
--- u-boot-2009.01/lib_blackfin/post.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_blackfin/post.c	2009-02-26 14:03:59.000000000 +0100
@@ -30,8 +30,6 @@
 #include <logbuff.h>
 #endif
 
-#ifdef CONFIG_POST
-
 DECLARE_GLOBAL_DATA_PTR;
 
 #define POST_MAX_NUMBER		32
@@ -421,5 +419,3 @@
 {
 	return (unsigned long)get_ticks() / (get_tbclk() / CONFIG_SYS_HZ) - base;
 }
-
-#endif				/* CONFIG_POST */
diff -Naur u-boot-2009.01/lib_blackfin/string.c u-boot/lib_blackfin/string.c
--- u-boot-2009.01/lib_blackfin/string.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_blackfin/string.c	2009-02-26 14:03:59.000000000 +0100
@@ -1,7 +1,7 @@
 /*
  * U-boot - string.c Contains library routines.
  *
- * Copyright (c) 2005-2007 Analog Devices Inc.
+ * Copyright (c) 2005-2008 Analog Devices Inc.
  *
  * (C) Copyright 2000-2004
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
@@ -130,12 +130,41 @@
 # define bfin_write_MDMA_D0_IRQ_STATUS bfin_write_MDMA1_D0_IRQ_STATUS
 # define bfin_read_MDMA_D0_IRQ_STATUS  bfin_read_MDMA1_D0_IRQ_STATUS
 #endif
-static void *dma_memcpy(void *dst, const void *src, size_t count)
+/* This version misbehaves for count values of 0 and 2^16+.
+ * Perhaps we should detect that ?  Nowhere do we actually
+ * use dma memcpy for those types of lengths though ...
+ */
+void dma_memcpy_nocache(void *dst, const void *src, size_t count)
 {
-	if (dcache_status())
-		blackfin_dcache_flush_range(src, src + count);
+	uint16_t wdsize, mod;
 
-	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+	/* Disable DMA in case it's still running (older u-boot's did not
+	 * always turn them off).  Do it before the if statement below so
+	 * we can be cheap and not do a SSYNC() due to the forced abort.
+	 */
+	bfin_write_MDMA_D0_CONFIG(0);
+	bfin_write_MDMA_S0_CONFIG(0);
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_RUN | DMA_DONE | DMA_ERR);
+
+	/* Scratchpad cannot be a DMA source or destination */
+	if (((unsigned long)src >= L1_SRAM_SCRATCH &&
+	     (unsigned long)src < L1_SRAM_SCRATCH_END) ||
+	    ((unsigned long)dst >= L1_SRAM_SCRATCH &&
+	     (unsigned long)dst < L1_SRAM_SCRATCH_END))
+		hang();
+
+	if (((unsigned long)dst | (unsigned long)src | count) & 0x1) {
+		wdsize = WDSIZE_8;
+		mod = 1;
+	} else if (((unsigned long)dst | (unsigned long)src | count) & 0x2) {
+		wdsize = WDSIZE_16;
+		count >>= 1;
+		mod = 2;
+	} else {
+		wdsize = WDSIZE_32;
+		count >>= 2;
+		mod = 4;
+	}
 
 	/* Copy sram functions from sdram to sram */
 	/* Setup destination start address */
@@ -143,31 +172,43 @@
 	/* Setup destination xcount */
 	bfin_write_MDMA_D0_X_COUNT(count);
 	/* Setup destination xmodify */
-	bfin_write_MDMA_D0_X_MODIFY(1);
+	bfin_write_MDMA_D0_X_MODIFY(mod);
 
 	/* Setup Source start address */
 	bfin_write_MDMA_S0_START_ADDR(src);
 	/* Setup Source xcount */
 	bfin_write_MDMA_S0_X_COUNT(count);
 	/* Setup Source xmodify */
-	bfin_write_MDMA_S0_X_MODIFY(1);
+	bfin_write_MDMA_S0_X_MODIFY(mod);
 
 	/* Enable source DMA */
-	bfin_write_MDMA_S0_CONFIG(DMAEN);
+	bfin_write_MDMA_S0_CONFIG(wdsize | DMAEN);
+	bfin_write_MDMA_D0_CONFIG(wdsize | DMAEN | WNR | DI_EN);
 	SSYNC();
 
-	bfin_write_MDMA_D0_CONFIG(WNR | DMAEN);
+	while (!(bfin_read_MDMA_D0_IRQ_STATUS() & DMA_DONE))
+		continue;
 
-	while (bfin_read_MDMA_D0_IRQ_STATUS() & DMA_RUN)
-		bfin_write_MDMA_D0_IRQ_STATUS(bfin_read_MDMA_D0_IRQ_STATUS() | DMA_DONE | DMA_ERR);
-	bfin_write_MDMA_D0_IRQ_STATUS(bfin_read_MDMA_D0_IRQ_STATUS() | DMA_DONE | DMA_ERR);
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_RUN | DMA_DONE | DMA_ERR);
+	bfin_write_MDMA_D0_CONFIG(0);
+	bfin_write_MDMA_S0_CONFIG(0);
+}
+/* We should do a dcache invalidate on the destination after the dma, but since
+ * we lack such hardware capability, we'll flush/invalidate the destination
+ * before the dma and bank on the idea that u-boot is single threaded.
+ */
+void *dma_memcpy(void *dst, const void *src, size_t count)
+{
+	if (dcache_status()) {
+		blackfin_dcache_flush_range(src, src + count);
+		blackfin_dcache_flush_invalidate_range(dst, dst + count);
+	}
+
+	dma_memcpy_nocache(dst, src, count);
 
 	if (icache_status())
 		blackfin_icache_flush_range(dst, dst + count);
 
-	if (dcache_status())
-		blackfin_dcache_invalidate_range(dst, dst + count);
-
 	return dst;
 }
 
diff -Naur u-boot-2009.01/lib_blackfin/tests.c u-boot/lib_blackfin/tests.c
--- u-boot-2009.01/lib_blackfin/tests.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_blackfin/tests.c	2009-02-26 14:03:59.000000000 +0100
@@ -27,7 +27,6 @@
 
 #include <common.h>
 #include <config.h>
-#ifdef CONFIG_POST
 
 #include <post.h>
 #define CONFIG_SYS_POST_FLASH  0x00004000
@@ -249,5 +248,3 @@
 };
 
 unsigned int post_list_size = sizeof(post_list) / sizeof(struct post_test);
-
-#endif				/* CONFIG_POST */
diff -Naur u-boot-2009.01/lib_generic/bzlib.c u-boot/lib_generic/bzlib.c
--- u-boot-2009.01/lib_generic/bzlib.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_generic/bzlib.c	2009-02-26 14:03:59.000000000 +0100
@@ -1,7 +1,6 @@
 #include <config.h>
 #include <common.h>
 #include <watchdog.h>
-#ifdef CONFIG_BZIP2
 
 /*
  * This file is a modified version of bzlib.c from the bzip2-1.0.2
@@ -1600,5 +1599,3 @@
 /*-------------------------------------------------------------*/
 /*--- end                                           bzlib.c ---*/
 /*-------------------------------------------------------------*/
-
-#endif /* CONFIG_BZIP2 */
diff -Naur u-boot-2009.01/lib_generic/bzlib_crctable.c u-boot/lib_generic/bzlib_crctable.c
--- u-boot-2009.01/lib_generic/bzlib_crctable.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_generic/bzlib_crctable.c	2009-02-26 14:03:59.000000000 +0100
@@ -1,5 +1,4 @@
 #include <config.h>
-#ifdef CONFIG_BZIP2
 
 /*-------------------------------------------------------------*/
 /*--- Table for doing CRCs                                  ---*/
@@ -144,5 +143,3 @@
 /*-------------------------------------------------------------*/
 /*--- end                                        crctable.c ---*/
 /*-------------------------------------------------------------*/
-
-#endif /* CONFIG_BZIP2 */
diff -Naur u-boot-2009.01/lib_generic/bzlib_decompress.c u-boot/lib_generic/bzlib_decompress.c
--- u-boot-2009.01/lib_generic/bzlib_decompress.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_generic/bzlib_decompress.c	2009-02-26 14:03:59.000000000 +0100
@@ -1,7 +1,6 @@
 #include <config.h>
 #include <common.h>
 #include <watchdog.h>
-#ifdef CONFIG_BZIP2
 
 /*-------------------------------------------------------------*/
 /*--- Decompression machinery                               ---*/
@@ -673,5 +672,3 @@
 /*-------------------------------------------------------------*/
 /*--- end                                      decompress.c ---*/
 /*-------------------------------------------------------------*/
-
-#endif /* CONFIG_BZIP2 */
diff -Naur u-boot-2009.01/lib_generic/bzlib_huffman.c u-boot/lib_generic/bzlib_huffman.c
--- u-boot-2009.01/lib_generic/bzlib_huffman.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_generic/bzlib_huffman.c	2009-02-26 14:03:59.000000000 +0100
@@ -1,5 +1,4 @@
 #include <config.h>
-#ifdef CONFIG_BZIP2
 
 /*-------------------------------------------------------------*/
 /*--- Huffman coding low-level stuff                        ---*/
@@ -228,5 +227,3 @@
 /*-------------------------------------------------------------*/
 /*--- end                                         huffman.c ---*/
 /*-------------------------------------------------------------*/
-
-#endif /* CONFIG_BZIP2 */
diff -Naur u-boot-2009.01/lib_generic/bzlib_randtable.c u-boot/lib_generic/bzlib_randtable.c
--- u-boot-2009.01/lib_generic/bzlib_randtable.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_generic/bzlib_randtable.c	2009-02-26 14:03:59.000000000 +0100
@@ -1,5 +1,4 @@
 #include <config.h>
-#ifdef CONFIG_BZIP2
 
 /*-------------------------------------------------------------*/
 /*--- Table for randomising repetitive blocks               ---*/
@@ -124,5 +123,3 @@
 /*-------------------------------------------------------------*/
 /*--- end                                       randtable.c ---*/
 /*-------------------------------------------------------------*/
-
-#endif /* CONFIG_BZIP2 */
diff -Naur u-boot-2009.01/lib_generic/gunzip.c u-boot/lib_generic/gunzip.c
--- u-boot-2009.01/lib_generic/gunzip.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_generic/gunzip.c	2009-02-26 14:03:59.000000000 +0100
@@ -102,8 +102,9 @@
 	s.next_out = dst;
 	s.avail_out = dstlen;
 	r = inflate(&s, Z_FINISH);
-	if (r != Z_OK && r != Z_STREAM_END) {
+	if (r != Z_STREAM_END) {
 		printf ("Error: inflate() returned %d\n", r);
+		inflateEnd(&s);
 		return (-1);
 	}
 	*lenp = s.next_out - (unsigned char *) dst;
diff -Naur u-boot-2009.01/lib_generic/Makefile u-boot/lib_generic/Makefile
--- u-boot-2009.01/lib_generic/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_generic/Makefile	2009-02-26 14:03:59.000000000 +0100
@@ -26,11 +26,11 @@
 LIB	= $(obj)libgeneric.a
 
 COBJS-$(CONFIG_ADDR_MAP) += addr_map.o
-COBJS-y += bzlib.o
-COBJS-y += bzlib_crctable.o
-COBJS-y += bzlib_decompress.o
-COBJS-y += bzlib_randtable.o
-COBJS-y += bzlib_huffman.o
+COBJS-$(CONFIG_BZIP2) += bzlib.o
+COBJS-$(CONFIG_BZIP2) += bzlib_crctable.o
+COBJS-$(CONFIG_BZIP2) += bzlib_decompress.o
+COBJS-$(CONFIG_BZIP2) += bzlib_randtable.o
+COBJS-$(CONFIG_BZIP2) += bzlib_huffman.o
 COBJS-y += crc16.o
 COBJS-y += crc32.o
 COBJS-y += ctype.o
diff -Naur u-boot-2009.01/lib_m68k/bootm.c u-boot/lib_m68k/bootm.c
--- u-boot-2009.01/lib_m68k/bootm.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_m68k/bootm.c	2009-02-26 14:03:59.000000000 +0100
@@ -111,11 +111,12 @@
 
 	/*
 	 * Linux Kernel Parameters (passing board info data):
-	 *   r3: ptr to board info data
-	 *   r4: initrd_start or 0 if no initrd
-	 *   r5: initrd_end - unused if r4 is 0
-	 *   r6: Start of command line string
-	 *   r7: End   of command line string
+	 *   sp+00: Ignore, side effect of using jsr to jump to kernel
+	 *   sp+04: ptr to board info data
+	 *   sp+08: initrd_start or 0 if no initrd
+	 *   sp+12: initrd_end - unused if initrd_start is 0
+	 *   sp+16: Start of command line string
+	 *   sp+20: End   of command line string
 	 */
 	(*kernel) (kbd, initrd_start, initrd_end, cmd_start, cmd_end);
 	/* does not return */
diff -Naur u-boot-2009.01/lib_m68k/interrupts.c u-boot/lib_m68k/interrupts.c
--- u-boot-2009.01/lib_m68k/interrupts.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_m68k/interrupts.c	2009-02-26 14:03:59.000000000 +0100
@@ -61,7 +61,7 @@
  */
 void irq_install_handler (int vec, interrupt_handler_t * handler, void *arg)
 {
-	if ((vec < 0) || (vec > NR_IRQS)) {
+	if ((vec < 0) || (vec >= NR_IRQS)) {
 		printf ("irq_install_handler: wrong interrupt vector %d\n",
 			vec);
 		return;
@@ -73,7 +73,7 @@
 
 void irq_free_handler (int vec)
 {
-	if ((vec < 0) || (vec > NR_IRQS)) {
+	if ((vec < 0) || (vec >= NR_IRQS)) {
 		return;
 	}
 
diff -Naur u-boot-2009.01/lib_microblaze/board.c u-boot/lib_microblaze/board.c
--- u-boot-2009.01/lib_microblaze/board.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_microblaze/board.c	2009-02-26 14:03:59.000000000 +0100
@@ -112,6 +112,10 @@
 #if defined(CONFIG_CMD_FLASH)
 	ulong flash_size = 0;
 #endif
+#if defined(CONFIG_CMD_NET)
+	char *s, *e;
+	int i;
+#endif
 	asm ("nop");	/* FIXME gd is not initialize - wait */
 	memset ((void *)gd, 0, CONFIG_SYS_GBL_DATA_SIZE);
 	gd->bd = (bd_t *) (gd + 1);	/* At end of global data */
@@ -132,11 +136,34 @@
 		}
 	}
 
+	puts ("SDRAM :\n");
+	printf ("\t\tIcache:%s\n", icache_status() ? "OK" : "FAIL");
+	printf ("\t\tDcache:%s\n", dcache_status() ? "OK" : "FAIL");
+	printf ("\tU-Boot Start:0x%08x\n", TEXT_BASE);
+
 #if defined(CONFIG_CMD_FLASH)
+	puts ("FLASH: ");
 	bd->bi_flashstart = CONFIG_SYS_FLASH_BASE;
 	if (0 < (flash_size = flash_init ())) {
 		bd->bi_flashsize = flash_size;
 		bd->bi_flashoffset = CONFIG_SYS_FLASH_BASE + flash_size;
+# ifdef CONFIG_SYS_FLASH_CHECKSUM
+		print_size (flash_size, "");
+		/*
+		 * Compute and print flash CRC if flashchecksum is set to 'y'
+		 *
+		 * NOTE: Maybe we should add some WATCHDOG_RESET()? XXX
+		 */
+		s = getenv ("flashchecksum");
+		if (s && (*s == 'y')) {
+			printf ("  CRC: %08X",
+				crc32 (0, (const unsigned char *) CONFIG_SYS_FLASH_BASE, flash_size)
+			);
+		}
+		putc ('\n');
+# else	/* !CONFIG_SYS_FLASH_CHECKSUM */
+		print_size (flash_size, "\n");
+# endif /* CONFIG_SYS_FLASH_CHECKSUM */
 	} else {
 		puts ("Flash init FAILED");
 		bd->bi_flashstart = 0;
@@ -146,10 +173,9 @@
 #endif
 
 #if defined(CONFIG_CMD_NET)
-	char *s, *e;
-	int i;
 	/* board MAC address */
 	s = getenv ("ethaddr");
+	printf ("MAC:%s\n",s);
 	for (i = 0; i < 6; ++i) {
 		bd->bi_enetaddr[i] = s ? simple_strtoul (s, &e, 16) : 0;
 		if (s)
diff -Naur u-boot-2009.01/lib_microblaze/cache.c u-boot/lib_microblaze/cache.c
--- u-boot-2009.01/lib_microblaze/cache.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_microblaze/cache.c	2009-02-26 14:03:59.000000000 +0100
@@ -26,6 +26,18 @@
 
 void flush_cache (ulong addr, ulong size)
 {
-	/* MicroBlaze have write thruough cache. nothing to do. */
-	return;
+	int i;
+	for (i = 0; i < size; i += 4)
+		asm volatile (
+#ifdef CONFIG_ICACHE
+				"wic	%0, r0;"
+#endif
+				"nop;"
+#ifdef CONFIG_DCACHE
+				"wdc	%0, r0;"
+#endif
+				"nop;"
+				:
+				: "r" (addr + i)
+				: "memory");
 }
diff -Naur u-boot-2009.01/lib_ppc/bat_rw.c u-boot/lib_ppc/bat_rw.c
--- u-boot-2009.01/lib_ppc/bat_rw.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_ppc/bat_rw.c	2009-02-26 14:03:59.000000000 +0100
@@ -27,14 +27,23 @@
 #include <asm/mmu.h>
 #include <asm/io.h>
 
+#ifdef CONFIG_ADDR_MAP
+#include <addr_map.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
 int write_bat (ppc_bat_t bat, unsigned long upper, unsigned long lower)
 {
+	int batn = -1;
+
 	sync();
 
 	switch (bat) {
 	case DBAT0:
 		mtspr (DBAT0L, lower);
 		mtspr (DBAT0U, upper);
+		batn = 0;
 		break;
 	case IBAT0:
 		mtspr (IBAT0L, lower);
@@ -43,6 +52,7 @@
 	case DBAT1:
 		mtspr (DBAT1L, lower);
 		mtspr (DBAT1U, upper);
+		batn = 1;
 		break;
 	case IBAT1:
 		mtspr (IBAT1L, lower);
@@ -51,6 +61,7 @@
 	case DBAT2:
 		mtspr (DBAT2L, lower);
 		mtspr (DBAT2U, upper);
+		batn = 2;
 		break;
 	case IBAT2:
 		mtspr (IBAT2L, lower);
@@ -59,6 +70,7 @@
 	case DBAT3:
 		mtspr (DBAT3L, lower);
 		mtspr (DBAT3U, upper);
+		batn = 3;
 		break;
 	case IBAT3:
 		mtspr (IBAT3L, lower);
@@ -68,6 +80,7 @@
 	case DBAT4:
 		mtspr (DBAT4L, lower);
 		mtspr (DBAT4U, upper);
+		batn = 4;
 		break;
 	case IBAT4:
 		mtspr (IBAT4L, lower);
@@ -76,6 +89,7 @@
 	case DBAT5:
 		mtspr (DBAT5L, lower);
 		mtspr (DBAT5U, upper);
+		batn = 5;
 		break;
 	case IBAT5:
 		mtspr (IBAT5L, lower);
@@ -84,6 +98,7 @@
 	case DBAT6:
 		mtspr (DBAT6L, lower);
 		mtspr (DBAT6U, upper);
+		batn = 6;
 		break;
 	case IBAT6:
 		mtspr (IBAT6L, lower);
@@ -92,6 +107,7 @@
 	case DBAT7:
 		mtspr (DBAT7L, lower);
 		mtspr (DBAT7U, upper);
+		batn = 7;
 		break;
 	case IBAT7:
 		mtspr (IBAT7L, lower);
@@ -102,6 +118,18 @@
 		return (-1);
 	}
 
+#ifdef CONFIG_ADDR_MAP
+	if ((gd->flags & GD_FLG_RELOC) && (batn >= 0)) {
+		phys_size_t size;
+		if (!BATU_VALID(upper))
+			size = 0;
+		else
+			size = BATU_SIZE(upper);
+		addrmap_set_entry(BATU_VADDR(upper), BATL_PADDR(lower),
+				  size, batn);
+	}
+#endif
+
 	sync();
 	isync();
 
diff -Naur u-boot-2009.01/lib_ppc/board.c u-boot/lib_ppc/board.c
--- u-boot-2009.01/lib_ppc/board.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_ppc/board.c	2009-02-26 14:03:59.000000000 +0100
@@ -38,9 +38,6 @@
 #if defined(CONFIG_CMD_IDE)
 #include <ide.h>
 #endif
-#if defined(CONFIG_CMD_SATA)
-#include <sata.h>
-#endif
 #if defined(CONFIG_CMD_SCSI)
 #include <scsi.h>
 #endif
@@ -51,6 +48,9 @@
 #include <status_led.h>
 #endif
 #include <net.h>
+#ifdef CONFIG_GENERIC_MMC
+#include <mmc.h>
+#endif
 #include <serial.h>
 #ifdef CONFIG_SYS_ALLOC_DPRAM
 #if !defined(CONFIG_CPM2)
@@ -355,9 +355,6 @@
 	NULL,			/* Terminate this list */
 };
 
-#ifndef CONFIG_MAX_MEM_MAPPED
-#define CONFIG_MAX_MEM_MAPPED (256 << 20)
-#endif
 ulong get_effective_memsize(void)
 {
 #ifndef	CONFIG_VERY_BIG_RAM
@@ -639,16 +636,6 @@
 	/* NOTREACHED - relocate_code() does not return */
 }
 
-int __is_sata_supported(void)
-{
-	/* For some boards, when sata disabled by the switch, and the
-	 * driver still access the sata registers, the cpu will hangup.
-	 * please define platform specific is_sata_supported() if your
-	 * board have such issue.*/
-	return 1;
-}
-int is_sata_supported(void) __attribute__((weak, alias("__is_sata_supported")));
-
 /************************************************************************
  *
  * This is the next part if the initialization sequence: we are now
@@ -698,7 +685,7 @@
 	 */
 	trap_init (dest_addr);
 
-#if defined(CONFIG_ADDR_MAP) && defined(CONFIG_E500)
+#ifdef CONFIG_ADDR_MAP
 	init_addr_map();
 #endif
 
@@ -1091,6 +1078,12 @@
 	scsi_init ();
 #endif
 
+#ifdef CONFIG_GENERIC_MMC
+	WATCHDOG_RESET ();
+	puts ("MMC:  ");
+	mmc_initialize (bd);
+#endif
+
 #if defined(CONFIG_CMD_DOC)
 	WATCHDOG_RESET ();
 	puts ("DOC:   ");
@@ -1152,13 +1145,6 @@
 #endif
 #endif
 
-#if defined(CONFIG_CMD_SATA)
-	if (is_sata_supported()) {
-		puts("SATA:  ");
-		sata_initialize();
-	}
-#endif
-
 #ifdef CONFIG_LAST_STAGE_INIT
 	WATCHDOG_RESET ();
 	/*
diff -Naur u-boot-2009.01/lib_ppc/cache.c u-boot/lib_ppc/cache.c
--- u-boot-2009.01/lib_ppc/cache.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/lib_ppc/cache.c	2009-02-26 14:03:59.000000000 +0100
@@ -33,14 +33,16 @@
 	start = start_addr & ~(CONFIG_SYS_CACHELINE_SIZE - 1);
 	end = start_addr + size - 1;
 
-	for (addr = start; addr <= end; addr += CONFIG_SYS_CACHELINE_SIZE) {
+	for (addr = start; (addr <= end) && (addr >= start);
+			addr += CONFIG_SYS_CACHELINE_SIZE) {
 		asm volatile("dcbst 0,%0" : : "r" (addr) : "memory");
 		WATCHDOG_RESET();
 	}
 	/* wait for all dcbst to complete on bus */
 	asm volatile("sync" : : : "memory");
 
-	for (addr = start; addr <= end; addr += CONFIG_SYS_CACHELINE_SIZE) {
+	for (addr = start; (addr <= end) && (addr >= start);
+			addr += CONFIG_SYS_CACHELINE_SIZE) {
 		asm volatile("icbi 0,%0" : : "r" (addr) : "memory");
 		WATCHDOG_RESET();
 	}
diff -Naur u-boot-2009.01/MAINTAINERS u-boot/MAINTAINERS
--- u-boot-2009.01/MAINTAINERS	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/MAINTAINERS	2009-02-26 14:03:58.000000000 +0100
@@ -132,6 +132,7 @@
 
 Dirk Eibach <eibach@gdsys.de>
 
+	gdppc440etx	PPC440EP/GR
 	neo		PPC405EP
 
 Dave Ellis <DGE@sixnetio.com>
@@ -263,6 +264,10 @@
 
 	MPC8641HPCN	MPC8641D
 
+Ron Madrid <info@sheldoninst.com>
+
+	SIMPC8313	MPC8313
+
 Dan Malek <dan@embeddedalley.com>
 
 	stxgp3		MPC85xx
@@ -374,6 +379,7 @@
 
 	ids8247		MPC8247
 	jupiter		MPC5200
+	kmeter1		MPC8360
 	mgcoge		MPC8247
 	mgsuvd		MPC852
 	mucmc52		MPC5200
@@ -481,6 +487,10 @@
 
 	armadillo	ARM720T
 
+Dirk Behme <dirk.behme@gmail.com>
+
+	omap3_beagle	ARM CORTEX-A8 (OMAP3530 SoC)
+
 Rishi Bhattacharya <rishi@ti.com>
 
 	omap5912osk	ARM926EJS
@@ -521,6 +531,10 @@
 	imx31_litekit	i.MX31
 	imx31_phycore	i.MX31
 
+Grazvydas Ignotas <notasas@gmail.com>
+
+	omap3_pandora	ARM CORTEX-A8 (OMAP3xx SoC)
+
 Gary Jennejohn <gj@denx.de>
 
 	smdk2400	ARM920T
@@ -548,6 +562,10 @@
 	mx31ads		i.MX31
 	SMDK6400	S3C6400
 
+Nishanth Menon <nm@ti.com>
+
+	omap3_zoom1	ARM CORTEX-A8 (OMAP3xx SoC)
+
 David Mller <d.mueller@elsoft.ch>
 
 	smdk2410	ARM920T
@@ -571,6 +589,10 @@
 
 	omap730p2	ARM926EJS
 
+Manikandan Pillai <mani.pillai@ti.com>
+
+	omap3_evm	ARM CORTEX-A8 (OMAP3xx SoC)
+
 Stelian Pop <stelian.pop@leadtechdesign.com>
 
 	at91cap9adk	ARM926EJS (AT91CAP9 SoC)
@@ -585,6 +607,15 @@
 	pdnb3		xscale
 	scpu		xscale
 
+Alessandro Rubini <rubini@unipv.it>
+Nomadik Linux Team <STN_WMM_nomadik_linux@list.st.com>
+
+	nmdk8815	ARM926EJS (Nomadik 8815 Soc)
+
+Steve Sakoman <sakoman@gmail.com>
+
+	omap3_overo	ARM CORTEX-A8 (OMAP3xx SoC)
+
 Robert Schwebel <r.schwebel@pengutronix.de>
 
 	csb226		xscale
@@ -624,6 +655,9 @@
 
 	afeb9260	ARM926EJS (AT91SAM9260 SoC)
 
+Wolfgang Denk <wd@denx.de>
+	qong		i.MX31
+
 -------------------------------------------------------------------------
 
 Unknown / orphaned boards:
@@ -663,6 +697,10 @@
 Vlad Lungu <vlad.lungu@windriver.com>
 	qemu_mips	MIPS32
 
+Stefan Roese <sr@denx.de>
+
+	vct_xxx		MIPS32 4Kc
+
 #########################################################################
 # Nios-32 Systems:							#
 #									#
@@ -707,7 +745,7 @@
 
 Michal Simek <monstr@monstr.eu>
 
-	ML401		MicroBlaze
+	microblaze-generic	MicroBlaze
 
 #########################################################################
 # Coldfire Systems:							#
diff -Naur u-boot-2009.01/MAKEALL u-boot/MAKEALL
--- u-boot-2009.01/MAKEALL	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/MAKEALL	2009-02-26 14:03:58.000000000 +0100
@@ -197,6 +197,7 @@
 	EXBITGEN	\
 	fx12mm		\
 	G2000		\
+	gdppc440etx	\
 	glacier		\
 	haleakala	\
 	haleakala_nand	\
@@ -335,6 +336,7 @@
 #########################################################################
 
 LIST_83xx="		\
+	kmeter1		\
 	MPC8313ERDB_33	\
 	MPC8313ERDB_NAND_66	\
 	MPC8315ERDB	\
@@ -352,6 +354,7 @@
 	MPC837XERDB	\
 	MVBLM7		\
 	sbc8349		\
+	SIMPC8313_LP	\
 	TQM834x		\
 "
 
@@ -372,6 +375,7 @@
 	MPC8560ADS	\
 	MPC8568MDS	\
 	MPC8572DS	\
+	MPC8572DS_36BIT	\
 	PM854		\
 	PM856		\
 	sbc8540		\
@@ -383,6 +387,8 @@
 	TQM8540		\
 	TQM8541		\
 	TQM8548		\
+	TQM8548_AG	\
+	TQM8548_BE	\
 	TQM8555		\
 	TQM8560		\
 	XPEDITE5200	\
@@ -498,6 +504,7 @@
 	mx1ads			\
 	mx1fs2			\
 	netstar			\
+	nmdk8815		\
 	omap1510inn		\
 	omap1610h2		\
 	omap1610inn		\
@@ -537,10 +544,22 @@
 	imx31_litekit	\
 	imx31_phycore	\
 	mx31ads		\
+	qong		\
 	smdk6400	\
 "
 
 #########################################################################
+## ARM Cortex-A8 Systems
+#########################################################################
+LIST_ARM_CORTEX_A8="		\
+	omap3_beagle		\
+	omap3_overo		\
+	omap3_evm		\
+	omap3_pandora		\
+	omap3_zoom1		\
+"
+
+#########################################################################
 ## AT91 Systems
 #########################################################################
 
@@ -594,15 +613,16 @@
 ## ARM groups
 #########################################################################
 
-LIST_arm="		\
-	${LIST_SA}	\
-	${LIST_ARM7}	\
-	${LIST_ARM9}	\
-	${LIST_ARM10}	\
-	${LIST_ARM11}	\
-	${LIST_at91}	\
-	${LIST_pxa}	\
-	${LIST_ixp}	\
+LIST_arm="			\
+	${LIST_SA}		\
+	${LIST_ARM7}		\
+	${LIST_ARM9}		\
+	${LIST_ARM10}		\
+	${LIST_ARM11}		\
+	${LIST_ARM_CORTEX_A8}	\
+	${LIST_at91}		\
+	${LIST_pxa}		\
+	${LIST_ixp}		\
 "
 
 #########################################################################
@@ -612,6 +632,18 @@
 LIST_mips4kc="		\
 	incaip		\
 	qemu_mips	\
+	vct_platinum	\
+	vct_platinum_small	\
+	vct_platinum_onenand	\
+	vct_platinum_onenand_small	\
+	vct_platinumavc	\
+	vct_platinumavc_small	\
+	vct_platinumavc_onenand	\
+	vct_platinumavc_onenand_small	\
+	vct_premium	\
+	vct_premium_small	\
+	vct_premium_onenand	\
+	vct_premium_onenand_small	\
 "
 
 LIST_mips5kc="		\
@@ -658,6 +690,7 @@
 
 LIST_I486="		\
 	sc520_cdp	\
+	sc520_eNET	\
 	sc520_spunk	\
 	sc520_spunk_rel	\
 "
@@ -697,9 +730,9 @@
 ## MicroBlaze Systems
 #########################################################################
 
-LIST_microblaze="	\
-	ml401		\
-	suzaku		\
+LIST_microblaze="			\
+	microblaze-generic		\
+	suzaku				\
 "
 
 #########################################################################
@@ -817,7 +850,7 @@
 for arg in $@
 do
 	case "$arg" in
-	arm|SA|ARM7|ARM9|ARM10|ARM11|at91|ixp|pxa \
+	arm|SA|ARM7|ARM9|ARM10|ARM11|ARM_CORTEX_A8|at91|ixp|pxa \
 	|avr32 \
 	|blackfin \
 	|coldfire \
diff -Naur u-boot-2009.01/Makefile u-boot/Makefile
--- u-boot-2009.01/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/Makefile	2009-02-26 14:10:10.000000000 +0100
@@ -22,9 +22,9 @@
 #
 
 VERSION = 2009
-PATCHLEVEL = 01
+PATCHLEVEL = 03
 SUBLEVEL =
-EXTRAVERSION =
+EXTRAVERSION = -rc1
 ifneq "$(SUBLEVEL)" ""
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 else
@@ -197,7 +197,7 @@
 OBJS  = cpu/$(CPU)/start.o
 ifeq ($(CPU),i386)
 OBJS += cpu/$(CPU)/start16.o
-OBJS += cpu/$(CPU)/reset.o
+OBJS += cpu/$(CPU)/resetvec.o
 endif
 ifeq ($(CPU),ppc4xx)
 OBJS += cpu/$(CPU)/resetvec.o
@@ -317,7 +317,7 @@
 		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
 
 $(obj)u-boot.ldr:	$(obj)u-boot
-		$(LDR) -T $(CONFIG_BFIN_CPU) -f -c $@ $< $(LDR_FLAGS)
+		$(LDR) -T $(CONFIG_BFIN_CPU) -c $@ $< $(LDR_FLAGS)
 
 $(obj)u-boot.ldr.hex:	$(obj)u-boot.ldr
 		$(OBJCOPY) ${OBJCFLAGS} -O ihex $< $@ -I binary
@@ -1325,6 +1325,9 @@
 G2000_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc ppc4xx g2000
 
+gdppc440etx_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx gdppc440etx gdsys
+
 hcu4_config:	unconfig
 	@mkdir -p $(obj)board/netstal/common
 	@$(MKCONFIG) $(@:_config=) ppc ppc4xx hcu4 netstal
@@ -2186,6 +2189,9 @@
 ## MPC83xx Systems
 #########################################################################
 
+kmeter1_config: unconfig
+	@$(MKCONFIG) kmeter1 ppc mpc83xx kmeter1 keymile
+
 MPC8313ERDB_33_config \
 MPC8313ERDB_66_config \
 MPC8313ERDB_NAND_33_config \
@@ -2325,6 +2331,21 @@
 sbc8349_config:		unconfig
 	@$(MKCONFIG) $(@:_config=) ppc mpc83xx sbc8349
 
+SIMPC8313_LP_config \
+SIMPC8313_SP_config: unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/sheldon/simpc8313
+	@if [ "$(findstring _LP_,$@)" ] ; then \
+		$(XECHO) -n "...Large Page NAND..." ; \
+		echo "#define CONFIG_NAND_LP" >> $(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _SP_,$@)" ] ; then \
+		$(XECHO) -n "...Small Page NAND..." ; \
+		echo "#define CONFIG_NAND_SP" >> $(obj)include/config.h ; \
+	fi ;
+	@$(MKCONFIG) -a SIMPC8313 ppc mpc83xx simpc8313 sheldon
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
 TQM834x_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc mpc83xx tqm834x tqc
 
@@ -2398,8 +2419,14 @@
 MPC8568MDS_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc mpc85xx mpc8568mds freescale
 
+MPC8572DS_36BIT_config \
 MPC8572DS_config:       unconfig
-	@$(MKCONFIG) $(@:_config=) ppc mpc85xx mpc8572ds freescale
+	@mkdir -p $(obj)include
+	@if [ "$(findstring _36BIT_,$@)" ] ; then \
+		echo "#define CONFIG_PHYS_64BIT" >>$(obj)include/config.h ; \
+		$(XECHO) "... enabling 36-bit physical addressing." ; \
+	fi
+	@$(MKCONFIG) -a MPC8572DS ppc mpc85xx mpc8572ds freescale
 
 PM854_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc mpc85xx pm854
@@ -2452,16 +2479,20 @@
 TQM8540_config		\
 TQM8541_config		\
 TQM8548_config		\
+TQM8548_AG_config	\
+TQM8548_BE_config	\
 TQM8555_config		\
 TQM8560_config:		unconfig
 	@mkdir -p $(obj)include
-	@CTYPE=$(subst TQM,,$(@:_config=)); \
-	$(XECHO) "... TQM"$${CTYPE}; \
+	@BTYPE=$(@:_config=); \
+	CTYPE=$(subst TQM,,$(subst _AG,,$(subst _BE,,$(@:_config=)))); \
+	$(XECHO) "... "$${BTYPE}" (MPC"$${CTYPE}")"; \
 	echo "#define CONFIG_MPC$${CTYPE}">>$(obj)include/config.h; \
-	echo "#define CONFIG_TQM$${CTYPE}">>$(obj)include/config.h; \
+	echo "#define CONFIG_$${BTYPE}">>$(obj)include/config.h; \
 	echo "#define CONFIG_HOSTNAME tqm$${CTYPE}">>$(obj)include/config.h; \
-	echo "#define CONFIG_BOARDNAME \"TQM$${CTYPE}\"">>$(obj)include/config.h;
+	echo "#define CONFIG_BOARDNAME \"$${BTYPE}\"">>$(obj)include/config.h;
 	@$(MKCONFIG) -a TQM85xx ppc mpc85xx tqm85xx tqc
+	@echo "CONFIG_$(@:_config=) = y">>$(obj)include/config.mk;
 
 XPEDITE5200_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc mpc85xx xpedite5200 xes
@@ -2689,7 +2720,7 @@
 ap920t_config		\
 ap926ejs_config		\
 ap946es_config: unconfig
-	@board/integratorap/split_by_variant.sh $@
+	@board/armltd/integratorap/split_by_variant.sh $@
 
 integratorcp_config	\
 cp_config		\
@@ -2701,7 +2732,7 @@
 cp922_config		\
 cp922_XA10_config	\
 cp1026_config: unconfig
-	@board/integratorcp/split_by_variant.sh $@
+	@board/armltd/integratorcp/split_by_variant.sh $@
 
 davinci_dvevm_config :	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm926ejs dvevm davinci davinci
@@ -2728,6 +2759,18 @@
 netstar_config:		unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm925t netstar
 
+nmdk8815_config \
+nmdk8815_onenand_config:	unconfig
+	@mkdir -p $(obj)include
+	@ > $(obj)include/config.h
+	@if [ "$(findstring _onenand, $@)" ] ; then \
+		echo "#define CONFIG_BOOT_ONENAND" >> $(obj)include/config.h; \
+		$(XECHO) "... configured for OneNand Flash"; \
+	else \
+		$(XECHO) "... configured for Nand Flash"; \
+	fi
+	@$(MKCONFIG) -a nmdk8815 arm arm926ejs nmdk8815 st nomadik
+
 omap1510inn_config :	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm925t omap1510inn
 
@@ -2779,13 +2822,22 @@
 	@$(MKCONFIG) $(@:_config=) arm arm920t scb9328 NULL imx
 
 smdk2400_config	:	unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2400 NULL s3c24x0
+	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2400 samsung s3c24x0
 
 smdk2410_config	:	unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 NULL s3c24x0
+	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 samsung s3c24x0
 
-SX1_config :		unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm925t sx1
+SX1_stdout_serial_config \
+SX1_config:		unconfig
+	@mkdir -p $(obj)include
+	@if [ "$(findstring _stdout_serial_, $@)" ] ; then \
+		echo "#undef CONFIG_STDOUT_USBTTY" >> $(obj)include/config.h ; \
+		$(XECHO) "... configured for stdout serial"; \
+	else \
+		echo "#define CONFIG_STDOUT_USBTTY" >> $(obj)include/config.h ; \
+		$(XECHO) "... configured for stdout usbtty"; \
+	fi;
+	@$(MKCONFIG) SX1 arm arm925t sx1
 
 # TRAB default configuration:	8 MB Flash, 32 MB RAM
 xtract_trab = $(subst _bigram,,$(subst _bigflash,,$(subst _old,,$(subst _config,,$1))))
@@ -2831,7 +2883,7 @@
 versatile_config	\
 versatileab_config	\
 versatilepb_config :	unconfig
-	@board/versatile/split_by_variant.sh $@
+	@board/armltd/versatile/split_by_variant.sh $@
 
 voiceblue_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm925t voiceblue
@@ -2869,6 +2921,25 @@
 	@$(MKCONFIG) $(@:_config=) arm arm720t SMN42 siemens lpc2292
 
 #########################################################################
+## ARM CORTEX Systems
+#########################################################################
+
+omap3_beagle_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 beagle omap3 omap3
+
+omap3_overo_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 overo omap3 omap3
+
+omap3_evm_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 evm omap3 omap3
+
+omap3_pandora_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 pandora omap3 omap3
+
+omap3_zoom1_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 zoom1 omap3 omap3
+
+#########################################################################
 ## XScale Systems
 #########################################################################
 
@@ -2967,6 +3038,10 @@
 omap2420h4_config	: unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm1136 omap2420h4 NULL omap24xx
 
+qong_config		: unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm1136 qong davedenx mx31
+
+
 #########################################################################
 ## ARM1176 Systems
 #########################################################################
@@ -2990,14 +3065,17 @@
 #########################################################################
 ## AMD SC520 CDP
 #########################################################################
+eNET_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) i386 i386 eNET NULL sc520
+
 sc520_cdp_config	:	unconfig
-	@$(MKCONFIG) $(@:_config=) i386 i386 sc520_cdp
+	@$(MKCONFIG) $(@:_config=) i386 i386 sc520_cdp NULL sc520
 
 sc520_spunk_config	:	unconfig
-	@$(MKCONFIG) $(@:_config=) i386 i386 sc520_spunk
+	@$(MKCONFIG) $(@:_config=) i386 i386 sc520_spunk NULL sc520
 
 sc520_spunk_rel_config	:	unconfig
-	@$(MKCONFIG) $(@:_config=) i386 i386 sc520_spunk
+	@$(MKCONFIG) $(@:_config=) i386 i386 sc520_spunk NULL sc520
 
 #========================================================================
 # MIPS
@@ -3030,6 +3108,41 @@
 tb0229_config: unconfig
 	@$(MKCONFIG) $(@:_config=) mips mips tb0229
 
+vct_premium_config		\
+vct_premium_small_config	\
+vct_premium_onenand_config	\
+vct_premium_onenand_small_config \
+vct_platinum_config		\
+vct_platinum_small_config	\
+vct_platinum_onenand_config	\
+vct_platinum_onenand_small_config \
+vct_platinumavc_config		\
+vct_platinumavc_small_config	\
+vct_platinumavc_onenand_config	\
+vct_platinumavc_onenand_small_config: unconfig
+	@mkdir -p $(obj)include
+	@if [ "$(findstring _premium,$@)" ] ; then \
+		echo "#define CONFIG_VCT_PREMIUM" > $(obj)include/config.h ; \
+		$(XECHO) "... on Premium board variant" ; \
+	fi
+	@if [ "$(findstring _platinum_,$@)" ] ; then \
+		echo "#define CONFIG_VCT_PLATINUM" > $(obj)include/config.h ; \
+		$(XECHO) "... on Platinum board variant" ; \
+	fi
+	@if [ "$(findstring _platinumavc,$@)" ] ; then \
+		echo "#define CONFIG_VCT_PLATINUMAVC" > $(obj)include/config.h ; \
+		$(XECHO) "... on PlatinumAVC board variant" ; \
+	fi
+	@if [ "$(findstring _onenand,$@)" ] ; then \
+		echo "#define CONFIG_VCT_ONENAND" >> $(obj)include/config.h ; \
+		$(XECHO) "... on OneNAND board variant" ; \
+	fi
+	@if [ "$(findstring _small,$@)" ] ; then \
+		echo "#define CONFIG_VCT_SMALL_IMAGE" >> $(obj)include/config.h ; \
+		$(XECHO) "... stripped down image variant" ; \
+	fi
+	@$(MKCONFIG) -a vct mips mips vct micronas
+
 #########################################################################
 ## MIPS32 AU1X00
 #########################################################################
@@ -3170,10 +3283,9 @@
 ## Microblaze
 #========================================================================
 
-ml401_config:	unconfig
+microblaze-generic_config:	unconfig
 	@mkdir -p $(obj)include
-	@echo "#define CONFIG_ML401 1" > $(obj)include/config.h
-	@$(MKCONFIG) -a $(@:_config=) microblaze microblaze ml401 xilinx
+	@$(MKCONFIG) -a $(@:_config=) microblaze microblaze microblaze-generic xilinx
 
 suzaku_config:	unconfig
 	@mkdir -p $(obj)include
@@ -3222,6 +3334,10 @@
 mimc200_config		:	unconfig
 	@$(MKCONFIG) $(@:_config=) avr32 at32ap mimc200 mimc at32ap700x
 
+ICNOVA_BOARDS = oem oemplus base old
+$(ICNOVA_BOARDS:%=icnova_%_config):	unconfig
+	@$(MKCONFIG) $(@:_config=) avr32 at32ap icnova in-circuit at32ap700x
+
 #========================================================================
 # SH3 (SuperH)
 #========================================================================
@@ -3231,7 +3347,7 @@
 #########################################################################
 rsk7203_config: unconfig
 	@mkdir -p $(obj)include
-	@echo "#define CONFIG_RSK7203 1" > $(obj)/include/config.h
+	@echo "#define CONFIG_RSK7203 1" > $(obj)include/config.h
 	@$(MKCONFIG) -a $(@:_config=) sh sh2 rsk7203 renesas
 
 #########################################################################
@@ -3345,7 +3461,7 @@
 	@rm -f $(obj)board/cray/L1/{bootscript.c,bootscript.image}	  \
 	       $(obj)board/netstar/{eeprom,crcek,crcit,*.srec,*.bin}	  \
 	       $(obj)board/trab/trab_fkt   $(obj)board/voiceblue/eeprom   \
-	       $(obj)board/{integratorap,integratorcp}/u-boot.lds	  \
+	       $(obj)board/armltd/{integratorap,integratorcp}/u-boot.lds  \
 	       $(obj)board/{bf533-ezkit,bf533-stamp,bf537-stamp,bf561-ezkit}/u-boot.lds \
 	       $(obj)cpu/blackfin/bootrom-asm-offsets.[chs]
 	@rm -f $(obj)include/bmp_logo.h
diff -Naur u-boot-2009.01/mkconfig u-boot/mkconfig
--- u-boot-2009.01/mkconfig	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/mkconfig	2009-02-26 14:15:42.000000000 +0100
@@ -64,7 +64,8 @@
 #
 # Create include file for Make
 #
-echo "ARCH   = $2" >  config.mk
+echo "BNAME  = $1"  > config.mk
+echo "ARCH   = $2" >> config.mk
 echo "CPU    = $3" >> config.mk
 echo "BOARD  = $4" >> config.mk
 
@@ -83,5 +84,6 @@
 fi
 echo "/* Automatically generated - do not edit */" >>config.h
 echo "#include <configs/$1.h>" >>config.h
+echo "#include <asm/config.h>" >>config.h
 
 exit 0
diff -Naur u-boot-2009.01/nand_spl/board/freescale/mpc8313erdb/Makefile u-boot/nand_spl/board/freescale/mpc8313erdb/Makefile
--- u-boot-2009.01/nand_spl/board/freescale/mpc8313erdb/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/nand_spl/board/freescale/mpc8313erdb/Makefile	2009-02-26 14:03:59.000000000 +0100
@@ -34,7 +34,8 @@
 CFLAGS	+= -DCONFIG_NAND_SPL
 
 SOBJS	= start.o ticks.o
-COBJS	= nand_boot_fsl_elbc.o $(BOARD).o sdram.o ns16550.o nand_init.o time.o
+COBJS	= nand_boot_fsl_elbc.o $(BOARD).o sdram.o ns16550.o nand_init.o \
+	  time.o cache.o
 
 SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
@@ -79,6 +80,9 @@
 $(obj)nand_init.c:
 	ln -sf $(SRCTREE)/cpu/mpc83xx/nand_init.c $(obj)nand_init.c
 
+$(obj)cache.c:
+	ln -sf $(SRCTREE)/lib_ppc/cache.c $(obj)cache.c
+
 $(obj)time.c:
 	ln -sf $(SRCTREE)/lib_ppc/time.c $(obj)time.c
 
diff -Naur u-boot-2009.01/nand_spl/board/sheldon/simpc8313/Makefile u-boot/nand_spl/board/sheldon/simpc8313/Makefile
--- u-boot-2009.01/nand_spl/board/sheldon/simpc8313/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/nand_spl/board/sheldon/simpc8313/Makefile	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,104 @@
+#
+# (C) Copyright 2007
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+# (C) Copyright 2008 Freescale Semiconductor
+# (C) Copyright Sheldon Instruments, Inc. 2008
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+NAND_SPL := y
+TEXT_BASE := 0xfff00000
+
+include $(TOPDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o ticks.o
+COBJS	= nand_boot_fsl_elbc.o $(BOARD).o sdram.o ns16550.o nand_init.o \
+	  time.o cache.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-16k.bin
+
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-16k.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} --pad-to=$(PAD_TO) -O binary $< $@
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+$(obj)start.S:
+	ln -sf $(SRCTREE)/cpu/mpc83xx/start.S $<
+
+$(obj)nand_boot_fsl_elbc.c:
+	ln -sf $(SRCTREE)/nand_spl/nand_boot_fsl_elbc.c $<
+
+$(obj)sdram.c:
+	ln -sf $(SRCTREE)/board/$(BOARDDIR)/sdram.c $<
+
+$(obj)$(BOARD).c:
+	ln -sf $(SRCTREE)/board/$(BOARDDIR)/$(BOARD).c $<
+
+$(obj)ns16550.c:
+	ln -sf $(SRCTREE)/drivers/serial/ns16550.c $<
+
+$(obj)nand_init.c:
+	ln -sf $(SRCTREE)/cpu/mpc83xx/nand_init.c $<
+
+$(obj)cache.c:
+	ln -sf $(SRCTREE)/lib_ppc/cache.c $<
+
+$(obj)time.c:
+	ln -sf $(SRCTREE)/lib_ppc/time.c $<
+
+$(obj)ticks.S:
+	ln -sf $(SRCTREE)/lib_ppc/ticks.S $<
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur u-boot-2009.01/nand_spl/board/sheldon/simpc8313/u-boot.lds u-boot/nand_spl/board/sheldon/simpc8313/u-boot.lds
--- u-boot-2009.01/nand_spl/board/sheldon/simpc8313/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot/nand_spl/board/sheldon/simpc8313/u-boot.lds	2009-02-26 14:03:59.000000000 +0100
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * Copyright 2008 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(powerpc)
+SECTIONS
+{
+	. = 0xfff00000;
+	.text : {
+		*(.text*)
+		. = ALIGN(16);
+		*(.rodata*)
+		*(.eh_frame)
+	}
+
+	. = ALIGN(8);
+	.data : {
+		*(.data*)
+		*(.sdata*)
+		_GOT2_TABLE_ = .;
+		*(.got2)
+		__got2_entries = (. - _GOT2_TABLE_) >> 2;
+	}
+
+	. = ALIGN(8);
+	__bss_start = .;
+	.bss (NOLOAD) : { *(.*bss) }
+	_end = .;
+}
+ENTRY(_start)
+ASSERT(_end <= 0xfff01000, "NAND bootstrap too big");
diff -Naur u-boot-2009.01/nand_spl/nand_boot.c u-boot/nand_spl/nand_boot.c
--- u-boot-2009.01/nand_spl/nand_boot.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/nand_spl/nand_boot.c	2009-02-26 14:03:59.000000000 +0100
@@ -27,8 +27,6 @@
 
 static int nand_ecc_pos[] = CONFIG_SYS_NAND_ECCPOS;
 
-extern void board_nand_init(struct nand_chip *nand);
-
 #if (CONFIG_SYS_NAND_PAGE_SIZE <= 512)
 /*
  * NAND command for small page NAND devices (512)
diff -Naur u-boot-2009.01/nand_spl/nand_boot_fsl_elbc.c u-boot/nand_spl/nand_boot_fsl_elbc.c
--- u-boot-2009.01/nand_spl/nand_boot_fsl_elbc.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/nand_spl/nand_boot_fsl_elbc.c	2009-02-26 14:03:59.000000000 +0100
@@ -143,6 +143,11 @@
 	 * Jump to U-Boot image
 	 */
 	puts("transfering control\n");
+	/*
+	 * Clean d-cache and invalidate i-cache, to
+	 * make sure that no stale data is executed.
+	 */
+	flush_cache(CONFIG_SYS_NAND_U_BOOT_DST, CONFIG_SYS_NAND_U_BOOT_SIZE);
 	uboot = (void *)CONFIG_SYS_NAND_U_BOOT_START;
 	uboot();
 }
diff -Naur u-boot-2009.01/net/eth.c u-boot/net/eth.c
--- u-boot-2009.01/net/eth.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/net/eth.c	2009-02-26 14:03:59.000000000 +0100
@@ -80,6 +80,28 @@
 	return target_dev;
 }
 
+struct eth_device *eth_get_dev_by_index(int index)
+{
+	struct eth_device *dev, *target_dev;
+	int idx = 0;
+
+	if (!eth_devices)
+		return NULL;
+
+	dev = eth_devices;
+	target_dev = NULL;
+	do {
+		if (idx == index) {
+			target_dev = dev;
+			break;
+		}
+		dev = dev->next;
+		idx++;
+	} while (dev != eth_devices);
+
+	return target_dev;
+}
+
 int eth_get_dev_index (void)
 {
 	struct eth_device *dev;
diff -Naur u-boot-2009.01/net/Makefile u-boot/net/Makefile
--- u-boot-2009.01/net/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/net/Makefile	2009-02-26 14:03:59.000000000 +0100
@@ -33,7 +33,7 @@
 COBJS-y += rarp.o
 COBJS-y += eth.o
 COBJS-y += nfs.o
-COBJS-y += sntp.o
+COBJS-$(CONFIG_CMD_SNTP) += sntp.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff -Naur u-boot-2009.01/net/net.c u-boot/net/net.c
--- u-boot-2009.01/net/net.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/net/net.c	2009-02-26 14:03:59.000000000 +0100
@@ -1684,7 +1684,7 @@
 void
 NetSetIP(volatile uchar * xip, IPaddr_t dest, int dport, int sport, int len)
 {
-	volatile IP_t *ip = (IP_t *)xip;
+	IP_t *ip = (IP_t *)xip;
 
 	/*
 	 *	If the data is an odd number of bytes, zero the
diff -Naur u-boot-2009.01/net/sntp.c u-boot/net/sntp.c
--- u-boot-2009.01/net/sntp.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/net/sntp.c	2009-02-26 14:03:59.000000000 +0100
@@ -12,8 +12,6 @@
 
 #include "sntp.h"
 
-#if defined(CONFIG_CMD_NET) && defined(CONFIG_CMD_SNTP)
-
 #define SNTP_TIMEOUT 10000UL
 
 static int SntpOurPort;
@@ -88,5 +86,3 @@
 
 	SntpSend ();
 }
-
-#endif
diff -Naur u-boot-2009.01/post/lib_ppc/fpu/20001122-1.c u-boot/post/lib_ppc/fpu/20001122-1.c
--- u-boot-2009.01/post/lib_ppc/fpu/20001122-1.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/post/lib_ppc/fpu/20001122-1.c	2009-02-26 14:03:59.000000000 +0100
@@ -30,6 +30,8 @@
 
 #if CONFIG_POST & CONFIG_SYS_POST_FPU
 
+GNU_FPOST_ATTR
+
 int fpu_post_test_math1 (void)
 {
 	volatile double a, *p;
diff -Naur u-boot-2009.01/post/lib_ppc/fpu/20010114-2.c u-boot/post/lib_ppc/fpu/20010114-2.c
--- u-boot-2009.01/post/lib_ppc/fpu/20010114-2.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/post/lib_ppc/fpu/20010114-2.c	2009-02-26 14:03:59.000000000 +0100
@@ -30,6 +30,8 @@
 
 #if CONFIG_POST & CONFIG_SYS_POST_FPU
 
+GNU_FPOST_ATTR
+
 static float rintf (float x)
 {
 	volatile float TWO23 = 8388608.0;
diff -Naur u-boot-2009.01/post/lib_ppc/fpu/20010226-1.c u-boot/post/lib_ppc/fpu/20010226-1.c
--- u-boot-2009.01/post/lib_ppc/fpu/20010226-1.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/post/lib_ppc/fpu/20010226-1.c	2009-02-26 14:03:59.000000000 +0100
@@ -30,6 +30,8 @@
 
 #if CONFIG_POST & CONFIG_SYS_POST_FPU
 
+GNU_FPOST_ATTR
+
 int fpu_post_test_math3 (void)
 {
 	volatile long double dfrom = 1.1;
diff -Naur u-boot-2009.01/post/lib_ppc/fpu/980619-1.c u-boot/post/lib_ppc/fpu/980619-1.c
--- u-boot-2009.01/post/lib_ppc/fpu/980619-1.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/post/lib_ppc/fpu/980619-1.c	2009-02-26 14:03:59.000000000 +0100
@@ -30,6 +30,8 @@
 
 #if CONFIG_POST & CONFIG_SYS_POST_FPU
 
+GNU_FPOST_ATTR
+
 int fpu_post_test_math4 (void)
 {
 	volatile float reale = 1.0f;
diff -Naur u-boot-2009.01/post/lib_ppc/fpu/acc1.c u-boot/post/lib_ppc/fpu/acc1.c
--- u-boot-2009.01/post/lib_ppc/fpu/acc1.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/post/lib_ppc/fpu/acc1.c	2009-02-26 14:03:59.000000000 +0100
@@ -30,6 +30,8 @@
 
 #if CONFIG_POST & CONFIG_SYS_POST_FPU
 
+GNU_FPOST_ATTR
+
 static double func (const double *array)
 {
 	double d = *array;
diff -Naur u-boot-2009.01/post/lib_ppc/fpu/compare-fp-1.c u-boot/post/lib_ppc/fpu/compare-fp-1.c
--- u-boot-2009.01/post/lib_ppc/fpu/compare-fp-1.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/post/lib_ppc/fpu/compare-fp-1.c	2009-02-26 14:03:59.000000000 +0100
@@ -32,6 +32,8 @@
 
 #if CONFIG_POST & CONFIG_SYS_POST_FPU
 
+GNU_FPOST_ATTR
+
 static int failed;
 
 #define TEST(c) if ((c) != ok) failed++
diff -Naur u-boot-2009.01/post/lib_ppc/fpu/fpu.c u-boot/post/lib_ppc/fpu/fpu.c
--- u-boot-2009.01/post/lib_ppc/fpu/fpu.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/post/lib_ppc/fpu/fpu.c	2009-02-26 14:03:59.000000000 +0100
@@ -40,6 +40,8 @@
 
 #include <watchdog.h>
 
+GNU_FPOST_ATTR
+
 extern int fpu_status (void);
 extern void fpu_enable (void);
 extern void fpu_disable (void);
diff -Naur u-boot-2009.01/post/lib_ppc/fpu/Makefile u-boot/post/lib_ppc/fpu/Makefile
--- u-boot-2009.01/post/lib_ppc/fpu/Makefile	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/post/lib_ppc/fpu/Makefile	2009-02-26 14:03:59.000000000 +0100
@@ -29,4 +29,5 @@
 
 include $(TOPDIR)/post/rules.mk
 
+CFLAGS := $(shell echo $(CFLAGS) | sed s/-msoft-float//)
 CFLAGS += -mhard-float -fkeep-inline-functions
diff -Naur u-boot-2009.01/post/lib_ppc/fpu/mul-subnormal-single-1.c u-boot/post/lib_ppc/fpu/mul-subnormal-single-1.c
--- u-boot-2009.01/post/lib_ppc/fpu/mul-subnormal-single-1.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/post/lib_ppc/fpu/mul-subnormal-single-1.c	2009-02-26 14:03:59.000000000 +0100
@@ -32,6 +32,8 @@
 
 #if CONFIG_POST & CONFIG_SYS_POST_FPU
 
+GNU_FPOST_ATTR
+
 union uf
 {
 	unsigned int u;
diff -Naur u-boot-2009.01/README u-boot/README
--- u-boot-2009.01/README	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/README	2009-02-26 14:03:58.000000000 +0100
@@ -484,6 +484,14 @@
 		CONFIG_SYS_BAUDRATE_TABLE, see below.
 		CONFIG_SYS_BRGCLK_PRESCALE, baudrate prescale
 
+- Console Rx buffer length
+		With CONFIG_SYS_SMC_RXBUFLEN it is possible to define
+		the maximum receive buffer length for the SMC.
+		This option is actual only for 82xx and 8xx possible.
+		If using CONFIG_SYS_SMC_RXBUFLEN also CONFIG_SYS_MAXIDLE
+		must be defined, to setup the maximum idle timeout for
+		the SMC.
+
 - Interrupt driven serial port input:
 		CONFIG_SERIAL_SOFTWARE_FIFO
 
@@ -592,11 +600,15 @@
 		CONFIG_CMD_DHCP		* DHCP support
 		CONFIG_CMD_DIAG		* Diagnostics
 		CONFIG_CMD_DOC		* Disk-On-Chip Support
+		CONFIG_CMD_DS4510	* ds4510 I2C gpio commands
+		CONFIG_CMD_DS4510_INFO	* ds4510 I2C info command
+		CONFIG_CMD_DS4510_MEM	* ds4510 I2C eeprom/sram commansd
+		CONFIG_CMD_DS4510_RST	* ds4510 I2C rst command
 		CONFIG_CMD_DTT		* Digital Therm and Thermostat
 		CONFIG_CMD_ECHO		  echo arguments
 		CONFIG_CMD_EEPROM	* EEPROM read/write support
 		CONFIG_CMD_ELF		* bootelf, bootvx
-		CONFIG_CMD_ENV		  saveenv
+		CONFIG_CMD_SAVEENV	  saveenv
 		CONFIG_CMD_FDC		* Floppy Disk Support
 		CONFIG_CMD_FAT		* FAT partition support
 		CONFIG_CMD_FDOS		* Dos diskette Support
@@ -1505,6 +1517,15 @@
 		Bus on the MPC8260. But it should be not so difficult
 		to add this option to other architectures.
 
+		CONFIG_SOFT_I2C_READ_REPEATED_START
+
+		defining this will force the i2c_read() function in
+		the soft_i2c driver to perform an I2C repeated start
+		between writing the address pointer and reading the
+		data.  If this define is omitted the default behaviour
+		of doing a stop-start sequence will be used.  Most I2C
+		devices can use either method, but some require one or
+		the other.
 
 - SPI Support:	CONFIG_SPI
 
@@ -2032,6 +2053,9 @@
 - CONFIG_SYS_LONGHELP: Defined when you want long help messages included;
 		undefine this when you're short of memory.
 
+- CONFIG_SYS_HELP_CMD_WIDTH: Defined when you want to override the default
+		width of the commands listed in the 'help' command output.
+
 - CONFIG_SYS_PROMPT:	This is what U-Boot prints on the console to
 		prompt for user input.
 
@@ -2434,6 +2458,13 @@
 - CONFIG_SYS_64BIT_STRTOUL:
 		Adds simple_strtoull that returns a 64bit value
 
+- CONFIG_NS16550_MIN_FUNCTIONS:
+		Define this if you desire to only have use of the NS16550_init
+		and NS16550_putc functions for the serial driver located at
+		drivers/serial/ns16550.c.  This option is useful for saving
+		space for already greatly restricted images, including but not
+		limited to NAND_SPL configurations.
+
 Low Level (hardware related) configuration options:
 ---------------------------------------------------
 
@@ -2579,6 +2610,10 @@
   CONFIG_SYS_POCMR2_MASK_ATTRIB: (MPC826x only)
 		Overrides the default PCI memory map in cpu/mpc8260/pci.c if set.
 
+- CONFIG_PCI_DISABLE_PCIE:
+		Disable PCI-Express on systems where it is supported but not
+		required.
+
 - CONFIG_SPD_EEPROM
 		Get DDR timing information from an I2C EEPROM. Common
 		with pluggable memory modules such as SODIMMs
@@ -2595,10 +2630,6 @@
 		Only for 83xx systems. If specified, then DDR should
 		be configured using CS0 and CS1 instead of CS2 and CS3.
 
-- CONFIG_SYS_83XX_DDR_USES_CS0
-		Only for 83xx systems. If specified, then DDR should
-		be configured using CS0 and CS1 instead of CS2 and CS3.
-
 - CONFIG_ETHER_ON_FEC[12]
 		Define to enable FEC[12] on a 8xx series processor.
 
@@ -3005,8 +3036,7 @@
 		  Useful on scripts which control the retry operation
 		  themselves.
 
-  npe_ucode	- see CONFIG_IXP4XX_NPE_EXT_UCOD
-		  if set load address for the NPE microcode
+  npe_ucode	- set load address for the NPE microcode
 
   tftpsrcport	- If this is set, the value is used for TFTP's
 		  UDP source port.
diff -Naur u-boot-2009.01/README.nios_CONFIG_SYS_NIOS_CPU u-boot/README.nios_CONFIG_SYS_NIOS_CPU
--- u-boot-2009.01/README.nios_CONFIG_SYS_NIOS_CPU	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/README.nios_CONFIG_SYS_NIOS_CPU	1970-01-01 01:00:00.000000000 +0100
@@ -1,140 +0,0 @@
-
-===============================================================================
-	C F G _ N I O S _ C P U _ *   v s .   N I O S	S D K
-===============================================================================
-
-When ever you have to make a new NIOS CPU configuration you can use this table
-as a reference list to the original NIOS SDK symbols made by Alteras SOPC
-Builder. Look into excalibur.h and excalibur.s in your SDK path cpu_sdk/inc.
-Symbols beginning with a '[ptf]:' are coming from your SOPC sytem description
-(PTF file) in sections WIZARD_SCRIPT_ARGUMENTS or SYSTEM_BUILDER_INFO.
-
-C O R E					N I O S	  S D K			[1],[7]
--------------------------------------------------------------------------------
-CONFIG_SYS_NIOS_CPU_CLK					nasys_clock_freq
-CONFIG_SYS_NIOS_CPU_ICACHE					nasys_icache_size
-CONFIG_SYS_NIOS_CPU_DCACHE					nasys_dcache_size
-CONFIG_SYS_NIOS_CPU_REG_NUMS					nasys_nios_num_regs
-CONFIG_SYS_NIOS_CPU_MUL					__nios_use_multiply__
-CONFIG_SYS_NIOS_CPU_MSTEP					__nios_use_mstep__
-CONFIG_SYS_NIOS_CPU_STACK					nasys_stack_top
-CONFIG_SYS_NIOS_CPU_VEC_BASE					nasys_vector_table
-CONFIG_SYS_NIOS_CPU_VEC_SIZE					nasys_vector_table_size
-CONFIG_SYS_NIOS_CPU_VEC_NUMS
-CONFIG_SYS_NIOS_CPU_RST_VECT					nasys_reset_address
-CONFIG_SYS_NIOS_CPU_DBG_CORE					nasys_debug_core
-CONFIG_SYS_NIOS_CPU_RAM_BASE		na_onchip_ram_64_kbytes
-CONFIG_SYS_NIOS_CPU_RAM_SIZE		na_onchip_ram_64_kbytes_size
-CONFIG_SYS_NIOS_CPU_ROM_BASE		na_boot_monitor_rom
-CONFIG_SYS_NIOS_CPU_ROM_SIZE		na_boot_monitor_rom_size
-CONFIG_SYS_NIOS_CPU_OCI_BASE					nasys_oci_core
-CONFIG_SYS_NIOS_CPU_OCI_SIZE
-CONFIG_SYS_NIOS_CPU_SRAM_BASE		na_ext_ram		nasys_program_mem
-							nasys_data_mem
-CONFIG_SYS_NIOS_CPU_SRAM_SIZE		na_ext_ram_size		nasys_program_mem_size
-							nasys_data_mem_size
-CONFIG_SYS_NIOS_CPU_SDRAM_BASE		 na_sdram
-CONFIG_SYS_NIOS_CPU_SDRAM_SIZE		 na_sdram_size
-CONFIG_SYS_NIOS_CPU_FLASH_BASE		 na_ext_flash		nasys_main_flash
-							nasys_am29lv065d_flash_0
-							nasys_flash_0
-CONFIG_SYS_NIOS_CPU_FLASH_SIZE	    na_ext_flash_size		nasys_main_flash_size
-
-T I M E R				N I O S	  S D K			    [3]
--------------------------------------------------------------------------------
-CONFIG_SYS_NIOS_CPU_TIMER_NUMS					nasys_timer_count
-CONFIG_SYS_NIOS_CPU_TIMER[0-9]					nasys_timer_[0-9]
-CONFIG_SYS_NIOS_CPU_TIMER[0-9]_IRQ				nasys_timer_[0-9]_irq
-CONFIG_SYS_NIOS_CPU_TIMER[0-9]_PER				[ptf]:period
-							[ptf]:period_units
-							[ptf]:mult
-CONFIG_SYS_NIOS_CPU_TIMER[0-9]_AR				[ptf]:always_run
-CONFIG_SYS_NIOS_CPU_TIMER[0-9]_FP				[ptf]:fixed_period
-CONFIG_SYS_NIOS_CPU_TIMER[0-9]_SS				[ptf]:snapshot
-
-U A R T					N I O S	  S D K			    [2]
--------------------------------------------------------------------------------
-CONFIG_SYS_NIOS_CPU_UART_NUMS					nasys_uart_count
-CONFIG_SYS_NIOS_CPU_UART[0-9]					nasys_uart_[0-9]
-CONFIG_SYS_NIOS_CPU_UART[0-9]_IRQ				nasys_uart_[0-9]_irq
-CONFIG_SYS_NIOS_CPU_UART[0-9]_BR				[ptf]:baud
-CONFIG_SYS_NIOS_CPU_UART[0-9]_DB				[ptf]:data_bits
-CONFIG_SYS_NIOS_CPU_UART[0-9]_SB				[ptf]:stop_bits
-CONFIG_SYS_NIOS_CPU_UART[0-9]_PA				[ptf]:parity
-CONFIG_SYS_NIOS_CPU_UART[0-9]_HS				[ptf]:use_cts_rts
-CONFIG_SYS_NIOS_CPU_UART[0-9]_EOP				[ptf]:use_eop_register
-
-P I O					N I O S	  S D K			    [4]
--------------------------------------------------------------------------------
-CONFIG_SYS_NIOS_CPU_PIO_NUMS					nasys_pio_count
-CONFIG_SYS_NIOS_CPU_PIO[0-9]					nasys_pio_[0-9]
-CONFIG_SYS_NIOS_CPU_PIO[0-9]_IRQ				nasys_pio_[0-9]_irq
-CONFIG_SYS_NIOS_CPU_PIO[0-9]_BITS				[ptf]:Data_Width
-CONFIG_SYS_NIOS_CPU_PIO[0-9]_TYPE				[ptf]:has_tri
-							[ptf]:has_out
-							[ptf]:has_in
-CONFIG_SYS_NIOS_CPU_PIO[0-9]_CAP				[ptf]:capture
-CONFIG_SYS_NIOS_CPU_PIO[0-9]_EDGE				[ptf]:edge_type
-CONFIG_SYS_NIOS_CPU_PIO[0-9]_ITYPE				[ptf]:irq_type
-
-S P I					N I O S	  S D K			    [6]
--------------------------------------------------------------------------------
-CONFIG_SYS_NIOS_CPU_SPI_NUMS					nasys_spi_count
-CONFIG_SYS_NIOS_CPU_SPI[0-9]					nasys_spi_[0-9]
-CONFIG_SYS_NIOS_CPU_SPI[0-9]_IRQ				nasys_spi_[0-9]_irq
-CONFIG_SYS_NIOS_CPU_SPI[0-9]_BITS				[ptf]:databits
-CONFIG_SYS_NIOS_CPU_SPI[0-9]_MA				[ptf]:ismaster
-CONFIG_SYS_NIOS_CPU_SPI[0-9]_SLN				[ptf]:numslaves
-CONFIG_SYS_NIOS_CPU_SPI[0-9]_TCLK				[ptf]:targetclock
-CONFIG_SYS_NIOS_CPU_SPI[0-9]_TDELAY				[ptf]:targetdelay
-CONFIG_SYS_NIOS_CPU_SPI[0-9]_*					[ptf]:*
-
-I D E					N I O S	  S D K
--------------------------------------------------------------------------------
-CONFIG_SYS_NIOS_CPU_IDE_NUMS					nasys_usersocket_count
-CONFIG_SYS_NIOS_CPU_IDE[0-9]					nasys_usersocket_[0-9]
-
-A S M I					N I O S	  S D K			    [5]
--------------------------------------------------------------------------------
-CONFIG_SYS_NIOS_CPU_ASMI_NUMS					nasys_asmi_count
-CONFIG_SYS_NIOS_CPU_ASMI[0-9]					nasys_asmi_[0-9]
-CONFIG_SYS_NIOS_CPU_ASMI[0-9]_IRQ				nasys_asmi_[0-9]_irq
-
-E t h e r n e t	  ( L A N )		N I O S	  S D K
--------------------------------------------------------------------------------
-CONFIG_SYS_NIOS_CPU_LAN_NUMS
-CONFIG_SYS_NIOS_CPU_LAN[0-9]_BASE	na_lan91c111
-CONFIG_SYS_NIOS_CPU_LAN[0-9]_OFFS				LAN91C111_REGISTERS_OFFSET
-CONFIG_SYS_NIOS_CPU_LAN[0-9]_IRQ	na_lan91c111_irq
-CONFIG_SYS_NIOS_CPU_LAN[0-9]_BUSW				LAN91C111_DATA_BUS_WIDTH
-CONFIG_SYS_NIOS_CPU_LAN[0-9]_TYPE
-
-s y s t e m   c o m p o s i n g		N I O S	  S D K
--------------------------------------------------------------------------------
-CONFIG_SYS_NIOS_CPU_TICK_TIMER		(na_low_priority_timer2)
-CONFIG_SYS_NIOS_CPU_USER_TIMER		(na_timer1)
-CONFIG_SYS_NIOS_CPU_BUTTON_PIO		(na_button_pio)
-CONFIG_SYS_NIOS_CPU_LCD_PIO		(na_lcd_pio)
-CONFIG_SYS_NIOS_CPU_LED_PIO		(na_led_pio)
-CONFIG_SYS_NIOS_CPU_SEVENSEG_PIO	(na_seven_seg_pio)
-CONFIG_SYS_NIOS_CPU_RECONF_PIO		(na_reconfig_request_pio)
-CONFIG_SYS_NIOS_CPU_CFPRESENT_PIO	(na_cf_present_pio)
-CONFIG_SYS_NIOS_CPU_CFPOWER_PIO	(na_cf_power_pio)
-CONFIG_SYS_NIOS_CPU_CFATASEL_PIO	(na_cf_ata_select_pio)
-CONFIG_SYS_NIOS_CPU_USER_SPI		(na_spi)
-
-
-===============================================================================
-	R E F E R E N C E S
-===============================================================================
-[1]	http://www.altera.com/literature/ds/ds_nioscpu.pdf
-[2]	http://www.altera.com/literature/ds/ds_nios_uart.pdf
-[3]	http://www.altera.com/literature/ds/ds_nios_timer.pdf
-[4]	http://www.altera.com/literature/ds/ds_nios_pio.pdf
-[5]	http://www.altera.com/literature/ds/ds_nios_asmi.pdf
-[6]	http://www.altera.com/literature/ds/ds_nios_spi.pdf
-[7]	http://www.altera.com/literature/ds/ds_legacy_sdram_ctrl.pdf
-
-
-===============================================================================
-Stephan Linz <linz@li-pro.net>
diff -Naur u-boot-2009.01/tools/easylogo/easylogo.c u-boot/tools/easylogo/easylogo.c
--- u-boot-2009.01/tools/easylogo/easylogo.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/tools/easylogo/easylogo.c	2009-02-26 14:03:59.000000000 +0100
@@ -3,15 +3,19 @@
 ** ==============================
 ** (C) 2000 by Paolo Scaffardi (arsenio@tin.it)
 ** AIRVENT SAM s.p.a - RIMINI(ITALY)
+** (C) 2007-2008 Mike Frysinger <vapier@gentoo.org>
 **
 ** This is still under construction!
 */
 
+#include <errno.h>
 #include <getopt.h>
 #include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
 
 #pragma pack(1)
 
@@ -49,6 +53,17 @@
 	int width, height, pixels, bpp, pixel_size, size, palette_size, yuyv;
 } image_t;
 
+void *xmalloc (size_t size)
+{
+	void *ret = malloc (size);
+	if (!ret) {
+		fprintf (stderr, "\nerror: malloc(%zu) failed: %s",
+			size, strerror(errno));
+		exit (1);
+	}
+	return ret;
+}
+
 void StringUpperCase (char *str)
 {
 	int count = strlen (str);
@@ -171,7 +186,7 @@
 	image->pixel_size = ((image->bpp - 1) / 8) + 1;
 	image->pixels = image->width * image->height;
 	image->size = image->pixels * image->pixel_size;
-	image->data = malloc (image->size);
+	image->data = xmalloc (image->size);
 
 	if (image->bpp != 24) {
 		printf ("Bpp not supported: %d!\n", image->bpp);
@@ -192,7 +207,7 @@
 /* Swapping image */
 
 	if (!(header.ImageDescriptorByte & 0x20)) {
-		unsigned char *temp = malloc (image->size);
+		unsigned char *temp = xmalloc (image->size);
 		int linesize = image->pixel_size * image->width;
 		void *dest = image->data,
 			*source = temp + image->size - linesize;
@@ -239,7 +254,7 @@
 	yuyv_image->pixels = yuyv_image->width * yuyv_image->height;
 	yuyv_image->size = yuyv_image->pixels * yuyv_image->pixel_size;
 	dest = (unsigned short *) (yuyv_image->data =
-				   malloc (yuyv_image->size));
+				   xmalloc (yuyv_image->size));
 	yuyv_image->palette = 0;
 	yuyv_image->palette_size = 0;
 
@@ -261,6 +276,8 @@
 	return 0;
 }
 
+int use_gzip = 0;
+
 int image_save_header (image_t * image, char *filename, char *varname)
 {
 	FILE *file = fopen (filename, "w");
@@ -283,6 +300,65 @@
 	fprintf (file, " *\t\t'x'\t\tis the horizontal position\n");
 	fprintf (file, " *\t\t'y'\t\tis the vertical position\n */\n\n");
 
+	/*  gzip compress */
+	if (use_gzip & 0x1) {
+		const char *errstr = NULL;
+		unsigned char *compressed;
+		struct stat st;
+		FILE *gz;
+		char *gzfilename = xmalloc(strlen (filename) + 20);
+		char *gzcmd = xmalloc(strlen (filename) + 20);
+
+		sprintf (gzfilename, "%s.gz", filename);
+		sprintf (gzcmd, "gzip > %s", gzfilename);
+		gz = popen (gzcmd, "w");
+		if (!gz) {
+			errstr = "\nerror: popen() failed";
+			goto done;
+		}
+		if (fwrite (image->data, image->size, 1, gz) != 1) {
+			errstr = "\nerror: writing data to gzip failed";
+			goto done;
+		}
+		if (pclose (gz)) {
+			errstr = "\nerror: gzip process failed";
+			goto done;
+		}
+
+		gz = fopen (gzfilename, "r");
+		if (!gz) {
+			errstr = "\nerror: open() on gzip data failed";
+			goto done;
+		}
+		if (stat (gzfilename, &st)) {
+			errstr = "\nerror: stat() on gzip file failed";
+			goto done;
+		}
+		compressed = xmalloc (st.st_size);
+		if (fread (compressed, st.st_size, 1, gz) != 1) {
+			errstr = "\nerror: reading gzip data failed";
+			goto done;
+		}
+		fclose (gz);
+
+		unlink (gzfilename);
+
+		dataptr = compressed;
+		count = st.st_size;
+		fprintf (file, "#define EASYLOGO_ENABLE_GZIP %i\n\n", count);
+		if (use_gzip & 0x2)
+			fprintf (file, "static unsigned char EASYLOGO_DECOMP_BUFFER[%i];\n\n", image->size);
+
+ done:
+		free (gzfilename);
+		free (gzcmd);
+
+		if (errstr) {
+			perror (errstr);
+			return -1;
+		}
+	}
+
 	/*	Headers */
 	fprintf (file, "#include <video_easylogo.h>\n\n");
 	/*	Macros */
@@ -300,8 +376,8 @@
 	fprintf (file, "#define	DEF_%s_SIZE\t\t%d\n\n", def_name,
 		 image->size);
 	/*  Declaration */
-	fprintf (file, "unsigned char DEF_%s_DATA[DEF_%s_SIZE] = {\n",
-		 def_name, def_name);
+	fprintf (file, "unsigned char DEF_%s_DATA[] = {\n",
+		 def_name);
 
 	/*	Data */
 	while (count)
@@ -359,6 +435,8 @@
 		"\n"
 		"Options:\n"
 		"  -r     Output RGB instead of YUYV\n"
+		"  -g     Compress with gzip\n"
+		"  -b     Preallocate space in bss for decompressing image\n"
 		"  -h     Help output\n"
 		"\n"
 		"Where: 'inputfile'   is the TGA image to load\n"
@@ -377,7 +455,7 @@
 
 	image_t rgb_logo, yuyv_logo;
 
-	while ((c = getopt(argc, argv, "hr")) > 0) {
+	while ((c = getopt(argc, argv, "hrgb")) > 0) {
 		switch (c) {
 		case 'h':
 			usage (0);
@@ -386,6 +464,14 @@
 			use_rgb = true;
 			puts ("Using 24-bit RGB Output Fromat");
 			break;
+		case 'g':
+			use_gzip |= 0x1;
+			puts ("Compressing with gzip");
+			break;
+		case 'b':
+			use_gzip |= 0x2;
+			puts ("Preallocating bss space for decompressing image");
+			break;
 		default:
 			usage (1);
 			break;
diff -Naur u-boot-2009.01/tools/updater/cmd_flash.c u-boot/tools/updater/cmd_flash.c
--- u-boot-2009.01/tools/updater/cmd_flash.c	2009-01-21 23:08:12.000000000 +0100
+++ u-boot/tools/updater/cmd_flash.c	2009-02-26 14:03:59.000000000 +0100
@@ -122,7 +122,7 @@
 	int rcode = 0;
 
 	if (argc < 2) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -147,7 +147,7 @@
 	}
 
 	if (argc != 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -168,7 +168,7 @@
 	addr_last  = simple_strtoul(argv[2], NULL, 16);
 
 	if (addr_first >= addr_last) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -244,7 +244,7 @@
 	int rcode = 0;
 
 	if (argc < 3) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -253,7 +253,7 @@
 	else if (strcmp(argv[1], "on") == 0)
 		p = 1;
 	else {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -310,7 +310,7 @@
 	}
 
 	if (argc != 4) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 
@@ -350,7 +350,7 @@
 	addr_last  = simple_strtoul(argv[3], NULL, 16);
 
 	if (addr_first >= addr_last) {
-		printf ("Usage:\n%s\n", cmdtp->usage);
+		cmd_usage(cmdtp);
 		return 1;
 	}
 	rcode = flash_sect_protect (p, addr_first, addr_last);
diff -Naur u-boot-2009.01/include/configs/icnova/flash.h u-boot-2009.01.fixed/include/configs/icnova/flash.h
--- u-boot-2009.01/include/configs/icnova/flash.h	2009-04-07 14:49:59.000000000 +0200
+++ u-boot-2009.01.fixed/include/configs/icnova/flash.h	2009-04-07 14:22:57.000000000 +0200
@@ -1,4 +1,5 @@
 #define CONFIG_CMD_JFFS2
+#define CONFIG_JFFS2_CMDLINE
 #define CONFIG_CMD_FLASH
 
 #define CONFIG_SYS_FLASH_BASE			0x00000000
@@ -10,7 +11,10 @@
 
 #define CONFIG_ENV_IS_IN_FLASH		1
 #define CONFIG_ENV_SIZE			65536
-#define CONFIG_ENV_ADDR			0x30000
+#define CONFIG_ENV_ADDR			0x20000
+
+#define MTDPARTS_DEFAULT "mtdparts=physmap-flash.0:128k(boot)ro,64k(env)ro,-(root)"
+#define MTDIDS_DEFAULT			"nor0=physmap-flash.0"
 
 #undef CONFIG_BOOTARGS
 #undef CONFIG_BOOTCOMMAND
diff -Naur u-boot-2009.01.orig/board/in-circuit/icnova/Makefile.icnova_oemplus2nw u-boot-2009.01.new/board/in-circuit/icnova/Makefile.icnova_oemplus2nw
--- u-boot-2009.01.orig/board/in-circuit/icnova/Makefile.icnova_oemplus2nw	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01.new/board/in-circuit/icnova/Makefile.icnova_oemplus2nw	2009-11-11 10:26:22.000000000 +0100
@@ -0,0 +1 @@
+include Makefile.icnova_oemplus
diff -Naur u-boot-2009.01.orig/include/configs/icnova_oem2nw.h u-boot-2009.01.new/include/configs/icnova_oem2nw.h
--- u-boot-2009.01.orig/include/configs/icnova_oem2nw.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01.new/include/configs/icnova_oem2nw.h	2009-11-11 10:25:02.000000000 +0100
@@ -0,0 +1,12 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/icnova/base.h>
+#include <configs/icnova/cpu140MHz.h>
+#include <configs/icnova/mmc.h>
+#include <configs/icnova/flash.h>
+#include <configs/icnova/net.h>
+#include <configs/icnova/usart0.h>
+#define CONFIG_MACB2
+
+#endif
diff -Naur u-boot-2009.01.orig/include/configs/icnova_oemplus2nw.h u-boot-2009.01.new/include/configs/icnova_oemplus2nw.h
--- u-boot-2009.01.orig/include/configs/icnova_oemplus2nw.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2009.01.new/include/configs/icnova_oemplus2nw.h	2009-11-11 10:24:21.000000000 +0100
@@ -0,0 +1,13 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/icnova/base.h>
+#include <configs/icnova/cpu140MHz.h>
+#include <configs/icnova/mmc.h>
+#include <configs/icnova/flash2x8.h>
+#include <configs/icnova/nand.h>
+#include <configs/icnova/net.h>
+#include <configs/icnova/usart0.h>
+#define CONFIG_MACB2
+
+#endif
diff -Naur u-boot-2009.01.orig/Makefile u-boot-2009.01.new/Makefile
--- u-boot-2009.01.orig/Makefile	2009-11-11 12:59:18.000000000 +0100
+++ u-boot-2009.01.new/Makefile	2009-11-11 10:20:30.000000000 +0100
@@ -3334,7 +3334,7 @@
 mimc200_config		:	unconfig
 	@$(MKCONFIG) $(@:_config=) avr32 at32ap mimc200 mimc at32ap700x
 
-ICNOVA_BOARDS = oem oemplus base old
+ICNOVA_BOARDS = oem oemplus base old oem2nw oemplus2nw
 $(ICNOVA_BOARDS:%=icnova_%_config):	unconfig
 	@$(MKCONFIG) $(@:_config=) avr32 at32ap icnova in-circuit at32ap700x
 
diff -Naur u-boot-2009.01/board/in-circuit/icnova/icnova.c u-boot-2009.01/board/in-circuit/icnova/icnova.c
--- u-boot-2009.01/board/in-circuit/icnova/icnova.c	2009-11-11 15:55:25.000000000 +0100
+++ u-boot-2009.01/board/in-circuit/icnova/icnova.c	2009-10-15 16:53:27.000000000 +0200
@@ -80,6 +80,12 @@
 	gpio_enable_macb0();
 #endif
 #ifdef CONFIG_MACB2
+	gpio_select_pio(GPIO_PIN_PA28, GPIOF_OUTPUT);
+	gpio_set_value(GPIO_PIN_PA28, 0);
+	gpio_select_pio(GPIO_PIN_PA20, GPIOF_OUTPUT);
+	gpio_set_value(GPIO_PIN_PA20, 0);
+	udelay(100);
+	gpio_set_value(GPIO_PIN_PA20, 1);
 	gpio_enable_macb1();
 #endif
 #ifdef CONFIG_MMC
diff -Naur u-boot-2009.01/board/in-circuit/icnova/flash.c u-boot-2009.01/board/in-circuit/icnova/flash.c
--- u-boot-2009.01/board/in-circuit/icnova/flash.c	2010-04-22 15:58:09.000000000 +0200
+++ u-boot-2009.01/board/in-circuit/icnova/flash.c	2010-08-25 14:15:43.000000000 +0200
@@ -29,6 +29,8 @@
 
 flash_info_t flash_info[1];
 
+#define FLASH_ID_NUMONYX	0x002022FD
+
 static void flash_identify(uint16_t *flash, flash_info_t *info)
 {
 	unsigned long flags;
@@ -41,7 +43,11 @@
 	writew(0x55, flash + 0xaaa);
 	writew(0x90, flash + 0x555);
 	info->flash_id = readl(flash);
-	writew(0xff, flash);
+	if(info->flash_id == FLASH_ID_NUMONYX) {
+		writew(0xf0, flash);
+	} else {
+		writew(0xff, flash);
+	}
 
 	readw(flash);
 
@@ -75,30 +81,65 @@
 	       info->size >> 10, info->sector_count);
 }
 
-int flash_erase(flash_info_t *info, int s_first, int s_last)
-{
+static int flash_erase_numonyx(flash_info_t *info, int s_first, int s_last) {
 	unsigned long flags;
-	unsigned long start_time;
 	uint16_t *fb, *sb;
 	unsigned int i;
-	int ret;
 	uint16_t status;
 
-	if ((s_first < 0) || (s_first > s_last)
-	    || (s_last >= info->sector_count)) {
-		puts("Error: first and/or last sector out of range\n");
-		return ERR_INVAL;
+	fb = (uint16_t *)uncached(info->start[0]);
+
+	printf("Erasing sector %3d-%3d...", s_first, s_last);
+
+	flags = disable_interrupts();
+
+	/* Erase sector */
+	writew(0xaa, fb + 0x555);
+	writew(0x55, fb + 0xaaa);
+	writew(0x80, fb + 0x555);
+	writew(0xaa, fb + 0x555);
+	writew(0x55, fb + 0xaaa);
+
+	for (i = s_first; (i <= s_last) && !ctrlc(); i++) {
+		sb = (uint16_t *)uncached(info->start[i]);
+
+		writew(0x30, sb);
 	}
 
-	for (i = s_first; i < s_last; i++)
-		if (info->protect[i]) {
-			printf("Error: sector %d is protected\n", i);
-			return ERR_PROTECTED;
-		}
+	/* Wait for completion */
+	do {
+		/* TODO: Timeout */
+		status = readw(sb);
+	} while ((status != 0xffff) && !(status & (1<<5)));
+
+	writew(0xf0, fb);
+
+	/*
+	 * Make sure the command actually makes it to the bus
+	 * before we re-enable interrupts.
+	 */
+	readw(fb);
 
-	fb = (uint16_t *)uncached(info->start[0]);
+	if (flags)
+		enable_interrupts();
 
-	dcache_flush_unlocked();
+	if (status != 0xffff) {
+		printf("Flash erase error at address 0x%p: 0x%02x\n",
+		       sb, status);
+		return ERR_PROG_ERROR;
+	}
+	return ERR_OK;
+
+}
+
+static int flash_erase_atmel(flash_info_t *info, int s_first, int s_last) {
+	unsigned long flags;
+	unsigned long start_time;
+	uint16_t *fb, *sb;
+	unsigned int i;
+	uint16_t status;
+
+	fb = (uint16_t *)uncached(info->start[0]);
 
 	for (i = s_first; (i <= s_last) && !ctrlc(); i++) {
 		printf("Erasing sector %3d...", i);
@@ -122,7 +163,6 @@
 		writew(0x30, sb);
 
 		/* Wait for completion */
-		ret = ERR_OK;
 		do {
 			/* TODO: Timeout */
 			status = readw(sb);
@@ -142,45 +182,99 @@
 		if (status != 0xffff) {
 			printf("Flash erase error at address 0x%p: 0x%02x\n",
 			       sb, status);
-			ret = ERR_PROG_ERROR;
-			break;
+			return ERR_PROG_ERROR;
 		}
 	}
+	return ERR_OK;
+}
+
+int flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+	int ret, i;
+	if ((s_first < 0) || (s_first > s_last)
+	    || (s_last >= info->sector_count)) {
+		puts("Error: first and/or last sector out of range\n");
+		return ERR_INVAL;
+	}
+
+	for (i = s_first; i < s_last; i++)
+		if (info->protect[i]) {
+			printf("Error: sector %d is protected\n", i);
+			return ERR_PROTECTED;
+		}
+
+	dcache_flush_unlocked();
+
+	if(info->flash_id == FLASH_ID_NUMONYX) {
+		ret = flash_erase_numonyx(info, s_first, s_last);
+	} else {
+		ret = flash_erase_atmel(info, s_first, s_last);
+	}
 
 	if (ctrlc())
 		printf("User interrupt!\n");
 
-	return ERR_OK;
+	return ret;
 }
 
-int write_buff(flash_info_t *info, uchar *src,
-			   ulong addr, ulong count)
+int write_buff_numonyx(flash_info_t *info, uchar *src, ulong addr, ulong count)
 {
-	unsigned long flags;
 	uint16_t *base, *p, *s, *end;
 	uint16_t word, status, status1;
-	int ret = ERR_OK;
 
-	if (addr < info->start[0]
-	    || (addr + count) > (info->start[0] + info->size)
-	    || (addr + count) < addr) {
-		puts("Error: invalid address range\n");
-		return ERR_INVAL;
-	}
+	base = (uint16_t *)uncached(info->start[0]);
+	end = (uint16_t *)uncached(addr + count);
 
-	if (addr & 1 || count & 1 || (unsigned int)src & 1) {
-		puts("Error: misaligned source, destination or count\n");
-		return ERR_ALIGN;
+	for (p = (uint16_t *)uncached(addr), s = (uint16_t *)src;
+	     p < end && !ctrlc(); p++, s++) {
+		word = *s;
+
+		writew(0xaa, base + 0x555);
+		writew(0x55, base + 0xaaa);
+		writew(0xa0, base + 0x555);
+		writew(word, p);
+
+		sync_write_buffer();
+
+		/* Wait for completion */
+		status1 = readw(p);
+		do {
+			/* TODO: Timeout */
+			status = status1;
+			status1 = readw(p);
+		} while (((status ^ status1) & 0x40)	/* toggled */
+			 && !(status1 & (1<<5)));	/* error bits */
+
+		/*
+		 * We'll need to check once again for toggle bit
+		 * because the toggle bit may stop toggling as I/O5
+		 * changes to "1" (ref at49bv642.pdf p9)
+		 */
+		status1 = readw(p);
+		status = readw(p);
+		if ((status ^ status1) & 0x40) {
+			printf("Flash write error at address 0x%p: "
+			       "0x%02x != 0x%02x\n",
+			       p, status,word);
+			writew(0xf0, base);
+			readw(base);
+			return ERR_PROG_ERROR;
+		}
+
+		writew(0xf0, base);
+		readw(base);
 	}
+	return ERR_OK;
+}
+
+int write_buff_atmel(flash_info_t *info, uchar *src, ulong addr, ulong count)
+{
+	uint16_t *base, *p, *s, *end;
+	uint16_t word, status, status1;
 
 	base = (uint16_t *)uncached(info->start[0]);
 	end = (uint16_t *)uncached(addr + count);
 
-	flags = disable_interrupts();
-
-	dcache_flush_unlocked();
-	sync_write_buffer();
-
 	for (p = (uint16_t *)uncached(addr), s = (uint16_t *)src;
 	     p < end && !ctrlc(); p++, s++) {
 		word = *s;
@@ -212,15 +306,44 @@
 			printf("Flash write error at address 0x%p: "
 			       "0x%02x != 0x%02x\n",
 			       p, status,word);
-			ret = ERR_PROG_ERROR;
 			writew(0xf0, base);
 			readw(base);
-			break;
+			return ERR_PROG_ERROR;
 		}
 
 		writew(0xf0, base);
 		readw(base);
 	}
+	return ERR_OK;
+}
+
+int write_buff(flash_info_t *info, uchar *src, ulong addr, ulong count)
+{
+	unsigned long flags;
+	int ret;
+
+	if (addr < info->start[0]
+	    || (addr + count) > (info->start[0] + info->size)
+	    || (addr + count) < addr) {
+		puts("Error: invalid address range\n");
+		return ERR_INVAL;
+	}
+
+	if (addr & 1 || count & 1 || (unsigned int)src & 1) {
+		puts("Error: misaligned source, destination or count\n");
+		return ERR_ALIGN;
+	}
+
+	flags = disable_interrupts();
+
+	dcache_flush_unlocked();
+	sync_write_buffer();
+
+	if(info->flash_id == FLASH_ID_NUMONYX) {
+		ret = write_buff_numonyx(info, src, addr, count);
+	} else {
+		ret = write_buff_atmel(info, src, addr, count);
+	}
 
 	if (flags)
 		enable_interrupts();
